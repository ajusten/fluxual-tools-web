var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["json-json-module"], {
        /***/ "./node_modules/@angular/cdk/esm2015/accordion.js": 
        /*!********************************************************!*\
          !*** ./node_modules/@angular/cdk/esm2015/accordion.js ***!
          \********************************************************/
        /*! exports provided: CdkAccordionItem, CdkAccordion, CdkAccordionModule */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkAccordionItem", function () { return CdkAccordionItem; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkAccordion", function () { return CdkAccordion; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkAccordionModule", function () { return CdkAccordionModule; });
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/collections */ "./node_modules/@angular/cdk/esm2015/collections.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Used to generate unique ID for each accordion.
             * @type {?}
             */
            var nextId = 0;
            /**
             * Directive whose purpose is to manage the expanded state of CdkAccordionItem children.
             */
            var CdkAccordion = /** @class */ (function () {
                function CdkAccordion() {
                    /**
                     * Emits when the state of the accordion changes
                     */
                    this._stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
                    /**
                     * Stream that emits true/false when openAll/closeAll is triggered.
                     */
                    this._openCloseAllActions = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
                    /**
                     * A readonly id value to use for unique selection coordination.
                     */
                    this.id = "cdk-accordion-" + nextId++;
                    this._multi = false;
                }
                Object.defineProperty(CdkAccordion.prototype, "multi", {
                    /**
                     * Whether the accordion should allow multiple expanded accordion items simultaneously.
                     * @return {?}
                     */
                    get: function () { return this._multi; },
                    /**
                     * @param {?} multi
                     * @return {?}
                     */
                    set: function (multi) { this._multi = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(multi); },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Opens all enabled accordion items in an accordion where multi is enabled.
                 * @return {?}
                 */
                CdkAccordion.prototype.openAll = function () {
                    this._openCloseAll(true);
                };
                /**
                 * Closes all enabled accordion items in an accordion where multi is enabled.
                 * @return {?}
                 */
                CdkAccordion.prototype.closeAll = function () {
                    this._openCloseAll(false);
                };
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                CdkAccordion.prototype.ngOnChanges = function (changes) {
                    this._stateChanges.next(changes);
                };
                /**
                 * @return {?}
                 */
                CdkAccordion.prototype.ngOnDestroy = function () {
                    this._stateChanges.complete();
                };
                /**
                 * @private
                 * @param {?} expanded
                 * @return {?}
                 */
                CdkAccordion.prototype._openCloseAll = function (expanded) {
                    if (this.multi) {
                        this._openCloseAllActions.next(expanded);
                    }
                };
                return CdkAccordion;
            }());
            CdkAccordion.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: 'cdk-accordion, [cdkAccordion]',
                            exportAs: 'cdkAccordion',
                        },] },
            ];
            CdkAccordion.propDecorators = {
                multi: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Used to generate unique ID for each accordion item.
             * @type {?}
             */
            var nextId$1 = 0;
            var ɵ0 = undefined;
            /**
             * An basic directive expected to be extended and decorated as a component.  Sets up all
             * events and attributes needed to be managed by a CdkAccordion parent.
             */
            var CdkAccordionItem = /** @class */ (function () {
                /**
                 * @param {?} accordion
                 * @param {?} _changeDetectorRef
                 * @param {?} _expansionDispatcher
                 */
                function CdkAccordionItem(accordion, _changeDetectorRef, _expansionDispatcher) {
                    var _this_1 = this;
                    this.accordion = accordion;
                    this._changeDetectorRef = _changeDetectorRef;
                    this._expansionDispatcher = _expansionDispatcher;
                    /**
                     * Subscription to openAll/closeAll events.
                     */
                    this._openCloseAllSubscription = rxjs__WEBPACK_IMPORTED_MODULE_2__["Subscription"].EMPTY;
                    /**
                     * Event emitted every time the AccordionItem is closed.
                     */
                    this.closed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
                    /**
                     * Event emitted every time the AccordionItem is opened.
                     */
                    this.opened = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
                    /**
                     * Event emitted when the AccordionItem is destroyed.
                     */
                    this.destroyed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
                    /**
                     * Emits whenever the expanded state of the accordion changes.
                     * Primarily used to facilitate two-way binding.
                     * \@docs-private
                     */
                    this.expandedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
                    /**
                     * The unique AccordionItem id.
                     */
                    this.id = "cdk-accordion-child-" + nextId$1++;
                    this._expanded = false;
                    this._disabled = false;
                    /**
                     * Unregister function for _expansionDispatcher.
                     */
                    this._removeUniqueSelectionListener = ( /**
                     * @return {?}
                     */function () { });
                    this._removeUniqueSelectionListener =
                        _expansionDispatcher.listen(( /**
                         * @param {?} id
                         * @param {?} accordionId
                         * @return {?}
                         */function (id, accordionId) {
                            if (_this_1.accordion && !_this_1.accordion.multi &&
                                _this_1.accordion.id === accordionId && _this_1.id !== id) {
                                _this_1.expanded = false;
                            }
                        }));
                    // When an accordion item is hosted in an accordion, subscribe to open/close events.
                    if (this.accordion) {
                        this._openCloseAllSubscription = this._subscribeToOpenCloseAllActions();
                    }
                }
                Object.defineProperty(CdkAccordionItem.prototype, "expanded", {
                    /**
                     * Whether the AccordionItem is expanded.
                     * @return {?}
                     */
                    get: function () { return this._expanded; },
                    /**
                     * @param {?} expanded
                     * @return {?}
                     */
                    set: function (expanded) {
                        expanded = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(expanded);
                        // Only emit events and update the internal value if the value changes.
                        if (this._expanded !== expanded) {
                            this._expanded = expanded;
                            this.expandedChange.emit(expanded);
                            if (expanded) {
                                this.opened.emit();
                                /**
                                 * In the unique selection dispatcher, the id parameter is the id of the CdkAccordionItem,
                                 * the name value is the id of the accordion.
                                 * @type {?}
                                 */
                                var accordionId = this.accordion ? this.accordion.id : this.id;
                                this._expansionDispatcher.notify(this.id, accordionId);
                            }
                            else {
                                this.closed.emit();
                            }
                            // Ensures that the animation will run when the value is set outside of an `@Input`.
                            // This includes cases like the open, close and toggle methods.
                            this._changeDetectorRef.markForCheck();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkAccordionItem.prototype, "disabled", {
                    /**
                     * Whether the AccordionItem is disabled.
                     * @return {?}
                     */
                    get: function () { return this._disabled; },
                    /**
                     * @param {?} disabled
                     * @return {?}
                     */
                    set: function (disabled) { this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(disabled); },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Emits an event for the accordion item being destroyed.
                 * @return {?}
                 */
                CdkAccordionItem.prototype.ngOnDestroy = function () {
                    this.opened.complete();
                    this.closed.complete();
                    this.destroyed.emit();
                    this.destroyed.complete();
                    this._removeUniqueSelectionListener();
                    this._openCloseAllSubscription.unsubscribe();
                };
                /**
                 * Toggles the expanded state of the accordion item.
                 * @return {?}
                 */
                CdkAccordionItem.prototype.toggle = function () {
                    if (!this.disabled) {
                        this.expanded = !this.expanded;
                    }
                };
                /**
                 * Sets the expanded state of the accordion item to false.
                 * @return {?}
                 */
                CdkAccordionItem.prototype.close = function () {
                    if (!this.disabled) {
                        this.expanded = false;
                    }
                };
                /**
                 * Sets the expanded state of the accordion item to true.
                 * @return {?}
                 */
                CdkAccordionItem.prototype.open = function () {
                    if (!this.disabled) {
                        this.expanded = true;
                    }
                };
                /**
                 * @private
                 * @return {?}
                 */
                CdkAccordionItem.prototype._subscribeToOpenCloseAllActions = function () {
                    var _this_1 = this;
                    return this.accordion._openCloseAllActions.subscribe(( /**
                     * @param {?} expanded
                     * @return {?}
                     */function (/**
                     * @param {?} expanded
                     * @return {?}
                     */ expanded) {
                        // Only change expanded state if item is enabled
                        if (!_this_1.disabled) {
                            _this_1.expanded = expanded;
                        }
                    }));
                };
                return CdkAccordionItem;
            }());
            CdkAccordionItem.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: 'cdk-accordion-item, [cdkAccordionItem]',
                            exportAs: 'cdkAccordionItem',
                            providers: [
                                // Provide CdkAccordion as undefined to prevent nested accordion items from registering
                                // to the same accordion.
                                { provide: CdkAccordion, useValue: ɵ0 },
                            ],
                        },] },
            ];
            /** @nocollapse */
            CdkAccordionItem.ctorParameters = function () { return [
                { type: CdkAccordion, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["SkipSelf"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
                { type: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__["UniqueSelectionDispatcher"] }
            ]; };
            CdkAccordionItem.propDecorators = {
                closed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
                opened: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
                destroyed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
                expandedChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
                expanded: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var CdkAccordionModule = /** @class */ (function () {
                function CdkAccordionModule() {
                }
                return CdkAccordionModule;
            }());
            CdkAccordionModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                            exports: [CdkAccordion, CdkAccordionItem],
                            declarations: [CdkAccordion, CdkAccordionItem],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=accordion.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/cdk/esm2015/overlay.js": 
        /*!******************************************************!*\
          !*** ./node_modules/@angular/cdk/esm2015/overlay.js ***!
          \******************************************************/
        /*! exports provided: ViewportRuler, VIEWPORT_RULER_PROVIDER, CdkScrollable, ScrollDispatcher, Overlay, OverlayContainer, CdkOverlayOrigin, CdkConnectedOverlay, FullscreenOverlayContainer, OverlayRef, OverlayKeyboardDispatcher, OverlayPositionBuilder, GlobalPositionStrategy, ConnectedPositionStrategy, FlexibleConnectedPositionStrategy, OverlayConfig, validateVerticalPosition, validateHorizontalPosition, ConnectionPositionPair, ScrollingVisibility, ConnectedOverlayPositionChange, ScrollStrategyOptions, RepositionScrollStrategy, CloseScrollStrategy, NoopScrollStrategy, BlockScrollStrategy, OverlayModule, OVERLAY_PROVIDERS, ɵg, ɵf, ɵb, ɵa, ɵc, ɵe, ɵd */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Overlay", function () { return Overlay; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OverlayContainer", function () { return OverlayContainer; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkOverlayOrigin", function () { return CdkOverlayOrigin; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkConnectedOverlay", function () { return CdkConnectedOverlay; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FullscreenOverlayContainer", function () { return FullscreenOverlayContainer; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OverlayRef", function () { return OverlayRef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OverlayKeyboardDispatcher", function () { return OverlayKeyboardDispatcher; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OverlayPositionBuilder", function () { return OverlayPositionBuilder; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GlobalPositionStrategy", function () { return GlobalPositionStrategy; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConnectedPositionStrategy", function () { return ConnectedPositionStrategy; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlexibleConnectedPositionStrategy", function () { return FlexibleConnectedPositionStrategy; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OverlayConfig", function () { return OverlayConfig; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateVerticalPosition", function () { return validateVerticalPosition; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateHorizontalPosition", function () { return validateHorizontalPosition; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConnectionPositionPair", function () { return ConnectionPositionPair; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScrollingVisibility", function () { return ScrollingVisibility; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConnectedOverlayPositionChange", function () { return ConnectedOverlayPositionChange; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScrollStrategyOptions", function () { return ScrollStrategyOptions; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RepositionScrollStrategy", function () { return RepositionScrollStrategy; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CloseScrollStrategy", function () { return CloseScrollStrategy; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoopScrollStrategy", function () { return NoopScrollStrategy; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockScrollStrategy", function () { return BlockScrollStrategy; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OverlayModule", function () { return OverlayModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OVERLAY_PROVIDERS", function () { return OVERLAY_PROVIDERS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵg", function () { return OVERLAY_KEYBOARD_DISPATCHER_PROVIDER; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵf", function () { return OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵb", function () { return OVERLAY_CONTAINER_PROVIDER; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵa", function () { return OVERLAY_CONTAINER_PROVIDER_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵc", function () { return CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵe", function () { return CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵd", function () { return CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY; });
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/scrolling */ "./node_modules/@angular/cdk/esm2015/scrolling.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ViewportRuler", function () { return _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__["ViewportRuler"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VIEWPORT_RULER_PROVIDER", function () { return _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__["VIEWPORT_RULER_PROVIDER"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CdkScrollable", function () { return _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__["CdkScrollable"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ScrollDispatcher", function () { return _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__["ScrollDispatcher"]; });
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/platform */ "./node_modules/@angular/cdk/esm2015/platform.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/cdk/portal */ "./node_modules/@angular/cdk/esm2015/portal.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Strategy that will prevent the user from scrolling while the overlay is visible.
             */
            var BlockScrollStrategy = /** @class */ (function () {
                /**
                 * @param {?} _viewportRuler
                 * @param {?} document
                 */
                function BlockScrollStrategy(_viewportRuler, document) {
                    this._viewportRuler = _viewportRuler;
                    this._previousHTMLStyles = { top: '', left: '' };
                    this._isEnabled = false;
                    this._document = document;
                }
                /**
                 * Attaches this scroll strategy to an overlay.
                 * @return {?}
                 */
                BlockScrollStrategy.prototype.attach = function () { };
                /**
                 * Blocks page-level scroll while the attached overlay is open.
                 * @return {?}
                 */
                BlockScrollStrategy.prototype.enable = function () {
                    if (this._canBeEnabled()) {
                        /** @type {?} */
                        var root = ( /** @type {?} */(this._document.documentElement));
                        this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();
                        // Cache the previous inline styles in case the user had set them.
                        this._previousHTMLStyles.left = root.style.left || '';
                        this._previousHTMLStyles.top = root.style.top || '';
                        // Note: we're using the `html` node, instead of the `body`, because the `body` may
                        // have the user agent margin, whereas the `html` is guaranteed not to have one.
                        root.style.left = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(-this._previousScrollPosition.left);
                        root.style.top = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(-this._previousScrollPosition.top);
                        root.classList.add('cdk-global-scrollblock');
                        this._isEnabled = true;
                    }
                };
                /**
                 * Unblocks page-level scroll while the attached overlay is open.
                 * @return {?}
                 */
                BlockScrollStrategy.prototype.disable = function () {
                    if (this._isEnabled) {
                        /** @type {?} */
                        var html = ( /** @type {?} */(this._document.documentElement));
                        /** @type {?} */
                        var body = ( /** @type {?} */(this._document.body));
                        /** @type {?} */
                        var htmlStyle = ( /** @type {?} */(html.style));
                        /** @type {?} */
                        var bodyStyle = ( /** @type {?} */(body.style));
                        /** @type {?} */
                        var previousHtmlScrollBehavior = htmlStyle.scrollBehavior || '';
                        /** @type {?} */
                        var previousBodyScrollBehavior = bodyStyle.scrollBehavior || '';
                        this._isEnabled = false;
                        htmlStyle.left = this._previousHTMLStyles.left;
                        htmlStyle.top = this._previousHTMLStyles.top;
                        html.classList.remove('cdk-global-scrollblock');
                        // Disable user-defined smooth scrolling temporarily while we restore the scroll position.
                        // See https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior
                        htmlStyle.scrollBehavior = bodyStyle.scrollBehavior = 'auto';
                        window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);
                        htmlStyle.scrollBehavior = previousHtmlScrollBehavior;
                        bodyStyle.scrollBehavior = previousBodyScrollBehavior;
                    }
                };
                /**
                 * @private
                 * @return {?}
                 */
                BlockScrollStrategy.prototype._canBeEnabled = function () {
                    // Since the scroll strategies can't be singletons, we have to use a global CSS class
                    // (`cdk-global-scrollblock`) to make sure that we don't try to disable global
                    // scrolling multiple times.
                    /** @type {?} */
                    var html = ( /** @type {?} */(this._document.documentElement));
                    if (html.classList.contains('cdk-global-scrollblock') || this._isEnabled) {
                        return false;
                    }
                    /** @type {?} */
                    var body = this._document.body;
                    /** @type {?} */
                    var viewport = this._viewportRuler.getViewportSize();
                    return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;
                };
                return BlockScrollStrategy;
            }());
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.
             * @return {?}
             */
            function getMatScrollStrategyAlreadyAttachedError() {
                return Error("Scroll strategy has already been attached.");
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Strategy that will close the overlay as soon as the user starts scrolling.
             */
            var CloseScrollStrategy = /** @class */ (function () {
                /**
                 * @param {?} _scrollDispatcher
                 * @param {?} _ngZone
                 * @param {?} _viewportRuler
                 * @param {?=} _config
                 */
                function CloseScrollStrategy(_scrollDispatcher, _ngZone, _viewportRuler, _config) {
                    var _this_1 = this;
                    this._scrollDispatcher = _scrollDispatcher;
                    this._ngZone = _ngZone;
                    this._viewportRuler = _viewportRuler;
                    this._config = _config;
                    this._scrollSubscription = null;
                    /**
                     * Detaches the overlay ref and disables the scroll strategy.
                     */
                    this._detach = ( /**
                     * @return {?}
                     */function () {
                        _this_1.disable();
                        if (_this_1._overlayRef.hasAttached()) {
                            _this_1._ngZone.run(( /**
                             * @return {?}
                             */function () { return _this_1._overlayRef.detach(); }));
                        }
                    });
                }
                /**
                 * Attaches this scroll strategy to an overlay.
                 * @param {?} overlayRef
                 * @return {?}
                 */
                CloseScrollStrategy.prototype.attach = function (overlayRef) {
                    if (this._overlayRef) {
                        throw getMatScrollStrategyAlreadyAttachedError();
                    }
                    this._overlayRef = overlayRef;
                };
                /**
                 * Enables the closing of the attached overlay on scroll.
                 * @return {?}
                 */
                CloseScrollStrategy.prototype.enable = function () {
                    var _this_1 = this;
                    if (this._scrollSubscription) {
                        return;
                    }
                    /** @type {?} */
                    var stream = this._scrollDispatcher.scrolled(0);
                    if (this._config && this._config.threshold && this._config.threshold > 1) {
                        this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top;
                        this._scrollSubscription = stream.subscribe(( /**
                         * @return {?}
                         */function () {
                            /** @type {?} */
                            var scrollPosition = _this_1._viewportRuler.getViewportScrollPosition().top;
                            if (Math.abs(scrollPosition - _this_1._initialScrollPosition) > ( /** @type {?} */(( /** @type {?} */(_this_1._config)).threshold))) {
                                _this_1._detach();
                            }
                            else {
                                _this_1._overlayRef.updatePosition();
                            }
                        }));
                    }
                    else {
                        this._scrollSubscription = stream.subscribe(this._detach);
                    }
                };
                /**
                 * Disables the closing the attached overlay on scroll.
                 * @return {?}
                 */
                CloseScrollStrategy.prototype.disable = function () {
                    if (this._scrollSubscription) {
                        this._scrollSubscription.unsubscribe();
                        this._scrollSubscription = null;
                    }
                };
                /**
                 * @return {?}
                 */
                CloseScrollStrategy.prototype.detach = function () {
                    this.disable();
                    this._overlayRef = ( /** @type {?} */(null));
                };
                return CloseScrollStrategy;
            }());
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Scroll strategy that doesn't do anything.
             */
            var NoopScrollStrategy = /** @class */ (function () {
                function NoopScrollStrategy() {
                }
                /**
                 * Does nothing, as this scroll strategy is a no-op.
                 * @return {?}
                 */
                NoopScrollStrategy.prototype.enable = function () { };
                /**
                 * Does nothing, as this scroll strategy is a no-op.
                 * @return {?}
                 */
                NoopScrollStrategy.prototype.disable = function () { };
                /**
                 * Does nothing, as this scroll strategy is a no-op.
                 * @return {?}
                 */
                NoopScrollStrategy.prototype.attach = function () { };
                return NoopScrollStrategy;
            }());
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // TODO(jelbourn): move this to live with the rest of the scrolling code
            // TODO(jelbourn): someday replace this with IntersectionObservers
            /**
             * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.
             * \@docs-private
             * @param {?} element Dimensions of the element (from getBoundingClientRect)
             * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)
             * @return {?} Whether the element is scrolled out of view
             */
            function isElementScrolledOutsideView(element, scrollContainers) {
                return scrollContainers.some(( /**
                 * @param {?} containerBounds
                 * @return {?}
                 */function (/**
                 * @param {?} containerBounds
                 * @return {?}
                 */ containerBounds) {
                    /** @type {?} */
                    var outsideAbove = element.bottom < containerBounds.top;
                    /** @type {?} */
                    var outsideBelow = element.top > containerBounds.bottom;
                    /** @type {?} */
                    var outsideLeft = element.right < containerBounds.left;
                    /** @type {?} */
                    var outsideRight = element.left > containerBounds.right;
                    return outsideAbove || outsideBelow || outsideLeft || outsideRight;
                }));
            }
            /**
             * Gets whether an element is clipped by any of its scrolling containers.
             * \@docs-private
             * @param {?} element Dimensions of the element (from getBoundingClientRect)
             * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)
             * @return {?} Whether the element is clipped
             */
            function isElementClippedByScrolling(element, scrollContainers) {
                return scrollContainers.some(( /**
                 * @param {?} scrollContainerRect
                 * @return {?}
                 */function (/**
                 * @param {?} scrollContainerRect
                 * @return {?}
                 */ scrollContainerRect) {
                    /** @type {?} */
                    var clippedAbove = element.top < scrollContainerRect.top;
                    /** @type {?} */
                    var clippedBelow = element.bottom > scrollContainerRect.bottom;
                    /** @type {?} */
                    var clippedLeft = element.left < scrollContainerRect.left;
                    /** @type {?} */
                    var clippedRight = element.right > scrollContainerRect.right;
                    return clippedAbove || clippedBelow || clippedLeft || clippedRight;
                }));
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Strategy that will update the element position as the user is scrolling.
             */
            var RepositionScrollStrategy = /** @class */ (function () {
                /**
                 * @param {?} _scrollDispatcher
                 * @param {?} _viewportRuler
                 * @param {?} _ngZone
                 * @param {?=} _config
                 */
                function RepositionScrollStrategy(_scrollDispatcher, _viewportRuler, _ngZone, _config) {
                    this._scrollDispatcher = _scrollDispatcher;
                    this._viewportRuler = _viewportRuler;
                    this._ngZone = _ngZone;
                    this._config = _config;
                    this._scrollSubscription = null;
                }
                /**
                 * Attaches this scroll strategy to an overlay.
                 * @param {?} overlayRef
                 * @return {?}
                 */
                RepositionScrollStrategy.prototype.attach = function (overlayRef) {
                    if (this._overlayRef) {
                        throw getMatScrollStrategyAlreadyAttachedError();
                    }
                    this._overlayRef = overlayRef;
                };
                /**
                 * Enables repositioning of the attached overlay on scroll.
                 * @return {?}
                 */
                RepositionScrollStrategy.prototype.enable = function () {
                    var _this_1 = this;
                    if (!this._scrollSubscription) {
                        /** @type {?} */
                        var throttle = this._config ? this._config.scrollThrottle : 0;
                        this._scrollSubscription = this._scrollDispatcher.scrolled(throttle).subscribe(( /**
                         * @return {?}
                         */function () {
                            _this_1._overlayRef.updatePosition();
                            // TODO(crisbeto): make `close` on by default once all components can handle it.
                            if (_this_1._config && _this_1._config.autoClose) {
                                /** @type {?} */
                                var overlayRect = _this_1._overlayRef.overlayElement.getBoundingClientRect();
                                var _a = _this_1._viewportRuler.getViewportSize(), width = _a.width, height = _a.height;
                                // TODO(crisbeto): include all ancestor scroll containers here once
                                // we have a way of exposing the trigger element to the scroll strategy.
                                /** @type {?} */
                                var parentRects = [{ width: width, height: height, bottom: height, right: width, top: 0, left: 0 }];
                                if (isElementScrolledOutsideView(overlayRect, parentRects)) {
                                    _this_1.disable();
                                    _this_1._ngZone.run(( /**
                                     * @return {?}
                                     */function () { return _this_1._overlayRef.detach(); }));
                                }
                            }
                        }));
                    }
                };
                /**
                 * Disables repositioning of the attached overlay on scroll.
                 * @return {?}
                 */
                RepositionScrollStrategy.prototype.disable = function () {
                    if (this._scrollSubscription) {
                        this._scrollSubscription.unsubscribe();
                        this._scrollSubscription = null;
                    }
                };
                /**
                 * @return {?}
                 */
                RepositionScrollStrategy.prototype.detach = function () {
                    this.disable();
                    this._overlayRef = ( /** @type {?} */(null));
                };
                return RepositionScrollStrategy;
            }());
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Options for how an overlay will handle scrolling.
             *
             * Users can provide a custom value for `ScrollStrategyOptions` to replace the default
             * behaviors. This class primarily acts as a factory for ScrollStrategy instances.
             */
            var ScrollStrategyOptions = /** @class */ (function () {
                /**
                 * @param {?} _scrollDispatcher
                 * @param {?} _viewportRuler
                 * @param {?} _ngZone
                 * @param {?} document
                 */
                function ScrollStrategyOptions(_scrollDispatcher, _viewportRuler, _ngZone, document) {
                    var _this_1 = this;
                    this._scrollDispatcher = _scrollDispatcher;
                    this._viewportRuler = _viewportRuler;
                    this._ngZone = _ngZone;
                    /**
                     * Do nothing on scroll.
                     */
                    this.noop = ( /**
                     * @return {?}
                     */function () { return new NoopScrollStrategy(); });
                    /**
                     * Close the overlay as soon as the user scrolls.
                     * @param config Configuration to be used inside the scroll strategy.
                     */
                    this.close = ( /**
                     * @param {?=} config
                     * @return {?}
                     */function (config) { return new CloseScrollStrategy(_this_1._scrollDispatcher, _this_1._ngZone, _this_1._viewportRuler, config); });
                    /**
                     * Block scrolling.
                     */
                    this.block = ( /**
                     * @return {?}
                     */function () { return new BlockScrollStrategy(_this_1._viewportRuler, _this_1._document); });
                    /**
                     * Update the overlay's position on scroll.
                     * @param config Configuration to be used inside the scroll strategy.
                     * Allows debouncing the reposition calls.
                     */
                    this.reposition = ( /**
                     * @param {?=} config
                     * @return {?}
                     */function (config) { return new RepositionScrollStrategy(_this_1._scrollDispatcher, _this_1._viewportRuler, _this_1._ngZone, config); });
                    this._document = document;
                }
                return ScrollStrategyOptions;
            }());
            ScrollStrategyOptions.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */
            ScrollStrategyOptions.ctorParameters = function () { return [
                { type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__["ScrollDispatcher"] },
                { type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__["ViewportRuler"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["NgZone"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"],] }] }
            ]; };
            /** @nocollapse */ ScrollStrategyOptions.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineInjectable"])({ factory: function ScrollStrategyOptions_Factory() { return new ScrollStrategyOptions(Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"])(_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__["ScrollDispatcher"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"])(_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__["ViewportRuler"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_3__["NgZone"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"])(_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"])); }, token: ScrollStrategyOptions, providedIn: "root" });
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Initial configuration used when creating an overlay.
             */
            var OverlayConfig = /** @class */ (function () {
                /**
                 * @param {?=} config
                 */
                function OverlayConfig(config) {
                    /**
                     * Strategy to be used when handling scroll events while the overlay is open.
                     */
                    this.scrollStrategy = new NoopScrollStrategy();
                    /**
                     * Custom class to add to the overlay pane.
                     */
                    this.panelClass = '';
                    /**
                     * Whether the overlay has a backdrop.
                     */
                    this.hasBackdrop = false;
                    /**
                     * Custom class to add to the backdrop
                     */
                    this.backdropClass = 'cdk-overlay-dark-backdrop';
                    /**
                     * Whether the overlay should be disposed of when the user goes backwards/forwards in history.
                     * Note that this usually doesn't include clicking on links (unless the user is using
                     * the `HashLocationStrategy`).
                     */
                    this.disposeOnNavigation = false;
                    if (config) {
                        /** @type {?} */
                        var configKeys = ( /** @type {?} */(Object.keys(config)));
                        for (var _a = 0, configKeys_1 = configKeys; _a < configKeys_1.length; _a++) {
                            var key = configKeys_1[_a];
                            if (config[key] !== undefined) {
                                // TypeScript, as of version 3.5, sees the left-hand-side of this expression
                                // as "I don't know *which* key this is, so the only valid value is the intersection
                                // of all the posible values." In this case, that happens to be `undefined`. TypeScript
                                // is not smart enough to see that the right-hand-side is actually an access of the same
                                // exact type with the same exact key, meaning that the value type must be identical.
                                // So we use `any` to work around this.
                                this[key] = ( /** @type {?} */(config[key]));
                            }
                        }
                    }
                }
                return OverlayConfig;
            }());
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * The points of the origin element and the overlay element to connect.
             */
            var ConnectionPositionPair = /** @class */ (function () {
                /**
                 * @param {?} origin
                 * @param {?} overlay
                 * @param {?=} offsetX
                 * @param {?=} offsetY
                 * @param {?=} panelClass
                 */
                function ConnectionPositionPair(origin, overlay, offsetX, offsetY, panelClass) {
                    this.offsetX = offsetX;
                    this.offsetY = offsetY;
                    this.panelClass = panelClass;
                    this.originX = origin.originX;
                    this.originY = origin.originY;
                    this.overlayX = overlay.overlayX;
                    this.overlayY = overlay.overlayY;
                }
                return ConnectionPositionPair;
            }());
            /**
             * Set of properties regarding the position of the origin and overlay relative to the viewport
             * with respect to the containing Scrollable elements.
             *
             * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the
             * bounds of any one of the strategy's Scrollable's bounding client rectangle.
             *
             * The overlay and origin are outside view if there is no overlap between their bounding client
             * rectangle and any one of the strategy's Scrollable's bounding client rectangle.
             *
             *       -----------                    -----------
             *       | outside |                    | clipped |
             *       |  view   |              --------------------------
             *       |         |              |     |         |        |
             *       ----------               |     -----------        |
             *  --------------------------    |                        |
             *  |                        |    |      Scrollable        |
             *  |                        |    |                        |
             *  |                        |     --------------------------
             *  |      Scrollable        |
             *  |                        |
             *  --------------------------
             *
             * \@docs-private
             */
            var ScrollingVisibility = /** @class */ (function () {
                function ScrollingVisibility() {
                }
                return ScrollingVisibility;
            }());
            /**
             * The change event emitted by the strategy when a fallback position is used.
             */
            var ConnectedOverlayPositionChange = /** @class */ (function () {
                /**
                 * @param {?} connectionPair
                 * @param {?} scrollableViewProperties
                 */
                function ConnectedOverlayPositionChange(connectionPair, scrollableViewProperties) {
                    this.connectionPair = connectionPair;
                    this.scrollableViewProperties = scrollableViewProperties;
                }
                return ConnectedOverlayPositionChange;
            }());
            /** @nocollapse */
            ConnectedOverlayPositionChange.ctorParameters = function () { return [
                { type: ConnectionPositionPair },
                { type: ScrollingVisibility, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }] }
            ]; };
            /**
             * Validates whether a vertical position property matches the expected values.
             * \@docs-private
             * @param {?} property Name of the property being validated.
             * @param {?} value Value of the property being validated.
             * @return {?}
             */
            function validateVerticalPosition(property, value) {
                if (value !== 'top' && value !== 'bottom' && value !== 'center') {
                    throw Error("ConnectedPosition: Invalid " + property + " \"" + value + "\". " +
                        "Expected \"top\", \"bottom\" or \"center\".");
                }
            }
            /**
             * Validates whether a horizontal position property matches the expected values.
             * \@docs-private
             * @param {?} property Name of the property being validated.
             * @param {?} value Value of the property being validated.
             * @return {?}
             */
            function validateHorizontalPosition(property, value) {
                if (value !== 'start' && value !== 'end' && value !== 'center') {
                    throw Error("ConnectedPosition: Invalid " + property + " \"" + value + "\". " +
                        "Expected \"start\", \"end\" or \"center\".");
                }
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Service for dispatching keyboard events that land on the body to appropriate overlay ref,
             * if any. It maintains a list of attached overlays to determine best suited overlay based
             * on event target and order of overlay opens.
             */
            var OverlayKeyboardDispatcher = /** @class */ (function () {
                /**
                 * @param {?} document
                 */
                function OverlayKeyboardDispatcher(document) {
                    var _this_1 = this;
                    /**
                     * Currently attached overlays in the order they were attached.
                     */
                    this._attachedOverlays = [];
                    /**
                     * Keyboard event listener that will be attached to the body.
                     */
                    this._keydownListener = ( /**
                     * @param {?} event
                     * @return {?}
                     */function (event) {
                        /** @type {?} */
                        var overlays = _this_1._attachedOverlays;
                        for (var i = overlays.length - 1; i > -1; i--) {
                            // Dispatch the keydown event to the top overlay which has subscribers to its keydown events.
                            // We want to target the most recent overlay, rather than trying to match where the event came
                            // from, because some components might open an overlay, but keep focus on a trigger element
                            // (e.g. for select and autocomplete). We skip overlays without keydown event subscriptions,
                            // because we don't want overlays that don't handle keyboard events to block the ones below
                            // them that do.
                            if (overlays[i]._keydownEventSubscriptions > 0) {
                                overlays[i]._keydownEvents.next(event);
                                break;
                            }
                        }
                    });
                    this._document = document;
                }
                /**
                 * @return {?}
                 */
                OverlayKeyboardDispatcher.prototype.ngOnDestroy = function () {
                    this._detach();
                };
                /**
                 * Add a new overlay to the list of attached overlay refs.
                 * @param {?} overlayRef
                 * @return {?}
                 */
                OverlayKeyboardDispatcher.prototype.add = function (overlayRef) {
                    // Ensure that we don't get the same overlay multiple times.
                    this.remove(overlayRef);
                    // Lazily start dispatcher once first overlay is added
                    if (!this._isAttached) {
                        this._document.body.addEventListener('keydown', this._keydownListener);
                        this._isAttached = true;
                    }
                    this._attachedOverlays.push(overlayRef);
                };
                /**
                 * Remove an overlay from the list of attached overlay refs.
                 * @param {?} overlayRef
                 * @return {?}
                 */
                OverlayKeyboardDispatcher.prototype.remove = function (overlayRef) {
                    /** @type {?} */
                    var index = this._attachedOverlays.indexOf(overlayRef);
                    if (index > -1) {
                        this._attachedOverlays.splice(index, 1);
                    }
                    // Remove the global listener once there are no more overlays.
                    if (this._attachedOverlays.length === 0) {
                        this._detach();
                    }
                };
                /**
                 * Detaches the global keyboard event listener.
                 * @private
                 * @return {?}
                 */
                OverlayKeyboardDispatcher.prototype._detach = function () {
                    if (this._isAttached) {
                        this._document.body.removeEventListener('keydown', this._keydownListener);
                        this._isAttached = false;
                    }
                };
                return OverlayKeyboardDispatcher;
            }());
            OverlayKeyboardDispatcher.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */
            OverlayKeyboardDispatcher.ctorParameters = function () { return [
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"],] }] }
            ]; };
            /** @nocollapse */ OverlayKeyboardDispatcher.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineInjectable"])({ factory: function OverlayKeyboardDispatcher_Factory() { return new OverlayKeyboardDispatcher(Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"])(_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"])); }, token: OverlayKeyboardDispatcher, providedIn: "root" });
            /**
             * \@docs-private \@deprecated \@breaking-change 8.0.0
             * @param {?} dispatcher
             * @param {?} _document
             * @return {?}
             */
            function OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY(dispatcher, _document) {
                return dispatcher || new OverlayKeyboardDispatcher(_document);
            }
            /**
             * \@docs-private \@deprecated \@breaking-change 8.0.0
             * @type {?}
             */
            var OVERLAY_KEYBOARD_DISPATCHER_PROVIDER = {
                // If there is already an OverlayKeyboardDispatcher available, use that.
                // Otherwise, provide a new one.
                provide: OverlayKeyboardDispatcher,
                deps: [
                    [new _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"](), new _angular_core__WEBPACK_IMPORTED_MODULE_3__["SkipSelf"](), OverlayKeyboardDispatcher],
                    ( /** @type {?} */(
                    // Coerce to `InjectionToken` so that the `deps` match the "shape"
                    // of the type expected by Angular
                    _angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"]))
                ],
                useFactory: OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Container inside which all overlays will render.
             */
            var OverlayContainer = /** @class */ (function () {
                /**
                 * @param {?} document
                 */
                function OverlayContainer(document) {
                    this._document = document;
                }
                /**
                 * @return {?}
                 */
                OverlayContainer.prototype.ngOnDestroy = function () {
                    if (this._containerElement && this._containerElement.parentNode) {
                        this._containerElement.parentNode.removeChild(this._containerElement);
                    }
                };
                /**
                 * This method returns the overlay container element. It will lazily
                 * create the element the first time  it is called to facilitate using
                 * the container in non-browser environments.
                 * @return {?} the container element
                 */
                OverlayContainer.prototype.getContainerElement = function () {
                    if (!this._containerElement) {
                        this._createContainer();
                    }
                    return this._containerElement;
                };
                /**
                 * Create the overlay container element, which is simply a div
                 * with the 'cdk-overlay-container' class on the document body.
                 * @protected
                 * @return {?}
                 */
                OverlayContainer.prototype._createContainer = function () {
                    /** @type {?} */
                    var containerClass = 'cdk-overlay-container';
                    /** @type {?} */
                    var previousContainers = this._document.getElementsByClassName(containerClass);
                    // Remove any old containers. This can happen when transitioning from the server to the client.
                    for (var i = 0; i < previousContainers.length; i++) {
                        ( /** @type {?} */(previousContainers[i].parentNode)).removeChild(previousContainers[i]);
                    }
                    /** @type {?} */
                    var container = this._document.createElement('div');
                    container.classList.add(containerClass);
                    this._document.body.appendChild(container);
                    this._containerElement = container;
                };
                return OverlayContainer;
            }());
            OverlayContainer.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */
            OverlayContainer.ctorParameters = function () { return [
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"],] }] }
            ]; };
            /** @nocollapse */ OverlayContainer.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineInjectable"])({ factory: function OverlayContainer_Factory() { return new OverlayContainer(Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"])(_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"])); }, token: OverlayContainer, providedIn: "root" });
            /**
             * \@docs-private \@deprecated \@breaking-change 8.0.0
             * @param {?} parentContainer
             * @param {?} _document
             * @return {?}
             */
            function OVERLAY_CONTAINER_PROVIDER_FACTORY(parentContainer, _document) {
                return parentContainer || new OverlayContainer(_document);
            }
            /**
             * \@docs-private \@deprecated \@breaking-change 8.0.0
             * @type {?}
             */
            var OVERLAY_CONTAINER_PROVIDER = {
                // If there is already an OverlayContainer available, use that. Otherwise, provide a new one.
                provide: OverlayContainer,
                deps: [
                    [new _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"](), new _angular_core__WEBPACK_IMPORTED_MODULE_3__["SkipSelf"](), OverlayContainer],
                    ( /** @type {?} */(_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"]))
                ],
                useFactory: OVERLAY_CONTAINER_PROVIDER_FACTORY
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Reference to an overlay that has been created with the Overlay service.
             * Used to manipulate or dispose of said overlay.
             */
            var OverlayRef = /** @class */ (function () {
                /**
                 * @param {?} _portalOutlet
                 * @param {?} _host
                 * @param {?} _pane
                 * @param {?} _config
                 * @param {?} _ngZone
                 * @param {?} _keyboardDispatcher
                 * @param {?} _document
                 * @param {?=} _location
                 */
                function OverlayRef(_portalOutlet, _host, _pane, _config, _ngZone, _keyboardDispatcher, _document, _location) {
                    var _this_1 = this;
                    this._portalOutlet = _portalOutlet;
                    this._host = _host;
                    this._pane = _pane;
                    this._config = _config;
                    this._ngZone = _ngZone;
                    this._keyboardDispatcher = _keyboardDispatcher;
                    this._document = _document;
                    this._location = _location;
                    this._backdropElement = null;
                    this._backdropClick = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
                    this._attachments = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
                    this._detachments = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
                    this._locationChanges = rxjs__WEBPACK_IMPORTED_MODULE_4__["Subscription"].EMPTY;
                    this._backdropClickHandler = ( /**
                     * @param {?} event
                     * @return {?}
                     */function (event) { return _this_1._backdropClick.next(event); });
                    this._keydownEventsObservable = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Observable"](( /**
                     * @param {?} observer
                     * @return {?}
                     */function (observer) {
                        /** @type {?} */
                        var subscription = _this_1._keydownEvents.subscribe(observer);
                        _this_1._keydownEventSubscriptions++;
                        return ( /**
                         * @return {?}
                         */function () {
                            subscription.unsubscribe();
                            _this_1._keydownEventSubscriptions--;
                        });
                    }));
                    /**
                     * Stream of keydown events dispatched to this overlay.
                     */
                    this._keydownEvents = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
                    /**
                     * Amount of subscriptions to the keydown events.
                     */
                    this._keydownEventSubscriptions = 0;
                    if (_config.scrollStrategy) {
                        this._scrollStrategy = _config.scrollStrategy;
                        this._scrollStrategy.attach(this);
                    }
                    this._positionStrategy = _config.positionStrategy;
                }
                Object.defineProperty(OverlayRef.prototype, "overlayElement", {
                    /**
                     * The overlay's HTML element
                     * @return {?}
                     */
                    get: function () {
                        return this._pane;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(OverlayRef.prototype, "backdropElement", {
                    /**
                     * The overlay's backdrop HTML element.
                     * @return {?}
                     */
                    get: function () {
                        return this._backdropElement;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(OverlayRef.prototype, "hostElement", {
                    /**
                     * Wrapper around the panel element. Can be used for advanced
                     * positioning where a wrapper with specific styling is
                     * required around the overlay pane.
                     * @return {?}
                     */
                    get: function () {
                        return this._host;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Attaches content, given via a Portal, to the overlay.
                 * If the overlay is configured to have a backdrop, it will be created.
                 *
                 * @param {?} portal Portal instance to which to attach the overlay.
                 * @return {?} The portal attachment result.
                 */
                OverlayRef.prototype.attach = function (portal) {
                    var _this_1 = this;
                    /** @type {?} */
                    var attachResult = this._portalOutlet.attach(portal);
                    if (this._positionStrategy) {
                        this._positionStrategy.attach(this);
                    }
                    // Update the pane element with the given configuration.
                    if (!this._host.parentElement && this._previousHostParent) {
                        this._previousHostParent.appendChild(this._host);
                    }
                    this._updateStackingOrder();
                    this._updateElementSize();
                    this._updateElementDirection();
                    if (this._scrollStrategy) {
                        this._scrollStrategy.enable();
                    }
                    // Update the position once the zone is stable so that the overlay will be fully rendered
                    // before attempting to position it, as the position may depend on the size of the rendered
                    // content.
                    this._ngZone.onStable
                        .asObservable()
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["take"])(1))
                        .subscribe(( /**
                 * @return {?}
                 */function () {
                        // The overlay could've been detached before the zone has stabilized.
                        if (_this_1.hasAttached()) {
                            _this_1.updatePosition();
                        }
                    }));
                    // Enable pointer events for the overlay pane element.
                    this._togglePointerEvents(true);
                    if (this._config.hasBackdrop) {
                        this._attachBackdrop();
                    }
                    if (this._config.panelClass) {
                        this._toggleClasses(this._pane, this._config.panelClass, true);
                    }
                    // Only emit the `attachments` event once all other setup is done.
                    this._attachments.next();
                    // Track this overlay by the keyboard dispatcher
                    this._keyboardDispatcher.add(this);
                    // @breaking-change 8.0.0 remove the null check for `_location`
                    // once the constructor parameter is made required.
                    if (this._config.disposeOnNavigation && this._location) {
                        this._locationChanges = this._location.subscribe(( /**
                         * @return {?}
                         */function () { return _this_1.dispose(); }));
                    }
                    return attachResult;
                };
                /**
                 * Detaches an overlay from a portal.
                 * @return {?} The portal detachment result.
                 */
                OverlayRef.prototype.detach = function () {
                    if (!this.hasAttached()) {
                        return;
                    }
                    this.detachBackdrop();
                    // When the overlay is detached, the pane element should disable pointer events.
                    // This is necessary because otherwise the pane element will cover the page and disable
                    // pointer events therefore. Depends on the position strategy and the applied pane boundaries.
                    this._togglePointerEvents(false);
                    if (this._positionStrategy && this._positionStrategy.detach) {
                        this._positionStrategy.detach();
                    }
                    if (this._scrollStrategy) {
                        this._scrollStrategy.disable();
                    }
                    /** @type {?} */
                    var detachmentResult = this._portalOutlet.detach();
                    // Only emit after everything is detached.
                    this._detachments.next();
                    // Remove this overlay from keyboard dispatcher tracking.
                    this._keyboardDispatcher.remove(this);
                    // Keeping the host element in DOM the can cause scroll jank, because it still gets
                    // rendered, even though it's transparent and unclickable which is why we remove it.
                    this._detachContentWhenStable();
                    // Stop listening for location changes.
                    this._locationChanges.unsubscribe();
                    return detachmentResult;
                };
                /**
                 * Cleans up the overlay from the DOM.
                 * @return {?}
                 */
                OverlayRef.prototype.dispose = function () {
                    /** @type {?} */
                    var isAttached = this.hasAttached();
                    if (this._positionStrategy) {
                        this._positionStrategy.dispose();
                    }
                    this._disposeScrollStrategy();
                    this.detachBackdrop();
                    this._locationChanges.unsubscribe();
                    this._keyboardDispatcher.remove(this);
                    this._portalOutlet.dispose();
                    this._attachments.complete();
                    this._backdropClick.complete();
                    this._keydownEvents.complete();
                    if (this._host && this._host.parentNode) {
                        this._host.parentNode.removeChild(this._host);
                        this._host = ( /** @type {?} */(null));
                    }
                    this._previousHostParent = this._pane = ( /** @type {?} */(null));
                    if (isAttached) {
                        this._detachments.next();
                    }
                    this._detachments.complete();
                };
                /**
                 * Whether the overlay has attached content.
                 * @return {?}
                 */
                OverlayRef.prototype.hasAttached = function () {
                    return this._portalOutlet.hasAttached();
                };
                /**
                 * Gets an observable that emits when the backdrop has been clicked.
                 * @return {?}
                 */
                OverlayRef.prototype.backdropClick = function () {
                    return this._backdropClick.asObservable();
                };
                /**
                 * Gets an observable that emits when the overlay has been attached.
                 * @return {?}
                 */
                OverlayRef.prototype.attachments = function () {
                    return this._attachments.asObservable();
                };
                /**
                 * Gets an observable that emits when the overlay has been detached.
                 * @return {?}
                 */
                OverlayRef.prototype.detachments = function () {
                    return this._detachments.asObservable();
                };
                /**
                 * Gets an observable of keydown events targeted to this overlay.
                 * @return {?}
                 */
                OverlayRef.prototype.keydownEvents = function () {
                    return this._keydownEventsObservable;
                };
                /**
                 * Gets the current overlay configuration, which is immutable.
                 * @return {?}
                 */
                OverlayRef.prototype.getConfig = function () {
                    return this._config;
                };
                /**
                 * Updates the position of the overlay based on the position strategy.
                 * @return {?}
                 */
                OverlayRef.prototype.updatePosition = function () {
                    if (this._positionStrategy) {
                        this._positionStrategy.apply();
                    }
                };
                /**
                 * Switches to a new position strategy and updates the overlay position.
                 * @param {?} strategy
                 * @return {?}
                 */
                OverlayRef.prototype.updatePositionStrategy = function (strategy) {
                    if (strategy === this._positionStrategy) {
                        return;
                    }
                    if (this._positionStrategy) {
                        this._positionStrategy.dispose();
                    }
                    this._positionStrategy = strategy;
                    if (this.hasAttached()) {
                        strategy.attach(this);
                        this.updatePosition();
                    }
                };
                /**
                 * Update the size properties of the overlay.
                 * @param {?} sizeConfig
                 * @return {?}
                 */
                OverlayRef.prototype.updateSize = function (sizeConfig) {
                    this._config = Object.assign({}, this._config, sizeConfig);
                    this._updateElementSize();
                };
                /**
                 * Sets the LTR/RTL direction for the overlay.
                 * @param {?} dir
                 * @return {?}
                 */
                OverlayRef.prototype.setDirection = function (dir) {
                    this._config = Object.assign({}, this._config, { direction: dir });
                    this._updateElementDirection();
                };
                /**
                 * Add a CSS class or an array of classes to the overlay pane.
                 * @param {?} classes
                 * @return {?}
                 */
                OverlayRef.prototype.addPanelClass = function (classes) {
                    if (this._pane) {
                        this._toggleClasses(this._pane, classes, true);
                    }
                };
                /**
                 * Remove a CSS class or an array of classes from the overlay pane.
                 * @param {?} classes
                 * @return {?}
                 */
                OverlayRef.prototype.removePanelClass = function (classes) {
                    if (this._pane) {
                        this._toggleClasses(this._pane, classes, false);
                    }
                };
                /**
                 * Returns the layout direction of the overlay panel.
                 * @return {?}
                 */
                OverlayRef.prototype.getDirection = function () {
                    /** @type {?} */
                    var direction = this._config.direction;
                    if (!direction) {
                        return 'ltr';
                    }
                    return typeof direction === 'string' ? direction : direction.value;
                };
                /**
                 * Switches to a new scroll strategy.
                 * @param {?} strategy
                 * @return {?}
                 */
                OverlayRef.prototype.updateScrollStrategy = function (strategy) {
                    if (strategy === this._scrollStrategy) {
                        return;
                    }
                    this._disposeScrollStrategy();
                    this._scrollStrategy = strategy;
                    if (this.hasAttached()) {
                        strategy.attach(this);
                        strategy.enable();
                    }
                };
                /**
                 * Updates the text direction of the overlay panel.
                 * @private
                 * @return {?}
                 */
                OverlayRef.prototype._updateElementDirection = function () {
                    this._host.setAttribute('dir', this.getDirection());
                };
                /**
                 * Updates the size of the overlay element based on the overlay config.
                 * @private
                 * @return {?}
                 */
                OverlayRef.prototype._updateElementSize = function () {
                    if (!this._pane) {
                        return;
                    }
                    /** @type {?} */
                    var style = this._pane.style;
                    style.width = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(this._config.width);
                    style.height = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(this._config.height);
                    style.minWidth = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(this._config.minWidth);
                    style.minHeight = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(this._config.minHeight);
                    style.maxWidth = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(this._config.maxWidth);
                    style.maxHeight = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(this._config.maxHeight);
                };
                /**
                 * Toggles the pointer events for the overlay pane element.
                 * @private
                 * @param {?} enablePointer
                 * @return {?}
                 */
                OverlayRef.prototype._togglePointerEvents = function (enablePointer) {
                    this._pane.style.pointerEvents = enablePointer ? 'auto' : 'none';
                };
                /**
                 * Attaches a backdrop for this overlay.
                 * @private
                 * @return {?}
                 */
                OverlayRef.prototype._attachBackdrop = function () {
                    var _this_1 = this;
                    /** @type {?} */
                    var showingClass = 'cdk-overlay-backdrop-showing';
                    this._backdropElement = this._document.createElement('div');
                    this._backdropElement.classList.add('cdk-overlay-backdrop');
                    if (this._config.backdropClass) {
                        this._toggleClasses(this._backdropElement, this._config.backdropClass, true);
                    }
                    // Insert the backdrop before the pane in the DOM order,
                    // in order to handle stacked overlays properly.
                    ( /** @type {?} */(this._host.parentElement)).insertBefore(this._backdropElement, this._host);
                    // Forward backdrop clicks such that the consumer of the overlay can perform whatever
                    // action desired when such a click occurs (usually closing the overlay).
                    this._backdropElement.addEventListener('click', this._backdropClickHandler);
                    // Add class to fade-in the backdrop after one frame.
                    if (typeof requestAnimationFrame !== 'undefined') {
                        this._ngZone.runOutsideAngular(( /**
                         * @return {?}
                         */function () {
                            requestAnimationFrame(( /**
                             * @return {?}
                             */function () {
                                if (_this_1._backdropElement) {
                                    _this_1._backdropElement.classList.add(showingClass);
                                }
                            }));
                        }));
                    }
                    else {
                        this._backdropElement.classList.add(showingClass);
                    }
                };
                /**
                 * Updates the stacking order of the element, moving it to the top if necessary.
                 * This is required in cases where one overlay was detached, while another one,
                 * that should be behind it, was destroyed. The next time both of them are opened,
                 * the stacking will be wrong, because the detached element's pane will still be
                 * in its original DOM position.
                 * @private
                 * @return {?}
                 */
                OverlayRef.prototype._updateStackingOrder = function () {
                    if (this._host.nextSibling) {
                        ( /** @type {?} */(this._host.parentNode)).appendChild(this._host);
                    }
                };
                /**
                 * Detaches the backdrop (if any) associated with the overlay.
                 * @return {?}
                 */
                OverlayRef.prototype.detachBackdrop = function () {
                    var _this_1 = this;
                    /** @type {?} */
                    var backdropToDetach = this._backdropElement;
                    if (!backdropToDetach) {
                        return;
                    }
                    /** @type {?} */
                    var timeoutId;
                    /** @type {?} */
                    var finishDetach = ( /**
                     * @return {?}
                     */function () {
                        // It may not be attached to anything in certain cases (e.g. unit tests).
                        if (backdropToDetach) {
                            backdropToDetach.removeEventListener('click', _this_1._backdropClickHandler);
                            backdropToDetach.removeEventListener('transitionend', finishDetach);
                            if (backdropToDetach.parentNode) {
                                backdropToDetach.parentNode.removeChild(backdropToDetach);
                            }
                        }
                        // It is possible that a new portal has been attached to this overlay since we started
                        // removing the backdrop. If that is the case, only clear the backdrop reference if it
                        // is still the same instance that we started to remove.
                        if (_this_1._backdropElement == backdropToDetach) {
                            _this_1._backdropElement = null;
                        }
                        if (_this_1._config.backdropClass) {
                            _this_1._toggleClasses(( /** @type {?} */(backdropToDetach)), _this_1._config.backdropClass, false);
                        }
                        clearTimeout(timeoutId);
                    });
                    backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');
                    this._ngZone.runOutsideAngular(( /**
                     * @return {?}
                     */function () {
                        ( /** @type {?} */(backdropToDetach)).addEventListener('transitionend', finishDetach);
                    }));
                    // If the backdrop doesn't have a transition, the `transitionend` event won't fire.
                    // In this case we make it unclickable and we try to remove it after a delay.
                    backdropToDetach.style.pointerEvents = 'none';
                    // Run this outside the Angular zone because there's nothing that Angular cares about.
                    // If it were to run inside the Angular zone, every test that used Overlay would have to be
                    // either async or fakeAsync.
                    timeoutId = this._ngZone.runOutsideAngular(( /**
                     * @return {?}
                     */function () { return setTimeout(finishDetach, 500); }));
                };
                /**
                 * Toggles a single CSS class or an array of classes on an element.
                 * @private
                 * @param {?} element
                 * @param {?} cssClasses
                 * @param {?} isAdd
                 * @return {?}
                 */
                OverlayRef.prototype._toggleClasses = function (element, cssClasses, isAdd) {
                    /** @type {?} */
                    var classList = element.classList;
                    Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceArray"])(cssClasses).forEach(( /**
                     * @param {?} cssClass
                     * @return {?}
                     */function (/**
                     * @param {?} cssClass
                     * @return {?}
                     */ cssClass) {
                        // We can't do a spread here, because IE doesn't support setting multiple classes.
                        // Also trying to add an empty string to a DOMTokenList will throw.
                        if (cssClass) {
                            isAdd ? classList.add(cssClass) : classList.remove(cssClass);
                        }
                    }));
                };
                /**
                 * Detaches the overlay content next time the zone stabilizes.
                 * @private
                 * @return {?}
                 */
                OverlayRef.prototype._detachContentWhenStable = function () {
                    var _this_1 = this;
                    // Normally we wouldn't have to explicitly run this outside the `NgZone`, however
                    // if the consumer is using `zone-patch-rxjs`, the `Subscription.unsubscribe` call will
                    // be patched to run inside the zone, which will throw us into an infinite loop.
                    this._ngZone.runOutsideAngular(( /**
                     * @return {?}
                     */function () {
                        // We can't remove the host here immediately, because the overlay pane's content
                        // might still be animating. This stream helps us avoid interrupting the animation
                        // by waiting for the pane to become empty.
                        /** @type {?} */
                        var subscription = _this_1._ngZone.onStable
                            .asObservable()
                            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["merge"])(_this_1._attachments, _this_1._detachments)))
                            .subscribe(( /**
                     * @return {?}
                     */function () {
                            // Needs a couple of checks for the pane and host, because
                            // they may have been removed by the time the zone stabilizes.
                            if (!_this_1._pane || !_this_1._host || _this_1._pane.children.length === 0) {
                                if (_this_1._pane && _this_1._config.panelClass) {
                                    _this_1._toggleClasses(_this_1._pane, _this_1._config.panelClass, false);
                                }
                                if (_this_1._host && _this_1._host.parentElement) {
                                    _this_1._previousHostParent = _this_1._host.parentElement;
                                    _this_1._previousHostParent.removeChild(_this_1._host);
                                }
                                subscription.unsubscribe();
                            }
                        }));
                    }));
                };
                /**
                 * Disposes of a scroll strategy.
                 * @private
                 * @return {?}
                 */
                OverlayRef.prototype._disposeScrollStrategy = function () {
                    /** @type {?} */
                    var scrollStrategy = this._scrollStrategy;
                    if (scrollStrategy) {
                        scrollStrategy.disable();
                        if (scrollStrategy.detach) {
                            scrollStrategy.detach();
                        }
                    }
                };
                return OverlayRef;
            }());
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // TODO: refactor clipping detection into a separate thing (part of scrolling module)
            // TODO: doesn't handle both flexible width and height when it has to scroll along both axis.
            /**
             * Class to be added to the overlay bounding box.
             * @type {?}
             */
            var boundingBoxClass = 'cdk-overlay-connected-position-bounding-box';
            /**
             * A strategy for positioning overlays. Using this strategy, an overlay is given an
             * implicit position relative some origin element. The relative position is defined in terms of
             * a point on the origin element that is connected to a point on the overlay element. For example,
             * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner
             * of the overlay.
             */
            var FlexibleConnectedPositionStrategy = /** @class */ (function () {
                /**
                 * @param {?} connectedTo
                 * @param {?} _viewportRuler
                 * @param {?} _document
                 * @param {?} _platform
                 * @param {?} _overlayContainer
                 */
                function FlexibleConnectedPositionStrategy(connectedTo, _viewportRuler, _document, _platform, _overlayContainer) {
                    this._viewportRuler = _viewportRuler;
                    this._document = _document;
                    this._platform = _platform;
                    this._overlayContainer = _overlayContainer;
                    /**
                     * Last size used for the bounding box. Used to avoid resizing the overlay after open.
                     */
                    this._lastBoundingBoxSize = { width: 0, height: 0 };
                    /**
                     * Whether the overlay was pushed in a previous positioning.
                     */
                    this._isPushed = false;
                    /**
                     * Whether the overlay can be pushed on-screen on the initial open.
                     */
                    this._canPush = true;
                    /**
                     * Whether the overlay can grow via flexible width/height after the initial open.
                     */
                    this._growAfterOpen = false;
                    /**
                     * Whether the overlay's width and height can be constrained to fit within the viewport.
                     */
                    this._hasFlexibleDimensions = true;
                    /**
                     * Whether the overlay position is locked.
                     */
                    this._positionLocked = false;
                    /**
                     * Amount of space that must be maintained between the overlay and the edge of the viewport.
                     */
                    this._viewportMargin = 0;
                    /**
                     * The Scrollable containers used to check scrollable view properties on position change.
                     */
                    this._scrollables = [];
                    /**
                     * Ordered list of preferred positions, from most to least desirable.
                     */
                    this._preferredPositions = [];
                    /**
                     * Subject that emits whenever the position changes.
                     */
                    this._positionChanges = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
                    /**
                     * Subscription to viewport size changes.
                     */
                    this._resizeSubscription = rxjs__WEBPACK_IMPORTED_MODULE_4__["Subscription"].EMPTY;
                    /**
                     * Default offset for the overlay along the x axis.
                     */
                    this._offsetX = 0;
                    /**
                     * Default offset for the overlay along the y axis.
                     */
                    this._offsetY = 0;
                    /**
                     * Keeps track of the CSS classes that the position strategy has applied on the overlay panel.
                     */
                    this._appliedPanelClasses = [];
                    /**
                     * Observable sequence of position changes.
                     */
                    this.positionChanges = this._positionChanges.asObservable();
                    this.setOrigin(connectedTo);
                }
                Object.defineProperty(FlexibleConnectedPositionStrategy.prototype, "positions", {
                    /**
                     * Ordered list of preferred positions, from most to least desirable.
                     * @return {?}
                     */
                    get: function () {
                        return this._preferredPositions;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Attaches this position strategy to an overlay.
                 * @param {?} overlayRef
                 * @return {?}
                 */
                FlexibleConnectedPositionStrategy.prototype.attach = function (overlayRef) {
                    var _this_1 = this;
                    if (this._overlayRef && overlayRef !== this._overlayRef) {
                        throw Error('This position strategy is already attached to an overlay');
                    }
                    this._validatePositions();
                    overlayRef.hostElement.classList.add(boundingBoxClass);
                    this._overlayRef = overlayRef;
                    this._boundingBox = overlayRef.hostElement;
                    this._pane = overlayRef.overlayElement;
                    this._isDisposed = false;
                    this._isInitialRender = true;
                    this._lastPosition = null;
                    this._resizeSubscription.unsubscribe();
                    this._resizeSubscription = this._viewportRuler.change().subscribe(( /**
                     * @return {?}
                     */function () {
                        // When the window is resized, we want to trigger the next reposition as if it
                        // was an initial render, in order for the strategy to pick a new optimal position,
                        // otherwise position locking will cause it to stay at the old one.
                        _this_1._isInitialRender = true;
                        _this_1.apply();
                    }));
                };
                /**
                 * Updates the position of the overlay element, using whichever preferred position relative
                 * to the origin best fits on-screen.
                 *
                 * The selection of a position goes as follows:
                 *  - If any positions fit completely within the viewport as-is,
                 *      choose the first position that does so.
                 *  - If flexible dimensions are enabled and at least one satifies the given minimum width/height,
                 *      choose the position with the greatest available size modified by the positions' weight.
                 *  - If pushing is enabled, take the position that went off-screen the least and push it
                 *      on-screen.
                 *  - If none of the previous criteria were met, use the position that goes off-screen the least.
                 * \@docs-private
                 * @return {?}
                 */
                FlexibleConnectedPositionStrategy.prototype.apply = function () {
                    // We shouldn't do anything if the strategy was disposed or we're on the server.
                    if (this._isDisposed || !this._platform.isBrowser) {
                        return;
                    }
                    // If the position has been applied already (e.g. when the overlay was opened) and the
                    // consumer opted into locking in the position, re-use the old position, in order to
                    // prevent the overlay from jumping around.
                    if (!this._isInitialRender && this._positionLocked && this._lastPosition) {
                        this.reapplyLastPosition();
                        return;
                    }
                    this._clearPanelClasses();
                    this._resetOverlayElementStyles();
                    this._resetBoundingBoxStyles();
                    // We need the bounding rects for the origin and the overlay to determine how to position
                    // the overlay relative to the origin.
                    // We use the viewport rect to determine whether a position would go off-screen.
                    this._viewportRect = this._getNarrowedViewportRect();
                    this._originRect = this._getOriginRect();
                    this._overlayRect = this._pane.getBoundingClientRect();
                    /** @type {?} */
                    var originRect = this._originRect;
                    /** @type {?} */
                    var overlayRect = this._overlayRect;
                    /** @type {?} */
                    var viewportRect = this._viewportRect;
                    // Positions where the overlay will fit with flexible dimensions.
                    /** @type {?} */
                    var flexibleFits = [];
                    // Fallback if none of the preferred positions fit within the viewport.
                    /** @type {?} */
                    var fallback;
                    // Go through each of the preferred positions looking for a good fit.
                    // If a good fit is found, it will be applied immediately.
                    for (var _a = 0, _b = this._preferredPositions; _a < _b.length; _a++) {
                        var pos = _b[_a];
                        // Get the exact (x, y) coordinate for the point-of-origin on the origin element.
                        /** @type {?} */
                        var originPoint = this._getOriginPoint(originRect, pos);
                        // From that point-of-origin, get the exact (x, y) coordinate for the top-left corner of the
                        // overlay in this position. We use the top-left corner for calculations and later translate
                        // this into an appropriate (top, left, bottom, right) style.
                        /** @type {?} */
                        var overlayPoint = this._getOverlayPoint(originPoint, overlayRect, pos);
                        // Calculate how well the overlay would fit into the viewport with this point.
                        /** @type {?} */
                        var overlayFit = this._getOverlayFit(overlayPoint, overlayRect, viewportRect, pos);
                        // If the overlay, without any further work, fits into the viewport, use this position.
                        if (overlayFit.isCompletelyWithinViewport) {
                            this._isPushed = false;
                            this._applyPosition(pos, originPoint);
                            return;
                        }
                        // If the overlay has flexible dimensions, we can use this position
                        // so long as there's enough space for the minimum dimensions.
                        if (this._canFitWithFlexibleDimensions(overlayFit, overlayPoint, viewportRect)) {
                            // Save positions where the overlay will fit with flexible dimensions. We will use these
                            // if none of the positions fit *without* flexible dimensions.
                            flexibleFits.push({
                                position: pos,
                                origin: originPoint,
                                overlayRect: overlayRect,
                                boundingBoxRect: this._calculateBoundingBoxRect(originPoint, pos)
                            });
                            continue;
                        }
                        // If the current preferred position does not fit on the screen, remember the position
                        // if it has more visible area on-screen than we've seen and move onto the next preferred
                        // position.
                        if (!fallback || fallback.overlayFit.visibleArea < overlayFit.visibleArea) {
                            fallback = { overlayFit: overlayFit, overlayPoint: overlayPoint, originPoint: originPoint, position: pos, overlayRect: overlayRect };
                        }
                    }
                    // If there are any positions where the overlay would fit with flexible dimensions, choose the
                    // one that has the greatest area available modified by the position's weight
                    if (flexibleFits.length) {
                        /** @type {?} */
                        var bestFit = null;
                        /** @type {?} */
                        var bestScore = -1;
                        for (var _f = 0, flexibleFits_1 = flexibleFits; _f < flexibleFits_1.length; _f++) {
                            var fit = flexibleFits_1[_f];
                            /** @type {?} */
                            var score = fit.boundingBoxRect.width * fit.boundingBoxRect.height * (fit.position.weight || 1);
                            if (score > bestScore) {
                                bestScore = score;
                                bestFit = fit;
                            }
                        }
                        this._isPushed = false;
                        this._applyPosition(( /** @type {?} */(bestFit)).position, ( /** @type {?} */(bestFit)).origin);
                        return;
                    }
                    // When none of the preferred positions fit within the viewport, take the position
                    // that went off-screen the least and attempt to push it on-screen.
                    if (this._canPush) {
                        // TODO(jelbourn): after pushing, the opening "direction" of the overlay might not make sense.
                        this._isPushed = true;
                        this._applyPosition(( /** @type {?} */(fallback)).position, ( /** @type {?} */(fallback)).originPoint);
                        return;
                    }
                    // All options for getting the overlay within the viewport have been exhausted, so go with the
                    // position that went off-screen the least.
                    this._applyPosition(( /** @type {?} */(fallback)).position, ( /** @type {?} */(fallback)).originPoint);
                };
                /**
                 * @return {?}
                 */
                FlexibleConnectedPositionStrategy.prototype.detach = function () {
                    this._clearPanelClasses();
                    this._lastPosition = null;
                    this._previousPushAmount = null;
                    this._resizeSubscription.unsubscribe();
                };
                /**
                 * Cleanup after the element gets destroyed.
                 * @return {?}
                 */
                FlexibleConnectedPositionStrategy.prototype.dispose = function () {
                    if (this._isDisposed) {
                        return;
                    }
                    // We can't use `_resetBoundingBoxStyles` here, because it resets
                    // some properties to zero, rather than removing them.
                    if (this._boundingBox) {
                        extendStyles(this._boundingBox.style, ( /** @type {?} */({
                            top: '',
                            left: '',
                            right: '',
                            bottom: '',
                            height: '',
                            width: '',
                            alignItems: '',
                            justifyContent: '',
                        })));
                    }
                    if (this._pane) {
                        this._resetOverlayElementStyles();
                    }
                    if (this._overlayRef) {
                        this._overlayRef.hostElement.classList.remove(boundingBoxClass);
                    }
                    this.detach();
                    this._positionChanges.complete();
                    this._overlayRef = this._boundingBox = ( /** @type {?} */(null));
                    this._isDisposed = true;
                };
                /**
                 * This re-aligns the overlay element with the trigger in its last calculated position,
                 * even if a position higher in the "preferred positions" list would now fit. This
                 * allows one to re-align the panel without changing the orientation of the panel.
                 * @return {?}
                 */
                FlexibleConnectedPositionStrategy.prototype.reapplyLastPosition = function () {
                    if (!this._isDisposed && (!this._platform || this._platform.isBrowser)) {
                        this._originRect = this._getOriginRect();
                        this._overlayRect = this._pane.getBoundingClientRect();
                        this._viewportRect = this._getNarrowedViewportRect();
                        /** @type {?} */
                        var lastPosition = this._lastPosition || this._preferredPositions[0];
                        /** @type {?} */
                        var originPoint = this._getOriginPoint(this._originRect, lastPosition);
                        this._applyPosition(lastPosition, originPoint);
                    }
                };
                /**
                 * Sets the list of Scrollable containers that host the origin element so that
                 * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every
                 * Scrollable must be an ancestor element of the strategy's origin element.
                 * @template THIS
                 * @this {THIS}
                 * @param {?} scrollables
                 * @return {THIS}
                 */
                FlexibleConnectedPositionStrategy.prototype.withScrollableContainers = function (scrollables) {
                    ( /** @type {?} */(this))._scrollables = scrollables;
                    return ( /** @type {?} */(this));
                };
                /**
                 * Adds new preferred positions.
                 * @template THIS
                 * @this {THIS}
                 * @param {?} positions List of positions options for this overlay.
                 * @return {THIS}
                 */
                FlexibleConnectedPositionStrategy.prototype.withPositions = function (positions) {
                    ( /** @type {?} */(this))._preferredPositions = positions;
                    // If the last calculated position object isn't part of the positions anymore, clear
                    // it in order to avoid it being picked up if the consumer tries to re-apply.
                    if (positions.indexOf(( /** @type {?} */(( /** @type {?} */(this))._lastPosition))) === -1) {
                        ( /** @type {?} */(this))._lastPosition = null;
                    }
                    ( /** @type {?} */(this))._validatePositions();
                    return ( /** @type {?} */(this));
                };
                /**
                 * Sets a minimum distance the overlay may be positioned to the edge of the viewport.
                 * @template THIS
                 * @this {THIS}
                 * @param {?} margin Required margin between the overlay and the viewport edge in pixels.
                 * @return {THIS}
                 */
                FlexibleConnectedPositionStrategy.prototype.withViewportMargin = function (margin) {
                    ( /** @type {?} */(this))._viewportMargin = margin;
                    return ( /** @type {?} */(this));
                };
                /**
                 * Sets whether the overlay's width and height can be constrained to fit within the viewport.
                 * @template THIS
                 * @this {THIS}
                 * @param {?=} flexibleDimensions
                 * @return {THIS}
                 */
                FlexibleConnectedPositionStrategy.prototype.withFlexibleDimensions = function (flexibleDimensions) {
                    if (flexibleDimensions === void 0) { flexibleDimensions = true; }
                    ( /** @type {?} */(this))._hasFlexibleDimensions = flexibleDimensions;
                    return ( /** @type {?} */(this));
                };
                /**
                 * Sets whether the overlay can grow after the initial open via flexible width/height.
                 * @template THIS
                 * @this {THIS}
                 * @param {?=} growAfterOpen
                 * @return {THIS}
                 */
                FlexibleConnectedPositionStrategy.prototype.withGrowAfterOpen = function (growAfterOpen) {
                    if (growAfterOpen === void 0) { growAfterOpen = true; }
                    ( /** @type {?} */(this))._growAfterOpen = growAfterOpen;
                    return ( /** @type {?} */(this));
                };
                /**
                 * Sets whether the overlay can be pushed on-screen if none of the provided positions fit.
                 * @template THIS
                 * @this {THIS}
                 * @param {?=} canPush
                 * @return {THIS}
                 */
                FlexibleConnectedPositionStrategy.prototype.withPush = function (canPush) {
                    if (canPush === void 0) { canPush = true; }
                    ( /** @type {?} */(this))._canPush = canPush;
                    return ( /** @type {?} */(this));
                };
                /**
                 * Sets whether the overlay's position should be locked in after it is positioned
                 * initially. When an overlay is locked in, it won't attempt to reposition itself
                 * when the position is re-applied (e.g. when the user scrolls away).
                 * @template THIS
                 * @this {THIS}
                 * @param {?=} isLocked Whether the overlay should locked in.
                 * @return {THIS}
                 */
                FlexibleConnectedPositionStrategy.prototype.withLockedPosition = function (isLocked) {
                    if (isLocked === void 0) { isLocked = true; }
                    ( /** @type {?} */(this))._positionLocked = isLocked;
                    return ( /** @type {?} */(this));
                };
                /**
                 * Sets the origin, relative to which to position the overlay.
                 * Using an element origin is useful for building components that need to be positioned
                 * relatively to a trigger (e.g. dropdown menus or tooltips), whereas using a point can be
                 * used for cases like contextual menus which open relative to the user's pointer.
                 * @template THIS
                 * @this {THIS}
                 * @param {?} origin Reference to the new origin.
                 * @return {THIS}
                 */
                FlexibleConnectedPositionStrategy.prototype.setOrigin = function (origin) {
                    ( /** @type {?} */(this))._origin = origin;
                    return ( /** @type {?} */(this));
                };
                /**
                 * Sets the default offset for the overlay's connection point on the x-axis.
                 * @template THIS
                 * @this {THIS}
                 * @param {?} offset New offset in the X axis.
                 * @return {THIS}
                 */
                FlexibleConnectedPositionStrategy.prototype.withDefaultOffsetX = function (offset) {
                    ( /** @type {?} */(this))._offsetX = offset;
                    return ( /** @type {?} */(this));
                };
                /**
                 * Sets the default offset for the overlay's connection point on the y-axis.
                 * @template THIS
                 * @this {THIS}
                 * @param {?} offset New offset in the Y axis.
                 * @return {THIS}
                 */
                FlexibleConnectedPositionStrategy.prototype.withDefaultOffsetY = function (offset) {
                    ( /** @type {?} */(this))._offsetY = offset;
                    return ( /** @type {?} */(this));
                };
                /**
                 * Configures that the position strategy should set a `transform-origin` on some elements
                 * inside the overlay, depending on the current position that is being applied. This is
                 * useful for the cases where the origin of an animation can change depending on the
                 * alignment of the overlay.
                 * @template THIS
                 * @this {THIS}
                 * @param {?} selector CSS selector that will be used to find the target
                 *    elements onto which to set the transform origin.
                 * @return {THIS}
                 */
                FlexibleConnectedPositionStrategy.prototype.withTransformOriginOn = function (selector) {
                    ( /** @type {?} */(this))._transformOriginSelector = selector;
                    return ( /** @type {?} */(this));
                };
                /**
                 * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.
                 * @private
                 * @param {?} originRect
                 * @param {?} pos
                 * @return {?}
                 */
                FlexibleConnectedPositionStrategy.prototype._getOriginPoint = function (originRect, pos) {
                    /** @type {?} */
                    var x;
                    if (pos.originX == 'center') {
                        // Note: when centering we should always use the `left`
                        // offset, otherwise the position will be wrong in RTL.
                        x = originRect.left + (originRect.width / 2);
                    }
                    else {
                        /** @type {?} */
                        var startX = this._isRtl() ? originRect.right : originRect.left;
                        /** @type {?} */
                        var endX = this._isRtl() ? originRect.left : originRect.right;
                        x = pos.originX == 'start' ? startX : endX;
                    }
                    /** @type {?} */
                    var y;
                    if (pos.originY == 'center') {
                        y = originRect.top + (originRect.height / 2);
                    }
                    else {
                        y = pos.originY == 'top' ? originRect.top : originRect.bottom;
                    }
                    return { x: x, y: y };
                };
                /**
                 * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and
                 * origin point to which the overlay should be connected.
                 * @private
                 * @param {?} originPoint
                 * @param {?} overlayRect
                 * @param {?} pos
                 * @return {?}
                 */
                FlexibleConnectedPositionStrategy.prototype._getOverlayPoint = function (originPoint, overlayRect, pos) {
                    // Calculate the (overlayStartX, overlayStartY), the start of the
                    // potential overlay position relative to the origin point.
                    /** @type {?} */
                    var overlayStartX;
                    if (pos.overlayX == 'center') {
                        overlayStartX = -overlayRect.width / 2;
                    }
                    else if (pos.overlayX === 'start') {
                        overlayStartX = this._isRtl() ? -overlayRect.width : 0;
                    }
                    else {
                        overlayStartX = this._isRtl() ? 0 : -overlayRect.width;
                    }
                    /** @type {?} */
                    var overlayStartY;
                    if (pos.overlayY == 'center') {
                        overlayStartY = -overlayRect.height / 2;
                    }
                    else {
                        overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;
                    }
                    // The (x, y) coordinates of the overlay.
                    return {
                        x: originPoint.x + overlayStartX,
                        y: originPoint.y + overlayStartY,
                    };
                };
                /**
                 * Gets how well an overlay at the given point will fit within the viewport.
                 * @private
                 * @param {?} point
                 * @param {?} overlay
                 * @param {?} viewport
                 * @param {?} position
                 * @return {?}
                 */
                FlexibleConnectedPositionStrategy.prototype._getOverlayFit = function (point, overlay, viewport, position) {
                    var x = point.x, y = point.y;
                    /** @type {?} */
                    var offsetX = this._getOffset(position, 'x');
                    /** @type {?} */
                    var offsetY = this._getOffset(position, 'y');
                    // Account for the offsets since they could push the overlay out of the viewport.
                    if (offsetX) {
                        x += offsetX;
                    }
                    if (offsetY) {
                        y += offsetY;
                    }
                    // How much the overlay would overflow at this position, on each side.
                    /** @type {?} */
                    var leftOverflow = 0 - x;
                    /** @type {?} */
                    var rightOverflow = (x + overlay.width) - viewport.width;
                    /** @type {?} */
                    var topOverflow = 0 - y;
                    /** @type {?} */
                    var bottomOverflow = (y + overlay.height) - viewport.height;
                    // Visible parts of the element on each axis.
                    /** @type {?} */
                    var visibleWidth = this._subtractOverflows(overlay.width, leftOverflow, rightOverflow);
                    /** @type {?} */
                    var visibleHeight = this._subtractOverflows(overlay.height, topOverflow, bottomOverflow);
                    /** @type {?} */
                    var visibleArea = visibleWidth * visibleHeight;
                    return {
                        visibleArea: visibleArea,
                        isCompletelyWithinViewport: (overlay.width * overlay.height) === visibleArea,
                        fitsInViewportVertically: visibleHeight === overlay.height,
                        fitsInViewportHorizontally: visibleWidth == overlay.width,
                    };
                };
                /**
                 * Whether the overlay can fit within the viewport when it may resize either its width or height.
                 * @private
                 * @param {?} fit How well the overlay fits in the viewport at some position.
                 * @param {?} point The (x, y) coordinates of the overlat at some position.
                 * @param {?} viewport The geometry of the viewport.
                 * @return {?}
                 */
                FlexibleConnectedPositionStrategy.prototype._canFitWithFlexibleDimensions = function (fit, point, viewport) {
                    if (this._hasFlexibleDimensions) {
                        /** @type {?} */
                        var availableHeight = viewport.bottom - point.y;
                        /** @type {?} */
                        var availableWidth = viewport.right - point.x;
                        /** @type {?} */
                        var minHeight = this._overlayRef.getConfig().minHeight;
                        /** @type {?} */
                        var minWidth = this._overlayRef.getConfig().minWidth;
                        /** @type {?} */
                        var verticalFit = fit.fitsInViewportVertically ||
                            (minHeight != null && minHeight <= availableHeight);
                        /** @type {?} */
                        var horizontalFit = fit.fitsInViewportHorizontally ||
                            (minWidth != null && minWidth <= availableWidth);
                        return verticalFit && horizontalFit;
                    }
                    return false;
                };
                /**
                 * Gets the point at which the overlay can be "pushed" on-screen. If the overlay is larger than
                 * the viewport, the top-left corner will be pushed on-screen (with overflow occuring on the
                 * right and bottom).
                 *
                 * @private
                 * @param {?} start Starting point from which the overlay is pushed.
                 * @param {?} overlay Dimensions of the overlay.
                 * @param {?} scrollPosition Current viewport scroll position.
                 * @return {?} The point at which to position the overlay after pushing. This is effectively a new
                 *     originPoint.
                 */
                FlexibleConnectedPositionStrategy.prototype._pushOverlayOnScreen = function (start, overlay, scrollPosition) {
                    // If the position is locked and we've pushed the overlay already, reuse the previous push
                    // amount, rather than pushing it again. If we were to continue pushing, the element would
                    // remain in the viewport, which goes against the expectations when position locking is enabled.
                    if (this._previousPushAmount && this._positionLocked) {
                        return {
                            x: start.x + this._previousPushAmount.x,
                            y: start.y + this._previousPushAmount.y
                        };
                    }
                    /** @type {?} */
                    var viewport = this._viewportRect;
                    // Determine how much the overlay goes outside the viewport on each
                    // side, which we'll use to decide which direction to push it.
                    /** @type {?} */
                    var overflowRight = Math.max(start.x + overlay.width - viewport.right, 0);
                    /** @type {?} */
                    var overflowBottom = Math.max(start.y + overlay.height - viewport.bottom, 0);
                    /** @type {?} */
                    var overflowTop = Math.max(viewport.top - scrollPosition.top - start.y, 0);
                    /** @type {?} */
                    var overflowLeft = Math.max(viewport.left - scrollPosition.left - start.x, 0);
                    // Amount by which to push the overlay in each axis such that it remains on-screen.
                    /** @type {?} */
                    var pushX = 0;
                    /** @type {?} */
                    var pushY = 0;
                    // If the overlay fits completely within the bounds of the viewport, push it from whichever
                    // direction is goes off-screen. Otherwise, push the top-left corner such that its in the
                    // viewport and allow for the trailing end of the overlay to go out of bounds.
                    if (overlay.width <= viewport.width) {
                        pushX = overflowLeft || -overflowRight;
                    }
                    else {
                        pushX = start.x < this._viewportMargin ? (viewport.left - scrollPosition.left) - start.x : 0;
                    }
                    if (overlay.height <= viewport.height) {
                        pushY = overflowTop || -overflowBottom;
                    }
                    else {
                        pushY = start.y < this._viewportMargin ? (viewport.top - scrollPosition.top) - start.y : 0;
                    }
                    this._previousPushAmount = { x: pushX, y: pushY };
                    return {
                        x: start.x + pushX,
                        y: start.y + pushY,
                    };
                };
                /**
                 * Applies a computed position to the overlay and emits a position change.
                 * @private
                 * @param {?} position The position preference
                 * @param {?} originPoint The point on the origin element where the overlay is connected.
                 * @return {?}
                 */
                FlexibleConnectedPositionStrategy.prototype._applyPosition = function (position, originPoint) {
                    this._setTransformOrigin(position);
                    this._setOverlayElementStyles(originPoint, position);
                    this._setBoundingBoxStyles(originPoint, position);
                    if (position.panelClass) {
                        this._addPanelClasses(position.panelClass);
                    }
                    // Save the last connected position in case the position needs to be re-calculated.
                    this._lastPosition = position;
                    // Notify that the position has been changed along with its change properties.
                    // We only emit if we've got any subscriptions, because the scroll visibility
                    // calculcations can be somewhat expensive.
                    if (this._positionChanges.observers.length) {
                        /** @type {?} */
                        var scrollableViewProperties = this._getScrollVisibility();
                        /** @type {?} */
                        var changeEvent = new ConnectedOverlayPositionChange(position, scrollableViewProperties);
                        this._positionChanges.next(changeEvent);
                    }
                    this._isInitialRender = false;
                };
                /**
                 * Sets the transform origin based on the configured selector and the passed-in position.
                 * @private
                 * @param {?} position
                 * @return {?}
                 */
                FlexibleConnectedPositionStrategy.prototype._setTransformOrigin = function (position) {
                    if (!this._transformOriginSelector) {
                        return;
                    }
                    /** @type {?} */
                    var elements = ( /** @type {?} */(this._boundingBox)).querySelectorAll(this._transformOriginSelector);
                    /** @type {?} */
                    var xOrigin;
                    /** @type {?} */
                    var yOrigin = position.overlayY;
                    if (position.overlayX === 'center') {
                        xOrigin = 'center';
                    }
                    else if (this._isRtl()) {
                        xOrigin = position.overlayX === 'start' ? 'right' : 'left';
                    }
                    else {
                        xOrigin = position.overlayX === 'start' ? 'left' : 'right';
                    }
                    for (var i = 0; i < elements.length; i++) {
                        elements[i].style.transformOrigin = xOrigin + " " + yOrigin;
                    }
                };
                /**
                 * Gets the position and size of the overlay's sizing container.
                 *
                 * This method does no measuring and applies no styles so that we can cheaply compute the
                 * bounds for all positions and choose the best fit based on these results.
                 * @private
                 * @param {?} origin
                 * @param {?} position
                 * @return {?}
                 */
                FlexibleConnectedPositionStrategy.prototype._calculateBoundingBoxRect = function (origin, position) {
                    /** @type {?} */
                    var viewport = this._viewportRect;
                    /** @type {?} */
                    var isRtl = this._isRtl();
                    /** @type {?} */
                    var height;
                    /** @type {?} */
                    var top;
                    /** @type {?} */
                    var bottom;
                    if (position.overlayY === 'top') {
                        // Overlay is opening "downward" and thus is bound by the bottom viewport edge.
                        top = origin.y;
                        height = viewport.height - top + this._viewportMargin;
                    }
                    else if (position.overlayY === 'bottom') {
                        // Overlay is opening "upward" and thus is bound by the top viewport edge. We need to add
                        // the viewport margin back in, because the viewport rect is narrowed down to remove the
                        // margin, whereas the `origin` position is calculated based on its `ClientRect`.
                        bottom = viewport.height - origin.y + this._viewportMargin * 2;
                        height = viewport.height - bottom + this._viewportMargin;
                    }
                    else {
                        // If neither top nor bottom, it means that the overlay is vertically centered on the
                        // origin point. Note that we want the position relative to the viewport, rather than
                        // the page, which is why we don't use something like `viewport.bottom - origin.y` and
                        // `origin.y - viewport.top`.
                        /** @type {?} */
                        var smallestDistanceToViewportEdge = Math.min(viewport.bottom - origin.y + viewport.top, origin.y);
                        /** @type {?} */
                        var previousHeight = this._lastBoundingBoxSize.height;
                        height = smallestDistanceToViewportEdge * 2;
                        top = origin.y - smallestDistanceToViewportEdge;
                        if (height > previousHeight && !this._isInitialRender && !this._growAfterOpen) {
                            top = origin.y - (previousHeight / 2);
                        }
                    }
                    // The overlay is opening 'right-ward' (the content flows to the right).
                    /** @type {?} */
                    var isBoundedByRightViewportEdge = (position.overlayX === 'start' && !isRtl) ||
                        (position.overlayX === 'end' && isRtl);
                    // The overlay is opening 'left-ward' (the content flows to the left).
                    /** @type {?} */
                    var isBoundedByLeftViewportEdge = (position.overlayX === 'end' && !isRtl) ||
                        (position.overlayX === 'start' && isRtl);
                    /** @type {?} */
                    var width;
                    /** @type {?} */
                    var left;
                    /** @type {?} */
                    var right;
                    if (isBoundedByLeftViewportEdge) {
                        right = viewport.width - origin.x + this._viewportMargin;
                        width = origin.x - this._viewportMargin;
                    }
                    else if (isBoundedByRightViewportEdge) {
                        left = origin.x;
                        width = viewport.right - origin.x;
                    }
                    else {
                        // If neither start nor end, it means that the overlay is horizontally centered on the
                        // origin point. Note that we want the position relative to the viewport, rather than
                        // the page, which is why we don't use something like `viewport.right - origin.x` and
                        // `origin.x - viewport.left`.
                        /** @type {?} */
                        var smallestDistanceToViewportEdge = Math.min(viewport.right - origin.x + viewport.left, origin.x);
                        /** @type {?} */
                        var previousWidth = this._lastBoundingBoxSize.width;
                        width = smallestDistanceToViewportEdge * 2;
                        left = origin.x - smallestDistanceToViewportEdge;
                        if (width > previousWidth && !this._isInitialRender && !this._growAfterOpen) {
                            left = origin.x - (previousWidth / 2);
                        }
                    }
                    return { top: ( /** @type {?} */(top)), left: ( /** @type {?} */(left)), bottom: ( /** @type {?} */(bottom)), right: ( /** @type {?} */(right)), width: width, height: height };
                };
                /**
                 * Sets the position and size of the overlay's sizing wrapper. The wrapper is positioned on the
                 * origin's connection point and stetches to the bounds of the viewport.
                 *
                 * @private
                 * @param {?} origin The point on the origin element where the overlay is connected.
                 * @param {?} position The position preference
                 * @return {?}
                 */
                FlexibleConnectedPositionStrategy.prototype._setBoundingBoxStyles = function (origin, position) {
                    /** @type {?} */
                    var boundingBoxRect = this._calculateBoundingBoxRect(origin, position);
                    // It's weird if the overlay *grows* while scrolling, so we take the last size into account
                    // when applying a new size.
                    if (!this._isInitialRender && !this._growAfterOpen) {
                        boundingBoxRect.height = Math.min(boundingBoxRect.height, this._lastBoundingBoxSize.height);
                        boundingBoxRect.width = Math.min(boundingBoxRect.width, this._lastBoundingBoxSize.width);
                    }
                    /** @type {?} */
                    var styles = ( /** @type {?} */({}));
                    if (this._hasExactPosition()) {
                        styles.top = styles.left = '0';
                        styles.bottom = styles.right = '';
                        styles.width = styles.height = '100%';
                    }
                    else {
                        /** @type {?} */
                        var maxHeight = this._overlayRef.getConfig().maxHeight;
                        /** @type {?} */
                        var maxWidth = this._overlayRef.getConfig().maxWidth;
                        styles.height = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(boundingBoxRect.height);
                        styles.top = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(boundingBoxRect.top);
                        styles.bottom = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(boundingBoxRect.bottom);
                        styles.width = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(boundingBoxRect.width);
                        styles.left = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(boundingBoxRect.left);
                        styles.right = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(boundingBoxRect.right);
                        // Push the pane content towards the proper direction.
                        if (position.overlayX === 'center') {
                            styles.alignItems = 'center';
                        }
                        else {
                            styles.alignItems = position.overlayX === 'end' ? 'flex-end' : 'flex-start';
                        }
                        if (position.overlayY === 'center') {
                            styles.justifyContent = 'center';
                        }
                        else {
                            styles.justifyContent = position.overlayY === 'bottom' ? 'flex-end' : 'flex-start';
                        }
                        if (maxHeight) {
                            styles.maxHeight = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(maxHeight);
                        }
                        if (maxWidth) {
                            styles.maxWidth = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(maxWidth);
                        }
                    }
                    this._lastBoundingBoxSize = boundingBoxRect;
                    extendStyles(( /** @type {?} */(this._boundingBox)).style, styles);
                };
                /**
                 * Resets the styles for the bounding box so that a new positioning can be computed.
                 * @private
                 * @return {?}
                 */
                FlexibleConnectedPositionStrategy.prototype._resetBoundingBoxStyles = function () {
                    extendStyles(( /** @type {?} */(this._boundingBox)).style, ( /** @type {?} */({
                        top: '0',
                        left: '0',
                        right: '0',
                        bottom: '0',
                        height: '',
                        width: '',
                        alignItems: '',
                        justifyContent: '',
                    })));
                };
                /**
                 * Resets the styles for the overlay pane so that a new positioning can be computed.
                 * @private
                 * @return {?}
                 */
                FlexibleConnectedPositionStrategy.prototype._resetOverlayElementStyles = function () {
                    extendStyles(this._pane.style, ( /** @type {?} */({
                        top: '',
                        left: '',
                        bottom: '',
                        right: '',
                        position: '',
                        transform: '',
                    })));
                };
                /**
                 * Sets positioning styles to the overlay element.
                 * @private
                 * @param {?} originPoint
                 * @param {?} position
                 * @return {?}
                 */
                FlexibleConnectedPositionStrategy.prototype._setOverlayElementStyles = function (originPoint, position) {
                    /** @type {?} */
                    var styles = ( /** @type {?} */({}));
                    if (this._hasExactPosition()) {
                        /** @type {?} */
                        var scrollPosition = this._viewportRuler.getViewportScrollPosition();
                        extendStyles(styles, this._getExactOverlayY(position, originPoint, scrollPosition));
                        extendStyles(styles, this._getExactOverlayX(position, originPoint, scrollPosition));
                    }
                    else {
                        styles.position = 'static';
                    }
                    // Use a transform to apply the offsets. We do this because the `center` positions rely on
                    // being in the normal flex flow and setting a `top` / `left` at all will completely throw
                    // off the position. We also can't use margins, because they won't have an effect in some
                    // cases where the element doesn't have anything to "push off of". Finally, this works
                    // better both with flexible and non-flexible positioning.
                    /** @type {?} */
                    var transformString = '';
                    /** @type {?} */
                    var offsetX = this._getOffset(position, 'x');
                    /** @type {?} */
                    var offsetY = this._getOffset(position, 'y');
                    if (offsetX) {
                        transformString += "translateX(" + offsetX + "px) ";
                    }
                    if (offsetY) {
                        transformString += "translateY(" + offsetY + "px)";
                    }
                    styles.transform = transformString.trim();
                    // If a maxWidth or maxHeight is specified on the overlay, we remove them. We do this because
                    // we need these values to both be set to "100%" for the automatic flexible sizing to work.
                    // The maxHeight and maxWidth are set on the boundingBox in order to enforce the constraint.
                    if (this._hasFlexibleDimensions && this._overlayRef.getConfig().maxHeight) {
                        styles.maxHeight = '';
                    }
                    if (this._hasFlexibleDimensions && this._overlayRef.getConfig().maxWidth) {
                        styles.maxWidth = '';
                    }
                    extendStyles(this._pane.style, styles);
                };
                /**
                 * Gets the exact top/bottom for the overlay when not using flexible sizing or when pushing.
                 * @private
                 * @param {?} position
                 * @param {?} originPoint
                 * @param {?} scrollPosition
                 * @return {?}
                 */
                FlexibleConnectedPositionStrategy.prototype._getExactOverlayY = function (position, originPoint, scrollPosition) {
                    // Reset any existing styles. This is necessary in case the
                    // preferred position has changed since the last `apply`.
                    /** @type {?} */
                    var styles = ( /** @type {?} */({ top: null, bottom: null }));
                    /** @type {?} */
                    var overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);
                    if (this._isPushed) {
                        overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);
                    }
                    /** @type {?} */
                    var virtualKeyboardOffset = this._overlayContainer.getContainerElement().getBoundingClientRect().top;
                    // Normally this would be zero, however when the overlay is attached to an input (e.g. in an
                    // autocomplete), mobile browsers will shift everything in order to put the input in the middle
                    // of the screen and to make space for the virtual keyboard. We need to account for this offset,
                    // otherwise our positioning will be thrown off.
                    overlayPoint.y -= virtualKeyboardOffset;
                    // We want to set either `top` or `bottom` based on whether the overlay wants to appear
                    // above or below the origin and the direction in which the element will expand.
                    if (position.overlayY === 'bottom') {
                        // When using `bottom`, we adjust the y position such that it is the distance
                        // from the bottom of the viewport rather than the top.
                        /** @type {?} */
                        var documentHeight = ( /** @type {?} */(this._document.documentElement)).clientHeight;
                        styles.bottom = documentHeight - (overlayPoint.y + this._overlayRect.height) + "px";
                    }
                    else {
                        styles.top = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(overlayPoint.y);
                    }
                    return styles;
                };
                /**
                 * Gets the exact left/right for the overlay when not using flexible sizing or when pushing.
                 * @private
                 * @param {?} position
                 * @param {?} originPoint
                 * @param {?} scrollPosition
                 * @return {?}
                 */
                FlexibleConnectedPositionStrategy.prototype._getExactOverlayX = function (position, originPoint, scrollPosition) {
                    // Reset any existing styles. This is necessary in case the preferred position has
                    // changed since the last `apply`.
                    /** @type {?} */
                    var styles = ( /** @type {?} */({ left: null, right: null }));
                    /** @type {?} */
                    var overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);
                    if (this._isPushed) {
                        overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);
                    }
                    // We want to set either `left` or `right` based on whether the overlay wants to appear "before"
                    // or "after" the origin, which determines the direction in which the element will expand.
                    // For the horizontal axis, the meaning of "before" and "after" change based on whether the
                    // page is in RTL or LTR.
                    /** @type {?} */
                    var horizontalStyleProperty;
                    if (this._isRtl()) {
                        horizontalStyleProperty = position.overlayX === 'end' ? 'left' : 'right';
                    }
                    else {
                        horizontalStyleProperty = position.overlayX === 'end' ? 'right' : 'left';
                    }
                    // When we're setting `right`, we adjust the x position such that it is the distance
                    // from the right edge of the viewport rather than the left edge.
                    if (horizontalStyleProperty === 'right') {
                        /** @type {?} */
                        var documentWidth = ( /** @type {?} */(this._document.documentElement)).clientWidth;
                        styles.right = documentWidth - (overlayPoint.x + this._overlayRect.width) + "px";
                    }
                    else {
                        styles.left = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(overlayPoint.x);
                    }
                    return styles;
                };
                /**
                 * Gets the view properties of the trigger and overlay, including whether they are clipped
                 * or completely outside the view of any of the strategy's scrollables.
                 * @private
                 * @return {?}
                 */
                FlexibleConnectedPositionStrategy.prototype._getScrollVisibility = function () {
                    // Note: needs fresh rects since the position could've changed.
                    /** @type {?} */
                    var originBounds = this._getOriginRect();
                    /** @type {?} */
                    var overlayBounds = this._pane.getBoundingClientRect();
                    // TODO(jelbourn): instead of needing all of the client rects for these scrolling containers
                    // every time, we should be able to use the scrollTop of the containers if the size of those
                    // containers hasn't changed.
                    /** @type {?} */
                    var scrollContainerBounds = this._scrollables.map(( /**
                     * @param {?} scrollable
                     * @return {?}
                     */function (/**
                     * @param {?} scrollable
                     * @return {?}
                     */ scrollable) {
                        return scrollable.getElementRef().nativeElement.getBoundingClientRect();
                    }));
                    return {
                        isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),
                        isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),
                        isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),
                        isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds),
                    };
                };
                /**
                 * Subtracts the amount that an element is overflowing on an axis from its length.
                 * @private
                 * @param {?} length
                 * @param {...?} overflows
                 * @return {?}
                 */
                FlexibleConnectedPositionStrategy.prototype._subtractOverflows = function (length) {
                    var overflows = [];
                    for (var _a = 1; _a < arguments.length; _a++) {
                        overflows[_a - 1] = arguments[_a];
                    }
                    return overflows.reduce(( /**
                     * @param {?} currentValue
                     * @param {?} currentOverflow
                     * @return {?}
                     */function (currentValue, currentOverflow) {
                        return currentValue - Math.max(currentOverflow, 0);
                    }), length);
                };
                /**
                 * Narrows the given viewport rect by the current _viewportMargin.
                 * @private
                 * @return {?}
                 */
                FlexibleConnectedPositionStrategy.prototype._getNarrowedViewportRect = function () {
                    // We recalculate the viewport rect here ourselves, rather than using the ViewportRuler,
                    // because we want to use the `clientWidth` and `clientHeight` as the base. The difference
                    // being that the client properties don't include the scrollbar, as opposed to `innerWidth`
                    // and `innerHeight` that do. This is necessary, because the overlay container uses
                    // 100% `width` and `height` which don't include the scrollbar either.
                    /** @type {?} */
                    var width = ( /** @type {?} */(this._document.documentElement)).clientWidth;
                    /** @type {?} */
                    var height = ( /** @type {?} */(this._document.documentElement)).clientHeight;
                    /** @type {?} */
                    var scrollPosition = this._viewportRuler.getViewportScrollPosition();
                    return {
                        top: scrollPosition.top + this._viewportMargin,
                        left: scrollPosition.left + this._viewportMargin,
                        right: scrollPosition.left + width - this._viewportMargin,
                        bottom: scrollPosition.top + height - this._viewportMargin,
                        width: width - (2 * this._viewportMargin),
                        height: height - (2 * this._viewportMargin),
                    };
                };
                /**
                 * Whether the we're dealing with an RTL context
                 * @private
                 * @return {?}
                 */
                FlexibleConnectedPositionStrategy.prototype._isRtl = function () {
                    return this._overlayRef.getDirection() === 'rtl';
                };
                /**
                 * Determines whether the overlay uses exact or flexible positioning.
                 * @private
                 * @return {?}
                 */
                FlexibleConnectedPositionStrategy.prototype._hasExactPosition = function () {
                    return !this._hasFlexibleDimensions || this._isPushed;
                };
                /**
                 * Retrieves the offset of a position along the x or y axis.
                 * @private
                 * @param {?} position
                 * @param {?} axis
                 * @return {?}
                 */
                FlexibleConnectedPositionStrategy.prototype._getOffset = function (position, axis) {
                    if (axis === 'x') {
                        // We don't do something like `position['offset' + axis]` in
                        // order to avoid breking minifiers that rename properties.
                        return position.offsetX == null ? this._offsetX : position.offsetX;
                    }
                    return position.offsetY == null ? this._offsetY : position.offsetY;
                };
                /**
                 * Validates that the current position match the expected values.
                 * @private
                 * @return {?}
                 */
                FlexibleConnectedPositionStrategy.prototype._validatePositions = function () {
                    if (!this._preferredPositions.length) {
                        throw Error('FlexibleConnectedPositionStrategy: At least one position is required.');
                    }
                    // TODO(crisbeto): remove these once Angular's template type
                    // checking is advanced enough to catch these cases.
                    this._preferredPositions.forEach(( /**
                     * @param {?} pair
                     * @return {?}
                     */function (/**
                     * @param {?} pair
                     * @return {?}
                     */ pair) {
                        validateHorizontalPosition('originX', pair.originX);
                        validateVerticalPosition('originY', pair.originY);
                        validateHorizontalPosition('overlayX', pair.overlayX);
                        validateVerticalPosition('overlayY', pair.overlayY);
                    }));
                };
                /**
                 * Adds a single CSS class or an array of classes on the overlay panel.
                 * @private
                 * @param {?} cssClasses
                 * @return {?}
                 */
                FlexibleConnectedPositionStrategy.prototype._addPanelClasses = function (cssClasses) {
                    var _this_1 = this;
                    if (this._pane) {
                        Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceArray"])(cssClasses).forEach(( /**
                         * @param {?} cssClass
                         * @return {?}
                         */function (/**
                         * @param {?} cssClass
                         * @return {?}
                         */ cssClass) {
                            if (cssClass !== '' && _this_1._appliedPanelClasses.indexOf(cssClass) === -1) {
                                _this_1._appliedPanelClasses.push(cssClass);
                                _this_1._pane.classList.add(cssClass);
                            }
                        }));
                    }
                };
                /**
                 * Clears the classes that the position strategy has applied from the overlay panel.
                 * @private
                 * @return {?}
                 */
                FlexibleConnectedPositionStrategy.prototype._clearPanelClasses = function () {
                    var _this_1 = this;
                    if (this._pane) {
                        this._appliedPanelClasses.forEach(( /**
                         * @param {?} cssClass
                         * @return {?}
                         */function (/**
                         * @param {?} cssClass
                         * @return {?}
                         */ cssClass) {
                            _this_1._pane.classList.remove(cssClass);
                        }));
                        this._appliedPanelClasses = [];
                    }
                };
                /**
                 * Returns the ClientRect of the current origin.
                 * @private
                 * @return {?}
                 */
                FlexibleConnectedPositionStrategy.prototype._getOriginRect = function () {
                    /** @type {?} */
                    var origin = this._origin;
                    if (origin instanceof _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"]) {
                        return origin.nativeElement.getBoundingClientRect();
                    }
                    if (origin instanceof HTMLElement) {
                        return origin.getBoundingClientRect();
                    }
                    /** @type {?} */
                    var width = origin.width || 0;
                    /** @type {?} */
                    var height = origin.height || 0;
                    // If the origin is a point, return a client rect as if it was a 0x0 element at the point.
                    return {
                        top: origin.y,
                        bottom: origin.y + height,
                        left: origin.x,
                        right: origin.x + width,
                        height: height,
                        width: width
                    };
                };
                return FlexibleConnectedPositionStrategy;
            }());
            /**
             * Shallow-extends a stylesheet object with another stylesheet object.
             * @param {?} dest
             * @param {?} source
             * @return {?}
             */
            function extendStyles(dest, source) {
                for (var key in source) {
                    if (source.hasOwnProperty(key)) {
                        dest[key] = source[key];
                    }
                }
                return dest;
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * A strategy for positioning overlays. Using this strategy, an overlay is given an
             * implicit position relative to some origin element. The relative position is defined in terms of
             * a point on the origin element that is connected to a point on the overlay element. For example,
             * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner
             * of the overlay.
             * @deprecated Use `FlexibleConnectedPositionStrategy` instead.
             * \@breaking-change 8.0.0
             */
            var ConnectedPositionStrategy = /** @class */ (function () {
                /**
                 * @param {?} originPos
                 * @param {?} overlayPos
                 * @param {?} connectedTo
                 * @param {?} viewportRuler
                 * @param {?} document
                 * @param {?} platform
                 * @param {?} overlayContainer
                 */
                function ConnectedPositionStrategy(originPos, overlayPos, connectedTo, viewportRuler, document, platform, overlayContainer) {
                    /**
                     * Ordered list of preferred positions, from most to least desirable.
                     */
                    this._preferredPositions = [];
                    // Since the `ConnectedPositionStrategy` is deprecated and we don't want to maintain
                    // the extra logic, we create an instance of the positioning strategy that has some
                    // defaults that make it behave as the old position strategy and to which we'll
                    // proxy all of the API calls.
                    this._positionStrategy = new FlexibleConnectedPositionStrategy(connectedTo, viewportRuler, document, platform, overlayContainer)
                        .withFlexibleDimensions(false)
                        .withPush(false)
                        .withViewportMargin(0);
                    this.withFallbackPosition(originPos, overlayPos);
                }
                Object.defineProperty(ConnectedPositionStrategy.prototype, "_isRtl", {
                    /**
                     * Whether the we're dealing with an RTL context
                     * @return {?}
                     */
                    get: function () {
                        return this._overlayRef.getDirection() === 'rtl';
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ConnectedPositionStrategy.prototype, "onPositionChange", {
                    /**
                     * Emits an event when the connection point changes.
                     * @return {?}
                     */
                    get: function () {
                        return this._positionStrategy.positionChanges;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ConnectedPositionStrategy.prototype, "positions", {
                    /**
                     * Ordered list of preferred positions, from most to least desirable.
                     * @return {?}
                     */
                    get: function () {
                        return this._preferredPositions;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Attach this position strategy to an overlay.
                 * @param {?} overlayRef
                 * @return {?}
                 */
                ConnectedPositionStrategy.prototype.attach = function (overlayRef) {
                    this._overlayRef = overlayRef;
                    this._positionStrategy.attach(overlayRef);
                    if (this._direction) {
                        overlayRef.setDirection(this._direction);
                        this._direction = null;
                    }
                };
                /**
                 * Disposes all resources used by the position strategy.
                 * @return {?}
                 */
                ConnectedPositionStrategy.prototype.dispose = function () {
                    this._positionStrategy.dispose();
                };
                /**
                 * \@docs-private
                 * @return {?}
                 */
                ConnectedPositionStrategy.prototype.detach = function () {
                    this._positionStrategy.detach();
                };
                /**
                 * Updates the position of the overlay element, using whichever preferred position relative
                 * to the origin fits on-screen.
                 * \@docs-private
                 * @return {?}
                 */
                ConnectedPositionStrategy.prototype.apply = function () {
                    this._positionStrategy.apply();
                };
                /**
                 * Re-positions the overlay element with the trigger in its last calculated position,
                 * even if a position higher in the "preferred positions" list would now fit. This
                 * allows one to re-align the panel without changing the orientation of the panel.
                 * @return {?}
                 */
                ConnectedPositionStrategy.prototype.recalculateLastPosition = function () {
                    this._positionStrategy.reapplyLastPosition();
                };
                /**
                 * Sets the list of Scrollable containers that host the origin element so that
                 * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every
                 * Scrollable must be an ancestor element of the strategy's origin element.
                 * @param {?} scrollables
                 * @return {?}
                 */
                ConnectedPositionStrategy.prototype.withScrollableContainers = function (scrollables) {
                    this._positionStrategy.withScrollableContainers(scrollables);
                };
                /**
                 * Adds a new preferred fallback position.
                 * @template THIS
                 * @this {THIS}
                 * @param {?} originPos
                 * @param {?} overlayPos
                 * @param {?=} offsetX
                 * @param {?=} offsetY
                 * @return {THIS}
                 */
                ConnectedPositionStrategy.prototype.withFallbackPosition = function (originPos, overlayPos, offsetX, offsetY) {
                    /** @type {?} */
                    var position = new ConnectionPositionPair(originPos, overlayPos, offsetX, offsetY);
                    ( /** @type {?} */(this))._preferredPositions.push(position);
                    ( /** @type {?} */(this))._positionStrategy.withPositions(( /** @type {?} */(this))._preferredPositions);
                    return ( /** @type {?} */(this));
                };
                /**
                 * Sets the layout direction so the overlay's position can be adjusted to match.
                 * @template THIS
                 * @this {THIS}
                 * @param {?} dir New layout direction.
                 * @return {THIS}
                 */
                ConnectedPositionStrategy.prototype.withDirection = function (dir) {
                    // Since the direction might be declared before the strategy is attached,
                    // we save the value in a temporary property and we'll transfer it to the
                    // overlay ref on attachment.
                    if (( /** @type {?} */(this))._overlayRef) {
                        ( /** @type {?} */(this))._overlayRef.setDirection(dir);
                    }
                    else {
                        ( /** @type {?} */(this))._direction = dir;
                    }
                    return ( /** @type {?} */(this));
                };
                /**
                 * Sets an offset for the overlay's connection point on the x-axis
                 * @template THIS
                 * @this {THIS}
                 * @param {?} offset New offset in the X axis.
                 * @return {THIS}
                 */
                ConnectedPositionStrategy.prototype.withOffsetX = function (offset) {
                    ( /** @type {?} */(this))._positionStrategy.withDefaultOffsetX(offset);
                    return ( /** @type {?} */(this));
                };
                /**
                 * Sets an offset for the overlay's connection point on the y-axis
                 * @template THIS
                 * @this {THIS}
                 * @param {?} offset New offset in the Y axis.
                 * @return {THIS}
                 */
                ConnectedPositionStrategy.prototype.withOffsetY = function (offset) {
                    ( /** @type {?} */(this))._positionStrategy.withDefaultOffsetY(offset);
                    return ( /** @type {?} */(this));
                };
                /**
                 * Sets whether the overlay's position should be locked in after it is positioned
                 * initially. When an overlay is locked in, it won't attempt to reposition itself
                 * when the position is re-applied (e.g. when the user scrolls away).
                 * @template THIS
                 * @this {THIS}
                 * @param {?} isLocked Whether the overlay should locked in.
                 * @return {THIS}
                 */
                ConnectedPositionStrategy.prototype.withLockedPosition = function (isLocked) {
                    ( /** @type {?} */(this))._positionStrategy.withLockedPosition(isLocked);
                    return ( /** @type {?} */(this));
                };
                /**
                 * Overwrites the current set of positions with an array of new ones.
                 * @template THIS
                 * @this {THIS}
                 * @param {?} positions Position pairs to be set on the strategy.
                 * @return {THIS}
                 */
                ConnectedPositionStrategy.prototype.withPositions = function (positions) {
                    ( /** @type {?} */(this))._preferredPositions = positions.slice();
                    ( /** @type {?} */(this))._positionStrategy.withPositions(( /** @type {?} */(this))._preferredPositions);
                    return ( /** @type {?} */(this));
                };
                /**
                 * Sets the origin element, relative to which to position the overlay.
                 * @template THIS
                 * @this {THIS}
                 * @param {?} origin Reference to the new origin element.
                 * @return {THIS}
                 */
                ConnectedPositionStrategy.prototype.setOrigin = function (origin) {
                    ( /** @type {?} */(this))._positionStrategy.setOrigin(origin);
                    return ( /** @type {?} */(this));
                };
                return ConnectedPositionStrategy;
            }());
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Class to be added to the overlay pane wrapper.
             * @type {?}
             */
            var wrapperClass = 'cdk-global-overlay-wrapper';
            /**
             * A strategy for positioning overlays. Using this strategy, an overlay is given an
             * explicit position relative to the browser's viewport. We use flexbox, instead of
             * transforms, in order to avoid issues with subpixel rendering which can cause the
             * element to become blurry.
             */
            var GlobalPositionStrategy = /** @class */ (function () {
                function GlobalPositionStrategy() {
                    this._cssPosition = 'static';
                    this._topOffset = '';
                    this._bottomOffset = '';
                    this._leftOffset = '';
                    this._rightOffset = '';
                    this._alignItems = '';
                    this._justifyContent = '';
                    this._width = '';
                    this._height = '';
                }
                /**
                 * @param {?} overlayRef
                 * @return {?}
                 */
                GlobalPositionStrategy.prototype.attach = function (overlayRef) {
                    /** @type {?} */
                    var config = overlayRef.getConfig();
                    this._overlayRef = overlayRef;
                    if (this._width && !config.width) {
                        overlayRef.updateSize({ width: this._width });
                    }
                    if (this._height && !config.height) {
                        overlayRef.updateSize({ height: this._height });
                    }
                    overlayRef.hostElement.classList.add(wrapperClass);
                    this._isDisposed = false;
                };
                /**
                 * Sets the top position of the overlay. Clears any previously set vertical position.
                 * @template THIS
                 * @this {THIS}
                 * @param {?=} value New top offset.
                 * @return {THIS}
                 */
                GlobalPositionStrategy.prototype.top = function (value) {
                    if (value === void 0) { value = ''; }
                    ( /** @type {?} */(this))._bottomOffset = '';
                    ( /** @type {?} */(this))._topOffset = value;
                    ( /** @type {?} */(this))._alignItems = 'flex-start';
                    return ( /** @type {?} */(this));
                };
                /**
                 * Sets the left position of the overlay. Clears any previously set horizontal position.
                 * @template THIS
                 * @this {THIS}
                 * @param {?=} value New left offset.
                 * @return {THIS}
                 */
                GlobalPositionStrategy.prototype.left = function (value) {
                    if (value === void 0) { value = ''; }
                    ( /** @type {?} */(this))._rightOffset = '';
                    ( /** @type {?} */(this))._leftOffset = value;
                    ( /** @type {?} */(this))._justifyContent = 'flex-start';
                    return ( /** @type {?} */(this));
                };
                /**
                 * Sets the bottom position of the overlay. Clears any previously set vertical position.
                 * @template THIS
                 * @this {THIS}
                 * @param {?=} value New bottom offset.
                 * @return {THIS}
                 */
                GlobalPositionStrategy.prototype.bottom = function (value) {
                    if (value === void 0) { value = ''; }
                    ( /** @type {?} */(this))._topOffset = '';
                    ( /** @type {?} */(this))._bottomOffset = value;
                    ( /** @type {?} */(this))._alignItems = 'flex-end';
                    return ( /** @type {?} */(this));
                };
                /**
                 * Sets the right position of the overlay. Clears any previously set horizontal position.
                 * @template THIS
                 * @this {THIS}
                 * @param {?=} value New right offset.
                 * @return {THIS}
                 */
                GlobalPositionStrategy.prototype.right = function (value) {
                    if (value === void 0) { value = ''; }
                    ( /** @type {?} */(this))._leftOffset = '';
                    ( /** @type {?} */(this))._rightOffset = value;
                    ( /** @type {?} */(this))._justifyContent = 'flex-end';
                    return ( /** @type {?} */(this));
                };
                /**
                 * Sets the overlay width and clears any previously set width.
                 * @deprecated Pass the `width` through the `OverlayConfig`.
                 * \@breaking-change 8.0.0
                 * @template THIS
                 * @this {THIS}
                 * @param {?=} value New width for the overlay
                 * @return {THIS}
                 */
                GlobalPositionStrategy.prototype.width = function (value) {
                    if (value === void 0) { value = ''; }
                    if (( /** @type {?} */(this))._overlayRef) {
                        ( /** @type {?} */(this))._overlayRef.updateSize({ width: value });
                    }
                    else {
                        ( /** @type {?} */(this))._width = value;
                    }
                    return ( /** @type {?} */(this));
                };
                /**
                 * Sets the overlay height and clears any previously set height.
                 * @deprecated Pass the `height` through the `OverlayConfig`.
                 * \@breaking-change 8.0.0
                 * @template THIS
                 * @this {THIS}
                 * @param {?=} value New height for the overlay
                 * @return {THIS}
                 */
                GlobalPositionStrategy.prototype.height = function (value) {
                    if (value === void 0) { value = ''; }
                    if (( /** @type {?} */(this))._overlayRef) {
                        ( /** @type {?} */(this))._overlayRef.updateSize({ height: value });
                    }
                    else {
                        ( /** @type {?} */(this))._height = value;
                    }
                    return ( /** @type {?} */(this));
                };
                /**
                 * Centers the overlay horizontally with an optional offset.
                 * Clears any previously set horizontal position.
                 *
                 * @template THIS
                 * @this {THIS}
                 * @param {?=} offset Overlay offset from the horizontal center.
                 * @return {THIS}
                 */
                GlobalPositionStrategy.prototype.centerHorizontally = function (offset) {
                    if (offset === void 0) { offset = ''; }
                    ( /** @type {?} */(this)).left(offset);
                    ( /** @type {?} */(this))._justifyContent = 'center';
                    return ( /** @type {?} */(this));
                };
                /**
                 * Centers the overlay vertically with an optional offset.
                 * Clears any previously set vertical position.
                 *
                 * @template THIS
                 * @this {THIS}
                 * @param {?=} offset Overlay offset from the vertical center.
                 * @return {THIS}
                 */
                GlobalPositionStrategy.prototype.centerVertically = function (offset) {
                    if (offset === void 0) { offset = ''; }
                    ( /** @type {?} */(this)).top(offset);
                    ( /** @type {?} */(this))._alignItems = 'center';
                    return ( /** @type {?} */(this));
                };
                /**
                 * Apply the position to the element.
                 * \@docs-private
                 * @return {?}
                 */
                GlobalPositionStrategy.prototype.apply = function () {
                    // Since the overlay ref applies the strategy asynchronously, it could
                    // have been disposed before it ends up being applied. If that is the
                    // case, we shouldn't do anything.
                    if (!this._overlayRef || !this._overlayRef.hasAttached()) {
                        return;
                    }
                    /** @type {?} */
                    var styles = this._overlayRef.overlayElement.style;
                    /** @type {?} */
                    var parentStyles = this._overlayRef.hostElement.style;
                    /** @type {?} */
                    var config = this._overlayRef.getConfig();
                    styles.position = this._cssPosition;
                    styles.marginLeft = config.width === '100%' ? '0' : this._leftOffset;
                    styles.marginTop = config.height === '100%' ? '0' : this._topOffset;
                    styles.marginBottom = this._bottomOffset;
                    styles.marginRight = this._rightOffset;
                    if (config.width === '100%') {
                        parentStyles.justifyContent = 'flex-start';
                    }
                    else if (this._justifyContent === 'center') {
                        parentStyles.justifyContent = 'center';
                    }
                    else if (this._overlayRef.getConfig().direction === 'rtl') {
                        // In RTL the browser will invert `flex-start` and `flex-end` automatically, but we
                        // don't want that because our positioning is explicitly `left` and `right`, hence
                        // why we do another inversion to ensure that the overlay stays in the same position.
                        // TODO: reconsider this if we add `start` and `end` methods.
                        if (this._justifyContent === 'flex-start') {
                            parentStyles.justifyContent = 'flex-end';
                        }
                        else if (this._justifyContent === 'flex-end') {
                            parentStyles.justifyContent = 'flex-start';
                        }
                    }
                    else {
                        parentStyles.justifyContent = this._justifyContent;
                    }
                    parentStyles.alignItems = config.height === '100%' ? 'flex-start' : this._alignItems;
                };
                /**
                 * Cleans up the DOM changes from the position strategy.
                 * \@docs-private
                 * @return {?}
                 */
                GlobalPositionStrategy.prototype.dispose = function () {
                    if (this._isDisposed || !this._overlayRef) {
                        return;
                    }
                    /** @type {?} */
                    var styles = this._overlayRef.overlayElement.style;
                    /** @type {?} */
                    var parent = this._overlayRef.hostElement;
                    /** @type {?} */
                    var parentStyles = parent.style;
                    parent.classList.remove(wrapperClass);
                    parentStyles.justifyContent = parentStyles.alignItems = styles.marginTop =
                        styles.marginBottom = styles.marginLeft = styles.marginRight = styles.position = '';
                    this._overlayRef = ( /** @type {?} */(null));
                    this._isDisposed = true;
                };
                return GlobalPositionStrategy;
            }());
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Builder for overlay position strategy.
             */
            var OverlayPositionBuilder = /** @class */ (function () {
                /**
                 * @param {?} _viewportRuler
                 * @param {?} _document
                 * @param {?} _platform
                 * @param {?} _overlayContainer
                 */
                function OverlayPositionBuilder(_viewportRuler, _document, _platform, _overlayContainer) {
                    this._viewportRuler = _viewportRuler;
                    this._document = _document;
                    this._platform = _platform;
                    this._overlayContainer = _overlayContainer;
                }
                /**
                 * Creates a global position strategy.
                 * @return {?}
                 */
                OverlayPositionBuilder.prototype.global = function () {
                    return new GlobalPositionStrategy();
                };
                /**
                 * Creates a relative position strategy.
                 * @deprecated Use `flexibleConnectedTo` instead.
                 * \@breaking-change 8.0.0
                 * @param {?} elementRef
                 * @param {?} originPos
                 * @param {?} overlayPos
                 * @return {?}
                 */
                OverlayPositionBuilder.prototype.connectedTo = function (elementRef, originPos, overlayPos) {
                    return new ConnectedPositionStrategy(originPos, overlayPos, elementRef, this._viewportRuler, this._document, this._platform, this._overlayContainer);
                };
                /**
                 * Creates a flexible position strategy.
                 * @param {?} origin Origin relative to which to position the overlay.
                 * @return {?}
                 */
                OverlayPositionBuilder.prototype.flexibleConnectedTo = function (origin) {
                    return new FlexibleConnectedPositionStrategy(origin, this._viewportRuler, this._document, this._platform, this._overlayContainer);
                };
                return OverlayPositionBuilder;
            }());
            OverlayPositionBuilder.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */
            OverlayPositionBuilder.ctorParameters = function () { return [
                { type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__["ViewportRuler"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"],] }] },
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_6__["Platform"] },
                { type: OverlayContainer }
            ]; };
            /** @nocollapse */ OverlayPositionBuilder.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineInjectable"])({ factory: function OverlayPositionBuilder_Factory() { return new OverlayPositionBuilder(Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"])(_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__["ViewportRuler"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"])(_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"])(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_6__["Platform"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"])(OverlayContainer)); }, token: OverlayPositionBuilder, providedIn: "root" });
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Next overlay unique ID.
             * @type {?}
             */
            var nextUniqueId = 0;
            // Note that Overlay is *not* scoped to the app root because the ComponentFactoryResolver
            // it needs is different based on where OverlayModule is imported.
            /**
             * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be
             * used as a low-level building block for other components. Dialogs, tooltips, menus,
             * selects, etc. can all be built using overlays. The service should primarily be used by authors
             * of re-usable components rather than developers building end-user applications.
             *
             * An overlay *is* a PortalOutlet, so any kind of Portal can be loaded into one.
             */
            var Overlay = /** @class */ (function () {
                /**
                 * @param {?} scrollStrategies
                 * @param {?} _overlayContainer
                 * @param {?} _componentFactoryResolver
                 * @param {?} _positionBuilder
                 * @param {?} _keyboardDispatcher
                 * @param {?} _injector
                 * @param {?} _ngZone
                 * @param {?} _document
                 * @param {?} _directionality
                 * @param {?=} _location
                 */
                function Overlay(scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _keyboardDispatcher, _injector, _ngZone, _document, _directionality, _location) {
                    this.scrollStrategies = scrollStrategies;
                    this._overlayContainer = _overlayContainer;
                    this._componentFactoryResolver = _componentFactoryResolver;
                    this._positionBuilder = _positionBuilder;
                    this._keyboardDispatcher = _keyboardDispatcher;
                    this._injector = _injector;
                    this._ngZone = _ngZone;
                    this._document = _document;
                    this._directionality = _directionality;
                    this._location = _location;
                }
                /**
                 * Creates an overlay.
                 * @param {?=} config Configuration applied to the overlay.
                 * @return {?} Reference to the created overlay.
                 */
                Overlay.prototype.create = function (config) {
                    /** @type {?} */
                    var host = this._createHostElement();
                    /** @type {?} */
                    var pane = this._createPaneElement(host);
                    /** @type {?} */
                    var portalOutlet = this._createPortalOutlet(pane);
                    /** @type {?} */
                    var overlayConfig = new OverlayConfig(config);
                    overlayConfig.direction = overlayConfig.direction || this._directionality.value;
                    return new OverlayRef(portalOutlet, host, pane, overlayConfig, this._ngZone, this._keyboardDispatcher, this._document, this._location);
                };
                /**
                 * Gets a position builder that can be used, via fluent API,
                 * to construct and configure a position strategy.
                 * @return {?} An overlay position builder.
                 */
                Overlay.prototype.position = function () {
                    return this._positionBuilder;
                };
                /**
                 * Creates the DOM element for an overlay and appends it to the overlay container.
                 * @private
                 * @param {?} host
                 * @return {?} Newly-created pane element
                 */
                Overlay.prototype._createPaneElement = function (host) {
                    /** @type {?} */
                    var pane = this._document.createElement('div');
                    pane.id = "cdk-overlay-" + nextUniqueId++;
                    pane.classList.add('cdk-overlay-pane');
                    host.appendChild(pane);
                    return pane;
                };
                /**
                 * Creates the host element that wraps around an overlay
                 * and can be used for advanced positioning.
                 * @private
                 * @return {?} Newly-create host element.
                 */
                Overlay.prototype._createHostElement = function () {
                    /** @type {?} */
                    var host = this._document.createElement('div');
                    this._overlayContainer.getContainerElement().appendChild(host);
                    return host;
                };
                /**
                 * Create a DomPortalOutlet into which the overlay content can be loaded.
                 * @private
                 * @param {?} pane The DOM element to turn into a portal outlet.
                 * @return {?} A portal outlet for the given DOM element.
                 */
                Overlay.prototype._createPortalOutlet = function (pane) {
                    // We have to resolve the ApplicationRef later in order to allow people
                    // to use overlay-based providers during app initialization.
                    if (!this._appRef) {
                        this._appRef = this._injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ApplicationRef"]);
                    }
                    return new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_8__["DomPortalOutlet"](pane, this._componentFactoryResolver, this._appRef, this._injector);
                };
                return Overlay;
            }());
            Overlay.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Injectable"] },
            ];
            /** @nocollapse */
            Overlay.ctorParameters = function () { return [
                { type: ScrollStrategyOptions },
                { type: OverlayContainer },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ComponentFactoryResolver"] },
                { type: OverlayPositionBuilder },
                { type: OverlayKeyboardDispatcher },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Injector"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["NgZone"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"],] }] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_7__["Directionality"] },
                { type: _angular_common__WEBPACK_IMPORTED_MODULE_2__["Location"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Default set of positions for the overlay. Follows the behavior of a dropdown.
             * @type {?}
             */
            var defaultPositionList = [
                {
                    originX: 'start',
                    originY: 'bottom',
                    overlayX: 'start',
                    overlayY: 'top'
                },
                {
                    originX: 'start',
                    originY: 'top',
                    overlayX: 'start',
                    overlayY: 'bottom'
                },
                {
                    originX: 'end',
                    originY: 'top',
                    overlayX: 'end',
                    overlayY: 'bottom'
                },
                {
                    originX: 'end',
                    originY: 'bottom',
                    overlayX: 'end',
                    overlayY: 'top'
                }
            ];
            /**
             * Injection token that determines the scroll handling while the connected overlay is open.
             * @type {?}
             */
            var CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["InjectionToken"]('cdk-connected-overlay-scroll-strategy');
            /**
             * Directive applied to an element to make it usable as an origin for an Overlay using a
             * ConnectedPositionStrategy.
             */
            var CdkOverlayOrigin = /** @class */ (function () {
                /**
                 * @param {?} elementRef
                 */
                function CdkOverlayOrigin(elementRef) {
                    this.elementRef = elementRef;
                }
                return CdkOverlayOrigin;
            }());
            CdkOverlayOrigin.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: '[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]',
                            exportAs: 'cdkOverlayOrigin',
                        },] },
            ];
            /** @nocollapse */
            CdkOverlayOrigin.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"] }
            ]; };
            /**
             * Directive to facilitate declarative creation of an
             * Overlay using a FlexibleConnectedPositionStrategy.
             */
            var CdkConnectedOverlay = /** @class */ (function () {
                // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.
                /**
                 * @param {?} _overlay
                 * @param {?} templateRef
                 * @param {?} viewContainerRef
                 * @param {?} scrollStrategyFactory
                 * @param {?} _dir
                 */
                function CdkConnectedOverlay(_overlay, templateRef, viewContainerRef, scrollStrategyFactory, _dir) {
                    this._overlay = _overlay;
                    this._dir = _dir;
                    this._hasBackdrop = false;
                    this._lockPosition = false;
                    this._growAfterOpen = false;
                    this._flexibleDimensions = false;
                    this._push = false;
                    this._backdropSubscription = rxjs__WEBPACK_IMPORTED_MODULE_4__["Subscription"].EMPTY;
                    /**
                     * Margin between the overlay and the viewport edges.
                     */
                    this.viewportMargin = 0;
                    /**
                     * Whether the overlay is open.
                     */
                    this.open = false;
                    /**
                     * Event emitted when the backdrop is clicked.
                     */
                    this.backdropClick = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /**
                     * Event emitted when the position has changed.
                     */
                    this.positionChange = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /**
                     * Event emitted when the overlay has been attached.
                     */
                    this.attach = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /**
                     * Event emitted when the overlay has been detached.
                     */
                    this.detach = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /**
                     * Emits when there are keyboard events that are targeted at the overlay.
                     */
                    this.overlayKeydown = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    this._templatePortal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_8__["TemplatePortal"](templateRef, viewContainerRef);
                    this._scrollStrategyFactory = scrollStrategyFactory;
                    this.scrollStrategy = this._scrollStrategyFactory();
                }
                Object.defineProperty(CdkConnectedOverlay.prototype, "offsetX", {
                    /**
                     * The offset in pixels for the overlay connection point on the x-axis
                     * @return {?}
                     */
                    get: function () { return this._offsetX; },
                    /**
                     * @param {?} offsetX
                     * @return {?}
                     */
                    set: function (offsetX) {
                        this._offsetX = offsetX;
                        if (this._position) {
                            this._updatePositionStrategy(this._position);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkConnectedOverlay.prototype, "offsetY", {
                    /**
                     * The offset in pixels for the overlay connection point on the y-axis
                     * @return {?}
                     */
                    get: function () { return this._offsetY; },
                    /**
                     * @param {?} offsetY
                     * @return {?}
                     */
                    set: function (offsetY) {
                        this._offsetY = offsetY;
                        if (this._position) {
                            this._updatePositionStrategy(this._position);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkConnectedOverlay.prototype, "hasBackdrop", {
                    /**
                     * Whether or not the overlay should attach a backdrop.
                     * @return {?}
                     */
                    get: function () { return this._hasBackdrop; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._hasBackdrop = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkConnectedOverlay.prototype, "lockPosition", {
                    /**
                     * Whether or not the overlay should be locked when scrolling.
                     * @return {?}
                     */
                    get: function () { return this._lockPosition; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._lockPosition = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkConnectedOverlay.prototype, "flexibleDimensions", {
                    /**
                     * Whether the overlay's width and height can be constrained to fit within the viewport.
                     * @return {?}
                     */
                    get: function () { return this._flexibleDimensions; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._flexibleDimensions = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkConnectedOverlay.prototype, "growAfterOpen", {
                    /**
                     * Whether the overlay can grow after the initial open when flexible positioning is turned on.
                     * @return {?}
                     */
                    get: function () { return this._growAfterOpen; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._growAfterOpen = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkConnectedOverlay.prototype, "push", {
                    /**
                     * Whether the overlay can be pushed on-screen if none of the provided positions fit.
                     * @return {?}
                     */
                    get: function () { return this._push; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._push = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkConnectedOverlay.prototype, "overlayRef", {
                    /**
                     * The associated overlay reference.
                     * @return {?}
                     */
                    get: function () {
                        return this._overlayRef;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkConnectedOverlay.prototype, "dir", {
                    /**
                     * The element's layout direction.
                     * @return {?}
                     */
                    get: function () {
                        return this._dir ? this._dir.value : 'ltr';
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                CdkConnectedOverlay.prototype.ngOnDestroy = function () {
                    if (this._overlayRef) {
                        this._overlayRef.dispose();
                    }
                    this._backdropSubscription.unsubscribe();
                };
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                CdkConnectedOverlay.prototype.ngOnChanges = function (changes) {
                    if (this._position) {
                        this._updatePositionStrategy(this._position);
                        this._overlayRef.updateSize({
                            width: this.width,
                            minWidth: this.minWidth,
                            height: this.height,
                            minHeight: this.minHeight,
                        });
                        if (changes['origin'] && this.open) {
                            this._position.apply();
                        }
                    }
                    if (changes['open']) {
                        this.open ? this._attachOverlay() : this._detachOverlay();
                    }
                };
                /**
                 * Creates an overlay
                 * @private
                 * @return {?}
                 */
                CdkConnectedOverlay.prototype._createOverlay = function () {
                    var _this_1 = this;
                    if (!this.positions || !this.positions.length) {
                        this.positions = defaultPositionList;
                    }
                    this._overlayRef = this._overlay.create(this._buildConfig());
                    this._overlayRef.keydownEvents().subscribe(( /**
                     * @param {?} event
                     * @return {?}
                     */function (event) {
                        _this_1.overlayKeydown.next(event);
                        if (event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_9__["ESCAPE"] && !Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_9__["hasModifierKey"])(event)) {
                            event.preventDefault();
                            _this_1._detachOverlay();
                        }
                    }));
                };
                /**
                 * Builds the overlay config based on the directive's inputs
                 * @private
                 * @return {?}
                 */
                CdkConnectedOverlay.prototype._buildConfig = function () {
                    /** @type {?} */
                    var positionStrategy = this._position = this._createPositionStrategy();
                    /** @type {?} */
                    var overlayConfig = new OverlayConfig({
                        direction: this._dir,
                        positionStrategy: positionStrategy,
                        scrollStrategy: this.scrollStrategy,
                        hasBackdrop: this.hasBackdrop
                    });
                    if (this.width || this.width === 0) {
                        overlayConfig.width = this.width;
                    }
                    if (this.height || this.height === 0) {
                        overlayConfig.height = this.height;
                    }
                    if (this.minWidth || this.minWidth === 0) {
                        overlayConfig.minWidth = this.minWidth;
                    }
                    if (this.minHeight || this.minHeight === 0) {
                        overlayConfig.minHeight = this.minHeight;
                    }
                    if (this.backdropClass) {
                        overlayConfig.backdropClass = this.backdropClass;
                    }
                    if (this.panelClass) {
                        overlayConfig.panelClass = this.panelClass;
                    }
                    return overlayConfig;
                };
                /**
                 * Updates the state of a position strategy, based on the values of the directive inputs.
                 * @private
                 * @param {?} positionStrategy
                 * @return {?}
                 */
                CdkConnectedOverlay.prototype._updatePositionStrategy = function (positionStrategy) {
                    var _this_1 = this;
                    /** @type {?} */
                    var positions = this.positions.map(( /**
                     * @param {?} currentPosition
                     * @return {?}
                     */function (/**
                     * @param {?} currentPosition
                     * @return {?}
                     */ currentPosition) { return ({
                        originX: currentPosition.originX,
                        originY: currentPosition.originY,
                        overlayX: currentPosition.overlayX,
                        overlayY: currentPosition.overlayY,
                        offsetX: currentPosition.offsetX || _this_1.offsetX,
                        offsetY: currentPosition.offsetY || _this_1.offsetY,
                        panelClass: currentPosition.panelClass || undefined,
                    }); }));
                    return positionStrategy
                        .setOrigin(this.origin.elementRef)
                        .withPositions(positions)
                        .withFlexibleDimensions(this.flexibleDimensions)
                        .withPush(this.push)
                        .withGrowAfterOpen(this.growAfterOpen)
                        .withViewportMargin(this.viewportMargin)
                        .withLockedPosition(this.lockPosition);
                };
                /**
                 * Returns the position strategy of the overlay to be set on the overlay config
                 * @private
                 * @return {?}
                 */
                CdkConnectedOverlay.prototype._createPositionStrategy = function () {
                    var _this_1 = this;
                    /** @type {?} */
                    var strategy = this._overlay.position().flexibleConnectedTo(this.origin.elementRef);
                    this._updatePositionStrategy(strategy);
                    strategy.positionChanges.subscribe(( /**
                     * @param {?} p
                     * @return {?}
                     */function (/**
                     * @param {?} p
                     * @return {?}
                     */ p) { return _this_1.positionChange.emit(p); }));
                    return strategy;
                };
                /**
                 * Attaches the overlay and subscribes to backdrop clicks if backdrop exists
                 * @private
                 * @return {?}
                 */
                CdkConnectedOverlay.prototype._attachOverlay = function () {
                    var _this_1 = this;
                    if (!this._overlayRef) {
                        this._createOverlay();
                    }
                    else {
                        // Update the overlay size, in case the directive's inputs have changed
                        this._overlayRef.getConfig().hasBackdrop = this.hasBackdrop;
                    }
                    if (!this._overlayRef.hasAttached()) {
                        this._overlayRef.attach(this._templatePortal);
                        this.attach.emit();
                    }
                    if (this.hasBackdrop) {
                        this._backdropSubscription = this._overlayRef.backdropClick().subscribe(( /**
                         * @param {?} event
                         * @return {?}
                         */function (/**
                         * @param {?} event
                         * @return {?}
                         */ event) {
                            _this_1.backdropClick.emit(event);
                        }));
                    }
                    else {
                        this._backdropSubscription.unsubscribe();
                    }
                };
                /**
                 * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists
                 * @private
                 * @return {?}
                 */
                CdkConnectedOverlay.prototype._detachOverlay = function () {
                    if (this._overlayRef) {
                        this._overlayRef.detach();
                        this.detach.emit();
                    }
                    this._backdropSubscription.unsubscribe();
                };
                return CdkConnectedOverlay;
            }());
            CdkConnectedOverlay.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: '[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]',
                            exportAs: 'cdkConnectedOverlay'
                        },] },
            ];
            /** @nocollapse */
            CdkConnectedOverlay.ctorParameters = function () { return [
                { type: Overlay },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["TemplateRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewContainerRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,] }] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_7__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }] }
            ]; };
            CdkConnectedOverlay.propDecorators = {
                origin: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['cdkConnectedOverlayOrigin',] }],
                positions: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['cdkConnectedOverlayPositions',] }],
                offsetX: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['cdkConnectedOverlayOffsetX',] }],
                offsetY: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['cdkConnectedOverlayOffsetY',] }],
                width: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['cdkConnectedOverlayWidth',] }],
                height: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['cdkConnectedOverlayHeight',] }],
                minWidth: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['cdkConnectedOverlayMinWidth',] }],
                minHeight: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['cdkConnectedOverlayMinHeight',] }],
                backdropClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['cdkConnectedOverlayBackdropClass',] }],
                panelClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['cdkConnectedOverlayPanelClass',] }],
                viewportMargin: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['cdkConnectedOverlayViewportMargin',] }],
                scrollStrategy: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['cdkConnectedOverlayScrollStrategy',] }],
                open: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['cdkConnectedOverlayOpen',] }],
                hasBackdrop: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['cdkConnectedOverlayHasBackdrop',] }],
                lockPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['cdkConnectedOverlayLockPosition',] }],
                flexibleDimensions: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['cdkConnectedOverlayFlexibleDimensions',] }],
                growAfterOpen: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['cdkConnectedOverlayGrowAfterOpen',] }],
                push: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['cdkConnectedOverlayPush',] }],
                backdropClick: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                positionChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                attach: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                detach: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                overlayKeydown: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }]
            };
            /**
             * \@docs-private
             * @param {?} overlay
             * @return {?}
             */
            function CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {
                return ( /**
                 * @return {?}
                 */function () { return overlay.scrollStrategies.reposition(); });
            }
            /**
             * \@docs-private
             * @type {?}
             */
            var CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {
                provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,
                deps: [Overlay],
                useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY,
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var OverlayModule = /** @class */ (function () {
                function OverlayModule() {
                }
                return OverlayModule;
            }());
            OverlayModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["NgModule"], args: [{
                            imports: [_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_7__["BidiModule"], _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_8__["PortalModule"], _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__["ScrollingModule"]],
                            exports: [CdkConnectedOverlay, CdkOverlayOrigin, _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__["ScrollingModule"]],
                            declarations: [CdkConnectedOverlay, CdkOverlayOrigin],
                            providers: [
                                Overlay,
                                CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER,
                            ],
                        },] },
            ];
            /**
             * @deprecated Use `OverlayModule` instead.
             * \@breaking-change 8.0.0
             * \@docs-private
             * @type {?}
             */
            var OVERLAY_PROVIDERS = [
                Overlay,
                OverlayPositionBuilder,
                OVERLAY_KEYBOARD_DISPATCHER_PROVIDER,
                _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__["VIEWPORT_RULER_PROVIDER"],
                OVERLAY_CONTAINER_PROVIDER,
                CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER,
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Alternative to OverlayContainer that supports correct displaying of overlay elements in
             * Fullscreen mode
             * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen
             *
             * Should be provided in the root component.
             */
            var FullscreenOverlayContainer = /** @class */ (function (_super) {
                __extends(FullscreenOverlayContainer, _super);
                /**
                 * @param {?} _document
                 */
                function FullscreenOverlayContainer(_document) {
                    return _super.call(this, _document) || this;
                }
                /**
                 * @return {?}
                 */
                FullscreenOverlayContainer.prototype.ngOnDestroy = function () {
                    _super.prototype.ngOnDestroy.call(this);
                    if (this._fullScreenEventName && this._fullScreenListener) {
                        this._document.removeEventListener(this._fullScreenEventName, this._fullScreenListener);
                    }
                };
                /**
                 * @protected
                 * @return {?}
                 */
                FullscreenOverlayContainer.prototype._createContainer = function () {
                    var _this_1 = this;
                    _super.prototype._createContainer.call(this);
                    this._adjustParentForFullscreenChange();
                    this._addFullscreenChangeListener(( /**
                     * @return {?}
                     */function () { return _this_1._adjustParentForFullscreenChange(); }));
                };
                /**
                 * @private
                 * @return {?}
                 */
                FullscreenOverlayContainer.prototype._adjustParentForFullscreenChange = function () {
                    if (!this._containerElement) {
                        return;
                    }
                    /** @type {?} */
                    var fullscreenElement = this.getFullscreenElement();
                    /** @type {?} */
                    var parent = fullscreenElement || this._document.body;
                    parent.appendChild(this._containerElement);
                };
                /**
                 * @private
                 * @param {?} fn
                 * @return {?}
                 */
                FullscreenOverlayContainer.prototype._addFullscreenChangeListener = function (fn) {
                    /** @type {?} */
                    var eventName = this._getEventName();
                    if (eventName) {
                        if (this._fullScreenListener) {
                            this._document.removeEventListener(eventName, this._fullScreenListener);
                        }
                        this._document.addEventListener(eventName, fn);
                        this._fullScreenListener = fn;
                    }
                };
                /**
                 * @private
                 * @return {?}
                 */
                FullscreenOverlayContainer.prototype._getEventName = function () {
                    if (!this._fullScreenEventName) {
                        /** @type {?} */
                        var _document = ( /** @type {?} */(this._document));
                        if (_document.fullscreenEnabled) {
                            this._fullScreenEventName = 'fullscreenchange';
                        }
                        else if (_document.webkitFullscreenEnabled) {
                            this._fullScreenEventName = 'webkitfullscreenchange';
                        }
                        else if (_document.mozFullScreenEnabled) {
                            this._fullScreenEventName = 'mozfullscreenchange';
                        }
                        else if (_document.msFullscreenEnabled) {
                            this._fullScreenEventName = 'MSFullscreenChange';
                        }
                    }
                    return this._fullScreenEventName;
                };
                /**
                 * When the page is put into fullscreen mode, a specific element is specified.
                 * Only that element and its children are visible when in fullscreen mode.
                 * @return {?}
                 */
                FullscreenOverlayContainer.prototype.getFullscreenElement = function () {
                    /** @type {?} */
                    var _document = ( /** @type {?} */(this._document));
                    return _document.fullscreenElement ||
                        _document.webkitFullscreenElement ||
                        _document.mozFullScreenElement ||
                        _document.msFullscreenElement ||
                        null;
                };
                return FullscreenOverlayContainer;
            }(OverlayContainer));
            FullscreenOverlayContainer.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */
            FullscreenOverlayContainer.ctorParameters = function () { return [
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"],] }] }
            ]; };
            /** @nocollapse */ FullscreenOverlayContainer.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineInjectable"])({ factory: function FullscreenOverlayContainer_Factory() { return new FullscreenOverlayContainer(Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"])(_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"])); }, token: FullscreenOverlayContainer, providedIn: "root" });
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=overlay.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/cdk/esm2015/portal.js": 
        /*!*****************************************************!*\
          !*** ./node_modules/@angular/cdk/esm2015/portal.js ***!
          \*****************************************************/
        /*! exports provided: Portal, ComponentPortal, TemplatePortal, BasePortalOutlet, BasePortalHost, DomPortalOutlet, DomPortalHost, CdkPortal, TemplatePortalDirective, CdkPortalOutlet, PortalHostDirective, PortalModule, PortalInjector */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Portal", function () { return Portal; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ComponentPortal", function () { return ComponentPortal; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TemplatePortal", function () { return TemplatePortal; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasePortalOutlet", function () { return BasePortalOutlet; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasePortalHost", function () { return BasePortalHost; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DomPortalOutlet", function () { return DomPortalOutlet; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DomPortalHost", function () { return DomPortalHost; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkPortal", function () { return CdkPortal; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TemplatePortalDirective", function () { return TemplatePortalDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkPortalOutlet", function () { return CdkPortalOutlet; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PortalHostDirective", function () { return PortalHostDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PortalModule", function () { return PortalModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PortalInjector", function () { return PortalInjector; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Throws an exception when attempting to attach a null portal to a host.
             * \@docs-private
             * @return {?}
             */
            function throwNullPortalError() {
                throw Error('Must provide a portal to attach');
            }
            /**
             * Throws an exception when attempting to attach a portal to a host that is already attached.
             * \@docs-private
             * @return {?}
             */
            function throwPortalAlreadyAttachedError() {
                throw Error('Host already has a portal attached');
            }
            /**
             * Throws an exception when attempting to attach a portal to an already-disposed host.
             * \@docs-private
             * @return {?}
             */
            function throwPortalOutletAlreadyDisposedError() {
                throw Error('This PortalOutlet has already been disposed');
            }
            /**
             * Throws an exception when attempting to attach an unknown portal type.
             * \@docs-private
             * @return {?}
             */
            function throwUnknownPortalTypeError() {
                throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' +
                    'a ComponentPortal or a TemplatePortal.');
            }
            /**
             * Throws an exception when attempting to attach a portal to a null host.
             * \@docs-private
             * @return {?}
             */
            function throwNullPortalOutletError() {
                throw Error('Attempting to attach a portal to a null PortalOutlet');
            }
            /**
             * Throws an exception when attempting to detach a portal that is not attached.
             * \@docs-private
             * @return {?}
             */
            function throwNoPortalAttachedError() {
                throw Error('Attempting to detach a portal that is not attached to a host');
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * A `Portal` is something that you want to render somewhere else.
             * It can be attach to / detached from a `PortalOutlet`.
             * @abstract
             * @template T
             */
            var Portal = /** @class */ (function () {
                function Portal() {
                }
                /**
                 * Attach this portal to a host.
                 * @param {?} host
                 * @return {?}
                 */
                Portal.prototype.attach = function (host) {
                    if (host == null) {
                        throwNullPortalOutletError();
                    }
                    if (host.hasAttached()) {
                        throwPortalAlreadyAttachedError();
                    }
                    this._attachedHost = host;
                    return ( /** @type {?} */(host.attach(this)));
                };
                /**
                 * Detach this portal from its host
                 * @return {?}
                 */
                Portal.prototype.detach = function () {
                    /** @type {?} */
                    var host = this._attachedHost;
                    if (host == null) {
                        throwNoPortalAttachedError();
                    }
                    else {
                        this._attachedHost = null;
                        host.detach();
                    }
                };
                Object.defineProperty(Portal.prototype, "isAttached", {
                    /**
                     * Whether this portal is attached to a host.
                     * @return {?}
                     */
                    get: function () {
                        return this._attachedHost != null;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Sets the PortalOutlet reference without performing `attach()`. This is used directly by
                 * the PortalOutlet when it is performing an `attach()` or `detach()`.
                 * @param {?} host
                 * @return {?}
                 */
                Portal.prototype.setAttachedHost = function (host) {
                    this._attachedHost = host;
                };
                return Portal;
            }());
            /**
             * A `ComponentPortal` is a portal that instantiates some Component upon attachment.
             * @template T
             */
            var ComponentPortal = /** @class */ (function (_super) {
                __extends(ComponentPortal, _super);
                /**
                 * @param {?} component
                 * @param {?=} viewContainerRef
                 * @param {?=} injector
                 * @param {?=} componentFactoryResolver
                 */
                function ComponentPortal(component, viewContainerRef, injector, componentFactoryResolver) {
                    var _this_1 = _super.call(this) || this;
                    _this_1.component = component;
                    _this_1.viewContainerRef = viewContainerRef;
                    _this_1.injector = injector;
                    _this_1.componentFactoryResolver = componentFactoryResolver;
                    return _this_1;
                }
                return ComponentPortal;
            }(Portal));
            /**
             * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).
             * @template C
             */
            var TemplatePortal = /** @class */ (function (_super) {
                __extends(TemplatePortal, _super);
                /**
                 * @param {?} template
                 * @param {?} viewContainerRef
                 * @param {?=} context
                 */
                function TemplatePortal(template, viewContainerRef, context) {
                    var _this_1 = _super.call(this) || this;
                    _this_1.templateRef = template;
                    _this_1.viewContainerRef = viewContainerRef;
                    _this_1.context = context;
                    return _this_1;
                }
                Object.defineProperty(TemplatePortal.prototype, "origin", {
                    /**
                     * @return {?}
                     */
                    get: function () {
                        return this.templateRef.elementRef;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Attach the portal to the provided `PortalOutlet`.
                 * When a context is provided it will override the `context` property of the `TemplatePortal`
                 * instance.
                 * @param {?} host
                 * @param {?=} context
                 * @return {?}
                 */
                TemplatePortal.prototype.attach = function (host, context) {
                    if (context === void 0) { context = this.context; }
                    this.context = context;
                    return _super.prototype.attach.call(this, host);
                };
                /**
                 * @return {?}
                 */
                TemplatePortal.prototype.detach = function () {
                    this.context = undefined;
                    return _super.prototype.detach.call(this);
                };
                return TemplatePortal;
            }(Portal));
            /**
             * Partial implementation of PortalOutlet that handles attaching
             * ComponentPortal and TemplatePortal.
             * @abstract
             */
            var BasePortalOutlet = /** @class */ (function () {
                function BasePortalOutlet() {
                    /**
                     * Whether this host has already been permanently disposed.
                     */
                    this._isDisposed = false;
                }
                /**
                 * Whether this host has an attached portal.
                 * @return {?}
                 */
                BasePortalOutlet.prototype.hasAttached = function () {
                    return !!this._attachedPortal;
                };
                /**
                 * Attaches a portal.
                 * @param {?} portal
                 * @return {?}
                 */
                BasePortalOutlet.prototype.attach = function (portal) {
                    if (!portal) {
                        throwNullPortalError();
                    }
                    if (this.hasAttached()) {
                        throwPortalAlreadyAttachedError();
                    }
                    if (this._isDisposed) {
                        throwPortalOutletAlreadyDisposedError();
                    }
                    if (portal instanceof ComponentPortal) {
                        this._attachedPortal = portal;
                        return this.attachComponentPortal(portal);
                    }
                    else if (portal instanceof TemplatePortal) {
                        this._attachedPortal = portal;
                        return this.attachTemplatePortal(portal);
                    }
                    throwUnknownPortalTypeError();
                };
                /**
                 * Detaches a previously attached portal.
                 * @return {?}
                 */
                BasePortalOutlet.prototype.detach = function () {
                    if (this._attachedPortal) {
                        this._attachedPortal.setAttachedHost(null);
                        this._attachedPortal = null;
                    }
                    this._invokeDisposeFn();
                };
                /**
                 * Permanently dispose of this portal host.
                 * @return {?}
                 */
                BasePortalOutlet.prototype.dispose = function () {
                    if (this.hasAttached()) {
                        this.detach();
                    }
                    this._invokeDisposeFn();
                    this._isDisposed = true;
                };
                /**
                 * \@docs-private
                 * @param {?} fn
                 * @return {?}
                 */
                BasePortalOutlet.prototype.setDisposeFn = function (fn) {
                    this._disposeFn = fn;
                };
                /**
                 * @private
                 * @return {?}
                 */
                BasePortalOutlet.prototype._invokeDisposeFn = function () {
                    if (this._disposeFn) {
                        this._disposeFn();
                        this._disposeFn = null;
                    }
                };
                return BasePortalOutlet;
            }());
            /**
             * @deprecated Use `BasePortalOutlet` instead.
             * \@breaking-change 9.0.0
             * @abstract
             */
            var BasePortalHost = /** @class */ (function (_super) {
                __extends(BasePortalHost, _super);
                function BasePortalHost() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return BasePortalHost;
            }(BasePortalOutlet));
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular
             * application context.
             */
            var DomPortalOutlet = /** @class */ (function (_super) {
                __extends(DomPortalOutlet, _super);
                /**
                 * @param {?} outletElement
                 * @param {?} _componentFactoryResolver
                 * @param {?} _appRef
                 * @param {?} _defaultInjector
                 */
                function DomPortalOutlet(outletElement, _componentFactoryResolver, _appRef, _defaultInjector) {
                    var _this_1 = _super.call(this) || this;
                    _this_1.outletElement = outletElement;
                    _this_1._componentFactoryResolver = _componentFactoryResolver;
                    _this_1._appRef = _appRef;
                    _this_1._defaultInjector = _defaultInjector;
                    return _this_1;
                }
                /**
                 * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.
                 * @template T
                 * @param {?} portal Portal to be attached
                 * @return {?} Reference to the created component.
                 */
                DomPortalOutlet.prototype.attachComponentPortal = function (portal) {
                    var _this_1 = this;
                    /** @type {?} */
                    var resolver = portal.componentFactoryResolver || this._componentFactoryResolver;
                    /** @type {?} */
                    var componentFactory = resolver.resolveComponentFactory(portal.component);
                    /** @type {?} */
                    var componentRef;
                    // If the portal specifies a ViewContainerRef, we will use that as the attachment point
                    // for the component (in terms of Angular's component tree, not rendering).
                    // When the ViewContainerRef is missing, we use the factory to create the component directly
                    // and then manually attach the view to the application.
                    if (portal.viewContainerRef) {
                        componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.injector);
                        this.setDisposeFn(( /**
                         * @return {?}
                         */function () { return componentRef.destroy(); }));
                    }
                    else {
                        componentRef = componentFactory.create(portal.injector || this._defaultInjector);
                        this._appRef.attachView(componentRef.hostView);
                        this.setDisposeFn(( /**
                         * @return {?}
                         */function () {
                            _this_1._appRef.detachView(componentRef.hostView);
                            componentRef.destroy();
                        }));
                    }
                    // At this point the component has been instantiated, so we move it to the location in the DOM
                    // where we want it to be rendered.
                    this.outletElement.appendChild(this._getComponentRootNode(componentRef));
                    return componentRef;
                };
                /**
                 * Attaches a template portal to the DOM as an embedded view.
                 * @template C
                 * @param {?} portal Portal to be attached.
                 * @return {?} Reference to the created embedded view.
                 */
                DomPortalOutlet.prototype.attachTemplatePortal = function (portal) {
                    var _this_1 = this;
                    /** @type {?} */
                    var viewContainer = portal.viewContainerRef;
                    /** @type {?} */
                    var viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);
                    viewRef.detectChanges();
                    // The method `createEmbeddedView` will add the view as a child of the viewContainer.
                    // But for the DomPortalOutlet the view can be added everywhere in the DOM
                    // (e.g Overlay Container) To move the view to the specified host element. We just
                    // re-append the existing root nodes.
                    viewRef.rootNodes.forEach(( /**
                     * @param {?} rootNode
                     * @return {?}
                     */function (/**
                     * @param {?} rootNode
                     * @return {?}
                     */ rootNode) { return _this_1.outletElement.appendChild(rootNode); }));
                    this.setDisposeFn((( /**
                     * @return {?}
                     */function () {
                        /** @type {?} */
                        var index = viewContainer.indexOf(viewRef);
                        if (index !== -1) {
                            viewContainer.remove(index);
                        }
                    })));
                    // TODO(jelbourn): Return locals from view.
                    return viewRef;
                };
                /**
                 * Clears out a portal from the DOM.
                 * @return {?}
                 */
                DomPortalOutlet.prototype.dispose = function () {
                    _super.prototype.dispose.call(this);
                    if (this.outletElement.parentNode != null) {
                        this.outletElement.parentNode.removeChild(this.outletElement);
                    }
                };
                /**
                 * Gets the root HTMLElement for an instantiated component.
                 * @private
                 * @param {?} componentRef
                 * @return {?}
                 */
                DomPortalOutlet.prototype._getComponentRootNode = function (componentRef) {
                    return ( /** @type {?} */((( /** @type {?} */(componentRef.hostView))).rootNodes[0]));
                };
                return DomPortalOutlet;
            }(BasePortalOutlet));
            /**
             * @deprecated Use `DomPortalOutlet` instead.
             * \@breaking-change 9.0.0
             */
            var DomPortalHost = /** @class */ (function (_super) {
                __extends(DomPortalHost, _super);
                function DomPortalHost() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return DomPortalHost;
            }(DomPortalOutlet));
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,
             * the directive instance itself can be attached to a host, enabling declarative use of portals.
             */
            var CdkPortal = /** @class */ (function (_super) {
                __extends(CdkPortal, _super);
                /**
                 * @param {?} templateRef
                 * @param {?} viewContainerRef
                 */
                function CdkPortal(templateRef, viewContainerRef) {
                    return _super.call(this, templateRef, viewContainerRef) || this;
                }
                return CdkPortal;
            }(TemplatePortal));
            CdkPortal.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[cdkPortal]',
                            exportAs: 'cdkPortal',
                        },] },
            ];
            /** @nocollapse */
            CdkPortal.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"] }
            ]; };
            /**
             * @deprecated Use `CdkPortal` instead.
             * \@breaking-change 9.0.0
             */
            var TemplatePortalDirective = /** @class */ (function (_super) {
                __extends(TemplatePortalDirective, _super);
                function TemplatePortalDirective() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return TemplatePortalDirective;
            }(CdkPortal));
            TemplatePortalDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[cdk-portal], [portal]',
                            exportAs: 'cdkPortal',
                            providers: [{
                                    provide: CdkPortal,
                                    useExisting: TemplatePortalDirective
                                }]
                        },] },
            ];
            /**
             * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be
             * directly attached to it, enabling declarative use.
             *
             * Usage:
             * `<ng-template [cdkPortalOutlet]="greeting"></ng-template>`
             */
            var CdkPortalOutlet = /** @class */ (function (_super) {
                __extends(CdkPortalOutlet, _super);
                /**
                 * @param {?} _componentFactoryResolver
                 * @param {?} _viewContainerRef
                 */
                function CdkPortalOutlet(_componentFactoryResolver, _viewContainerRef) {
                    var _this_1 = _super.call(this) || this;
                    _this_1._componentFactoryResolver = _componentFactoryResolver;
                    _this_1._viewContainerRef = _viewContainerRef;
                    /**
                     * Whether the portal component is initialized.
                     */
                    _this_1._isInitialized = false;
                    /**
                     * Emits when a portal is attached to the outlet.
                     */
                    _this_1.attached = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    return _this_1;
                }
                Object.defineProperty(CdkPortalOutlet.prototype, "portal", {
                    /**
                     * Portal associated with the Portal outlet.
                     * @return {?}
                     */
                    get: function () {
                        return this._attachedPortal;
                    },
                    /**
                     * @param {?} portal
                     * @return {?}
                     */
                    set: function (portal) {
                        // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have
                        // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`
                        // and attach a portal programmatically in the parent component. When Angular does the first CD
                        // round, it will fire the setter with empty string, causing the user's content to be cleared.
                        if (this.hasAttached() && !portal && !this._isInitialized) {
                            return;
                        }
                        if (this.hasAttached()) {
                            _super.prototype.detach.call(this);
                        }
                        if (portal) {
                            _super.prototype.attach.call(this, portal);
                        }
                        this._attachedPortal = portal;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkPortalOutlet.prototype, "attachedRef", {
                    /**
                     * Component or view reference that is attached to the portal.
                     * @return {?}
                     */
                    get: function () {
                        return this._attachedRef;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                CdkPortalOutlet.prototype.ngOnInit = function () {
                    this._isInitialized = true;
                };
                /**
                 * @return {?}
                 */
                CdkPortalOutlet.prototype.ngOnDestroy = function () {
                    _super.prototype.dispose.call(this);
                    this._attachedPortal = null;
                    this._attachedRef = null;
                };
                /**
                 * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.
                 *
                 * @template T
                 * @param {?} portal Portal to be attached to the portal outlet.
                 * @return {?} Reference to the created component.
                 */
                CdkPortalOutlet.prototype.attachComponentPortal = function (portal) {
                    portal.setAttachedHost(this);
                    // If the portal specifies an origin, use that as the logical location of the component
                    // in the application tree. Otherwise use the location of this PortalOutlet.
                    /** @type {?} */
                    var viewContainerRef = portal.viewContainerRef != null ?
                        portal.viewContainerRef :
                        this._viewContainerRef;
                    /** @type {?} */
                    var resolver = portal.componentFactoryResolver || this._componentFactoryResolver;
                    /** @type {?} */
                    var componentFactory = resolver.resolveComponentFactory(portal.component);
                    /** @type {?} */
                    var ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.injector);
                    _super.prototype.setDisposeFn.call(this, ( /**
                     * @return {?}
                     */function () { return ref.destroy(); }));
                    this._attachedPortal = portal;
                    this._attachedRef = ref;
                    this.attached.emit(ref);
                    return ref;
                };
                /**
                 * Attach the given TemplatePortal to this PortlHost as an embedded View.
                 * @template C
                 * @param {?} portal Portal to be attached.
                 * @return {?} Reference to the created embedded view.
                 */
                CdkPortalOutlet.prototype.attachTemplatePortal = function (portal) {
                    var _this_1 = this;
                    portal.setAttachedHost(this);
                    /** @type {?} */
                    var viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);
                    _super.prototype.setDisposeFn.call(this, ( /**
                     * @return {?}
                     */function () { return _this_1._viewContainerRef.clear(); }));
                    this._attachedPortal = portal;
                    this._attachedRef = viewRef;
                    this.attached.emit(viewRef);
                    return viewRef;
                };
                return CdkPortalOutlet;
            }(BasePortalOutlet));
            CdkPortalOutlet.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[cdkPortalOutlet]',
                            exportAs: 'cdkPortalOutlet',
                            inputs: ['portal: cdkPortalOutlet']
                        },] },
            ];
            /** @nocollapse */
            CdkPortalOutlet.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"] }
            ]; };
            CdkPortalOutlet.propDecorators = {
                attached: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }]
            };
            /**
             * @deprecated Use `CdkPortalOutlet` instead.
             * \@breaking-change 9.0.0
             */
            var PortalHostDirective = /** @class */ (function (_super) {
                __extends(PortalHostDirective, _super);
                function PortalHostDirective() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return PortalHostDirective;
            }(CdkPortalOutlet));
            PortalHostDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[cdkPortalHost], [portalHost]',
                            exportAs: 'cdkPortalHost',
                            inputs: ['portal: cdkPortalHost'],
                            providers: [{
                                    provide: CdkPortalOutlet,
                                    useExisting: PortalHostDirective
                                }]
                        },] },
            ];
            var PortalModule = /** @class */ (function () {
                function PortalModule() {
                }
                return PortalModule;
            }());
            PortalModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            exports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective],
                            declarations: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Custom injector to be used when providing custom
             * injection tokens to components inside a portal.
             * \@docs-private
             */
            var PortalInjector = /** @class */ (function () {
                /**
                 * @param {?} _parentInjector
                 * @param {?} _customTokens
                 */
                function PortalInjector(_parentInjector, _customTokens) {
                    this._parentInjector = _parentInjector;
                    this._customTokens = _customTokens;
                }
                /**
                 * @param {?} token
                 * @param {?=} notFoundValue
                 * @return {?}
                 */
                PortalInjector.prototype.get = function (token, notFoundValue) {
                    /** @type {?} */
                    var value = this._customTokens.get(token);
                    if (typeof value !== 'undefined') {
                        return value;
                    }
                    return this._parentInjector.get(token, notFoundValue);
                };
                return PortalInjector;
            }());
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=portal.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/cdk/esm2015/stepper.js": 
        /*!******************************************************!*\
          !*** ./node_modules/@angular/cdk/esm2015/stepper.js ***!
          \******************************************************/
        /*! exports provided: StepperSelectionEvent, STEP_STATE, STEPPER_GLOBAL_OPTIONS, MAT_STEPPER_GLOBAL_OPTIONS, CdkStep, CdkStepper, CdkStepLabel, CdkStepperNext, CdkStepperPrevious, CdkStepperModule, CdkStepHeader */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StepperSelectionEvent", function () { return StepperSelectionEvent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STEP_STATE", function () { return STEP_STATE; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STEPPER_GLOBAL_OPTIONS", function () { return STEPPER_GLOBAL_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_STEPPER_GLOBAL_OPTIONS", function () { return MAT_STEPPER_GLOBAL_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkStep", function () { return CdkStep; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkStepper", function () { return CdkStepper; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkStepLabel", function () { return CdkStepLabel; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkStepperNext", function () { return CdkStepperNext; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkStepperPrevious", function () { return CdkStepperPrevious; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkStepperModule", function () { return CdkStepperModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkStepHeader", function () { return CdkStepHeader; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var CdkStepHeader = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 */
                function CdkStepHeader(_elementRef) {
                    this._elementRef = _elementRef;
                }
                /**
                 * Focuses the step header.
                 * @return {?}
                 */
                CdkStepHeader.prototype.focus = function () {
                    this._elementRef.nativeElement.focus();
                };
                return CdkStepHeader;
            }());
            CdkStepHeader.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[cdkStepHeader]',
                            host: {
                                'role': 'tab',
                            },
                        },] },
            ];
            /** @nocollapse */
            CdkStepHeader.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var CdkStepLabel = /** @class */ (function () {
                /**
                 * @param {?} template
                 */
                function CdkStepLabel(/** @docs-private */ template) {
                    this.template = template;
                }
                return CdkStepLabel;
            }());
            CdkStepLabel.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[cdkStepLabel]',
                        },] },
            ];
            /** @nocollapse */
            CdkStepLabel.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Used to generate unique ID for each stepper component.
             * @type {?}
             */
            var nextId = 0;
            /**
             * Change event emitted on selection changes.
             */
            var StepperSelectionEvent = /** @class */ (function () {
                function StepperSelectionEvent() {
                }
                return StepperSelectionEvent;
            }());
            /**
             * Enum to represent the different states of the steps.
             * @type {?}
             */
            var STEP_STATE = {
                NUMBER: 'number',
                EDIT: 'edit',
                DONE: 'done',
                ERROR: 'error'
            };
            /**
             * InjectionToken that can be used to specify the global stepper options.
             * @type {?}
             */
            var STEPPER_GLOBAL_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('STEPPER_GLOBAL_OPTIONS');
            /**
             * InjectionToken that can be used to specify the global stepper options.
             * @deprecated Use `STEPPER_GLOBAL_OPTIONS` instead.
             * \@breaking-change 8.0.0.
             * @type {?}
             */
            var MAT_STEPPER_GLOBAL_OPTIONS = STEPPER_GLOBAL_OPTIONS;
            var CdkStep = /** @class */ (function () {
                /**
                 * \@breaking-change 8.0.0 remove the `?` after `stepperOptions`
                 * @param {?} _stepper
                 * @param {?=} stepperOptions
                 */
                function CdkStep(_stepper, stepperOptions) {
                    this._stepper = _stepper;
                    /**
                     * Whether user has seen the expanded step content or not.
                     */
                    this.interacted = false;
                    this._editable = true;
                    this._optional = false;
                    this._completedOverride = null;
                    this._customError = null;
                    this._stepperOptions = stepperOptions ? stepperOptions : {};
                    this._displayDefaultIndicatorType = this._stepperOptions.displayDefaultIndicatorType !== false;
                    this._showError = !!this._stepperOptions.showError;
                }
                Object.defineProperty(CdkStep.prototype, "editable", {
                    /**
                     * Whether the user can return to this step once it has been marked as completed.
                     * @return {?}
                     */
                    get: function () {
                        return this._editable;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._editable = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkStep.prototype, "optional", {
                    /**
                     * Whether the completion of step is optional.
                     * @return {?}
                     */
                    get: function () {
                        return this._optional;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._optional = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkStep.prototype, "completed", {
                    /**
                     * Whether step is marked as completed.
                     * @return {?}
                     */
                    get: function () {
                        return this._completedOverride == null ? this._getDefaultCompleted() : this._completedOverride;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._completedOverride = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @private
                 * @return {?}
                 */
                CdkStep.prototype._getDefaultCompleted = function () {
                    return this.stepControl ? this.stepControl.valid && this.interacted : this.interacted;
                };
                Object.defineProperty(CdkStep.prototype, "hasError", {
                    /**
                     * Whether step has an error.
                     * @return {?}
                     */
                    get: function () {
                        return this._customError == null ? this._getDefaultError() : this._customError;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._customError = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @private
                 * @return {?}
                 */
                CdkStep.prototype._getDefaultError = function () {
                    return this.stepControl && this.stepControl.invalid && this.interacted;
                };
                /**
                 * Selects this step component.
                 * @return {?}
                 */
                CdkStep.prototype.select = function () {
                    this._stepper.selected = this;
                };
                /**
                 * Resets the step to its initial state. Note that this includes resetting form data.
                 * @return {?}
                 */
                CdkStep.prototype.reset = function () {
                    this.interacted = false;
                    if (this._completedOverride != null) {
                        this._completedOverride = false;
                    }
                    if (this._customError != null) {
                        this._customError = false;
                    }
                    if (this.stepControl) {
                        this.stepControl.reset();
                    }
                };
                /**
                 * @return {?}
                 */
                CdkStep.prototype.ngOnChanges = function () {
                    // Since basically all inputs of the MatStep get proxied through the view down to the
                    // underlying MatStepHeader, we have to make sure that change detection runs correctly.
                    this._stepper._stateChanged();
                };
                return CdkStep;
            }());
            CdkStep.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'cdk-step',
                            exportAs: 'cdkStep',
                            template: '<ng-template><ng-content></ng-content></ng-template>',
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            CdkStep.ctorParameters = function () { return [
                { type: CdkStepper, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                                                 * @return {?}
                                                 */function () { return CdkStepper; })),] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [STEPPER_GLOBAL_OPTIONS,] }] }
            ]; };
            CdkStep.propDecorators = {
                stepLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChild"], args: [CdkStepLabel, { static: false },] }],
                content: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"], { static: true },] }],
                stepControl: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                label: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                errorMessage: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                ariaLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['aria-label',] }],
                ariaLabelledby: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['aria-labelledby',] }],
                state: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                editable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                optional: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                completed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                hasError: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            var CdkStepper = /** @class */ (function () {
                /**
                 * @param {?} _dir
                 * @param {?} _changeDetectorRef
                 * @param {?=} _elementRef
                 * @param {?=} _document
                 */
                function CdkStepper(_dir, _changeDetectorRef, _elementRef, _document) {
                    this._dir = _dir;
                    this._changeDetectorRef = _changeDetectorRef;
                    this._elementRef = _elementRef;
                    /**
                     * Emits when the component is destroyed.
                     */
                    this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_6__["Subject"]();
                    this._linear = false;
                    this._selectedIndex = 0;
                    /**
                     * Event emitted when the selected step has changed.
                     */
                    this.selectionChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    this._orientation = 'horizontal';
                    this._groupId = nextId++;
                    this._document = _document;
                }
                Object.defineProperty(CdkStepper.prototype, "steps", {
                    /**
                     * The list of step components that the stepper is holding.
                     * @return {?}
                     */
                    get: function () {
                        return this._steps;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkStepper.prototype, "linear", {
                    /**
                     * Whether the validity of previous steps should be checked or not.
                     * @return {?}
                     */
                    get: function () {
                        return this._linear;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._linear = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkStepper.prototype, "selectedIndex", {
                    /**
                     * The index of the selected step.
                     * @return {?}
                     */
                    get: function () {
                        return this._selectedIndex;
                    },
                    /**
                     * @param {?} index
                     * @return {?}
                     */
                    set: function (index) {
                        /** @type {?} */
                        var newIndex = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceNumberProperty"])(index);
                        if (this.steps) {
                            // Ensure that the index can't be out of bounds.
                            if (newIndex < 0 || newIndex > this.steps.length - 1) {
                                throw Error('cdkStepper: Cannot assign out-of-bounds value to `selectedIndex`.');
                            }
                            if (this._selectedIndex != newIndex && !this._anyControlsInvalidOrPending(newIndex) &&
                                (newIndex >= this._selectedIndex || this.steps.toArray()[newIndex].editable)) {
                                this._updateSelectedItemIndex(index);
                            }
                        }
                        else {
                            this._selectedIndex = newIndex;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkStepper.prototype, "selected", {
                    /**
                     * The step that is selected.
                     * @return {?}
                     */
                    get: function () {
                        // @breaking-change 8.0.0 Change return type to `CdkStep | undefined`.
                        return this.steps ? this.steps.toArray()[this.selectedIndex] : ( /** @type {?} */(undefined));
                    },
                    /**
                     * @param {?} step
                     * @return {?}
                     */
                    set: function (step) {
                        this.selectedIndex = this.steps ? this.steps.toArray().indexOf(step) : -1;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                CdkStepper.prototype.ngAfterViewInit = function () {
                    var _this_1 = this;
                    // Note that while the step headers are content children by default, any components that
                    // extend this one might have them as view chidren. We initialize the keyboard handling in
                    // AfterViewInit so we're guaranteed for both view and content children to be defined.
                    this._keyManager = new _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__["FocusKeyManager"](this._stepHeader)
                        .withWrap()
                        .withVerticalOrientation(this._orientation === 'vertical');
                    (this._dir ? (( /** @type {?} */(this._dir.change))) : Object(rxjs__WEBPACK_IMPORTED_MODULE_6__["of"])())
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["startWith"])(this._layoutDirection()), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["takeUntil"])(this._destroyed))
                        .subscribe(( /**
                 * @param {?} direction
                 * @return {?}
                 */function (/**
                 * @param {?} direction
                 * @return {?}
                 */ direction) { return _this_1._keyManager.withHorizontalOrientation(direction); }));
                    this._keyManager.updateActiveItemIndex(this._selectedIndex);
                    this.steps.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["takeUntil"])(this._destroyed)).subscribe(( /**
                     * @return {?}
                     */function () {
                        if (!_this_1.selected) {
                            _this_1._selectedIndex = Math.max(_this_1._selectedIndex - 1, 0);
                        }
                    }));
                };
                /**
                 * @return {?}
                 */
                CdkStepper.prototype.ngOnDestroy = function () {
                    this._destroyed.next();
                    this._destroyed.complete();
                };
                /**
                 * Selects and focuses the next step in list.
                 * @return {?}
                 */
                CdkStepper.prototype.next = function () {
                    this.selectedIndex = Math.min(this._selectedIndex + 1, this.steps.length - 1);
                };
                /**
                 * Selects and focuses the previous step in list.
                 * @return {?}
                 */
                CdkStepper.prototype.previous = function () {
                    this.selectedIndex = Math.max(this._selectedIndex - 1, 0);
                };
                /**
                 * Resets the stepper to its initial state. Note that this includes clearing form data.
                 * @return {?}
                 */
                CdkStepper.prototype.reset = function () {
                    this._updateSelectedItemIndex(0);
                    this.steps.forEach(( /**
                     * @param {?} step
                     * @return {?}
                     */function (/**
                     * @param {?} step
                     * @return {?}
                     */ step) { return step.reset(); }));
                    this._stateChanged();
                };
                /**
                 * Returns a unique id for each step label element.
                 * @param {?} i
                 * @return {?}
                 */
                CdkStepper.prototype._getStepLabelId = function (i) {
                    return "cdk-step-label-" + this._groupId + "-" + i;
                };
                /**
                 * Returns unique id for each step content element.
                 * @param {?} i
                 * @return {?}
                 */
                CdkStepper.prototype._getStepContentId = function (i) {
                    return "cdk-step-content-" + this._groupId + "-" + i;
                };
                /**
                 * Marks the component to be change detected.
                 * @return {?}
                 */
                CdkStepper.prototype._stateChanged = function () {
                    this._changeDetectorRef.markForCheck();
                };
                /**
                 * Returns position state of the step with the given index.
                 * @param {?} index
                 * @return {?}
                 */
                CdkStepper.prototype._getAnimationDirection = function (index) {
                    /** @type {?} */
                    var position = index - this._selectedIndex;
                    if (position < 0) {
                        return this._layoutDirection() === 'rtl' ? 'next' : 'previous';
                    }
                    else if (position > 0) {
                        return this._layoutDirection() === 'rtl' ? 'previous' : 'next';
                    }
                    return 'current';
                };
                /**
                 * Returns the type of icon to be displayed.
                 * @param {?} index
                 * @param {?=} state
                 * @return {?}
                 */
                CdkStepper.prototype._getIndicatorType = function (index, state) {
                    if (state === void 0) { state = STEP_STATE.NUMBER; }
                    /** @type {?} */
                    var step = this.steps.toArray()[index];
                    /** @type {?} */
                    var isCurrentStep = this._isCurrentStep(index);
                    return step._displayDefaultIndicatorType ? this._getDefaultIndicatorLogic(step, isCurrentStep) :
                        this._getGuidelineLogic(step, isCurrentStep, state);
                };
                /**
                 * @private
                 * @param {?} step
                 * @param {?} isCurrentStep
                 * @return {?}
                 */
                CdkStepper.prototype._getDefaultIndicatorLogic = function (step, isCurrentStep) {
                    if (step._showError && step.hasError && !isCurrentStep) {
                        return STEP_STATE.ERROR;
                    }
                    else if (!step.completed || isCurrentStep) {
                        return STEP_STATE.NUMBER;
                    }
                    else {
                        return step.editable ? STEP_STATE.EDIT : STEP_STATE.DONE;
                    }
                };
                /**
                 * @private
                 * @param {?} step
                 * @param {?} isCurrentStep
                 * @param {?=} state
                 * @return {?}
                 */
                CdkStepper.prototype._getGuidelineLogic = function (step, isCurrentStep, state) {
                    if (state === void 0) { state = STEP_STATE.NUMBER; }
                    if (step._showError && step.hasError && !isCurrentStep) {
                        return STEP_STATE.ERROR;
                    }
                    else if (step.completed && !isCurrentStep) {
                        return STEP_STATE.DONE;
                    }
                    else if (step.completed && isCurrentStep) {
                        return state;
                    }
                    else if (step.editable && isCurrentStep) {
                        return STEP_STATE.EDIT;
                    }
                    else {
                        return state;
                    }
                };
                /**
                 * @private
                 * @param {?} index
                 * @return {?}
                 */
                CdkStepper.prototype._isCurrentStep = function (index) {
                    return this._selectedIndex === index;
                };
                /**
                 * Returns the index of the currently-focused step header.
                 * @return {?}
                 */
                CdkStepper.prototype._getFocusIndex = function () {
                    return this._keyManager ? this._keyManager.activeItemIndex : this._selectedIndex;
                };
                /**
                 * @private
                 * @param {?} newIndex
                 * @return {?}
                 */
                CdkStepper.prototype._updateSelectedItemIndex = function (newIndex) {
                    /** @type {?} */
                    var stepsArray = this.steps.toArray();
                    this.selectionChange.emit({
                        selectedIndex: newIndex,
                        previouslySelectedIndex: this._selectedIndex,
                        selectedStep: stepsArray[newIndex],
                        previouslySelectedStep: stepsArray[this._selectedIndex],
                    });
                    // If focus is inside the stepper, move it to the next header, otherwise it may become
                    // lost when the active step content is hidden. We can't be more granular with the check
                    // (e.g. checking whether focus is inside the active step), because we don't have a
                    // reference to the elements that are rendering out the content.
                    this._containsFocus() ? this._keyManager.setActiveItem(newIndex) :
                        this._keyManager.updateActiveItemIndex(newIndex);
                    this._selectedIndex = newIndex;
                    this._stateChanged();
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                CdkStepper.prototype._onKeydown = function (event) {
                    /** @type {?} */
                    var hasModifier = Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__["hasModifierKey"])(event);
                    /** @type {?} */
                    var keyCode = event.keyCode;
                    /** @type {?} */
                    var manager = this._keyManager;
                    if (manager.activeItemIndex != null && !hasModifier &&
                        (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__["SPACE"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__["ENTER"])) {
                        this.selectedIndex = manager.activeItemIndex;
                        event.preventDefault();
                    }
                    else if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__["HOME"]) {
                        manager.setFirstItemActive();
                        event.preventDefault();
                    }
                    else if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__["END"]) {
                        manager.setLastItemActive();
                        event.preventDefault();
                    }
                    else {
                        manager.onKeydown(event);
                    }
                };
                /**
                 * @private
                 * @param {?} index
                 * @return {?}
                 */
                CdkStepper.prototype._anyControlsInvalidOrPending = function (index) {
                    /** @type {?} */
                    var steps = this.steps.toArray();
                    steps[this._selectedIndex].interacted = true;
                    if (this._linear && index >= 0) {
                        return steps.slice(0, index).some(( /**
                         * @param {?} step
                         * @return {?}
                         */function (/**
                         * @param {?} step
                         * @return {?}
                         */ step) {
                            /** @type {?} */
                            var control = step.stepControl;
                            /** @type {?} */
                            var isIncomplete = control ? (control.invalid || control.pending || !step.interacted) : !step.completed;
                            return isIncomplete && !step.optional && !step._completedOverride;
                        }));
                    }
                    return false;
                };
                /**
                 * @private
                 * @return {?}
                 */
                CdkStepper.prototype._layoutDirection = function () {
                    return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
                };
                /**
                 * Checks whether the stepper contains the focused element.
                 * @private
                 * @return {?}
                 */
                CdkStepper.prototype._containsFocus = function () {
                    if (!this._document || !this._elementRef) {
                        return false;
                    }
                    /** @type {?} */
                    var stepperElement = this._elementRef.nativeElement;
                    /** @type {?} */
                    var focusedElement = this._document.activeElement;
                    return stepperElement === focusedElement || stepperElement.contains(focusedElement);
                };
                return CdkStepper;
            }());
            CdkStepper.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[cdkStepper]',
                            exportAs: 'cdkStepper',
                        },] },
            ];
            /** @nocollapse */
            CdkStepper.ctorParameters = function () { return [
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_5__["DOCUMENT"],] }] }
            ]; };
            CdkStepper.propDecorators = {
                _steps: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChildren"], args: [CdkStep,] }],
                _stepHeader: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChildren"], args: [CdkStepHeader,] }],
                linear: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selectedIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selectionChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Button that moves to the next step in a stepper workflow.
             */
            var CdkStepperNext = /** @class */ (function () {
                /**
                 * @param {?} _stepper
                 */
                function CdkStepperNext(_stepper) {
                    this._stepper = _stepper;
                    /**
                     * Type of the next button. Defaults to "submit" if not specified.
                     */
                    this.type = 'submit';
                }
                // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.
                // In Ivy the `host` bindings will be merged when this class is extended, whereas in
                // ViewEngine they're overwritten.
                // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.
                // tslint:disable-next-line:no-host-decorator-in-concrete
                /**
                 * @return {?}
                 */
                CdkStepperNext.prototype._handleClick = function () {
                    this._stepper.next();
                };
                return CdkStepperNext;
            }());
            CdkStepperNext.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'button[cdkStepperNext]',
                            host: {
                                '[type]': 'type',
                            }
                        },] },
            ];
            /** @nocollapse */
            CdkStepperNext.ctorParameters = function () { return [
                { type: CdkStepper }
            ]; };
            CdkStepperNext.propDecorators = {
                type: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                _handleClick: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"], args: ['click',] }]
            };
            /**
             * Button that moves to the previous step in a stepper workflow.
             */
            var CdkStepperPrevious = /** @class */ (function () {
                /**
                 * @param {?} _stepper
                 */
                function CdkStepperPrevious(_stepper) {
                    this._stepper = _stepper;
                    /**
                     * Type of the previous button. Defaults to "button" if not specified.
                     */
                    this.type = 'button';
                }
                // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.
                // In Ivy the `host` bindings will be merged when this class is extended, whereas in
                // ViewEngine they're overwritten.
                // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.
                // tslint:disable-next-line:no-host-decorator-in-concrete
                /**
                 * @return {?}
                 */
                CdkStepperPrevious.prototype._handleClick = function () {
                    this._stepper.previous();
                };
                return CdkStepperPrevious;
            }());
            CdkStepperPrevious.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'button[cdkStepperPrevious]',
                            host: {
                                '[type]': 'type',
                            }
                        },] },
            ];
            /** @nocollapse */
            CdkStepperPrevious.ctorParameters = function () { return [
                { type: CdkStepper }
            ]; };
            CdkStepperPrevious.propDecorators = {
                type: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                _handleClick: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"], args: ['click',] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var CdkStepperModule = /** @class */ (function () {
                function CdkStepperModule() {
                }
                return CdkStepperModule;
            }());
            CdkStepperModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__["BidiModule"], _angular_common__WEBPACK_IMPORTED_MODULE_5__["CommonModule"]],
                            exports: [
                                CdkStep,
                                CdkStepper,
                                CdkStepHeader,
                                CdkStepLabel,
                                CdkStepperNext,
                                CdkStepperPrevious,
                            ],
                            declarations: [
                                CdkStep,
                                CdkStepper,
                                CdkStepHeader,
                                CdkStepLabel,
                                CdkStepperNext,
                                CdkStepperPrevious,
                            ]
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=stepper.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/cdk/esm2015/text-field.js": 
        /*!*********************************************************!*\
          !*** ./node_modules/@angular/cdk/esm2015/text-field.js ***!
          \*********************************************************/
        /*! exports provided: AutofillMonitor, CdkAutofill, CdkTextareaAutosize, TextFieldModule */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AutofillMonitor", function () { return AutofillMonitor; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkAutofill", function () { return CdkAutofill; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkTextareaAutosize", function () { return CdkTextareaAutosize; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextFieldModule", function () { return TextFieldModule; });
            /* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/platform */ "./node_modules/@angular/cdk/esm2015/platform.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Options to pass to the animationstart listener.
             * @type {?}
             */
            var listenerOptions = Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__["normalizePassiveListenerOptions"])({ passive: true });
            /**
             * An injectable service that can be used to monitor the autofill state of an input.
             * Based on the following blog post:
             * https://medium.com/\@brunn/detecting-autofilled-fields-in-javascript-aed598d25da7
             */
            var AutofillMonitor = /** @class */ (function () {
                /**
                 * @param {?} _platform
                 * @param {?} _ngZone
                 */
                function AutofillMonitor(_platform, _ngZone) {
                    this._platform = _platform;
                    this._ngZone = _ngZone;
                    this._monitoredElements = new Map();
                }
                /**
                 * @param {?} elementOrRef
                 * @return {?}
                 */
                AutofillMonitor.prototype.monitor = function (elementOrRef) {
                    var _this_1 = this;
                    if (!this._platform.isBrowser) {
                        return rxjs__WEBPACK_IMPORTED_MODULE_3__["EMPTY"];
                    }
                    /** @type {?} */
                    var element = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceElement"])(elementOrRef);
                    /** @type {?} */
                    var info = this._monitoredElements.get(element);
                    if (info) {
                        return info.subject.asObservable();
                    }
                    /** @type {?} */
                    var result = new rxjs__WEBPACK_IMPORTED_MODULE_3__["Subject"]();
                    /** @type {?} */
                    var cssClass = 'cdk-text-field-autofilled';
                    /** @type {?} */
                    var listener = ( /** @type {?} */((( /**
                     * @param {?} event
                     * @return {?}
                     */function (event) {
                        // Animation events fire on initial element render, we check for the presence of the autofill
                        // CSS class to make sure this is a real change in state, not just the initial render before
                        // we fire off events.
                        if (event.animationName === 'cdk-text-field-autofill-start' &&
                            !element.classList.contains(cssClass)) {
                            element.classList.add(cssClass);
                            _this_1._ngZone.run(( /**
                             * @return {?}
                             */function () { return result.next({ target: ( /** @type {?} */(event.target)), isAutofilled: true }); }));
                        }
                        else if (event.animationName === 'cdk-text-field-autofill-end' &&
                            element.classList.contains(cssClass)) {
                            element.classList.remove(cssClass);
                            _this_1._ngZone.run(( /**
                             * @return {?}
                             */function () { return result.next({ target: ( /** @type {?} */(event.target)), isAutofilled: false }); }));
                        }
                    }))));
                    this._ngZone.runOutsideAngular(( /**
                     * @return {?}
                     */function () {
                        element.addEventListener('animationstart', listener, listenerOptions);
                        element.classList.add('cdk-text-field-autofill-monitored');
                    }));
                    this._monitoredElements.set(element, {
                        subject: result,
                        unlisten: ( /**
                         * @return {?}
                         */function () {
                            element.removeEventListener('animationstart', listener, listenerOptions);
                        })
                    });
                    return result.asObservable();
                };
                /**
                 * @param {?} elementOrRef
                 * @return {?}
                 */
                AutofillMonitor.prototype.stopMonitoring = function (elementOrRef) {
                    /** @type {?} */
                    var element = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceElement"])(elementOrRef);
                    /** @type {?} */
                    var info = this._monitoredElements.get(element);
                    if (info) {
                        info.unlisten();
                        info.subject.complete();
                        element.classList.remove('cdk-text-field-autofill-monitored');
                        element.classList.remove('cdk-text-field-autofilled');
                        this._monitoredElements.delete(element);
                    }
                };
                /**
                 * @return {?}
                 */
                AutofillMonitor.prototype.ngOnDestroy = function () {
                    var _this_1 = this;
                    this._monitoredElements.forEach(( /**
                     * @param {?} _info
                     * @param {?} element
                     * @return {?}
                     */function (_info, element) { return _this_1.stopMonitoring(element); }));
                };
                return AutofillMonitor;
            }());
            AutofillMonitor.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */
            AutofillMonitor.ctorParameters = function () { return [
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__["Platform"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] }
            ]; };
            /** @nocollapse */ AutofillMonitor.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({ factory: function AutofillMonitor_Factory() { return new AutofillMonitor(Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__["Platform"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"])); }, token: AutofillMonitor, providedIn: "root" });
            /**
             * A directive that can be used to monitor the autofill state of an input.
             */
            var CdkAutofill = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 * @param {?} _autofillMonitor
                 */
                function CdkAutofill(_elementRef, _autofillMonitor) {
                    this._elementRef = _elementRef;
                    this._autofillMonitor = _autofillMonitor;
                    /**
                     * Emits when the autofill state of the element changes.
                     */
                    this.cdkAutofill = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
                }
                /**
                 * @return {?}
                 */
                CdkAutofill.prototype.ngOnInit = function () {
                    var _this_1 = this;
                    this._autofillMonitor
                        .monitor(this._elementRef)
                        .subscribe(( /**
                 * @param {?} event
                 * @return {?}
                 */function (/**
                 * @param {?} event
                 * @return {?}
                 */ event) { return _this_1.cdkAutofill.emit(event); }));
                };
                /**
                 * @return {?}
                 */
                CdkAutofill.prototype.ngOnDestroy = function () {
                    this._autofillMonitor.stopMonitoring(this._elementRef);
                };
                return CdkAutofill;
            }());
            CdkAutofill.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[cdkAutofill]',
                        },] },
            ];
            /** @nocollapse */
            CdkAutofill.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
                { type: AutofillMonitor }
            ]; };
            CdkAutofill.propDecorators = {
                cdkAutofill: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Directive to automatically resize a textarea to fit its content.
             */
            var CdkTextareaAutosize = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 * @param {?} _platform
                 * @param {?} _ngZone
                 */
                function CdkTextareaAutosize(_elementRef, _platform, _ngZone) {
                    this._elementRef = _elementRef;
                    this._platform = _platform;
                    this._ngZone = _ngZone;
                    this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_3__["Subject"]();
                    this._enabled = true;
                    /**
                     * Value of minRows as of last resize. If the minRows has decreased, the
                     * height of the textarea needs to be recomputed to reflect the new minimum. The maxHeight
                     * does not have the same problem because it does not affect the textarea's scrollHeight.
                     */
                    this._previousMinRows = -1;
                    this._textareaElement = ( /** @type {?} */(this._elementRef.nativeElement));
                }
                Object.defineProperty(CdkTextareaAutosize.prototype, "minRows", {
                    /**
                     * Minimum amount of rows in the textarea.
                     * @return {?}
                     */
                    get: function () { return this._minRows; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._minRows = value;
                        this._setMinHeight();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkTextareaAutosize.prototype, "maxRows", {
                    /**
                     * Maximum amount of rows in the textarea.
                     * @return {?}
                     */
                    get: function () { return this._maxRows; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._maxRows = value;
                        this._setMaxHeight();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkTextareaAutosize.prototype, "enabled", {
                    /**
                     * Whether autosizing is enabled or not
                     * @return {?}
                     */
                    get: function () { return this._enabled; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        value = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(value);
                        // Only act if the actual value changed. This specifically helps to not run
                        // resizeToFitContent too early (i.e. before ngAfterViewInit)
                        if (this._enabled !== value) {
                            (this._enabled = value) ? this.resizeToFitContent(true) : this.reset();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Sets the minimum height of the textarea as determined by minRows.
                 * @return {?}
                 */
                CdkTextareaAutosize.prototype._setMinHeight = function () {
                    /** @type {?} */
                    var minHeight = this.minRows && this._cachedLineHeight ?
                        this.minRows * this._cachedLineHeight + "px" : null;
                    if (minHeight) {
                        this._textareaElement.style.minHeight = minHeight;
                    }
                };
                /**
                 * Sets the maximum height of the textarea as determined by maxRows.
                 * @return {?}
                 */
                CdkTextareaAutosize.prototype._setMaxHeight = function () {
                    /** @type {?} */
                    var maxHeight = this.maxRows && this._cachedLineHeight ?
                        this.maxRows * this._cachedLineHeight + "px" : null;
                    if (maxHeight) {
                        this._textareaElement.style.maxHeight = maxHeight;
                    }
                };
                /**
                 * @return {?}
                 */
                CdkTextareaAutosize.prototype.ngAfterViewInit = function () {
                    var _this_1 = this;
                    if (this._platform.isBrowser) {
                        // Remember the height which we started with in case autosizing is disabled
                        this._initialHeight = this._textareaElement.style.height;
                        this.resizeToFitContent();
                        this._ngZone.runOutsideAngular(( /**
                         * @return {?}
                         */function () {
                            Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["fromEvent"])(window, 'resize')
                                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["auditTime"])(16), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["takeUntil"])(_this_1._destroyed))
                                .subscribe(( /**
                         * @return {?}
                         */function () { return _this_1.resizeToFitContent(true); }));
                        }));
                    }
                };
                /**
                 * @return {?}
                 */
                CdkTextareaAutosize.prototype.ngOnDestroy = function () {
                    this._destroyed.next();
                    this._destroyed.complete();
                };
                /**
                 * Cache the height of a single-row textarea if it has not already been cached.
                 *
                 * We need to know how large a single "row" of a textarea is in order to apply minRows and
                 * maxRows. For the initial version, we will assume that the height of a single line in the
                 * textarea does not ever change.
                 * @private
                 * @return {?}
                 */
                CdkTextareaAutosize.prototype._cacheTextareaLineHeight = function () {
                    if (this._cachedLineHeight) {
                        return;
                    }
                    // Use a clone element because we have to override some styles.
                    /** @type {?} */
                    var textareaClone = ( /** @type {?} */(this._textareaElement.cloneNode(false)));
                    textareaClone.rows = 1;
                    // Use `position: absolute` so that this doesn't cause a browser layout and use
                    // `visibility: hidden` so that nothing is rendered. Clear any other styles that
                    // would affect the height.
                    textareaClone.style.position = 'absolute';
                    textareaClone.style.visibility = 'hidden';
                    textareaClone.style.border = 'none';
                    textareaClone.style.padding = '0';
                    textareaClone.style.height = '';
                    textareaClone.style.minHeight = '';
                    textareaClone.style.maxHeight = '';
                    // In Firefox it happens that textarea elements are always bigger than the specified amount
                    // of rows. This is because Firefox tries to add extra space for the horizontal scrollbar.
                    // As a workaround that removes the extra space for the scrollbar, we can just set overflow
                    // to hidden. This ensures that there is no invalid calculation of the line height.
                    // See Firefox bug report: https://bugzilla.mozilla.org/show_bug.cgi?id=33654
                    textareaClone.style.overflow = 'hidden';
                    ( /** @type {?} */(this._textareaElement.parentNode)).appendChild(textareaClone);
                    this._cachedLineHeight = textareaClone.clientHeight;
                    ( /** @type {?} */(this._textareaElement.parentNode)).removeChild(textareaClone);
                    // Min and max heights have to be re-calculated if the cached line height changes
                    this._setMinHeight();
                    this._setMaxHeight();
                };
                /**
                 * @return {?}
                 */
                CdkTextareaAutosize.prototype.ngDoCheck = function () {
                    if (this._platform.isBrowser) {
                        this.resizeToFitContent();
                    }
                };
                /**
                 * Resize the textarea to fit its content.
                 * @param {?=} force Whether to force a height recalculation. By default the height will be
                 *    recalculated only if the value changed since the last call.
                 * @return {?}
                 */
                CdkTextareaAutosize.prototype.resizeToFitContent = function (force) {
                    var _this_1 = this;
                    if (force === void 0) { force = false; }
                    // If autosizing is disabled, just skip everything else
                    if (!this._enabled) {
                        return;
                    }
                    this._cacheTextareaLineHeight();
                    // If we haven't determined the line-height yet, we know we're still hidden and there's no point
                    // in checking the height of the textarea.
                    if (!this._cachedLineHeight) {
                        return;
                    }
                    /** @type {?} */
                    var textarea = ( /** @type {?} */(this._elementRef.nativeElement));
                    /** @type {?} */
                    var value = textarea.value;
                    // Only resize if the value or minRows have changed since these calculations can be expensive.
                    if (!force && this._minRows === this._previousMinRows && value === this._previousValue) {
                        return;
                    }
                    /** @type {?} */
                    var placeholderText = textarea.placeholder;
                    // Reset the textarea height to auto in order to shrink back to its default size.
                    // Also temporarily force overflow:hidden, so scroll bars do not interfere with calculations.
                    // Long placeholders that are wider than the textarea width may lead to a bigger scrollHeight
                    // value. To ensure that the scrollHeight is not bigger than the content, the placeholders
                    // need to be removed temporarily.
                    textarea.classList.add('cdk-textarea-autosize-measuring');
                    textarea.placeholder = '';
                    // The cdk-textarea-autosize-measuring class includes a 2px padding to workaround an issue with
                    // Chrome, so we account for that extra space here by subtracting 4 (2px top + 2px bottom).
                    /** @type {?} */
                    var height = textarea.scrollHeight - 4;
                    // Use the scrollHeight to know how large the textarea *would* be if fit its entire value.
                    textarea.style.height = height + "px";
                    textarea.classList.remove('cdk-textarea-autosize-measuring');
                    textarea.placeholder = placeholderText;
                    this._ngZone.runOutsideAngular(( /**
                     * @return {?}
                     */function () {
                        if (typeof requestAnimationFrame !== 'undefined') {
                            requestAnimationFrame(( /**
                             * @return {?}
                             */function () { return _this_1._scrollToCaretPosition(textarea); }));
                        }
                        else {
                            setTimeout(( /**
                             * @return {?}
                             */function () { return _this_1._scrollToCaretPosition(textarea); }));
                        }
                    }));
                    this._previousValue = value;
                    this._previousMinRows = this._minRows;
                };
                /**
                 * Resets the textarea to its original size
                 * @return {?}
                 */
                CdkTextareaAutosize.prototype.reset = function () {
                    // Do not try to change the textarea, if the initialHeight has not been determined yet
                    // This might potentially remove styles when reset() is called before ngAfterViewInit
                    if (this._initialHeight === undefined) {
                        return;
                    }
                    this._textareaElement.style.height = this._initialHeight;
                };
                /**
                 * @return {?}
                 */
                CdkTextareaAutosize.prototype._noopInputHandler = function () {
                    // no-op handler that ensures we're running change detection on input events.
                };
                /**
                 * Scrolls a textarea to the caret position. On Firefox resizing the textarea will
                 * prevent it from scrolling to the caret position. We need to re-set the selection
                 * in order for it to scroll to the proper position.
                 * @private
                 * @param {?} textarea
                 * @return {?}
                 */
                CdkTextareaAutosize.prototype._scrollToCaretPosition = function (textarea) {
                    var selectionStart = textarea.selectionStart, selectionEnd = textarea.selectionEnd;
                    // IE will throw an "Unspecified error" if we try to set the selection range after the
                    // element has been removed from the DOM. Assert that the directive hasn't been destroyed
                    // between the time we requested the animation frame and when it was executed.
                    // Also note that we have to assert that the textarea is focused before we set the
                    // selection range. Setting the selection range on a non-focused textarea will cause
                    // it to receive focus on IE and Edge.
                    if (!this._destroyed.isStopped && document.activeElement === textarea) {
                        textarea.setSelectionRange(selectionStart, selectionEnd);
                    }
                };
                return CdkTextareaAutosize;
            }());
            CdkTextareaAutosize.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: 'textarea[cdkTextareaAutosize]',
                            exportAs: 'cdkTextareaAutosize',
                            host: {
                                'class': 'cdk-textarea-autosize',
                                // Textarea elements that have the directive applied should have a single row by default.
                                // Browsers normally show two rows by default and therefore this limits the minRows binding.
                                'rows': '1',
                                '(input)': '_noopInputHandler()',
                            },
                        },] },
            ];
            /** @nocollapse */
            CdkTextareaAutosize.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__["Platform"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] }
            ]; };
            CdkTextareaAutosize.propDecorators = {
                minRows: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['cdkAutosizeMinRows',] }],
                maxRows: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['cdkAutosizeMaxRows',] }],
                enabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['cdkTextareaAutosize',] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var TextFieldModule = /** @class */ (function () {
                function TextFieldModule() {
                }
                return TextFieldModule;
            }());
            TextFieldModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                            declarations: [CdkAutofill, CdkTextareaAutosize],
                            imports: [_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__["PlatformModule"]],
                            exports: [CdkAutofill, CdkTextareaAutosize],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=text-field.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/flex-layout/esm2015/core.js": 
        /*!***********************************************************!*\
          !*** ./node_modules/@angular/flex-layout/esm2015/core.js ***!
          \***********************************************************/
        /*! exports provided: ɵMatchMedia, ɵMockMatchMedia, ɵMockMatchMediaProvider, CoreModule, removeStyles, BROWSER_PROVIDER, CLASS_NAME, MediaChange, StylesheetMap, DEFAULT_CONFIG, LAYOUT_CONFIG, SERVER_TOKEN, BREAKPOINT, mergeAlias, BaseDirective2, DEFAULT_BREAKPOINTS, ScreenTypes, ORIENTATION_BREAKPOINTS, BreakPointRegistry, BREAKPOINTS, MediaObserver, MediaTrigger, sortDescendingPriority, sortAscendingPriority, coerceArray, StyleUtils, StyleBuilder, validateBasis, MediaMarshaller, BREAKPOINT_PRINT, PrintHook */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵMatchMedia", function () { return MatchMedia; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵMockMatchMedia", function () { return MockMatchMedia; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵMockMatchMediaProvider", function () { return MockMatchMediaProvider; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CoreModule", function () { return CoreModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeStyles", function () { return removeStyles; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BROWSER_PROVIDER", function () { return BROWSER_PROVIDER; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASS_NAME", function () { return CLASS_NAME; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MediaChange", function () { return MediaChange; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StylesheetMap", function () { return StylesheetMap; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_CONFIG", function () { return DEFAULT_CONFIG; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LAYOUT_CONFIG", function () { return LAYOUT_CONFIG; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SERVER_TOKEN", function () { return SERVER_TOKEN; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BREAKPOINT", function () { return BREAKPOINT; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeAlias", function () { return mergeAlias; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseDirective2", function () { return BaseDirective2; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_BREAKPOINTS", function () { return DEFAULT_BREAKPOINTS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScreenTypes", function () { return ScreenTypes; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ORIENTATION_BREAKPOINTS", function () { return ORIENTATION_BREAKPOINTS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BreakPointRegistry", function () { return BreakPointRegistry; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BREAKPOINTS", function () { return BREAKPOINTS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MediaObserver", function () { return MediaObserver; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MediaTrigger", function () { return MediaTrigger; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sortDescendingPriority", function () { return sortDescendingPriority; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sortAscendingPriority", function () { return sortAscendingPriority; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "coerceArray", function () { return coerceArray; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StyleUtils", function () { return StyleUtils; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StyleBuilder", function () { return StyleBuilder; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateBasis", function () { return validateBasis; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MediaMarshaller", function () { return MediaMarshaller; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BREAKPOINT_PRINT", function () { return BREAKPOINT_PRINT; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PrintHook", function () { return PrintHook; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Find all of the server-generated stylings, if any, and remove them
             * This will be in the form of inline classes and the style block in the
             * head of the DOM
             * @param {?} _document
             * @param {?} platformId
             * @return {?}
             */
            function removeStyles(_document, platformId) {
                return ( /**
                 * @return {?}
                 */function () {
                    if (Object(_angular_common__WEBPACK_IMPORTED_MODULE_1__["isPlatformBrowser"])(platformId)) {
                        /** @type {?} */
                        var elements = Array.from(_document.querySelectorAll("[class*=" + CLASS_NAME + "]"));
                        // RegExp constructor should only be used if passing a variable to the constructor.
                        // When using static regular expression it is more performant to use reg exp literal.
                        // This is also needed to provide Safari 9 compatibility, please see
                        // https://stackoverflow.com/questions/37919802 for more discussion.
                        /** @type {?} */
                        var classRegex_1 = /\bflex-layout-.+?\b/g;
                        elements.forEach(( /**
                         * @param {?} el
                         * @return {?}
                         */function (/**
                         * @param {?} el
                         * @return {?}
                         */ el) {
                            el.classList.contains(CLASS_NAME + "ssr") && el.parentNode ?
                                el.parentNode.removeChild(el) : el.className.replace(classRegex_1, '');
                        }));
                    }
                });
            }
            /**
             *  Provider to remove SSR styles on the browser
             * @type {?}
             */
            var BROWSER_PROVIDER = {
                provide: ( /** @type {?} */(_angular_core__WEBPACK_IMPORTED_MODULE_0__["APP_BOOTSTRAP_LISTENER"])),
                useFactory: removeStyles,
                deps: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["DOCUMENT"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["PLATFORM_ID"]],
                multi: true
            };
            /** @type {?} */
            var CLASS_NAME = 'flex-layout-';
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * *****************************************************************
             * Define module for the MediaQuery API
             * *****************************************************************
             */
            var CoreModule = /** @class */ (function () {
                function CoreModule() {
                }
                return CoreModule;
            }());
            CoreModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            providers: [BROWSER_PROVIDER]
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Class instances emitted [to observers] for each mql notification
             */
            var MediaChange = /** @class */ (function () {
                /**
                 * @param {?=} matches whether the mediaQuery is currently activated
                 * @param {?=} mediaQuery e.g. (min-width: 600px) and (max-width: 959px)
                 * @param {?=} mqAlias e.g. gt-sm, md, gt-lg
                 * @param {?=} suffix e.g. GtSM, Md, GtLg
                 * @param {?=} priority the priority of activation for the given breakpoint
                 */
                function MediaChange(matches, mediaQuery, mqAlias, suffix, priority) {
                    if (matches === void 0) { matches = false; }
                    if (mediaQuery === void 0) { mediaQuery = 'all'; }
                    if (mqAlias === void 0) { mqAlias = ''; }
                    if (suffix === void 0) { suffix = ''; }
                    if (priority === void 0) { priority = 0; }
                    this.matches = matches;
                    this.mediaQuery = mediaQuery;
                    this.mqAlias = mqAlias;
                    this.suffix = suffix;
                    this.priority = priority;
                    this.property = '';
                }
                /**
                 * Create an exact copy of the MediaChange
                 * @return {?}
                 */
                MediaChange.prototype.clone = function () {
                    return new MediaChange(this.matches, this.mediaQuery, this.mqAlias, this.suffix);
                };
                return MediaChange;
            }());
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Utility to emulate a CSS stylesheet
             *
             * This utility class stores all of the styles for a given HTML element
             * as a readonly `stylesheet` map.
             */
            var StylesheetMap = /** @class */ (function () {
                function StylesheetMap() {
                    this.stylesheet = new Map();
                }
                /**
                 * Add an individual style to an HTML element
                 * @param {?} element
                 * @param {?} style
                 * @param {?} value
                 * @return {?}
                 */
                StylesheetMap.prototype.addStyleToElement = function (element, style, value) {
                    /** @type {?} */
                    var stylesheet = this.stylesheet.get(element);
                    if (stylesheet) {
                        stylesheet.set(style, value);
                    }
                    else {
                        this.stylesheet.set(element, new Map([[style, value]]));
                    }
                };
                /**
                 * Clear the virtual stylesheet
                 * @return {?}
                 */
                StylesheetMap.prototype.clearStyles = function () {
                    this.stylesheet.clear();
                };
                /**
                 * Retrieve a given style for an HTML element
                 * @param {?} el
                 * @param {?} styleName
                 * @return {?}
                 */
                StylesheetMap.prototype.getStyleForElement = function (el, styleName) {
                    /** @type {?} */
                    var styles = this.stylesheet.get(el);
                    /** @type {?} */
                    var value = '';
                    if (styles) {
                        /** @type {?} */
                        var style = styles.get(styleName);
                        if (typeof style === 'number' || typeof style === 'string') {
                            value = style + '';
                        }
                    }
                    return value;
                };
                return StylesheetMap;
            }());
            StylesheetMap.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */ StylesheetMap.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function StylesheetMap_Factory() { return new StylesheetMap(); }, token: StylesheetMap, providedIn: "root" });
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var DEFAULT_CONFIG = {
                addFlexToParent: true,
                addOrientationBps: false,
                disableDefaultBps: false,
                disableVendorPrefixes: false,
                serverLoaded: false,
                useColumnBasisZero: true,
                printWithBreakpoints: [],
                mediaTriggerAutoRestore: true,
                ssrObserveBreakpoints: [],
            };
            /** @type {?} */
            var LAYOUT_CONFIG = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('Flex Layout token, config options for the library', {
                providedIn: 'root',
                factory: ( /**
                 * @return {?}
                 */function () { return DEFAULT_CONFIG; })
            });
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Token that is provided to tell whether the FlexLayoutServerModule
             * has been included in the bundle
             *
             * NOTE: This can be manually provided to disable styles when using SSR
             * @type {?}
             */
            var SERVER_TOKEN = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('FlexLayoutServerLoaded', {
                providedIn: 'root',
                factory: ( /**
                 * @return {?}
                 */function () { return false; })
            });
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var BREAKPOINT = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('Flex Layout token, collect all breakpoints into one provider', {
                providedIn: 'root',
                factory: ( /**
                 * @return {?}
                 */function () { return null; })
            });
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * For the specified MediaChange, make sure it contains the breakpoint alias
             * and suffix (if available).
             * @param {?} dest
             * @param {?} source
             * @return {?}
             */
            function mergeAlias(dest, source) {
                dest = dest ? dest.clone() : new MediaChange();
                if (source) {
                    dest.mqAlias = source.alias;
                    dest.mediaQuery = source.mediaQuery;
                    dest.suffix = ( /** @type {?} */(source.suffix));
                    dest.priority = ( /** @type {?} */(source.priority));
                }
                return dest;
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             * @type {?}
             */
            var INLINE = 'inline';
            /** @type {?} */
            var LAYOUT_VALUES = ['row', 'column', 'row-reverse', 'column-reverse'];
            /**
             * Validate the direction|'direction wrap' value and then update the host's inline flexbox styles
             * @param {?} value
             * @return {?}
             */
            function buildLayoutCSS(value) {
                var _a = validateValue(value), direction = _a[0], wrap = _a[1], isInline = _a[2];
                return buildCSS(direction, wrap, isInline);
            }
            /**
             * Validate the value to be one of the acceptable value options
             * Use default fallback of 'row'
             * @param {?} value
             * @return {?}
             */
            function validateValue(value) {
                value = value ? value.toLowerCase() : '';
                var _a = value.split(' '), direction = _a[0], wrap = _a[1], inline = _a[2];
                // First value must be the `flex-direction`
                if (!LAYOUT_VALUES.find(( /**
                 * @param {?} x
                 * @return {?}
                 */function (/**
                 * @param {?} x
                 * @return {?}
                 */ x) { return x === direction; }))) {
                    direction = LAYOUT_VALUES[0];
                }
                if (wrap === INLINE) {
                    wrap = (inline !== INLINE) ? inline : '';
                    inline = INLINE;
                }
                return [direction, validateWrapValue(wrap), !!inline];
            }
            /**
             * Convert layout-wrap='<value>' to expected flex-wrap style
             * @param {?} value
             * @return {?}
             */
            function validateWrapValue(value) {
                if (!!value) {
                    switch (value.toLowerCase()) {
                        case 'reverse':
                        case 'wrap-reverse':
                        case 'reverse-wrap':
                            value = 'wrap-reverse';
                            break;
                        case 'no':
                        case 'none':
                        case 'nowrap':
                            value = 'nowrap';
                            break;
                        // All other values fallback to 'wrap'
                        default:
                            value = 'wrap';
                            break;
                    }
                }
                return value;
            }
            /**
             * Build the CSS that should be assigned to the element instance
             * BUG:
             *   1) min-height on a column flex container won’t apply to its flex item children in IE 10-11.
             *      Use height instead if possible; height : <xxx>vh;
             *
             *  This way any padding or border specified on the child elements are
             *  laid out and drawn inside that element's specified width and height.
             * @param {?} direction
             * @param {?=} wrap
             * @param {?=} inline
             * @return {?}
             */
            function buildCSS(direction, wrap, inline) {
                if (wrap === void 0) { wrap = null; }
                if (inline === void 0) { inline = false; }
                return {
                    'display': inline ? 'inline-flex' : 'flex',
                    'box-sizing': 'border-box',
                    'flex-direction': direction,
                    'flex-wrap': !!wrap ? wrap : null
                };
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @abstract
             */
            var BaseDirective2 = /** @class */ (function () {
                /**
                 * @protected
                 * @param {?} elementRef
                 * @param {?} styleBuilder
                 * @param {?} styler
                 * @param {?} marshal
                 */
                function BaseDirective2(elementRef, styleBuilder, styler, marshal) {
                    this.elementRef = elementRef;
                    this.styleBuilder = styleBuilder;
                    this.styler = styler;
                    this.marshal = marshal;
                    this.DIRECTIVE_KEY = '';
                    this.inputs = [];
                    /**
                     * The most recently used styles for the builder
                     */
                    this.mru = {};
                    this.destroySubject = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
                    /**
                     * Cache map for style computation
                     */
                    this.styleCache = new Map();
                }
                Object.defineProperty(BaseDirective2.prototype, "parentElement", {
                    /**
                     * Access to host element's parent DOM node
                     * @protected
                     * @return {?}
                     */
                    get: function () {
                        return this.elementRef.nativeElement.parentElement;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BaseDirective2.prototype, "nativeElement", {
                    /**
                     * Access to the HTMLElement for the directive
                     * @protected
                     * @return {?}
                     */
                    get: function () {
                        return this.elementRef.nativeElement;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BaseDirective2.prototype, "activatedValue", {
                    /**
                     * Access to the activated value for the directive
                     * @return {?}
                     */
                    get: function () {
                        return this.marshal.getValue(this.nativeElement, this.DIRECTIVE_KEY);
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this.marshal.setValue(this.nativeElement, this.DIRECTIVE_KEY, value, this.marshal.activatedAlias);
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * For \@Input changes
                 * @param {?} changes
                 * @return {?}
                 */
                BaseDirective2.prototype.ngOnChanges = function (changes) {
                    var _this_1 = this;
                    Object.keys(changes).forEach(( /**
                     * @param {?} key
                     * @return {?}
                     */function (/**
                     * @param {?} key
                     * @return {?}
                     */ key) {
                        if (_this_1.inputs.indexOf(key) !== -1) {
                            /** @type {?} */
                            var bp = key.split('.').slice(1).join('.');
                            /** @type {?} */
                            var val = changes[key].currentValue;
                            _this_1.setValue(val, bp);
                        }
                    }));
                };
                /**
                 * @return {?}
                 */
                BaseDirective2.prototype.ngOnDestroy = function () {
                    this.destroySubject.next();
                    this.destroySubject.complete();
                    this.marshal.releaseElement(this.nativeElement);
                };
                /**
                 * Register with central marshaller service
                 * @protected
                 * @param {?=} extraTriggers
                 * @return {?}
                 */
                BaseDirective2.prototype.init = function (extraTriggers) {
                    if (extraTriggers === void 0) { extraTriggers = []; }
                    this.marshal.init(this.elementRef.nativeElement, this.DIRECTIVE_KEY, this.updateWithValue.bind(this), this.clearStyles.bind(this), extraTriggers);
                };
                /**
                 * Add styles to the element using predefined style builder
                 * @protected
                 * @param {?} input
                 * @param {?=} parent
                 * @return {?}
                 */
                BaseDirective2.prototype.addStyles = function (input, parent) {
                    /** @type {?} */
                    var builder = this.styleBuilder;
                    /** @type {?} */
                    var useCache = builder.shouldCache;
                    /** @type {?} */
                    var genStyles = this.styleCache.get(input);
                    if (!genStyles || !useCache) {
                        genStyles = builder.buildStyles(input, parent);
                        if (useCache) {
                            this.styleCache.set(input, genStyles);
                        }
                    }
                    this.mru = Object.assign({}, genStyles);
                    this.applyStyleToElement(genStyles);
                    builder.sideEffect(input, genStyles, parent);
                };
                /**
                 * Remove generated styles from an element using predefined style builder
                 * @protected
                 * @return {?}
                 */
                BaseDirective2.prototype.clearStyles = function () {
                    var _this_1 = this;
                    Object.keys(this.mru).forEach(( /**
                     * @param {?} k
                     * @return {?}
                     */function (/**
                     * @param {?} k
                     * @return {?}
                     */ k) {
                        _this_1.mru[k] = '';
                    }));
                    this.applyStyleToElement(this.mru);
                    this.mru = {};
                };
                /**
                 * Force trigger style updates on DOM element
                 * @protected
                 * @return {?}
                 */
                BaseDirective2.prototype.triggerUpdate = function () {
                    this.marshal.triggerUpdate(this.nativeElement, this.DIRECTIVE_KEY);
                };
                /**
                 * Determine the DOM element's Flexbox flow (flex-direction).
                 *
                 * Check inline style first then check computed (stylesheet) style.
                 * And optionally add the flow value to element's inline style.
                 * @protected
                 * @param {?} target
                 * @param {?=} addIfMissing
                 * @return {?}
                 */
                BaseDirective2.prototype.getFlexFlowDirection = function (target, addIfMissing) {
                    if (addIfMissing === void 0) { addIfMissing = false; }
                    if (target) {
                        var _a = this.styler.getFlowDirection(target), value = _a[0], hasInlineValue = _a[1];
                        if (!hasInlineValue && addIfMissing) {
                            /** @type {?} */
                            var style = buildLayoutCSS(value);
                            /** @type {?} */
                            var elements = [target];
                            this.styler.applyStyleToElements(style, elements);
                        }
                        return value.trim();
                    }
                    return 'row';
                };
                /**
                 * Applies styles given via string pair or object map to the directive element
                 * @protected
                 * @param {?} style
                 * @param {?=} value
                 * @param {?=} element
                 * @return {?}
                 */
                BaseDirective2.prototype.applyStyleToElement = function (style, value, element) {
                    if (element === void 0) { element = this.nativeElement; }
                    this.styler.applyStyleToElement(element, style, value);
                };
                /**
                 * @protected
                 * @param {?} val
                 * @param {?} bp
                 * @return {?}
                 */
                BaseDirective2.prototype.setValue = function (val, bp) {
                    this.marshal.setValue(this.nativeElement, this.DIRECTIVE_KEY, val, bp);
                };
                /**
                 * @protected
                 * @param {?} input
                 * @return {?}
                 */
                BaseDirective2.prototype.updateWithValue = function (input) {
                    this.addStyles(input);
                };
                return BaseDirective2;
            }());
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * NOTE: Smaller ranges have HIGHER priority since the match is more specific
             * @type {?}
             */
            var DEFAULT_BREAKPOINTS = [
                {
                    alias: 'xs',
                    mediaQuery: 'screen and (min-width: 0px) and (max-width: 599.9px)',
                    priority: 1000,
                },
                {
                    alias: 'sm',
                    mediaQuery: 'screen and (min-width: 600px) and (max-width: 959.9px)',
                    priority: 900,
                },
                {
                    alias: 'md',
                    mediaQuery: 'screen and (min-width: 960px) and (max-width: 1279.9px)',
                    priority: 800,
                },
                {
                    alias: 'lg',
                    mediaQuery: 'screen and (min-width: 1280px) and (max-width: 1919.9px)',
                    priority: 700,
                },
                {
                    alias: 'xl',
                    mediaQuery: 'screen and (min-width: 1920px) and (max-width: 4999.9px)',
                    priority: 600,
                },
                {
                    alias: 'lt-sm',
                    overlapping: true,
                    mediaQuery: 'screen and (max-width: 599.9px)',
                    priority: 950,
                },
                {
                    alias: 'lt-md',
                    overlapping: true,
                    mediaQuery: 'screen and (max-width: 959.9px)',
                    priority: 850,
                },
                {
                    alias: 'lt-lg',
                    overlapping: true,
                    mediaQuery: 'screen and (max-width: 1279.9px)',
                    priority: 750,
                },
                {
                    alias: 'lt-xl',
                    overlapping: true,
                    priority: 650,
                    mediaQuery: 'screen and (max-width: 1919.9px)',
                },
                {
                    alias: 'gt-xs',
                    overlapping: true,
                    mediaQuery: 'screen and (min-width: 600px)',
                    priority: -950,
                },
                {
                    alias: 'gt-sm',
                    overlapping: true,
                    mediaQuery: 'screen and (min-width: 960px)',
                    priority: -850,
                }, {
                    alias: 'gt-md',
                    overlapping: true,
                    mediaQuery: 'screen and (min-width: 1280px)',
                    priority: -750,
                },
                {
                    alias: 'gt-lg',
                    overlapping: true,
                    mediaQuery: 'screen and (min-width: 1920px)',
                    priority: -650,
                }
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /* tslint:disable */
            /** @type {?} */
            var HANDSET_PORTRAIT = '(orientation: portrait) and (max-width: 599.9px)';
            /** @type {?} */
            var HANDSET_LANDSCAPE = '(orientation: landscape) and (max-width: 959.9px)';
            /** @type {?} */
            var TABLET_PORTRAIT = '(orientation: portrait) and (min-width: 600px) and (max-width: 839.9px)';
            /** @type {?} */
            var TABLET_LANDSCAPE = '(orientation: landscape) and (min-width: 960px) and (max-width: 1279.9px)';
            /** @type {?} */
            var WEB_PORTRAIT = '(orientation: portrait) and (min-width: 840px)';
            /** @type {?} */
            var WEB_LANDSCAPE = '(orientation: landscape) and (min-width: 1280px)';
            /** @type {?} */
            var ScreenTypes = {
                'HANDSET': HANDSET_PORTRAIT + ", " + HANDSET_LANDSCAPE,
                'TABLET': TABLET_PORTRAIT + " , " + TABLET_LANDSCAPE,
                'WEB': WEB_PORTRAIT + ", " + WEB_LANDSCAPE + " ",
                'HANDSET_PORTRAIT': "" + HANDSET_PORTRAIT,
                'TABLET_PORTRAIT': TABLET_PORTRAIT + " ",
                'WEB_PORTRAIT': "" + WEB_PORTRAIT,
                'HANDSET_LANDSCAPE': HANDSET_LANDSCAPE + "]",
                'TABLET_LANDSCAPE': "" + TABLET_LANDSCAPE,
                'WEB_LANDSCAPE': "" + WEB_LANDSCAPE
            };
            /**
             * Extended Breakpoints for handset/tablets with landscape or portrait orientations
             * @type {?}
             */
            var ORIENTATION_BREAKPOINTS = [
                { 'alias': 'handset', priority: 2000, 'mediaQuery': ScreenTypes.HANDSET },
                { 'alias': 'handset.landscape', priority: 2000, 'mediaQuery': ScreenTypes.HANDSET_LANDSCAPE },
                { 'alias': 'handset.portrait', priority: 2000, 'mediaQuery': ScreenTypes.HANDSET_PORTRAIT },
                { 'alias': 'tablet', priority: 2100, 'mediaQuery': ScreenTypes.TABLET },
                { 'alias': 'tablet.landscape', priority: 2100, 'mediaQuery': ScreenTypes.TABLET },
                { 'alias': 'tablet.portrait', priority: 2100, 'mediaQuery': ScreenTypes.TABLET_PORTRAIT },
                { 'alias': 'web', priority: 2200, 'mediaQuery': ScreenTypes.WEB, overlapping: true },
                { 'alias': 'web.landscape', priority: 2200, 'mediaQuery': ScreenTypes.WEB_LANDSCAPE, overlapping: true },
                { 'alias': 'web.portrait', priority: 2200, 'mediaQuery': ScreenTypes.WEB_PORTRAIT, overlapping: true }
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Extends an object with the *enumerable* and *own* properties of one or more source objects,
             * similar to Object.assign.
             *
             * @param {?} dest The object which will have properties copied to it.
             * @param {...?} sources The source objects from which properties will be copied.
             * @return {?}
             */
            function extendObject(dest) {
                var sources = [];
                for (var _a = 1; _a < arguments.length; _a++) {
                    sources[_a - 1] = arguments[_a];
                }
                if (dest == null) {
                    throw TypeError('Cannot convert undefined or null to object');
                }
                for (var _b = 0, sources_1 = sources; _b < sources_1.length; _b++) {
                    var source = sources_1[_b];
                    if (source != null) {
                        for (var key in source) {
                            if (source.hasOwnProperty(key)) {
                                dest[key] = source[key];
                            }
                        }
                    }
                }
                return dest;
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var ALIAS_DELIMITERS = /(\.|-|_)/g;
            /**
             * @param {?} part
             * @return {?}
             */
            function firstUpperCase(part) {
                /** @type {?} */
                var first = part.length > 0 ? part.charAt(0) : '';
                /** @type {?} */
                var remainder = (part.length > 1) ? part.slice(1) : '';
                return first.toUpperCase() + remainder;
            }
            /**
             * Converts snake-case to SnakeCase.
             * @param {?} name Text to UpperCamelCase
             * @return {?}
             */
            function camelCase(name) {
                return name
                    .replace(ALIAS_DELIMITERS, '|')
                    .split('|')
                    .map(firstUpperCase)
                    .join('');
            }
            /**
             * For each breakpoint, ensure that a Suffix is defined;
             * fallback to UpperCamelCase the unique Alias value
             * @param {?} list
             * @return {?}
             */
            function validateSuffixes(list) {
                list.forEach(( /**
                 * @param {?} bp
                 * @return {?}
                 */function (bp) {
                    if (!bp.suffix) {
                        bp.suffix = camelCase(bp.alias); // create Suffix value based on alias
                        bp.overlapping = !!bp.overlapping; // ensure default value
                    }
                }));
                return list;
            }
            /**
             * Merge a custom breakpoint list with the default list based on unique alias values
             *  - Items are added if the alias is not in the default list
             *  - Items are merged with the custom override if the alias exists in the default list
             * @param {?} defaults
             * @param {?=} custom
             * @return {?}
             */
            function mergeByAlias(defaults, custom) {
                if (custom === void 0) { custom = []; }
                /** @type {?} */
                var dict = {};
                defaults.forEach(( /**
                 * @param {?} bp
                 * @return {?}
                 */function (/**
                 * @param {?} bp
                 * @return {?}
                 */ bp) {
                    dict[bp.alias] = bp;
                }));
                // Merge custom breakpoints
                custom.forEach(( /**
                 * @param {?} bp
                 * @return {?}
                 */function (bp) {
                    if (dict[bp.alias]) {
                        extendObject(dict[bp.alias], bp);
                    }
                    else {
                        dict[bp.alias] = bp;
                    }
                }));
                return validateSuffixes(Object.keys(dict).map(( /**
                 * @param {?} k
                 * @return {?}
                 */function (/**
                 * @param {?} k
                 * @return {?}
                 */ k) { return dict[k]; })));
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             *  Injection token unique to the flex-layout library.
             *  Use this token when build a custom provider (see below).
             * @type {?}
             */
            var BREAKPOINTS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('Token (@angular/flex-layout) Breakpoints', {
                providedIn: 'root',
                factory: ( /**
                 * @return {?}
                 */function () {
                    /** @type {?} */
                    var breakpoints = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["inject"])(BREAKPOINT);
                    /** @type {?} */
                    var layoutConfig = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["inject"])(LAYOUT_CONFIG);
                    /** @type {?} */
                    var bpFlattenArray = [].concat.apply([], (breakpoints || [])
                        .map(( /**
                 * @param {?} v
                 * @return {?}
                 */function (v) { return Array.isArray(v) ? v : [v]; })));
                    /** @type {?} */
                    var builtIns = (layoutConfig.disableDefaultBps ? [] : DEFAULT_BREAKPOINTS)
                        .concat(layoutConfig.addOrientationBps ? ORIENTATION_BREAKPOINTS : []);
                    return mergeByAlias(builtIns, bpFlattenArray);
                })
            });
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * HOF to sort the breakpoints by descending priority
             * @template T
             * @param {?} a
             * @param {?} b
             * @return {?}
             */
            function sortDescendingPriority(a, b) {
                /** @type {?} */
                var priorityA = a ? a.priority || 0 : 0;
                /** @type {?} */
                var priorityB = b ? b.priority || 0 : 0;
                return priorityB - priorityA;
            }
            /**
             * HOF to sort the breakpoints by ascending priority
             * @template T
             * @param {?} a
             * @param {?} b
             * @return {?}
             */
            function sortAscendingPriority(a, b) {
                /** @type {?} */
                var pA = a.priority || 0;
                /** @type {?} */
                var pB = b.priority || 0;
                return pA - pB;
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Registry of 1..n MediaQuery breakpoint ranges
             * This is published as a provider and may be overridden from custom, application-specific ranges
             *
             */
            var BreakPointRegistry = /** @class */ (function () {
                /**
                 * @param {?} list
                 */
                function BreakPointRegistry(list) {
                    /**
                     * Memoized BreakPoint Lookups
                     */
                    this.findByMap = new Map();
                    this.items = list.slice().sort(sortAscendingPriority);
                }
                /**
                 * Search breakpoints by alias (e.g. gt-xs)
                 * @param {?} alias
                 * @return {?}
                 */
                BreakPointRegistry.prototype.findByAlias = function (alias) {
                    return !alias ? null : this.findWithPredicate(alias, ( /**
                     * @param {?} bp
                     * @return {?}
                     */function (bp) { return bp.alias == alias; }));
                };
                /**
                 * @param {?} query
                 * @return {?}
                 */
                BreakPointRegistry.prototype.findByQuery = function (query) {
                    return this.findWithPredicate(query, ( /**
                     * @param {?} bp
                     * @return {?}
                     */function (bp) { return bp.mediaQuery == query; }));
                };
                Object.defineProperty(BreakPointRegistry.prototype, "overlappings", {
                    /**
                     * Get all the breakpoints whose ranges could overlapping `normal` ranges;
                     * e.g. gt-sm overlaps md, lg, and xl
                     * @return {?}
                     */
                    get: function () {
                        return this.items.filter(( /**
                         * @param {?} it
                         * @return {?}
                         */function (/**
                         * @param {?} it
                         * @return {?}
                         */ it) { return it.overlapping == true; }));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BreakPointRegistry.prototype, "aliases", {
                    /**
                     * Get list of all registered (non-empty) breakpoint aliases
                     * @return {?}
                     */
                    get: function () {
                        return this.items.map(( /**
                         * @param {?} it
                         * @return {?}
                         */function (/**
                         * @param {?} it
                         * @return {?}
                         */ it) { return it.alias; }));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BreakPointRegistry.prototype, "suffixes", {
                    /**
                     * Aliases are mapped to properties using suffixes
                     * e.g.  'gt-sm' for property 'layout'  uses suffix 'GtSm'
                     * for property layoutGtSM.
                     * @return {?}
                     */
                    get: function () {
                        return this.items.map(( /**
                         * @param {?} it
                         * @return {?}
                         */function (/**
                         * @param {?} it
                         * @return {?}
                         */ it) { return !!it.suffix ? it.suffix : ''; }));
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Memoized lookup using custom predicate function
                 * @private
                 * @param {?} key
                 * @param {?} searchFn
                 * @return {?}
                 */
                BreakPointRegistry.prototype.findWithPredicate = function (key, searchFn) {
                    /** @type {?} */
                    var response = this.findByMap.get(key);
                    if (!response) {
                        response = this.items.find(searchFn) || null;
                        this.findByMap.set(key, response);
                    }
                    return response || null;
                };
                return BreakPointRegistry;
            }());
            BreakPointRegistry.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */
            BreakPointRegistry.ctorParameters = function () { return [
                { type: Array, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [BREAKPOINTS,] }] }
            ]; };
            /** @nocollapse */ BreakPointRegistry.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function BreakPointRegistry_Factory() { return new BreakPointRegistry(Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(BREAKPOINTS)); }, token: BreakPointRegistry, providedIn: "root" });
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * MediaMonitor configures listeners to mediaQuery changes and publishes an Observable facade to
             * convert mediaQuery change callbacks to subscriber notifications. These notifications will be
             * performed within the ng Zone to trigger change detections and component updates.
             *
             * NOTE: both mediaQuery activations and de-activations are announced in notifications
             */
            var MatchMedia = /** @class */ (function () {
                /**
                 * @param {?} _zone
                 * @param {?} _platformId
                 * @param {?} _document
                 */
                function MatchMedia(_zone, _platformId, _document) {
                    this._zone = _zone;
                    this._platformId = _platformId;
                    this._document = _document;
                    /**
                     * Initialize source with 'all' so all non-responsive APIs trigger style updates
                     */
                    this.source = new rxjs__WEBPACK_IMPORTED_MODULE_2__["BehaviorSubject"](new MediaChange(true));
                    this.registry = new Map();
                    this._observable$ = this.source.asObservable();
                }
                Object.defineProperty(MatchMedia.prototype, "activations", {
                    /**
                     * Publish list of all current activations
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var results = [];
                        this.registry.forEach(( /**
                         * @param {?} mql
                         * @param {?} key
                         * @return {?}
                         */function (mql, key) {
                            if (mql.matches) {
                                results.push(key);
                            }
                        }));
                        return results;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * For the specified mediaQuery?
                 * @param {?} mediaQuery
                 * @return {?}
                 */
                MatchMedia.prototype.isActive = function (mediaQuery) {
                    /** @type {?} */
                    var mql = this.registry.get(mediaQuery);
                    return !!mql ? mql.matches : false;
                };
                /**
                 * External observers can watch for all (or a specific) mql changes.
                 * Typically used by the MediaQueryAdaptor; optionally available to components
                 * who wish to use the MediaMonitor as mediaMonitor$ observable service.
                 *
                 * Use deferred registration process to register breakpoints only on subscription
                 * This logic also enforces logic to register all mediaQueries BEFORE notify
                 * subscribers of notifications.
                 * @param {?=} mqList
                 * @param {?=} filterOthers
                 * @return {?}
                 */
                MatchMedia.prototype.observe = function (mqList, filterOthers) {
                    var _this_1 = this;
                    if (filterOthers === void 0) { filterOthers = false; }
                    if (mqList && mqList.length) {
                        /** @type {?} */
                        var matchMedia$ = this._observable$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["filter"])(( /**
                         * @param {?} change
                         * @return {?}
                         */function (change) {
                            return !filterOthers ? true : (mqList.indexOf(change.mediaQuery) > -1);
                        })));
                        /** @type {?} */
                        var registration$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Observable"](( /**
                         * @param {?} observer
                         * @return {?}
                         */function (observer) {
                            // tslint:disable-line:max-line-length
                            /** @type {?} */
                            var matches = _this_1.registerQuery(mqList);
                            if (matches.length) {
                                /** @type {?} */
                                var lastChange = ( /** @type {?} */(matches.pop()));
                                matches.forEach(( /**
                                 * @param {?} e
                                 * @return {?}
                                 */function (e) {
                                    observer.next(e);
                                }));
                                _this_1.source.next(lastChange); // last match is cached
                            }
                            observer.complete();
                        }));
                        return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["merge"])(registration$, matchMedia$);
                    }
                    return this._observable$;
                };
                /**
                 * Based on the BreakPointRegistry provider, register internal listeners for each unique
                 * mediaQuery. Each listener emits specific MediaChange data to observers
                 * @param {?} mediaQuery
                 * @return {?}
                 */
                MatchMedia.prototype.registerQuery = function (mediaQuery) {
                    var _this_1 = this;
                    /** @type {?} */
                    var list = Array.isArray(mediaQuery) ? mediaQuery : [mediaQuery];
                    /** @type {?} */
                    var matches = [];
                    buildQueryCss(list, this._document);
                    list.forEach(( /**
                     * @param {?} query
                     * @return {?}
                     */function (query) {
                        /** @type {?} */
                        var onMQLEvent = ( /**
                         * @param {?} e
                         * @return {?}
                         */function (e) {
                            _this_1._zone.run(( /**
                             * @return {?}
                             */function () { return _this_1.source.next(new MediaChange(e.matches, query)); }));
                        });
                        /** @type {?} */
                        var mql = _this_1.registry.get(query);
                        if (!mql) {
                            mql = _this_1.buildMQL(query);
                            mql.addListener(onMQLEvent);
                            _this_1.registry.set(query, mql);
                        }
                        if (mql.matches) {
                            matches.push(new MediaChange(true, query));
                        }
                    }));
                    return matches;
                };
                /**
                 * Call window.matchMedia() to build a MediaQueryList; which
                 * supports 0..n listeners for activation/deactivation
                 * @protected
                 * @param {?} query
                 * @return {?}
                 */
                MatchMedia.prototype.buildMQL = function (query) {
                    return constructMql(query, Object(_angular_common__WEBPACK_IMPORTED_MODULE_1__["isPlatformBrowser"])(this._platformId));
                };
                return MatchMedia;
            }());
            MatchMedia.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */
            MatchMedia.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] },
                { type: Object, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["PLATFORM_ID"],] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["DOCUMENT"],] }] }
            ]; };
            /** @nocollapse */ MatchMedia.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function MatchMedia_Factory() { return new MatchMedia(Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_0__["PLATFORM_ID"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_common__WEBPACK_IMPORTED_MODULE_1__["DOCUMENT"])); }, token: MatchMedia, providedIn: "root" });
            /**
             * Private global registry for all dynamically-created, injected style tags
             * @see prepare(query)
             * @type {?}
             */
            var ALL_STYLES = {};
            /**
             * For Webkit engines that only trigger the MediaQueryList Listener
             * when there is at least one CSS selector for the respective media query.
             *
             * @param {?} mediaQueries
             * @param {?} _document
             * @return {?}
             */
            function buildQueryCss(mediaQueries, _document) {
                /** @type {?} */
                var list = mediaQueries.filter(( /**
                 * @param {?} it
                 * @return {?}
                 */function (/**
                 * @param {?} it
                 * @return {?}
                 */ it) { return !ALL_STYLES[it]; }));
                if (list.length > 0) {
                    /** @type {?} */
                    var query = list.join(', ');
                    try {
                        /** @type {?} */
                        var styleEl_1 = _document.createElement('style');
                        styleEl_1.setAttribute('type', 'text/css');
                        if (!(( /** @type {?} */(styleEl_1))).styleSheet) {
                            /** @type {?} */
                            var cssText = "\n/*\n  @angular/flex-layout - workaround for possible browser quirk with mediaQuery listeners\n  see http://bit.ly/2sd4HMP\n*/\n@media " + query + " {.fx-query-test{ }}\n";
                            styleEl_1.appendChild(_document.createTextNode(cssText));
                        }
                        ( /** @type {?} */(_document.head)).appendChild(styleEl_1);
                        // Store in private global registry
                        list.forEach(( /**
                         * @param {?} mq
                         * @return {?}
                         */function (/**
                         * @param {?} mq
                         * @return {?}
                         */ mq) { return ALL_STYLES[mq] = styleEl_1; }));
                    }
                    catch (e) {
                        console.error(e);
                    }
                }
            }
            /**
             * @param {?} query
             * @param {?} isBrowser
             * @return {?}
             */
            function constructMql(query, isBrowser) {
                /** @type {?} */
                var canListen = isBrowser && !!(( /** @type {?} */(window))).matchMedia('all').addListener;
                return canListen ? (( /** @type {?} */(window))).matchMedia(query) : ( /** @type {?} */(( /** @type {?} */({
                    matches: query === 'all' || query === '',
                    media: query,
                    addListener: ( /**
                     * @return {?}
                     */function () {
                    }),
                    removeListener: ( /**
                     * @return {?}
                     */function () {
                    })
                }))));
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * MockMatchMedia mocks calls to the Window API matchMedia with a build of a simulated
             * MockMediaQueryListener. Methods are available to simulate an activation of a mediaQuery
             * range and to clearAll mediaQuery listeners.
             */
            var MockMatchMedia = /** @class */ (function (_super) {
                __extends(MockMatchMedia, _super);
                // Allow fallback to overlapping mediaQueries
                /**
                 * @param {?} _zone
                 * @param {?} _platformId
                 * @param {?} _document
                 * @param {?} _breakpoints
                 */
                function MockMatchMedia(_zone, _platformId, _document, _breakpoints) {
                    var _this_1 = _super.call(this, _zone, _platformId, _document) || this;
                    _this_1._breakpoints = _breakpoints;
                    _this_1.autoRegisterQueries = true; // Used for testing BreakPoint registrations
                    // Used for testing BreakPoint registrations
                    _this_1.useOverlaps = false; // Allow fallback to overlapping mediaQueries
                    return _this_1;
                }
                /**
                 * Easy method to clear all listeners for all mediaQueries
                 * @return {?}
                 */
                MockMatchMedia.prototype.clearAll = function () {
                    this.registry.forEach(( /**
                     * @param {?} mql
                     * @return {?}
                     */function (mql) {
                        (( /** @type {?} */(mql))).destroy();
                    }));
                    this.registry.clear();
                    this.useOverlaps = false;
                };
                /**
                 * Feature to support manual, simulated activation of a mediaQuery.
                 * @param {?} mediaQuery
                 * @param {?=} useOverlaps
                 * @return {?}
                 */
                MockMatchMedia.prototype.activate = function (mediaQuery, useOverlaps) {
                    if (useOverlaps === void 0) { useOverlaps = false; }
                    useOverlaps = useOverlaps || this.useOverlaps;
                    mediaQuery = this._validateQuery(mediaQuery);
                    if (useOverlaps || !this.isActive(mediaQuery)) {
                        this._deactivateAll();
                        this._registerMediaQuery(mediaQuery);
                        this._activateWithOverlaps(mediaQuery, useOverlaps);
                    }
                    return this.hasActivated;
                };
                /**
                 * Converts an optional mediaQuery alias to a specific, valid mediaQuery
                 * @param {?} queryOrAlias
                 * @return {?}
                 */
                MockMatchMedia.prototype._validateQuery = function (queryOrAlias) {
                    /** @type {?} */
                    var bp = this._breakpoints.findByAlias(queryOrAlias);
                    return (bp && bp.mediaQuery) || queryOrAlias;
                };
                /**
                 * Manually onMediaChange any overlapping mediaQueries to simulate
                 * similar functionality in the window.matchMedia()
                 * @private
                 * @param {?} mediaQuery
                 * @param {?} useOverlaps
                 * @return {?}
                 */
                MockMatchMedia.prototype._activateWithOverlaps = function (mediaQuery, useOverlaps) {
                    if (useOverlaps) {
                        /** @type {?} */
                        var bp = this._breakpoints.findByQuery(mediaQuery);
                        /** @type {?} */
                        var alias = bp ? bp.alias : 'unknown';
                        // Simulate activation of overlapping lt-<XXX> ranges
                        switch (alias) {
                            case 'lg':
                                this._activateByAlias('lt-xl');
                                break;
                            case 'md':
                                this._activateByAlias('lt-xl, lt-lg');
                                break;
                            case 'sm':
                                this._activateByAlias('lt-xl, lt-lg, lt-md');
                                break;
                            case 'xs':
                                this._activateByAlias('lt-xl, lt-lg, lt-md, lt-sm');
                                break;
                        }
                        // Simulate activation of overlapping gt-<xxxx> mediaQuery ranges
                        switch (alias) {
                            case 'xl':
                                this._activateByAlias('gt-lg, gt-md, gt-sm, gt-xs');
                                break;
                            case 'lg':
                                this._activateByAlias('gt-md, gt-sm, gt-xs');
                                break;
                            case 'md':
                                this._activateByAlias('gt-sm, gt-xs');
                                break;
                            case 'sm':
                                this._activateByAlias('gt-xs');
                                break;
                        }
                    }
                    // Activate last since the responsiveActivation is watching *this* mediaQuery
                    return this._activateByQuery(mediaQuery);
                };
                /**
                 *
                 * @private
                 * @param {?} aliases
                 * @return {?}
                 */
                MockMatchMedia.prototype._activateByAlias = function (aliases) {
                    var _this_1 = this;
                    /** @type {?} */
                    var activate = ( /**
                     * @param {?} alias
                     * @return {?}
                     */function (alias) {
                        /** @type {?} */
                        var bp = _this_1._breakpoints.findByAlias(alias);
                        _this_1._activateByQuery(bp ? bp.mediaQuery : alias);
                    });
                    aliases.split(',').forEach(( /**
                     * @param {?} alias
                     * @return {?}
                     */function (/**
                     * @param {?} alias
                     * @return {?}
                     */ alias) { return activate(alias.trim()); }));
                };
                /**
                 *
                 * @private
                 * @param {?} mediaQuery
                 * @return {?}
                 */
                MockMatchMedia.prototype._activateByQuery = function (mediaQuery) {
                    /** @type {?} */
                    var mql = ( /** @type {?} */(this.registry.get(mediaQuery)));
                    if (mql && !this.isActive(mediaQuery)) {
                        this.registry.set(mediaQuery, mql.activate());
                    }
                    return this.hasActivated;
                };
                /**
                 * Deactivate all current MQLs and reset the buffer
                 * @private
                 * @template THIS
                 * @this {THIS}
                 * @return {THIS}
                 */
                MockMatchMedia.prototype._deactivateAll = function () {
                    ( /** @type {?} */(this)).registry.forEach(( /**
                     * @param {?} it
                     * @return {?}
                     */function (it) {
                        (( /** @type {?} */(it))).deactivate();
                    }));
                    return ( /** @type {?} */(this));
                };
                /**
                 * Insure the mediaQuery is registered with MatchMedia
                 * @private
                 * @param {?} mediaQuery
                 * @return {?}
                 */
                MockMatchMedia.prototype._registerMediaQuery = function (mediaQuery) {
                    if (!this.registry.has(mediaQuery) && this.autoRegisterQueries) {
                        this.registerQuery(mediaQuery);
                    }
                };
                /**
                 * Call window.matchMedia() to build a MediaQueryList; which
                 * supports 0..n listeners for activation/deactivation
                 * @protected
                 * @param {?} query
                 * @return {?}
                 */
                MockMatchMedia.prototype.buildMQL = function (query) {
                    return new MockMediaQueryList(query);
                };
                Object.defineProperty(MockMatchMedia.prototype, "hasActivated", {
                    /**
                     * @protected
                     * @return {?}
                     */
                    get: function () {
                        return this.activations.length > 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                return MockMatchMedia;
            }(MatchMedia));
            MockMatchMedia.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"] },
            ];
            /** @nocollapse */
            MockMatchMedia.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] },
                { type: Object, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["PLATFORM_ID"],] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["DOCUMENT"],] }] },
                { type: BreakPointRegistry }
            ]; };
            /**
             * Special internal class to simulate a MediaQueryList and
             * - supports manual activation to simulate mediaQuery matching
             * - manages listeners
             */
            var MockMediaQueryList = /** @class */ (function () {
                /**
                 * @param {?} _mediaQuery
                 */
                function MockMediaQueryList(_mediaQuery) {
                    this._mediaQuery = _mediaQuery;
                    this._isActive = false;
                    this._listeners = [];
                    this.onchange = null;
                }
                Object.defineProperty(MockMediaQueryList.prototype, "matches", {
                    /**
                     * @return {?}
                     */
                    get: function () {
                        return this._isActive;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MockMediaQueryList.prototype, "media", {
                    /**
                     * @return {?}
                     */
                    get: function () {
                        return this._mediaQuery;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Destroy the current list by deactivating the
                 * listeners and clearing the internal list
                 * @return {?}
                 */
                MockMediaQueryList.prototype.destroy = function () {
                    this.deactivate();
                    this._listeners = [];
                };
                /**
                 * Notify all listeners that 'matches === TRUE'
                 * @return {?}
                 */
                MockMediaQueryList.prototype.activate = function () {
                    var _this_1 = this;
                    if (!this._isActive) {
                        this._isActive = true;
                        this._listeners.forEach(( /**
                         * @param {?} callback
                         * @return {?}
                         */function (callback) {
                            /** @type {?} */
                            var cb = ( /** @type {?} */(callback));
                            cb.call(null, _this_1);
                        }));
                    }
                    return this;
                };
                /**
                 * Notify all listeners that 'matches === false'
                 * @return {?}
                 */
                MockMediaQueryList.prototype.deactivate = function () {
                    var _this_1 = this;
                    if (this._isActive) {
                        this._isActive = false;
                        this._listeners.forEach(( /**
                         * @param {?} callback
                         * @return {?}
                         */function (callback) {
                            /** @type {?} */
                            var cb = ( /** @type {?} */(callback));
                            cb.call(null, _this_1);
                        }));
                    }
                    return this;
                };
                /**
                 * Add a listener to our internal list to activate later
                 * @param {?} listener
                 * @return {?}
                 */
                MockMediaQueryList.prototype.addListener = function (listener) {
                    if (this._listeners.indexOf(listener) === -1) {
                        this._listeners.push(listener);
                    }
                    if (this._isActive) {
                        /** @type {?} */
                        var cb = ( /** @type {?} */(listener));
                        cb.call(null, this);
                    }
                };
                /**
                 * Don't need to remove listeners in the testing environment
                 * @param {?} _
                 * @return {?}
                 */
                MockMediaQueryList.prototype.removeListener = function (_) {
                };
                /**
                 * @param {?} _
                 * @param {?} __
                 * @param {?=} ___
                 * @return {?}
                 */
                MockMediaQueryList.prototype.addEventListener = function (_, __, ___) {
                };
                /**
                 * @param {?} _
                 * @param {?} __
                 * @param {?=} ___
                 * @return {?}
                 */
                MockMediaQueryList.prototype.removeEventListener = function (_, __, ___) {
                };
                /**
                 * @param {?} _
                 * @return {?}
                 */
                MockMediaQueryList.prototype.dispatchEvent = function (_) {
                    return false;
                };
                return MockMediaQueryList;
            }());
            /**
             * Pre-configured provider for MockMatchMedia
             * @type {?}
             */
            var MockMatchMediaProvider = {
                // tslint:disable-line:variable-name
                provide: MatchMedia,
                useClass: MockMatchMedia
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var PRINT = 'print';
            /** @type {?} */
            var BREAKPOINT_PRINT = {
                alias: PRINT,
                mediaQuery: PRINT,
                priority: 1000
            };
            /**
             * PrintHook - Use to intercept print MediaQuery activations and force
             *             layouts to render with the specified print alias/breakpoint
             *
             * Used in MediaMarshaller and MediaObserver
             */
            var PrintHook = /** @class */ (function () {
                /**
                 * @param {?} breakpoints
                 * @param {?} layoutConfig
                 */
                function PrintHook(breakpoints, layoutConfig) {
                    this.breakpoints = breakpoints;
                    this.layoutConfig = layoutConfig;
                    /**
                     * Is this service currently in Print-mode ?
                     */
                    this.isPrinting = false;
                    this.queue = new PrintQueue();
                    this.deactivations = [];
                }
                /**
                 * Add 'print' mediaQuery: to listen for matchMedia activations
                 * @param {?} queries
                 * @return {?}
                 */
                PrintHook.prototype.withPrintQuery = function (queries) {
                    return queries.concat([PRINT]);
                };
                /**
                 * Is the MediaChange event for any 'print' \@media
                 * @param {?} e
                 * @return {?}
                 */
                PrintHook.prototype.isPrintEvent = function (e) {
                    return e.mediaQuery.startsWith(PRINT);
                };
                Object.defineProperty(PrintHook.prototype, "printAlias", {
                    /**
                     * What is the desired mqAlias to use while printing?
                     * @return {?}
                     */
                    get: function () {
                        return this.layoutConfig.printWithBreakpoints || [];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(PrintHook.prototype, "printBreakPoints", {
                    /**
                     * Lookup breakpoints associated with print aliases.
                     * @return {?}
                     */
                    get: function () {
                        var _this_1 = this;
                        return ( /** @type {?} */(this.printAlias
                            .map(( /**
                     * @param {?} alias
                     * @return {?}
                     */function (/**
                     * @param {?} alias
                     * @return {?}
                     */ alias) { return _this_1.breakpoints.findByAlias(alias); }))
                            .filter(( /**
                     * @param {?} bp
                     * @return {?}
                     */function (/**
                     * @param {?} bp
                     * @return {?}
                     */ bp) { return bp !== null; }))));
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Lookup breakpoint associated with mediaQuery
                 * @param {?} __0
                 * @return {?}
                 */
                PrintHook.prototype.getEventBreakpoints = function (_a) {
                    var mediaQuery = _a.mediaQuery;
                    /** @type {?} */
                    var bp = this.breakpoints.findByQuery(mediaQuery);
                    /** @type {?} */
                    var list = bp ? this.printBreakPoints.concat([bp]) : this.printBreakPoints;
                    return list.sort(sortDescendingPriority);
                };
                /**
                 * Update event with printAlias mediaQuery information
                 * @param {?} event
                 * @return {?}
                 */
                PrintHook.prototype.updateEvent = function (event) {
                    /** @type {?} */
                    var bp = this.breakpoints.findByQuery(event.mediaQuery);
                    if (this.isPrintEvent(event)) {
                        // Reset from 'print' to first (highest priority) print breakpoint
                        bp = this.getEventBreakpoints(event)[0];
                        event.mediaQuery = bp ? bp.mediaQuery : '';
                    }
                    return mergeAlias(event, bp);
                };
                /**
                 * Prepare RxJs filter operator with partial application
                 * @param {?} target
                 * @return {?} pipeable filter predicate
                 */
                PrintHook.prototype.interceptEvents = function (target) {
                    var _this_1 = this;
                    return ( /**
                     * @param {?} event
                     * @return {?}
                     */function (event) {
                        if (_this_1.isPrintEvent(event)) {
                            if (event.matches && !_this_1.isPrinting) {
                                _this_1.startPrinting(target, _this_1.getEventBreakpoints(event));
                                target.updateStyles();
                            }
                            else if (!event.matches && _this_1.isPrinting) {
                                _this_1.stopPrinting(target);
                                target.updateStyles();
                            }
                        }
                        else {
                            _this_1.collectActivations(event);
                        }
                    });
                };
                /**
                 * Stop mediaChange event propagation in event streams
                 * @return {?}
                 */
                PrintHook.prototype.blockPropagation = function () {
                    var _this_1 = this;
                    return ( /**
                     * @param {?} event
                     * @return {?}
                     */function (event) {
                        return !(_this_1.isPrinting || _this_1.isPrintEvent(event));
                    });
                };
                /**
                 * Save current activateBreakpoints (for later restore)
                 * and substitute only the printAlias breakpoint
                 * @protected
                 * @param {?} target
                 * @param {?} bpList
                 * @return {?}
                 */
                PrintHook.prototype.startPrinting = function (target, bpList) {
                    this.isPrinting = true;
                    target.activatedBreakpoints = this.queue.addPrintBreakpoints(bpList);
                };
                /**
                 * For any print de-activations, reset the entire print queue
                 * @protected
                 * @param {?} target
                 * @return {?}
                 */
                PrintHook.prototype.stopPrinting = function (target) {
                    target.activatedBreakpoints = this.deactivations;
                    this.deactivations = [];
                    this.queue.clear();
                    this.isPrinting = false;
                };
                /**
                 * To restore pre-Print Activations, we must capture the proper
                 * list of breakpoint activations BEFORE print starts. OnBeforePrint()
                 * is not supported; so 'print' mediaQuery activations must be used.
                 *
                 * >  But activated breakpoints are deactivated BEFORE 'print' activation.
                 *
                 * Let's capture all de-activations using the following logic:
                 *
                 *  When not printing:
                 *    - clear cache when activating non-print breakpoint
                 *    - update cache (and sort) when deactivating
                 *
                 *  When printing:
                 *    - sort and save when starting print
                 *    - restore as activatedTargets and clear when stop printing
                 * @param {?} event
                 * @return {?}
                 */
                PrintHook.prototype.collectActivations = function (event) {
                    if (!this.isPrinting) {
                        if (!event.matches) {
                            /** @type {?} */
                            var bp = this.breakpoints.findByQuery(event.mediaQuery);
                            if (bp) { // Deactivating a breakpoint
                                this.deactivations.push(bp);
                                this.deactivations.sort(sortDescendingPriority);
                            }
                        }
                        else {
                            this.deactivations = [];
                        }
                    }
                };
                return PrintHook;
            }());
            PrintHook.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */
            PrintHook.ctorParameters = function () { return [
                { type: BreakPointRegistry },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [LAYOUT_CONFIG,] }] }
            ]; };
            /** @nocollapse */ PrintHook.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function PrintHook_Factory() { return new PrintHook(Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(BreakPointRegistry), Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(LAYOUT_CONFIG)); }, token: PrintHook, providedIn: "root" });
            // ************************************************************************
            // Internal Utility class 'PrintQueue'
            // ************************************************************************
            /**
             * Utility class to manage print breakpoints + activatedBreakpoints
             * with correct sorting WHILE printing
             */
            var PrintQueue = /** @class */ (function () {
                function PrintQueue() {
                    /**
                     * Sorted queue with prioritized print breakpoints
                     */
                    this.printBreakpoints = [];
                }
                /**
                 * @param {?} bpList
                 * @return {?}
                 */
                PrintQueue.prototype.addPrintBreakpoints = function (bpList) {
                    var _this_1 = this;
                    bpList.push(BREAKPOINT_PRINT);
                    bpList.sort(sortDescendingPriority);
                    bpList.forEach(( /**
                     * @param {?} bp
                     * @return {?}
                     */function (/**
                     * @param {?} bp
                     * @return {?}
                     */ bp) { return _this_1.addBreakpoint(bp); }));
                    return this.printBreakpoints;
                };
                /**
                 * Add Print breakpoint to queue
                 * @param {?} bp
                 * @return {?}
                 */
                PrintQueue.prototype.addBreakpoint = function (bp) {
                    if (!!bp) {
                        /** @type {?} */
                        var bpInList = this.printBreakpoints.find(( /**
                         * @param {?} it
                         * @return {?}
                         */function (/**
                         * @param {?} it
                         * @return {?}
                         */ it) { return it.mediaQuery === bp.mediaQuery; }));
                        if (bpInList === undefined) {
                            // If this is a `printAlias` breakpoint, then append. If a true 'print' breakpoint,
                            // register as highest priority in the queue
                            this.printBreakpoints = isPrintBreakPoint(bp) ? [bp].concat(this.printBreakpoints) : this.printBreakpoints.concat([bp]);
                        }
                    }
                };
                /**
                 * Restore original activated breakpoints and clear internal caches
                 * @return {?}
                 */
                PrintQueue.prototype.clear = function () {
                    this.printBreakpoints = [];
                };
                return PrintQueue;
            }());
            // ************************************************************************
            // Internal Utility methods
            // ************************************************************************
            /**
             * Only support intercept queueing if the Breakpoint is a print \@media query
             * @param {?} bp
             * @return {?}
             */
            function isPrintBreakPoint(bp) {
                return bp ? bp.mediaQuery.startsWith(PRINT) : false;
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Wraps the provided value in an array, unless the provided value is an array.
             * @template T
             * @param {?} value
             * @return {?}
             */
            function coerceArray(value) {
                return Array.isArray(value) ? value : [value];
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * MediaObserver enables applications to listen for 1..n mediaQuery activations and to determine
             * if a mediaQuery is currently activated.
             *
             * Since a breakpoint change will first deactivate 1...n mediaQueries and then possibly activate
             * 1..n mediaQueries, the MediaObserver will debounce notifications and report ALL *activations*
             * in 1 event notification. The reported activations will be sorted in descending priority order.
             *
             * This class uses the BreakPoint Registry to inject alias information into the raw MediaChange
             * notification. For custom mediaQuery notifications, alias information will not be injected and
             * those fields will be ''.
             *
             * Note: Developers should note that only mediaChange activations (not de-activations)
             *       are announced by the MediaObserver.
             *
             * \@usage
             *
             *  // RxJS
             *  import { filter } from 'rxjs/operators';
             *  import { MediaObserver } from '\@angular/flex-layout';
             *
             * \@Component({ ... })
             *  export class AppComponent {
             *    status: string = '';
             *
             *    constructor(mediaObserver: MediaObserver) {
             *      const media$ = mediaObserver.asObservable().pipe(
             *        filter((changes: MediaChange[]) => true)   // silly noop filter
             *      );
             *
             *      media$.subscribe((changes: MediaChange[]) => {
             *        let status = '';
             *        changes.forEach( change => {
             *          status += `'${change.mqAlias}' = (${change.mediaQuery}) <br/>` ;
             *        });
             *        this.status = status;
             *     });
             *
             *    }
             *  }
             */
            var MediaObserver = /** @class */ (function () {
                /**
                 * @param {?} breakpoints
                 * @param {?} matchMedia
                 * @param {?} hook
                 */
                function MediaObserver(breakpoints, matchMedia, hook) {
                    this.breakpoints = breakpoints;
                    this.matchMedia = matchMedia;
                    this.hook = hook;
                    /**
                     * Filter MediaChange notifications for overlapping breakpoints
                     */
                    this.filterOverlaps = false;
                    this.destroyed$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
                    this._media$ = this.watchActivations();
                    this.media$ = this._media$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["filter"])(( /**
                     * @param {?} changes
                     * @return {?}
                     */function (changes) { return changes.length > 0; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(( /**
                     * @param {?} changes
                     * @return {?}
                     */function (changes) { return changes[0]; })));
                }
                /**
                 * Completes the active subject, signalling to all complete for all
                 * MediaObserver subscribers
                 * @return {?}
                 */
                MediaObserver.prototype.ngOnDestroy = function () {
                    this.destroyed$.next();
                    this.destroyed$.complete();
                };
                // ************************************************
                // Public Methods
                // ************************************************
                /**
                 * Observe changes to current activation 'list'
                 * @return {?}
                 */
                MediaObserver.prototype.asObservable = function () {
                    return this._media$;
                };
                /**
                 * Allow programmatic query to determine if one or more media query/alias match
                 * the current viewport size.
                 * @param {?} value One or more media queries (or aliases) to check.
                 * @return {?} Whether any of the media queries match.
                 */
                MediaObserver.prototype.isActive = function (value) {
                    var _this_1 = this;
                    /** @type {?} */
                    var aliases = splitQueries(coerceArray(value));
                    return aliases.some(( /**
                     * @param {?} alias
                     * @return {?}
                     */function (/**
                     * @param {?} alias
                     * @return {?}
                     */ alias) {
                        /** @type {?} */
                        var query = toMediaQuery(alias, _this_1.breakpoints);
                        return _this_1.matchMedia.isActive(query);
                    }));
                };
                // ************************************************
                // Internal Methods
                // ************************************************
                /**
                 * Register all the mediaQueries registered in the BreakPointRegistry
                 * This is needed so subscribers can be auto-notified of all standard, registered
                 * mediaQuery activations
                 * @private
                 * @return {?}
                 */
                MediaObserver.prototype.watchActivations = function () {
                    /** @type {?} */
                    var queries = this.breakpoints.items.map(( /**
                     * @param {?} bp
                     * @return {?}
                     */function (/**
                     * @param {?} bp
                     * @return {?}
                     */ bp) { return bp.mediaQuery; }));
                    return this.buildObservable(queries);
                };
                /**
                 * Only pass/announce activations (not de-activations)
                 *
                 * Since multiple-mediaQueries can be activation in a cycle,
                 * gather all current activations into a single list of changes to observers
                 *
                 * Inject associated (if any) alias information into the MediaChange event
                 * - Exclude mediaQuery activations for overlapping mQs. List bounded mQ ranges only
                 * - Exclude print activations that do not have an associated mediaQuery
                 *
                 * NOTE: the raw MediaChange events [from MatchMedia] do not
                 *       contain important alias information; as such this info
                 *       must be injected into the MediaChange
                 * @private
                 * @param {?} mqList
                 * @return {?}
                 */
                MediaObserver.prototype.buildObservable = function (mqList) {
                    var _this_1 = this;
                    /** @type {?} */
                    var hasChanges = ( /**
                     * @param {?} changes
                     * @return {?}
                     */function (changes) {
                        /** @type {?} */
                        var isValidQuery = ( /**
                         * @param {?} change
                         * @return {?}
                         */function (change) { return (change.mediaQuery.length > 0); });
                        return (changes.filter(isValidQuery).length > 0);
                    });
                    /** @type {?} */
                    var excludeOverlaps = ( /**
                     * @param {?} changes
                     * @return {?}
                     */function (changes) {
                        return !_this_1.filterOverlaps ? changes : changes.filter(( /**
                         * @param {?} change
                         * @return {?}
                         */function (/**
                         * @param {?} change
                         * @return {?}
                         */ change) {
                            /** @type {?} */
                            var bp = _this_1.breakpoints.findByQuery(change.mediaQuery);
                            return !bp ? true : !bp.overlapping;
                        }));
                    });
                    /**
                     */
                    return this.matchMedia
                        .observe(this.hook.withPrintQuery(mqList))
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["filter"])(( /**
                 * @param {?} change
                 * @return {?}
                 */function (change) { return change.matches; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["debounceTime"])(0, rxjs__WEBPACK_IMPORTED_MODULE_2__["asapScheduler"]), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["switchMap"])(( /**
                     * @param {?} _
                     * @return {?}
                     */function (/**
                     * @param {?} _
                     * @return {?}
                     */ _) { return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(_this_1.findAllActivations()); })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(excludeOverlaps), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["filter"])(hasChanges), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["takeUntil"])(this.destroyed$));
                };
                /**
                 * Find all current activations and prepare single list of activations
                 * sorted by descending priority.
                 * @private
                 * @return {?}
                 */
                MediaObserver.prototype.findAllActivations = function () {
                    var _this_1 = this;
                    /** @type {?} */
                    var mergeMQAlias = ( /**
                     * @param {?} change
                     * @return {?}
                     */function (change) {
                        /** @type {?} */
                        var bp = _this_1.breakpoints.findByQuery(change.mediaQuery);
                        return mergeAlias(change, bp);
                    });
                    /** @type {?} */
                    var replaceWithPrintAlias = ( /**
                     * @param {?} change
                     * @return {?}
                     */function (change) {
                        return _this_1.hook.isPrintEvent(change) ? _this_1.hook.updateEvent(change) : change;
                    });
                    return this.matchMedia
                        .activations
                        .map(( /**
                 * @param {?} query
                 * @return {?}
                 */function (/**
                 * @param {?} query
                 * @return {?}
                 */ query) { return new MediaChange(true, query); }))
                        .map(replaceWithPrintAlias)
                        .map(mergeMQAlias)
                        .sort(sortDescendingPriority);
                };
                return MediaObserver;
            }());
            MediaObserver.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */
            MediaObserver.ctorParameters = function () { return [
                { type: BreakPointRegistry },
                { type: MatchMedia },
                { type: PrintHook }
            ]; };
            /** @nocollapse */ MediaObserver.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function MediaObserver_Factory() { return new MediaObserver(Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(BreakPointRegistry), Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(MatchMedia), Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(PrintHook)); }, token: MediaObserver, providedIn: "root" });
            /**
             * Find associated breakpoint (if any)
             * @param {?} query
             * @param {?} locator
             * @return {?}
             */
            function toMediaQuery(query, locator) {
                /** @type {?} */
                var bp = locator.findByAlias(query) || locator.findByQuery(query);
                return bp ? bp.mediaQuery : query;
            }
            /**
             * Split each query string into separate query strings if two queries are provided as comma
             * separated.
             * @param {?} queries
             * @return {?}
             */
            function splitQueries(queries) {
                return queries.map(( /**
                 * @param {?} query
                 * @return {?}
                 */function (query) { return query.split(','); }))
                    .reduce(( /**
             * @param {?} a1
             * @param {?} a2
             * @return {?}
             */function (a1, a2) { return a1.concat(a2); }))
                    .map(( /**
             * @param {?} query
             * @return {?}
             */function (/**
             * @param {?} query
             * @return {?}
             */ query) { return query.trim(); }));
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Class
             */
            var MediaTrigger = /** @class */ (function () {
                /**
                 * @param {?} breakpoints
                 * @param {?} matchMedia
                 * @param {?} layoutConfig
                 * @param {?} _platformId
                 * @param {?} _document
                 */
                function MediaTrigger(breakpoints, matchMedia, layoutConfig, _platformId, _document) {
                    this.breakpoints = breakpoints;
                    this.matchMedia = matchMedia;
                    this.layoutConfig = layoutConfig;
                    this._platformId = _platformId;
                    this._document = _document;
                    this.hasCachedRegistryMatches = false;
                    this.originalActivations = [];
                    this.originalRegistry = new Map();
                }
                /**
                 * Manually activate range of breakpoints
                 * @param {?} list array of mediaQuery or alias strings
                 * @return {?}
                 */
                MediaTrigger.prototype.activate = function (list) {
                    list = list.map(( /**
                     * @param {?} it
                     * @return {?}
                     */function (/**
                     * @param {?} it
                     * @return {?}
                     */ it) { return it.trim(); })); // trim queries
                    this.saveActivations();
                    this.deactivateAll();
                    this.setActivations(list);
                    this.prepareAutoRestore();
                };
                /**
                 * Restore original, 'real' breakpoints and emit events
                 * to trigger stream notification
                 * @return {?}
                 */
                MediaTrigger.prototype.restore = function () {
                    if (this.hasCachedRegistryMatches) {
                        /** @type {?} */
                        var extractQuery = ( /**
                         * @param {?} change
                         * @return {?}
                         */function (change) { return change.mediaQuery; });
                        /** @type {?} */
                        var list = this.originalActivations.map(extractQuery);
                        try {
                            this.deactivateAll();
                            this.restoreRegistryMatches();
                            this.setActivations(list);
                        }
                        finally {
                            this.originalActivations = [];
                            if (this.resizeSubscription) {
                                this.resizeSubscription.unsubscribe();
                            }
                        }
                    }
                };
                // ************************************************
                // Internal Methods
                // ************************************************
                /**
                 * Whenever window resizes, immediately auto-restore original
                 * activations (if we are simulating activations)
                 * @private
                 * @return {?}
                 */
                MediaTrigger.prototype.prepareAutoRestore = function () {
                    /** @type {?} */
                    var isBrowser = Object(_angular_common__WEBPACK_IMPORTED_MODULE_1__["isPlatformBrowser"])(this._platformId) && this._document;
                    /** @type {?} */
                    var enableAutoRestore = isBrowser && this.layoutConfig.mediaTriggerAutoRestore;
                    if (enableAutoRestore) {
                        /** @type {?} */
                        var resize$ = Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["fromEvent"])(window, 'resize').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["take"])(1));
                        this.resizeSubscription = resize$.subscribe(this.restore.bind(this));
                    }
                };
                /**
                 * Notify all matchMedia subscribers of de-activations
                 *
                 * Note: we must force 'matches' updates for
                 *       future matchMedia::activation lookups
                 * @private
                 * @return {?}
                 */
                MediaTrigger.prototype.deactivateAll = function () {
                    /** @type {?} */
                    var list = this.currentActivations;
                    this.forceRegistryMatches(list, false);
                    this.simulateMediaChanges(list, false);
                };
                /**
                 * Cache current activations as sorted, prioritized list of MediaChanges
                 * @private
                 * @return {?}
                 */
                MediaTrigger.prototype.saveActivations = function () {
                    var _this_1 = this;
                    if (!this.hasCachedRegistryMatches) {
                        /** @type {?} */
                        var toMediaChange = ( /**
                         * @param {?} query
                         * @return {?}
                         */function (query) { return new MediaChange(true, query); });
                        /** @type {?} */
                        var mergeMQAlias = ( /**
                         * @param {?} change
                         * @return {?}
                         */function (change) {
                            /** @type {?} */
                            var bp = _this_1.breakpoints.findByQuery(change.mediaQuery);
                            return mergeAlias(change, bp);
                        });
                        this.originalActivations = this.currentActivations
                            .map(toMediaChange)
                            .map(mergeMQAlias)
                            .sort(sortDescendingPriority);
                        this.cacheRegistryMatches();
                    }
                };
                /**
                 * Force set manual activations for specified mediaQuery list
                 * @private
                 * @param {?} list
                 * @return {?}
                 */
                MediaTrigger.prototype.setActivations = function (list) {
                    if (!!this.originalRegistry) {
                        this.forceRegistryMatches(list, true);
                    }
                    this.simulateMediaChanges(list);
                };
                /**
                 * For specified mediaQuery list manually simulate activations or deactivations
                 * @private
                 * @param {?} queries
                 * @param {?=} matches
                 * @return {?}
                 */
                MediaTrigger.prototype.simulateMediaChanges = function (queries, matches) {
                    var _this_1 = this;
                    if (matches === void 0) { matches = true; }
                    /** @type {?} */
                    var toMediaQuery = ( /**
                     * @param {?} query
                     * @return {?}
                     */function (query) {
                        /** @type {?} */
                        var locator = _this_1.breakpoints;
                        /** @type {?} */
                        var bp = locator.findByAlias(query) || locator.findByQuery(query);
                        return bp ? bp.mediaQuery : query;
                    });
                    /** @type {?} */
                    var emitChangeEvent = ( /**
                     * @param {?} query
                     * @return {?}
                     */function (query) { return _this_1.emitChangeEvent(matches, query); });
                    queries.map(toMediaQuery).forEach(emitChangeEvent);
                };
                /**
                 * Replace current registry with simulated registry...
                 * Note: this is required since MediaQueryList::matches is 'readOnly'
                 * @private
                 * @param {?} queries
                 * @param {?} matches
                 * @return {?}
                 */
                MediaTrigger.prototype.forceRegistryMatches = function (queries, matches) {
                    /** @type {?} */
                    var registry = new Map();
                    queries.forEach(( /**
                     * @param {?} query
                     * @return {?}
                     */function (/**
                     * @param {?} query
                     * @return {?}
                     */ query) {
                        registry.set(query, ( /** @type {?} */({ matches: matches })));
                    }));
                    this.matchMedia.registry = registry;
                };
                /**
                 * Save current MatchMedia::registry items.
                 * @private
                 * @return {?}
                 */
                MediaTrigger.prototype.cacheRegistryMatches = function () {
                    /** @type {?} */
                    var target = this.originalRegistry;
                    target.clear();
                    this.matchMedia.registry.forEach(( /**
                     * @param {?} value
                     * @param {?} key
                     * @return {?}
                     */function (value, key) {
                        target.set(key, value);
                    }));
                    this.hasCachedRegistryMatches = true;
                };
                /**
                 * Restore original, 'true' registry
                 * @private
                 * @return {?}
                 */
                MediaTrigger.prototype.restoreRegistryMatches = function () {
                    /** @type {?} */
                    var target = this.matchMedia.registry;
                    target.clear();
                    this.originalRegistry.forEach(( /**
                     * @param {?} value
                     * @param {?} key
                     * @return {?}
                     */function (value, key) {
                        target.set(key, value);
                    }));
                    this.originalRegistry.clear();
                    this.hasCachedRegistryMatches = false;
                };
                /**
                 * Manually emit a MediaChange event via the MatchMedia to MediaMarshaller and MediaObserver
                 * @private
                 * @param {?} matches
                 * @param {?} query
                 * @return {?}
                 */
                MediaTrigger.prototype.emitChangeEvent = function (matches, query) {
                    this.matchMedia.source.next(new MediaChange(matches, query));
                };
                Object.defineProperty(MediaTrigger.prototype, "currentActivations", {
                    /**
                     * @private
                     * @return {?}
                     */
                    get: function () {
                        return this.matchMedia.activations;
                    },
                    enumerable: true,
                    configurable: true
                });
                return MediaTrigger;
            }());
            MediaTrigger.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */
            MediaTrigger.ctorParameters = function () { return [
                { type: BreakPointRegistry },
                { type: MatchMedia },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [LAYOUT_CONFIG,] }] },
                { type: Object, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["PLATFORM_ID"],] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["DOCUMENT"],] }] }
            ]; };
            /** @nocollapse */ MediaTrigger.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function MediaTrigger_Factory() { return new MediaTrigger(Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(BreakPointRegistry), Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(MatchMedia), Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(LAYOUT_CONFIG), Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_0__["PLATFORM_ID"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_common__WEBPACK_IMPORTED_MODULE_1__["DOCUMENT"])); }, token: MediaTrigger, providedIn: "root" });
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Applies CSS prefixes to appropriate style keys.
             *
             * Note: `-ms-`, `-moz` and `-webkit-box` are no longer supported. e.g.
             *    {
             *      display: -webkit-flex;     NEW - Safari 6.1+. iOS 7.1+, BB10
             *      display: flex;             NEW, Spec - Firefox, Chrome, Opera
             *      // display: -webkit-box;   OLD - iOS 6-, Safari 3.1-6, BB7
             *      // display: -ms-flexbox;   TWEENER - IE 10
             *      // display: -moz-flexbox;  OLD - Firefox
             *    }
             * @param {?} target
             * @return {?}
             */
            function applyCssPrefixes(target) {
                for (var key in target) {
                    /** @type {?} */
                    var value = target[key] || '';
                    switch (key) {
                        case 'display':
                            if (value === 'flex') {
                                target['display'] = [
                                    '-webkit-flex',
                                    'flex'
                                ];
                            }
                            else if (value === 'inline-flex') {
                                target['display'] = [
                                    '-webkit-inline-flex',
                                    'inline-flex'
                                ];
                            }
                            else {
                                target['display'] = value;
                            }
                            break;
                        case 'align-items':
                        case 'align-self':
                        case 'align-content':
                        case 'flex':
                        case 'flex-basis':
                        case 'flex-flow':
                        case 'flex-grow':
                        case 'flex-shrink':
                        case 'flex-wrap':
                        case 'justify-content':
                            target['-webkit-' + key] = value;
                            break;
                        case 'flex-direction':
                            value = value || 'row';
                            target['-webkit-flex-direction'] = value;
                            target['flex-direction'] = value;
                            break;
                        case 'order':
                            target['order'] = target['-webkit-' + key] = isNaN(+value) ? '0' : value;
                            break;
                    }
                }
                return target;
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var StyleUtils = /** @class */ (function () {
                /**
                 * @param {?} _serverStylesheet
                 * @param {?} _serverModuleLoaded
                 * @param {?} _platformId
                 * @param {?} layoutConfig
                 */
                function StyleUtils(_serverStylesheet, _serverModuleLoaded, _platformId, layoutConfig) {
                    this._serverStylesheet = _serverStylesheet;
                    this._serverModuleLoaded = _serverModuleLoaded;
                    this._platformId = _platformId;
                    this.layoutConfig = layoutConfig;
                }
                /**
                 * Applies styles given via string pair or object map to the directive element
                 * @param {?} element
                 * @param {?} style
                 * @param {?=} value
                 * @return {?}
                 */
                StyleUtils.prototype.applyStyleToElement = function (element, style, value) {
                    if (value === void 0) { value = null; }
                    /** @type {?} */
                    var styles = {};
                    if (typeof style === 'string') {
                        styles[style] = value;
                        style = styles;
                    }
                    styles = this.layoutConfig.disableVendorPrefixes ? style : applyCssPrefixes(style);
                    this._applyMultiValueStyleToElement(styles, element);
                };
                /**
                 * Applies styles given via string pair or object map to the directive's element
                 * @param {?} style
                 * @param {?=} elements
                 * @return {?}
                 */
                StyleUtils.prototype.applyStyleToElements = function (style, elements) {
                    var _this_1 = this;
                    if (elements === void 0) { elements = []; }
                    /** @type {?} */
                    var styles = this.layoutConfig.disableVendorPrefixes ? style : applyCssPrefixes(style);
                    elements.forEach(( /**
                     * @param {?} el
                     * @return {?}
                     */function (/**
                     * @param {?} el
                     * @return {?}
                     */ el) {
                        _this_1._applyMultiValueStyleToElement(styles, el);
                    }));
                };
                /**
                 * Determine the DOM element's Flexbox flow (flex-direction)
                 *
                 * Check inline style first then check computed (stylesheet) style
                 * @param {?} target
                 * @return {?}
                 */
                StyleUtils.prototype.getFlowDirection = function (target) {
                    /** @type {?} */
                    var query = 'flex-direction';
                    /** @type {?} */
                    var value = this.lookupStyle(target, query);
                    /** @type {?} */
                    var hasInlineValue = this.lookupInlineStyle(target, query) ||
                        (Object(_angular_common__WEBPACK_IMPORTED_MODULE_1__["isPlatformServer"])(this._platformId) && this._serverModuleLoaded) ? value : '';
                    return [value || 'row', hasInlineValue];
                };
                /**
                 * Find the DOM element's raw attribute value (if any)
                 * @param {?} element
                 * @param {?} attribute
                 * @return {?}
                 */
                StyleUtils.prototype.lookupAttributeValue = function (element, attribute) {
                    return element.getAttribute(attribute) || '';
                };
                /**
                 * Find the DOM element's inline style value (if any)
                 * @param {?} element
                 * @param {?} styleName
                 * @return {?}
                 */
                StyleUtils.prototype.lookupInlineStyle = function (element, styleName) {
                    return Object(_angular_common__WEBPACK_IMPORTED_MODULE_1__["isPlatformBrowser"])(this._platformId) ?
                        element.style.getPropertyValue(styleName) : this._getServerStyle(element, styleName);
                };
                /**
                 * Determine the inline or inherited CSS style
                 * NOTE: platform-server has no implementation for getComputedStyle
                 * @param {?} element
                 * @param {?} styleName
                 * @param {?=} inlineOnly
                 * @return {?}
                 */
                StyleUtils.prototype.lookupStyle = function (element, styleName, inlineOnly) {
                    if (inlineOnly === void 0) { inlineOnly = false; }
                    /** @type {?} */
                    var value = '';
                    if (element) {
                        /** @type {?} */
                        var immediateValue = value = this.lookupInlineStyle(element, styleName);
                        if (!immediateValue) {
                            if (Object(_angular_common__WEBPACK_IMPORTED_MODULE_1__["isPlatformBrowser"])(this._platformId)) {
                                if (!inlineOnly) {
                                    value = getComputedStyle(element).getPropertyValue(styleName);
                                }
                            }
                            else {
                                if (this._serverModuleLoaded) {
                                    value = this._serverStylesheet.getStyleForElement(element, styleName);
                                }
                            }
                        }
                    }
                    // Note: 'inline' is the default of all elements, unless UA stylesheet overrides;
                    //       in which case getComputedStyle() should determine a valid value.
                    return value ? value.trim() : '';
                };
                /**
                 * Applies the styles to the element. The styles object map may contain an array of values
                 * Each value will be added as element style
                 * Keys are sorted to add prefixed styles (like -webkit-x) first, before the standard ones
                 * @private
                 * @param {?} styles
                 * @param {?} element
                 * @return {?}
                 */
                StyleUtils.prototype._applyMultiValueStyleToElement = function (styles, element) {
                    var _this_1 = this;
                    Object.keys(styles).sort().forEach(( /**
                     * @param {?} key
                     * @return {?}
                     */function (/**
                     * @param {?} key
                     * @return {?}
                     */ key) {
                        /** @type {?} */
                        var el = styles[key];
                        /** @type {?} */
                        var values = Array.isArray(el) ? el : [el];
                        values.sort();
                        for (var _a = 0, values_1 = values; _a < values_1.length; _a++) {
                            var value = values_1[_a];
                            value = value ? value + '' : '';
                            if (Object(_angular_common__WEBPACK_IMPORTED_MODULE_1__["isPlatformBrowser"])(_this_1._platformId) || !_this_1._serverModuleLoaded) {
                                Object(_angular_common__WEBPACK_IMPORTED_MODULE_1__["isPlatformBrowser"])(_this_1._platformId) ?
                                    element.style.setProperty(key, value) : _this_1._setServerStyle(element, key, value);
                            }
                            else {
                                _this_1._serverStylesheet.addStyleToElement(element, key, value);
                            }
                        }
                    }));
                };
                /**
                 * @private
                 * @param {?} element
                 * @param {?} styleName
                 * @param {?=} styleValue
                 * @return {?}
                 */
                StyleUtils.prototype._setServerStyle = function (element, styleName, styleValue) {
                    styleName = styleName.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
                    /** @type {?} */
                    var styleMap = this._readStyleAttribute(element);
                    styleMap[styleName] = styleValue || '';
                    this._writeStyleAttribute(element, styleMap);
                };
                /**
                 * @private
                 * @param {?} element
                 * @param {?} styleName
                 * @return {?}
                 */
                StyleUtils.prototype._getServerStyle = function (element, styleName) {
                    /** @type {?} */
                    var styleMap = this._readStyleAttribute(element);
                    return styleMap[styleName] || '';
                };
                /**
                 * @private
                 * @param {?} element
                 * @return {?}
                 */
                StyleUtils.prototype._readStyleAttribute = function (element) {
                    /** @type {?} */
                    var styleMap = {};
                    /** @type {?} */
                    var styleAttribute = element.getAttribute('style');
                    if (styleAttribute) {
                        /** @type {?} */
                        var styleList = styleAttribute.split(/;+/g);
                        for (var i = 0; i < styleList.length; i++) {
                            /** @type {?} */
                            var style = styleList[i].trim();
                            if (style.length > 0) {
                                /** @type {?} */
                                var colonIndex = style.indexOf(':');
                                if (colonIndex === -1) {
                                    throw new Error("Invalid CSS style: " + style);
                                }
                                /** @type {?} */
                                var name = style.substr(0, colonIndex).trim();
                                styleMap[name] = style.substr(colonIndex + 1).trim();
                            }
                        }
                    }
                    return styleMap;
                };
                /**
                 * @private
                 * @param {?} element
                 * @param {?} styleMap
                 * @return {?}
                 */
                StyleUtils.prototype._writeStyleAttribute = function (element, styleMap) {
                    /** @type {?} */
                    var styleAttrValue = '';
                    for (var key in styleMap) {
                        /** @type {?} */
                        var newValue = styleMap[key];
                        if (newValue) {
                            styleAttrValue += key + ':' + styleMap[key] + ';';
                        }
                    }
                    element.setAttribute('style', styleAttrValue);
                };
                return StyleUtils;
            }());
            StyleUtils.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */
            StyleUtils.ctorParameters = function () { return [
                { type: StylesheetMap, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: Boolean, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [SERVER_TOKEN,] }] },
                { type: Object, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["PLATFORM_ID"],] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [LAYOUT_CONFIG,] }] }
            ]; };
            /** @nocollapse */ StyleUtils.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function StyleUtils_Factory() { return new StyleUtils(Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(StylesheetMap, 8), Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(SERVER_TOKEN, 8), Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_0__["PLATFORM_ID"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(LAYOUT_CONFIG)); }, token: StyleUtils, providedIn: "root" });
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * A class that encapsulates CSS style generation for common directives
             * @abstract
             */
            var StyleBuilder = /** @class */ (function () {
                function StyleBuilder() {
                    /**
                     * Whether to cache the generated output styles
                     */
                    this.shouldCache = true;
                }
                /**
                 * Run a side effect computation given the input string and the computed styles
                 * from the build task and the host configuration object
                 * NOTE: This should be a no-op unless an algorithm is provided in a subclass
                 * @param {?} _input
                 * @param {?} _styles
                 * @param {?=} _parent
                 * @return {?}
                 */
                StyleBuilder.prototype.sideEffect = function (_input, _styles, _parent) {
                };
                return StyleBuilder;
            }());
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * The flex API permits 3 or 1 parts of the value:
             *    - `flex-grow flex-shrink flex-basis`, or
             *    - `flex-basis`
             * @param {?} basis
             * @param {?=} grow
             * @param {?=} shrink
             * @return {?}
             */
            function validateBasis(basis, grow, shrink) {
                if (grow === void 0) { grow = '1'; }
                if (shrink === void 0) { shrink = '1'; }
                /** @type {?} */
                var parts = [grow, shrink, basis];
                /** @type {?} */
                var j = basis.indexOf('calc');
                if (j > 0) {
                    parts[2] = _validateCalcValue(basis.substring(j).trim());
                    /** @type {?} */
                    var matches = basis.substr(0, j).trim().split(' ');
                    if (matches.length == 2) {
                        parts[0] = matches[0];
                        parts[1] = matches[1];
                    }
                }
                else if (j == 0) {
                    parts[2] = _validateCalcValue(basis.trim());
                }
                else {
                    /** @type {?} */
                    var matches = basis.split(' ');
                    parts = (matches.length === 3) ? matches : [
                        grow, shrink, basis
                    ];
                }
                return parts;
            }
            /**
             * Calc expressions require whitespace before & after any expression operators
             * This is a simple, crude whitespace padding solution.
             *   - '3 3 calc(15em + 20px)'
             *   - calc(100% / 7 * 2)
             *   - 'calc(15em + 20px)'
             *   - 'calc(15em+20px)'
             *   - '37px'
             *   = '43%'
             * @param {?} calc
             * @return {?}
             */
            function _validateCalcValue(calc) {
                return calc.replace(/[\s]/g, '').replace(/[\/\*\+\-]/g, ' $& ');
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * MediaMarshaller - register responsive values from directives and
             *                   trigger them based on media query events
             */
            var MediaMarshaller = /** @class */ (function () {
                /**
                 * @param {?} matchMedia
                 * @param {?} breakpoints
                 * @param {?} hook
                 */
                function MediaMarshaller(matchMedia, breakpoints, hook) {
                    this.matchMedia = matchMedia;
                    this.breakpoints = breakpoints;
                    this.hook = hook;
                    this.activatedBreakpoints = [];
                    this.elementMap = new Map();
                    this.elementKeyMap = new WeakMap();
                    this.watcherMap = new WeakMap(); // special triggers to update elements
                    // special triggers to update elements
                    this.updateMap = new WeakMap(); // callback functions to update styles
                    // callback functions to update styles
                    this.clearMap = new WeakMap(); // callback functions to clear styles
                    // callback functions to clear styles
                    this.subject = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
                    this.observeActivations();
                }
                Object.defineProperty(MediaMarshaller.prototype, "activatedAlias", {
                    /**
                     * @return {?}
                     */
                    get: function () {
                        return this.activatedBreakpoints[0] ? this.activatedBreakpoints[0].alias : '';
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Update styles on breakpoint activates or deactivates
                 * @param {?} mc
                 * @return {?}
                 */
                MediaMarshaller.prototype.onMediaChange = function (mc) {
                    /** @type {?} */
                    var bp = this.findByQuery(mc.mediaQuery);
                    if (bp) {
                        mc = mergeAlias(mc, bp);
                        if (mc.matches && this.activatedBreakpoints.indexOf(bp) === -1) {
                            this.activatedBreakpoints.push(bp);
                            this.activatedBreakpoints.sort(sortDescendingPriority);
                            this.updateStyles();
                        }
                        else if (!mc.matches && this.activatedBreakpoints.indexOf(bp) !== -1) {
                            // Remove the breakpoint when it's deactivated
                            this.activatedBreakpoints.splice(this.activatedBreakpoints.indexOf(bp), 1);
                            this.activatedBreakpoints.sort(sortDescendingPriority);
                            this.updateStyles();
                        }
                    }
                };
                /**
                 * initialize the marshaller with necessary elements for delegation on an element
                 * @param {?} element
                 * @param {?} key
                 * @param {?=} updateFn optional callback so that custom bp directives don't have to re-provide this
                 * @param {?=} clearFn optional callback so that custom bp directives don't have to re-provide this
                 * @param {?=} extraTriggers other triggers to force style updates (e.g. layout, directionality, etc)
                 * @return {?}
                 */
                MediaMarshaller.prototype.init = function (element, key, updateFn, clearFn, extraTriggers) {
                    if (extraTriggers === void 0) { extraTriggers = []; }
                    initBuilderMap(this.updateMap, element, key, updateFn);
                    initBuilderMap(this.clearMap, element, key, clearFn);
                    this.buildElementKeyMap(element, key);
                    this.watchExtraTriggers(element, key, extraTriggers);
                };
                /**
                 * get the value for an element and key and optionally a given breakpoint
                 * @param {?} element
                 * @param {?} key
                 * @param {?=} bp
                 * @return {?}
                 */
                MediaMarshaller.prototype.getValue = function (element, key, bp) {
                    /** @type {?} */
                    var bpMap = this.elementMap.get(element);
                    if (bpMap) {
                        /** @type {?} */
                        var values = bp !== undefined ? bpMap.get(bp) : this.getActivatedValues(bpMap, key);
                        if (values) {
                            return values.get(key);
                        }
                    }
                    return undefined;
                };
                /**
                 * whether the element has values for a given key
                 * @param {?} element
                 * @param {?} key
                 * @return {?}
                 */
                MediaMarshaller.prototype.hasValue = function (element, key) {
                    /** @type {?} */
                    var bpMap = this.elementMap.get(element);
                    if (bpMap) {
                        /** @type {?} */
                        var values = this.getActivatedValues(bpMap, key);
                        if (values) {
                            return values.get(key) !== undefined || false;
                        }
                    }
                    return false;
                };
                /**
                 * Set the value for an input on a directive
                 * @param {?} element the element in question
                 * @param {?} key the type of the directive (e.g. flex, layout-gap, etc)
                 * @param {?} val the value for the breakpoint
                 * @param {?} bp the breakpoint suffix (empty string = default)
                 * @return {?}
                 */
                MediaMarshaller.prototype.setValue = function (element, key, val, bp) {
                    /** @type {?} */
                    var bpMap = this.elementMap.get(element);
                    if (!bpMap) {
                        bpMap = new Map().set(bp, new Map().set(key, val));
                        this.elementMap.set(element, bpMap);
                    }
                    else {
                        /** @type {?} */
                        var values = (bpMap.get(bp) || new Map()).set(key, val);
                        bpMap.set(bp, values);
                        this.elementMap.set(element, bpMap);
                    }
                    /** @type {?} */
                    var value = this.getValue(element, key);
                    if (value !== undefined) {
                        this.updateElement(element, key, value);
                    }
                };
                /**
                 * Track element value changes for a specific key
                 * @param {?} element
                 * @param {?} key
                 * @return {?}
                 */
                MediaMarshaller.prototype.trackValue = function (element, key) {
                    return this.subject
                        .asObservable()
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["filter"])(( /**
                 * @param {?} v
                 * @return {?}
                 */function (/**
                 * @param {?} v
                 * @return {?}
                 */ v) { return v.element === element && v.key === key; })));
                };
                /**
                 * update all styles for all elements on the current breakpoint
                 * @return {?}
                 */
                MediaMarshaller.prototype.updateStyles = function () {
                    var _this_1 = this;
                    this.elementMap.forEach(( /**
                     * @param {?} bpMap
                     * @param {?} el
                     * @return {?}
                     */function (bpMap, el) {
                        /** @type {?} */
                        var keyMap = new Set(( /** @type {?} */(_this_1.elementKeyMap.get(el))));
                        /** @type {?} */
                        var valueMap = _this_1.getActivatedValues(bpMap);
                        if (valueMap) {
                            valueMap.forEach(( /**
                             * @param {?} v
                             * @param {?} k
                             * @return {?}
                             */function (v, k) {
                                _this_1.updateElement(el, k, v);
                                keyMap.delete(k);
                            }));
                        }
                        keyMap.forEach(( /**
                         * @param {?} k
                         * @return {?}
                         */function (/**
                         * @param {?} k
                         * @return {?}
                         */ k) {
                            valueMap = _this_1.getActivatedValues(bpMap, k);
                            if (valueMap) {
                                /** @type {?} */
                                var value = valueMap.get(k);
                                _this_1.updateElement(el, k, value);
                            }
                            else {
                                _this_1.clearElement(el, k);
                            }
                        }));
                    }));
                };
                /**
                 * clear the styles for a given element
                 * @param {?} element
                 * @param {?} key
                 * @return {?}
                 */
                MediaMarshaller.prototype.clearElement = function (element, key) {
                    /** @type {?} */
                    var builders = this.clearMap.get(element);
                    if (builders) {
                        /** @type {?} */
                        var clearFn = ( /** @type {?} */(builders.get(key)));
                        if (!!clearFn) {
                            clearFn();
                            this.subject.next({ element: element, key: key, value: '' });
                        }
                    }
                };
                /**
                 * update a given element with the activated values for a given key
                 * @param {?} element
                 * @param {?} key
                 * @param {?} value
                 * @return {?}
                 */
                MediaMarshaller.prototype.updateElement = function (element, key, value) {
                    /** @type {?} */
                    var builders = this.updateMap.get(element);
                    if (builders) {
                        /** @type {?} */
                        var updateFn = ( /** @type {?} */(builders.get(key)));
                        if (!!updateFn) {
                            updateFn(value);
                            this.subject.next({ element: element, key: key, value: value });
                        }
                    }
                };
                /**
                 * release all references to a given element
                 * @param {?} element
                 * @return {?}
                 */
                MediaMarshaller.prototype.releaseElement = function (element) {
                    /** @type {?} */
                    var watcherMap = this.watcherMap.get(element);
                    if (watcherMap) {
                        watcherMap.forEach(( /**
                         * @param {?} s
                         * @return {?}
                         */function (/**
                         * @param {?} s
                         * @return {?}
                         */ s) { return s.unsubscribe(); }));
                        this.watcherMap.delete(element);
                    }
                    /** @type {?} */
                    var elementMap = this.elementMap.get(element);
                    if (elementMap) {
                        elementMap.forEach(( /**
                         * @param {?} _
                         * @param {?} s
                         * @return {?}
                         */function (_, s) { return elementMap.delete(s); }));
                        this.elementMap.delete(element);
                    }
                };
                /**
                 * trigger an update for a given element and key (e.g. layout)
                 * @param {?} element
                 * @param {?=} key
                 * @return {?}
                 */
                MediaMarshaller.prototype.triggerUpdate = function (element, key) {
                    var _this_1 = this;
                    /** @type {?} */
                    var bpMap = this.elementMap.get(element);
                    if (bpMap) {
                        /** @type {?} */
                        var valueMap = this.getActivatedValues(bpMap, key);
                        if (valueMap) {
                            if (key) {
                                this.updateElement(element, key, valueMap.get(key));
                            }
                            else {
                                valueMap.forEach(( /**
                                 * @param {?} v
                                 * @param {?} k
                                 * @return {?}
                                 */function (v, k) { return _this_1.updateElement(element, k, v); }));
                            }
                        }
                    }
                };
                /**
                 * Cross-reference for HTMLElement with directive key
                 * @private
                 * @param {?} element
                 * @param {?} key
                 * @return {?}
                 */
                MediaMarshaller.prototype.buildElementKeyMap = function (element, key) {
                    /** @type {?} */
                    var keyMap = this.elementKeyMap.get(element);
                    if (!keyMap) {
                        keyMap = new Set();
                        this.elementKeyMap.set(element, keyMap);
                    }
                    keyMap.add(key);
                };
                /**
                 * Other triggers that should force style updates:
                 * - directionality
                 * - layout changes
                 * - mutationobserver updates
                 * @private
                 * @param {?} element
                 * @param {?} key
                 * @param {?} triggers
                 * @return {?}
                 */
                MediaMarshaller.prototype.watchExtraTriggers = function (element, key, triggers) {
                    var _this_1 = this;
                    if (triggers && triggers.length) {
                        /** @type {?} */
                        var watchers = this.watcherMap.get(element);
                        if (!watchers) {
                            watchers = new Map();
                            this.watcherMap.set(element, watchers);
                        }
                        /** @type {?} */
                        var subscription = watchers.get(key);
                        if (!subscription) {
                            /** @type {?} */
                            var newSubscription = Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["merge"]).apply(void 0, triggers).subscribe(( /**
                             * @return {?}
                             */function () {
                                /** @type {?} */
                                var currentValue = _this_1.getValue(element, key);
                                _this_1.updateElement(element, key, currentValue);
                            }));
                            watchers.set(key, newSubscription);
                        }
                    }
                };
                /**
                 * Breakpoint locator by mediaQuery
                 * @private
                 * @param {?} query
                 * @return {?}
                 */
                MediaMarshaller.prototype.findByQuery = function (query) {
                    return this.breakpoints.findByQuery(query);
                };
                /**
                 * get the fallback breakpoint for a given element, starting with the current breakpoint
                 * @private
                 * @param {?} bpMap
                 * @param {?=} key
                 * @return {?}
                 */
                MediaMarshaller.prototype.getActivatedValues = function (bpMap, key) {
                    for (var i = 0; i < this.activatedBreakpoints.length; i++) {
                        /** @type {?} */
                        var activatedBp = this.activatedBreakpoints[i];
                        /** @type {?} */
                        var valueMap = bpMap.get(activatedBp.alias);
                        if (valueMap) {
                            if (key === undefined || valueMap.has(key)) {
                                return valueMap;
                            }
                        }
                    }
                    /** @type {?} */
                    var lastHope = bpMap.get('');
                    return (key === undefined || lastHope && lastHope.has(key)) ? lastHope : undefined;
                };
                /**
                 * Watch for mediaQuery breakpoint activations
                 * @private
                 * @return {?}
                 */
                MediaMarshaller.prototype.observeActivations = function () {
                    /** @type {?} */
                    var target = ( /** @type {?} */(( /** @type {?} */(this))));
                    /** @type {?} */
                    var queries = this.breakpoints.items.map(( /**
                     * @param {?} bp
                     * @return {?}
                     */function (/**
                     * @param {?} bp
                     * @return {?}
                     */ bp) { return bp.mediaQuery; }));
                    this.matchMedia
                        .observe(this.hook.withPrintQuery(queries))
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["tap"])(this.hook.interceptEvents(target)), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["filter"])(this.hook.blockPropagation()))
                        .subscribe(this.onMediaChange.bind(this));
                };
                return MediaMarshaller;
            }());
            MediaMarshaller.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */
            MediaMarshaller.ctorParameters = function () { return [
                { type: MatchMedia },
                { type: BreakPointRegistry },
                { type: PrintHook }
            ]; };
            /** @nocollapse */ MediaMarshaller.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function MediaMarshaller_Factory() { return new MediaMarshaller(Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(MatchMedia), Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(BreakPointRegistry), Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(PrintHook)); }, token: MediaMarshaller, providedIn: "root" });
            /**
             * @param {?} map
             * @param {?} element
             * @param {?} key
             * @param {?=} input
             * @return {?}
             */
            function initBuilderMap(map$$1, element, key, input) {
                if (input !== undefined) {
                    /** @type {?} */
                    var oldMap = map$$1.get(element);
                    if (!oldMap) {
                        oldMap = new Map();
                        map$$1.set(element, oldMap);
                    }
                    oldMap.set(key, input);
                }
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=core.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/flex-layout/esm2015/extended.js": 
        /*!***************************************************************!*\
          !*** ./node_modules/@angular/flex-layout/esm2015/extended.js ***!
          \***************************************************************/
        /*! exports provided: ExtendedModule, ClassDirective, LayoutNgClassImplProvider, DefaultClassDirective, ImgSrcStyleBuilder, ImgSrcDirective, DefaultImgSrcDirective, ShowHideStyleBuilder, ShowHideDirective, DefaultShowHideDirective, StyleDirective, LayoutNgStyleImplProvider, DefaultStyleDirective */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExtendedModule", function () { return ExtendedModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClassDirective", function () { return ClassDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayoutNgClassImplProvider", function () { return LayoutNgClassImplProvider; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultClassDirective", function () { return DefaultClassDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImgSrcStyleBuilder", function () { return ImgSrcStyleBuilder; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImgSrcDirective", function () { return ImgSrcDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultImgSrcDirective", function () { return DefaultImgSrcDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShowHideStyleBuilder", function () { return ShowHideStyleBuilder; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShowHideDirective", function () { return ShowHideDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultShowHideDirective", function () { return DefaultShowHideDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StyleDirective", function () { return StyleDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayoutNgStyleImplProvider", function () { return LayoutNgStyleImplProvider; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultStyleDirective", function () { return DefaultStyleDirective; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/flex-layout/core */ "./node_modules/@angular/flex-layout/esm2015/core.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/platform-browser */ "./node_modules/@angular/platform-browser/fesm2015/platform-browser.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var ImgSrcStyleBuilder = /** @class */ (function (_super) {
                __extends(ImgSrcStyleBuilder, _super);
                function ImgSrcStyleBuilder() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                /**
                 * @param {?} url
                 * @return {?}
                 */
                ImgSrcStyleBuilder.prototype.buildStyles = function (url) {
                    return { 'content': url ? "url(" + url + ")" : '' };
                };
                return ImgSrcStyleBuilder;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["StyleBuilder"]));
            ImgSrcStyleBuilder.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */ ImgSrcStyleBuilder.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function ImgSrcStyleBuilder_Factory() { return new ImgSrcStyleBuilder(); }, token: ImgSrcStyleBuilder, providedIn: "root" });
            var ImgSrcDirective = /** @class */ (function (_super) {
                __extends(ImgSrcDirective, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} styleBuilder
                 * @param {?} styler
                 * @param {?} marshal
                 * @param {?} platformId
                 * @param {?} serverModuleLoaded
                 */
                function ImgSrcDirective(elementRef, styleBuilder, styler, marshal, platformId, serverModuleLoaded) {
                    var _this_1 = _super.call(this, elementRef, styleBuilder, styler, marshal) || this;
                    _this_1.elementRef = elementRef;
                    _this_1.styleBuilder = styleBuilder;
                    _this_1.styler = styler;
                    _this_1.marshal = marshal;
                    _this_1.platformId = platformId;
                    _this_1.serverModuleLoaded = serverModuleLoaded;
                    _this_1.DIRECTIVE_KEY = 'img-src';
                    _this_1.defaultSrc = '';
                    _this_1.styleCache = imgSrcCache;
                    _this_1.init();
                    _this_1.setValue(_this_1.nativeElement.getAttribute('src') || '', '');
                    if (Object(_angular_common__WEBPACK_IMPORTED_MODULE_1__["isPlatformServer"])(_this_1.platformId) && _this_1.serverModuleLoaded) {
                        _this_1.nativeElement.setAttribute('src', '');
                    }
                    return _this_1;
                }
                Object.defineProperty(ImgSrcDirective.prototype, "src", {
                    /**
                     * @param {?} val
                     * @return {?}
                     */
                    set: function (val) {
                        this.defaultSrc = val;
                        this.setValue(this.defaultSrc, '');
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Use the [responsively] activated input value to update
                 * the host img src attribute or assign a default `img.src=''`
                 * if the src has not been defined.
                 *
                 * Do nothing to standard `<img src="">` usages, only when responsive
                 * keys are present do we actually call `setAttribute()`
                 * @protected
                 * @param {?=} value
                 * @return {?}
                 */
                ImgSrcDirective.prototype.updateWithValue = function (value) {
                    /** @type {?} */
                    var url = value || this.defaultSrc;
                    if (Object(_angular_common__WEBPACK_IMPORTED_MODULE_1__["isPlatformServer"])(this.platformId) && this.serverModuleLoaded) {
                        this.addStyles(url);
                    }
                    else {
                        this.nativeElement.setAttribute('src', url);
                    }
                };
                return ImgSrcDirective;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["BaseDirective2"]));
            ImgSrcDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: 'img-src-directive' },] },
            ];
            /** @nocollapse */
            ImgSrcDirective.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: ImgSrcStyleBuilder },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["StyleUtils"] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["MediaMarshaller"] },
                { type: Object, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["PLATFORM_ID"],] }] },
                { type: Boolean, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["SERVER_TOKEN"],] }] }
            ]; };
            ImgSrcDirective.propDecorators = {
                src: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['src',] }]
            };
            /** @type {?} */
            var imgSrcCache = new Map();
            /** @type {?} */
            var inputs = [
                'src.xs', 'src.sm', 'src.md', 'src.lg', 'src.xl',
                'src.lt-sm', 'src.lt-md', 'src.lt-lg', 'src.lt-xl',
                'src.gt-xs', 'src.gt-sm', 'src.gt-md', 'src.gt-lg'
            ];
            /** @type {?} */
            var selector = "\n  img[src.xs],    img[src.sm],    img[src.md],    img[src.lg],   img[src.xl],\n  img[src.lt-sm], img[src.lt-md], img[src.lt-lg], img[src.lt-xl],\n  img[src.gt-xs], img[src.gt-sm], img[src.gt-md], img[src.gt-lg]\n";
            /**
             * This directive provides a responsive API for the HTML <img> 'src' attribute
             * and will update the img.src property upon each responsive activation.
             *
             * e.g.
             *      <img src="defaultScene.jpg" src.xs="mobileScene.jpg"></img>
             *
             * @see https://css-tricks.com/responsive-images-youre-just-changing-resolutions-use-src/
             */
            var DefaultImgSrcDirective = /** @class */ (function (_super) {
                __extends(DefaultImgSrcDirective, _super);
                function DefaultImgSrcDirective() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.inputs = inputs;
                    return _this_1;
                }
                return DefaultImgSrcDirective;
            }(ImgSrcDirective));
            DefaultImgSrcDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: selector, inputs: inputs },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var ClassDirective = /** @class */ (function (_super) {
                __extends(ClassDirective, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} styler
                 * @param {?} marshal
                 * @param {?} delegate
                 * @param {?} ngClassInstance
                 */
                function ClassDirective(elementRef, styler, marshal, delegate, ngClassInstance) {
                    var _this_1 = _super.call(this, elementRef, ( /** @type {?} */(null)), styler, marshal) || this;
                    _this_1.elementRef = elementRef;
                    _this_1.styler = styler;
                    _this_1.marshal = marshal;
                    _this_1.delegate = delegate;
                    _this_1.ngClassInstance = ngClassInstance;
                    _this_1.DIRECTIVE_KEY = 'ngClass';
                    if (!_this_1.ngClassInstance) {
                        // Create an instance NgClass Directive instance only if `ngClass=""` has NOT been defined on
                        // the same host element; since the responsive variations may be defined...
                        _this_1.ngClassInstance = new _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgClass"](_this_1.delegate);
                    }
                    _this_1.init();
                    _this_1.setValue('', '');
                    return _this_1;
                }
                Object.defineProperty(ClassDirective.prototype, "klass", {
                    /**
                     * Capture class assignments so we cache the default classes
                     * which are merged with activated styles and used as fallbacks.
                     * @param {?} val
                     * @return {?}
                     */
                    set: function (val) {
                        this.ngClassInstance.klass = val;
                        this.setValue(val, '');
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @protected
                 * @param {?} value
                 * @return {?}
                 */
                ClassDirective.prototype.updateWithValue = function (value) {
                    this.ngClassInstance.ngClass = value;
                    this.ngClassInstance.ngDoCheck();
                };
                // ******************************************************************
                // Lifecycle Hooks
                // ******************************************************************
                /**
                 * For ChangeDetectionStrategy.onPush and ngOnChanges() updates
                 * @return {?}
                 */
                ClassDirective.prototype.ngDoCheck = function () {
                    this.ngClassInstance.ngDoCheck();
                };
                return ClassDirective;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["BaseDirective2"]));
            ClassDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: 'class-directive' },] },
            ];
            /** @nocollapse */
            ClassDirective.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["StyleUtils"] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["MediaMarshaller"] },
                { type: _angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵNgClassImpl"] },
                { type: _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgClass"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Self"] }] }
            ]; };
            ClassDirective.propDecorators = {
                klass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['class',] }]
            };
            /** @type {?} */
            var inputs$1 = [
                'ngClass', 'ngClass.xs', 'ngClass.sm', 'ngClass.md', 'ngClass.lg', 'ngClass.xl',
                'ngClass.lt-sm', 'ngClass.lt-md', 'ngClass.lt-lg', 'ngClass.lt-xl',
                'ngClass.gt-xs', 'ngClass.gt-sm', 'ngClass.gt-md', 'ngClass.gt-lg'
            ];
            /** @type {?} */
            var selector$1 = "\n  [ngClass], [ngClass.xs], [ngClass.sm], [ngClass.md], [ngClass.lg], [ngClass.xl],\n  [ngClass.lt-sm], [ngClass.lt-md], [ngClass.lt-lg], [ngClass.lt-xl],\n  [ngClass.gt-xs], [ngClass.gt-sm], [ngClass.gt-md], [ngClass.gt-lg]\n";
            // tslint:disable-next-line:variable-name
            /** @type {?} */
            var LayoutNgClassImplProvider = {
                provide: _angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵNgClassImpl"],
                useClass: _angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵNgClassR2Impl"]
            };
            /**
             * Directive to add responsive support for ngClass.
             * This maintains the core functionality of 'ngClass' and adds responsive API
             * Note: this class is a no-op when rendered on the server
             */
            var DefaultClassDirective = /** @class */ (function (_super) {
                __extends(DefaultClassDirective, _super);
                function DefaultClassDirective() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.inputs = inputs$1;
                    return _this_1;
                }
                return DefaultClassDirective;
            }(ClassDirective));
            DefaultClassDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: selector$1, inputs: inputs$1, providers: [LayoutNgClassImplProvider] },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var ShowHideStyleBuilder = /** @class */ (function (_super) {
                __extends(ShowHideStyleBuilder, _super);
                function ShowHideStyleBuilder() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                /**
                 * @param {?} show
                 * @param {?} parent
                 * @return {?}
                 */
                ShowHideStyleBuilder.prototype.buildStyles = function (show, parent) {
                    /** @type {?} */
                    var shouldShow = show === 'true';
                    return { 'display': shouldShow ? parent.display : 'none' };
                };
                return ShowHideStyleBuilder;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["StyleBuilder"]));
            ShowHideStyleBuilder.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */ ShowHideStyleBuilder.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function ShowHideStyleBuilder_Factory() { return new ShowHideStyleBuilder(); }, token: ShowHideStyleBuilder, providedIn: "root" });
            var ShowHideDirective = /** @class */ (function (_super) {
                __extends(ShowHideDirective, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} styleBuilder
                 * @param {?} styler
                 * @param {?} marshal
                 * @param {?} layoutConfig
                 * @param {?} platformId
                 * @param {?} serverModuleLoaded
                 */
                function ShowHideDirective(elementRef, styleBuilder, styler, marshal, layoutConfig, platformId, serverModuleLoaded) {
                    var _this_1 = _super.call(this, elementRef, styleBuilder, styler, marshal) || this;
                    _this_1.elementRef = elementRef;
                    _this_1.styleBuilder = styleBuilder;
                    _this_1.styler = styler;
                    _this_1.marshal = marshal;
                    _this_1.layoutConfig = layoutConfig;
                    _this_1.platformId = platformId;
                    _this_1.serverModuleLoaded = serverModuleLoaded;
                    _this_1.DIRECTIVE_KEY = 'show-hide';
                    /**
                     * Original dom Elements CSS display style
                     */
                    _this_1.display = '';
                    _this_1.hasLayout = false;
                    _this_1.hasFlexChild = false;
                    return _this_1;
                }
                // *********************************************
                // Lifecycle Methods
                // *********************************************
                /**
                 * @return {?}
                 */
                ShowHideDirective.prototype.ngAfterViewInit = function () {
                    this.trackExtraTriggers();
                    /** @type {?} */
                    var children = Array.from(this.nativeElement.children);
                    for (var i = 0; i < children.length; i++) {
                        if (this.marshal.hasValue(( /** @type {?} */(children[i])), 'flex')) {
                            this.hasFlexChild = true;
                            break;
                        }
                    }
                    if (DISPLAY_MAP.has(this.nativeElement)) {
                        this.display = ( /** @type {?} */(DISPLAY_MAP.get(this.nativeElement)));
                    }
                    else {
                        this.display = this.getDisplayStyle();
                        DISPLAY_MAP.set(this.nativeElement, this.display);
                    }
                    this.init();
                    // set the default to show unless explicitly overridden
                    /** @type {?} */
                    var defaultValue = this.marshal.getValue(this.nativeElement, this.DIRECTIVE_KEY, '');
                    if (defaultValue === undefined || defaultValue === '') {
                        this.setValue(true, '');
                    }
                    else {
                        this.triggerUpdate();
                    }
                };
                /**
                 * On changes to any \@Input properties...
                 * Default to use the non-responsive Input value ('fxShow')
                 * Then conditionally override with the mq-activated Input's current value
                 * @param {?} changes
                 * @return {?}
                 */
                ShowHideDirective.prototype.ngOnChanges = function (changes) {
                    var _this_1 = this;
                    Object.keys(changes).forEach(( /**
                     * @param {?} key
                     * @return {?}
                     */function (/**
                     * @param {?} key
                     * @return {?}
                     */ key) {
                        if (_this_1.inputs.indexOf(key) !== -1) {
                            /** @type {?} */
                            var inputKey = key.split('.');
                            /** @type {?} */
                            var bp = inputKey.slice(1).join('.');
                            /** @type {?} */
                            var inputValue = changes[key].currentValue;
                            /** @type {?} */
                            var shouldShow = inputValue !== '' ?
                                inputValue !== 0 ? Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(inputValue) : false
                                : true;
                            if (inputKey[0] === 'fxHide') {
                                shouldShow = !shouldShow;
                            }
                            _this_1.setValue(shouldShow, bp);
                        }
                    }));
                };
                // *********************************************
                // Protected methods
                // *********************************************
                /**
                 *  Watch for these extra triggers to update fxShow, fxHide stylings
                 * @protected
                 * @return {?}
                 */
                ShowHideDirective.prototype.trackExtraTriggers = function () {
                    var _this_1 = this;
                    this.hasLayout = this.marshal.hasValue(this.nativeElement, 'layout');
                    ['layout', 'layout-align'].forEach(( /**
                     * @param {?} key
                     * @return {?}
                     */function (/**
                     * @param {?} key
                     * @return {?}
                     */ key) {
                        _this_1.marshal
                            .trackValue(_this_1.nativeElement, key)
                            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["takeUntil"])(_this_1.destroySubject))
                            .subscribe(_this_1.triggerUpdate.bind(_this_1));
                    }));
                };
                /**
                 * Override accessor to the current HTMLElement's `display` style
                 * Note: Show/Hide will not change the display to 'flex' but will set it to 'block'
                 * unless it was already explicitly specified inline or in a CSS stylesheet.
                 * @protected
                 * @return {?}
                 */
                ShowHideDirective.prototype.getDisplayStyle = function () {
                    return (this.hasLayout || (this.hasFlexChild && this.layoutConfig.addFlexToParent)) ?
                        'flex' : this.styler.lookupStyle(this.nativeElement, 'display', true);
                };
                /**
                 * Validate the visibility value and then update the host's inline display style
                 * @protected
                 * @param {?=} value
                 * @return {?}
                 */
                ShowHideDirective.prototype.updateWithValue = function (value) {
                    if (value === void 0) { value = true; }
                    if (value === '') {
                        return;
                    }
                    this.addStyles(value ? 'true' : 'false', { display: this.display });
                    if (Object(_angular_common__WEBPACK_IMPORTED_MODULE_1__["isPlatformServer"])(this.platformId) && this.serverModuleLoaded) {
                        this.nativeElement.style.setProperty('display', '');
                    }
                    this.marshal.triggerUpdate(( /** @type {?} */(this.parentElement)), 'layout-gap');
                };
                return ShowHideDirective;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["BaseDirective2"]));
            ShowHideDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: 'show-hide-directive' },] },
            ];
            /** @nocollapse */
            ShowHideDirective.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: ShowHideStyleBuilder },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["StyleUtils"] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["MediaMarshaller"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["LAYOUT_CONFIG"],] }] },
                { type: Object, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["PLATFORM_ID"],] }] },
                { type: Boolean, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["SERVER_TOKEN"],] }] }
            ]; };
            /** @type {?} */
            var DISPLAY_MAP = new WeakMap();
            /** @type {?} */
            var inputs$2 = [
                'fxShow', 'fxShow.print',
                'fxShow.xs', 'fxShow.sm', 'fxShow.md', 'fxShow.lg', 'fxShow.xl',
                'fxShow.lt-sm', 'fxShow.lt-md', 'fxShow.lt-lg', 'fxShow.lt-xl',
                'fxShow.gt-xs', 'fxShow.gt-sm', 'fxShow.gt-md', 'fxShow.gt-lg',
                'fxHide', 'fxHide.print',
                'fxHide.xs', 'fxHide.sm', 'fxHide.md', 'fxHide.lg', 'fxHide.xl',
                'fxHide.lt-sm', 'fxHide.lt-md', 'fxHide.lt-lg', 'fxHide.lt-xl',
                'fxHide.gt-xs', 'fxHide.gt-sm', 'fxHide.gt-md', 'fxHide.gt-lg'
            ];
            /** @type {?} */
            var selector$2 = "\n  [fxShow], [fxShow.print],\n  [fxShow.xs], [fxShow.sm], [fxShow.md], [fxShow.lg], [fxShow.xl],\n  [fxShow.lt-sm], [fxShow.lt-md], [fxShow.lt-lg], [fxShow.lt-xl],\n  [fxShow.gt-xs], [fxShow.gt-sm], [fxShow.gt-md], [fxShow.gt-lg],\n  [fxHide], [fxHide.print],\n  [fxHide.xs], [fxHide.sm], [fxHide.md], [fxHide.lg], [fxHide.xl],\n  [fxHide.lt-sm], [fxHide.lt-md], [fxHide.lt-lg], [fxHide.lt-xl],\n  [fxHide.gt-xs], [fxHide.gt-sm], [fxHide.gt-md], [fxHide.gt-lg]\n";
            /**
             * 'show' Layout API directive
             */
            var DefaultShowHideDirective = /** @class */ (function (_super) {
                __extends(DefaultShowHideDirective, _super);
                function DefaultShowHideDirective() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.inputs = inputs$2;
                    return _this_1;
                }
                return DefaultShowHideDirective;
            }(ShowHideDirective));
            DefaultShowHideDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: selector$2, inputs: inputs$2 },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * NgStyle allowed inputs
             */
            var NgStyleKeyValue = /** @class */ (function () {
                /**
                 * @param {?} key
                 * @param {?} value
                 * @param {?=} noQuotes
                 */
                function NgStyleKeyValue(key, value, noQuotes) {
                    if (noQuotes === void 0) { noQuotes = true; }
                    this.key = key;
                    this.value = value;
                    this.key = noQuotes ? key.replace(/['"]/g, '').trim() : key.trim();
                    this.value = noQuotes ? value.replace(/['"]/g, '').trim() : value.trim();
                    this.value = this.value.replace(/;/, '');
                }
                return NgStyleKeyValue;
            }());
            /**
             * @param {?} target
             * @return {?}
             */
            function getType(target) {
                /** @type {?} */
                var what = typeof target;
                if (what === 'object') {
                    return (target.constructor === Array) ? 'array' :
                        (target.constructor === Set) ? 'set' : 'object';
                }
                return what;
            }
            /**
             * Split string of key:value pairs into Array of k-v pairs
             * e.g.  'key:value; key:value; key:value;' -> ['key:value',...]
             * @param {?} source
             * @param {?=} delimiter
             * @return {?}
             */
            function buildRawList(source, delimiter) {
                if (delimiter === void 0) { delimiter = ';'; }
                return String(source)
                    .trim()
                    .split(delimiter)
                    .map(( /**
             * @param {?} val
             * @return {?}
             */function (val) { return val.trim(); }))
                    .filter(( /**
             * @param {?} val
             * @return {?}
             */function (/**
             * @param {?} val
             * @return {?}
             */ val) { return val !== ''; }));
            }
            /**
             * Convert array of key:value strings to a iterable map object
             * @param {?} styles
             * @param {?=} sanitize
             * @return {?}
             */
            function buildMapFromList(styles, sanitize) {
                /** @type {?} */
                var sanitizeValue = ( /**
                 * @param {?} it
                 * @return {?}
                 */function (it) {
                    if (sanitize) {
                        it.value = sanitize(it.value);
                    }
                    return it;
                });
                return styles
                    .map(stringToKeyValue)
                    .filter(( /**
             * @param {?} entry
             * @return {?}
             */function (/**
             * @param {?} entry
             * @return {?}
             */ entry) { return !!entry; }))
                    .map(sanitizeValue)
                    .reduce(keyValuesToMap, ( /** @type {?} */({})));
            }
            /**
             * Convert Set<string> or raw Object to an iterable NgStyleMap
             * @param {?} source
             * @param {?=} sanitize
             * @return {?}
             */
            function buildMapFromSet(source, sanitize) {
                /** @type {?} */
                var list = [];
                if (getType(source) === 'set') {
                    (( /** @type {?} */(source))).forEach(( /**
                     * @param {?} entry
                     * @return {?}
                     */function (/**
                     * @param {?} entry
                     * @return {?}
                     */ entry) { return list.push(entry); }));
                }
                else {
                    Object.keys(source).forEach(( /**
                     * @param {?} key
                     * @return {?}
                     */function (key) {
                        list.push(key + ":" + (( /** @type {?} */(source)))[key]);
                    }));
                }
                return buildMapFromList(list, sanitize);
            }
            /**
             * Convert 'key:value' -> [key, value]
             * @param {?} it
             * @return {?}
             */
            function stringToKeyValue(it) {
                var _a = it.split(':'), key = _a[0], vals = _a.slice(1);
                return new NgStyleKeyValue(key, vals.join(':'));
            }
            /**
             * Convert [ [key,value] ] -> { key : value }
             * @param {?} map
             * @param {?} entry
             * @return {?}
             */
            function keyValuesToMap(map, entry) {
                if (!!entry.key) {
                    map[entry.key] = entry.value;
                }
                return map;
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var StyleDirective = /** @class */ (function (_super) {
                __extends(StyleDirective, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} styler
                 * @param {?} marshal
                 * @param {?} delegate
                 * @param {?} sanitizer
                 * @param {?} ngStyleInstance
                 * @param {?} serverLoaded
                 * @param {?} platformId
                 */
                function StyleDirective(elementRef, styler, marshal, delegate, sanitizer, ngStyleInstance, serverLoaded, platformId) {
                    var _this_1 = _super.call(this, elementRef, ( /** @type {?} */(null)), styler, marshal) || this;
                    _this_1.elementRef = elementRef;
                    _this_1.styler = styler;
                    _this_1.marshal = marshal;
                    _this_1.delegate = delegate;
                    _this_1.sanitizer = sanitizer;
                    _this_1.ngStyleInstance = ngStyleInstance;
                    _this_1.DIRECTIVE_KEY = 'ngStyle';
                    if (!_this_1.ngStyleInstance) {
                        // Create an instance NgClass Directive instance only if `ngClass=""` has NOT been
                        // defined on the same host element; since the responsive variations may be defined...
                        _this_1.ngStyleInstance = new _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgStyle"](_this_1.delegate);
                    }
                    _this_1.init();
                    /** @type {?} */
                    var styles = _this_1.nativeElement.getAttribute('style') || '';
                    _this_1.fallbackStyles = _this_1.buildStyleMap(styles);
                    _this_1.isServer = serverLoaded && Object(_angular_common__WEBPACK_IMPORTED_MODULE_1__["isPlatformServer"])(platformId);
                    return _this_1;
                }
                /**
                 * Add generated styles
                 * @protected
                 * @param {?} value
                 * @return {?}
                 */
                StyleDirective.prototype.updateWithValue = function (value) {
                    /** @type {?} */
                    var styles = this.buildStyleMap(value);
                    this.ngStyleInstance.ngStyle = Object.assign({}, this.fallbackStyles, styles);
                    if (this.isServer) {
                        this.applyStyleToElement(styles);
                    }
                    this.ngStyleInstance.ngDoCheck();
                };
                /**
                 * Remove generated styles
                 * @protected
                 * @return {?}
                 */
                StyleDirective.prototype.clearStyles = function () {
                    this.ngStyleInstance.ngStyle = this.fallbackStyles;
                    this.ngStyleInstance.ngDoCheck();
                };
                /**
                 * Convert raw strings to ngStyleMap; which is required by ngStyle
                 * NOTE: Raw string key-value pairs MUST be delimited by `;`
                 *       Comma-delimiters are not supported due to complexities of
                 *       possible style values such as `rgba(x,x,x,x)` and others
                 * @protected
                 * @param {?} styles
                 * @return {?}
                 */
                StyleDirective.prototype.buildStyleMap = function (styles) {
                    var _this_1 = this;
                    // Always safe-guard (aka sanitize) style property values
                    /** @type {?} */
                    var sanitizer = ( /**
                     * @param {?} val
                     * @return {?}
                     */function (val) { return _this_1.sanitizer.sanitize(_angular_core__WEBPACK_IMPORTED_MODULE_0__["SecurityContext"].STYLE, val) || ''; });
                    if (styles) {
                        switch (getType(styles)) {
                            case 'string': return buildMapFromList$1(buildRawList(styles), sanitizer);
                            case 'array': return buildMapFromList$1(( /** @type {?} */(styles)), sanitizer);
                            case 'set': return buildMapFromSet(styles, sanitizer);
                            default: return buildMapFromSet(styles, sanitizer);
                        }
                    }
                    return {};
                };
                // ******************************************************************
                // Lifecycle Hooks
                // ******************************************************************
                /**
                 * For ChangeDetectionStrategy.onPush and ngOnChanges() updates
                 * @return {?}
                 */
                StyleDirective.prototype.ngDoCheck = function () {
                    this.ngStyleInstance.ngDoCheck();
                };
                return StyleDirective;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["BaseDirective2"]));
            StyleDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: 'style-directive' },] },
            ];
            /** @nocollapse */
            StyleDirective.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["StyleUtils"] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["MediaMarshaller"] },
                { type: _angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵNgStyleImpl"] },
                { type: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_5__["DomSanitizer"] },
                { type: _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgStyle"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Self"] }] },
                { type: Boolean, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["SERVER_TOKEN"],] }] },
                { type: Object, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["PLATFORM_ID"],] }] }
            ]; };
            /** @type {?} */
            var inputs$3 = [
                'ngStyle',
                'ngStyle.xs', 'ngStyle.sm', 'ngStyle.md', 'ngStyle.lg', 'ngStyle.xl',
                'ngStyle.lt-sm', 'ngStyle.lt-md', 'ngStyle.lt-lg', 'ngStyle.lt-xl',
                'ngStyle.gt-xs', 'ngStyle.gt-sm', 'ngStyle.gt-md', 'ngStyle.gt-lg'
            ];
            /** @type {?} */
            var selector$3 = "\n  [ngStyle],\n  [ngStyle.xs], [ngStyle.sm], [ngStyle.md], [ngStyle.lg], [ngStyle.xl],\n  [ngStyle.lt-sm], [ngStyle.lt-md], [ngStyle.lt-lg], [ngStyle.lt-xl],\n  [ngStyle.gt-xs], [ngStyle.gt-sm], [ngStyle.gt-md], [ngStyle.gt-lg]\n";
            // tslint:disable-next-line:variable-name
            /** @type {?} */
            var LayoutNgStyleImplProvider = {
                provide: _angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵNgStyleImpl"],
                useClass: _angular_common__WEBPACK_IMPORTED_MODULE_1__["ɵNgStyleR2Impl"]
            };
            /**
             * Directive to add responsive support for ngStyle.
             *
             */
            var DefaultStyleDirective = /** @class */ (function (_super) {
                __extends(DefaultStyleDirective, _super);
                function DefaultStyleDirective() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.inputs = inputs$3;
                    return _this_1;
                }
                return DefaultStyleDirective;
            }(StyleDirective));
            DefaultStyleDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: selector$3, inputs: inputs$3, providers: [LayoutNgStyleImplProvider] },] },
            ];
            /**
             * Build a styles map from a list of styles, while sanitizing bad values first
             * @param {?} styles
             * @param {?=} sanitize
             * @return {?}
             */
            function buildMapFromList$1(styles, sanitize) {
                /** @type {?} */
                var sanitizeValue = ( /**
                 * @param {?} it
                 * @return {?}
                 */function (it) {
                    if (sanitize) {
                        it.value = sanitize(it.value);
                    }
                    return it;
                });
                return styles
                    .map(stringToKeyValue)
                    .filter(( /**
             * @param {?} entry
             * @return {?}
             */function (/**
             * @param {?} entry
             * @return {?}
             */ entry) { return !!entry; }))
                    .map(sanitizeValue)
                    .reduce(keyValuesToMap, ( /** @type {?} */({})));
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var ALL_DIRECTIVES = [
                DefaultShowHideDirective,
                DefaultClassDirective,
                DefaultStyleDirective,
                DefaultImgSrcDirective,
                ClassDirective,
                ImgSrcDirective,
                ShowHideDirective,
                StyleDirective,
            ];
            /**
             * *****************************************************************
             * Define module for the Extended API
             * *****************************************************************
             */
            var ExtendedModule = /** @class */ (function () {
                function ExtendedModule() {
                }
                return ExtendedModule;
            }());
            ExtendedModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["CoreModule"]],
                            declarations: ALL_DIRECTIVES.slice(),
                            exports: ALL_DIRECTIVES.slice()
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=extended.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/flex-layout/esm2015/flex-layout.js": 
        /*!******************************************************************!*\
          !*** ./node_modules/@angular/flex-layout/esm2015/flex-layout.js ***!
          \******************************************************************/
        /*! exports provided: ɵMatchMedia, ɵMockMatchMedia, ɵMockMatchMediaProvider, CoreModule, removeStyles, BROWSER_PROVIDER, CLASS_NAME, MediaChange, StylesheetMap, DEFAULT_CONFIG, LAYOUT_CONFIG, SERVER_TOKEN, BREAKPOINT, mergeAlias, BaseDirective2, DEFAULT_BREAKPOINTS, ScreenTypes, ORIENTATION_BREAKPOINTS, BreakPointRegistry, BREAKPOINTS, MediaObserver, MediaTrigger, sortDescendingPriority, sortAscendingPriority, coerceArray, StyleUtils, StyleBuilder, validateBasis, MediaMarshaller, BREAKPOINT_PRINT, PrintHook, ExtendedModule, ClassDirective, LayoutNgClassImplProvider, DefaultClassDirective, ImgSrcStyleBuilder, ImgSrcDirective, DefaultImgSrcDirective, ShowHideStyleBuilder, ShowHideDirective, DefaultShowHideDirective, StyleDirective, LayoutNgStyleImplProvider, DefaultStyleDirective, FlexModule, FlexStyleBuilder, FlexDirective, DefaultFlexDirective, FlexAlignStyleBuilder, FlexAlignDirective, DefaultFlexAlignDirective, FlexFillStyleBuilder, FlexFillDirective, FlexOffsetStyleBuilder, FlexOffsetDirective, DefaultFlexOffsetDirective, FlexOrderStyleBuilder, FlexOrderDirective, DefaultFlexOrderDirective, LayoutStyleBuilder, LayoutDirective, DefaultLayoutDirective, LayoutAlignStyleBuilder, LayoutAlignDirective, DefaultLayoutAlignDirective, LayoutGapStyleBuilder, LayoutGapDirective, DefaultLayoutGapDirective, ɵf2, ɵe2, ɵd2, ɵi2, ɵh2, ɵg2, ɵl2, ɵk2, ɵj2, ɵo2, ɵn2, ɵm2, ɵr2, ɵq2, ɵp2, ɵu2, ɵt2, ɵs2, ɵx2, ɵw2, ɵv2, ɵba2, ɵz2, ɵy2, ɵc2, ɵb2, ɵa2, ɵbd2, ɵbc2, ɵbb2, ɵbg2, ɵbf2, ɵbe2, GridModule, VERSION, FlexLayoutModule */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERSION", function () { return VERSION; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlexLayoutModule", function () { return FlexLayoutModule; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/flex-layout/core */ "./node_modules/@angular/flex-layout/esm2015/core.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵMatchMedia", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["ɵMatchMedia"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵMockMatchMedia", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["ɵMockMatchMedia"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵMockMatchMediaProvider", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["ɵMockMatchMediaProvider"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CoreModule", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["CoreModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "removeStyles", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["removeStyles"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BROWSER_PROVIDER", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["BROWSER_PROVIDER"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CLASS_NAME", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["CLASS_NAME"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MediaChange", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["MediaChange"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StylesheetMap", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["StylesheetMap"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_CONFIG", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_CONFIG"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LAYOUT_CONFIG", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["LAYOUT_CONFIG"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SERVER_TOKEN", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["SERVER_TOKEN"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BREAKPOINT", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["BREAKPOINT"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeAlias", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["mergeAlias"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BaseDirective2", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["BaseDirective2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_BREAKPOINTS", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_BREAKPOINTS"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ScreenTypes", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["ScreenTypes"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ORIENTATION_BREAKPOINTS", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["ORIENTATION_BREAKPOINTS"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BreakPointRegistry", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["BreakPointRegistry"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BREAKPOINTS", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["BREAKPOINTS"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MediaObserver", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["MediaObserver"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MediaTrigger", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["MediaTrigger"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sortDescendingPriority", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["sortDescendingPriority"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sortAscendingPriority", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["sortAscendingPriority"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "coerceArray", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["coerceArray"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StyleUtils", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["StyleUtils"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StyleBuilder", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["StyleBuilder"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "validateBasis", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["validateBasis"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MediaMarshaller", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["MediaMarshaller"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BREAKPOINT_PRINT", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["BREAKPOINT_PRINT"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PrintHook", function () { return _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["PrintHook"]; });
            /* harmony import */ var _angular_flex_layout_extended__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/flex-layout/extended */ "./node_modules/@angular/flex-layout/esm2015/extended.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ExtendedModule", function () { return _angular_flex_layout_extended__WEBPACK_IMPORTED_MODULE_3__["ExtendedModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ClassDirective", function () { return _angular_flex_layout_extended__WEBPACK_IMPORTED_MODULE_3__["ClassDirective"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LayoutNgClassImplProvider", function () { return _angular_flex_layout_extended__WEBPACK_IMPORTED_MODULE_3__["LayoutNgClassImplProvider"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DefaultClassDirective", function () { return _angular_flex_layout_extended__WEBPACK_IMPORTED_MODULE_3__["DefaultClassDirective"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ImgSrcStyleBuilder", function () { return _angular_flex_layout_extended__WEBPACK_IMPORTED_MODULE_3__["ImgSrcStyleBuilder"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ImgSrcDirective", function () { return _angular_flex_layout_extended__WEBPACK_IMPORTED_MODULE_3__["ImgSrcDirective"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DefaultImgSrcDirective", function () { return _angular_flex_layout_extended__WEBPACK_IMPORTED_MODULE_3__["DefaultImgSrcDirective"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ShowHideStyleBuilder", function () { return _angular_flex_layout_extended__WEBPACK_IMPORTED_MODULE_3__["ShowHideStyleBuilder"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ShowHideDirective", function () { return _angular_flex_layout_extended__WEBPACK_IMPORTED_MODULE_3__["ShowHideDirective"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DefaultShowHideDirective", function () { return _angular_flex_layout_extended__WEBPACK_IMPORTED_MODULE_3__["DefaultShowHideDirective"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StyleDirective", function () { return _angular_flex_layout_extended__WEBPACK_IMPORTED_MODULE_3__["StyleDirective"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LayoutNgStyleImplProvider", function () { return _angular_flex_layout_extended__WEBPACK_IMPORTED_MODULE_3__["LayoutNgStyleImplProvider"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DefaultStyleDirective", function () { return _angular_flex_layout_extended__WEBPACK_IMPORTED_MODULE_3__["DefaultStyleDirective"]; });
            /* harmony import */ var _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/flex-layout/flex */ "./node_modules/@angular/flex-layout/esm2015/flex.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FlexModule", function () { return _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__["FlexModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FlexStyleBuilder", function () { return _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__["FlexStyleBuilder"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FlexDirective", function () { return _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__["FlexDirective"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DefaultFlexDirective", function () { return _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__["DefaultFlexDirective"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FlexAlignStyleBuilder", function () { return _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__["FlexAlignStyleBuilder"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FlexAlignDirective", function () { return _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__["FlexAlignDirective"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DefaultFlexAlignDirective", function () { return _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__["DefaultFlexAlignDirective"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FlexFillStyleBuilder", function () { return _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__["FlexFillStyleBuilder"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FlexFillDirective", function () { return _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__["FlexFillDirective"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FlexOffsetStyleBuilder", function () { return _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__["FlexOffsetStyleBuilder"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FlexOffsetDirective", function () { return _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__["FlexOffsetDirective"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DefaultFlexOffsetDirective", function () { return _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__["DefaultFlexOffsetDirective"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FlexOrderStyleBuilder", function () { return _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__["FlexOrderStyleBuilder"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FlexOrderDirective", function () { return _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__["FlexOrderDirective"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DefaultFlexOrderDirective", function () { return _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__["DefaultFlexOrderDirective"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LayoutStyleBuilder", function () { return _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__["LayoutStyleBuilder"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LayoutDirective", function () { return _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__["LayoutDirective"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DefaultLayoutDirective", function () { return _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__["DefaultLayoutDirective"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LayoutAlignStyleBuilder", function () { return _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__["LayoutAlignStyleBuilder"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LayoutAlignDirective", function () { return _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__["LayoutAlignDirective"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DefaultLayoutAlignDirective", function () { return _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__["DefaultLayoutAlignDirective"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LayoutGapStyleBuilder", function () { return _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__["LayoutGapStyleBuilder"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LayoutGapDirective", function () { return _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__["LayoutGapDirective"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DefaultLayoutGapDirective", function () { return _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__["DefaultLayoutGapDirective"]; });
            /* harmony import */ var _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/flex-layout/grid */ "./node_modules/@angular/flex-layout/esm2015/grid.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵf2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵf2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵe2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵe2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵd2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵd2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵi2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵi2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵh2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵh2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵg2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵg2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵl2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵl2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵk2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵk2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵj2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵj2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵo2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵo2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵn2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵn2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵm2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵm2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵr2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵr2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵq2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵq2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵp2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵp2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵu2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵu2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵt2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵt2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵs2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵs2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵx2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵx2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵw2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵw2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵv2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵv2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵba2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵba2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵz2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵz2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵy2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵy2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵc2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵc2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵb2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵb2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵa2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵa2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵbd2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵbd2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵbc2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵbc2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵbb2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵbb2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵbg2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵbg2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵbf2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵbf2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵbe2", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["ɵbe2"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GridModule", function () { return _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["GridModule"]; });
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Current version of Angular Flex-Layout.
             * @type {?}
             */
            var VERSION = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["Version"]('8.0.0-beta.27');
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * FlexLayoutModule -- the main import for all utilities in the Angular Layout library
             * * Will automatically provide Flex, Grid, and Extended modules for use in the application
             * * Can be configured using the static withConfig method, options viewable on the Wiki's
             *   Configuration page
             */
            var FlexLayoutModule = /** @class */ (function () {
                /**
                 * @param {?} serverModuleLoaded
                 * @param {?} platformId
                 */
                function FlexLayoutModule(serverModuleLoaded, platformId) {
                    if (Object(_angular_common__WEBPACK_IMPORTED_MODULE_1__["isPlatformServer"])(platformId) && !serverModuleLoaded) {
                        console.warn('Warning: Flex Layout loaded on the server without FlexLayoutServerModule');
                    }
                }
                /**
                 * Initialize the FlexLayoutModule with a set of config options,
                 * which sets the corresponding tokens accordingly
                 * @param {?} configOptions
                 * @param {?=} breakpoints
                 * @return {?}
                 */
                FlexLayoutModule.withConfig = function (configOptions, breakpoints) {
                    if (breakpoints === void 0) { breakpoints = []; }
                    return {
                        ngModule: FlexLayoutModule,
                        providers: configOptions.serverLoaded ?
                            [
                                { provide: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["LAYOUT_CONFIG"], useValue: Object.assign({}, _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_CONFIG"], configOptions) },
                                { provide: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["BREAKPOINT"], useValue: breakpoints, multi: true },
                                { provide: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["SERVER_TOKEN"], useValue: true },
                            ] : [
                            { provide: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["LAYOUT_CONFIG"], useValue: Object.assign({}, _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_CONFIG"], configOptions) },
                            { provide: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["BREAKPOINT"], useValue: breakpoints, multi: true },
                        ]
                    };
                };
                return FlexLayoutModule;
            }());
            FlexLayoutModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [_angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__["FlexModule"], _angular_flex_layout_extended__WEBPACK_IMPORTED_MODULE_3__["ExtendedModule"], _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["GridModule"]],
                            exports: [_angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__["FlexModule"], _angular_flex_layout_extended__WEBPACK_IMPORTED_MODULE_3__["ExtendedModule"], _angular_flex_layout_grid__WEBPACK_IMPORTED_MODULE_5__["GridModule"]]
                        },] },
            ];
            /** @nocollapse */
            FlexLayoutModule.ctorParameters = function () { return [
                { type: Boolean, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_2__["SERVER_TOKEN"],] }] },
                { type: Object, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["PLATFORM_ID"],] }] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=flex-layout.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/flex-layout/esm2015/flex.js": 
        /*!***********************************************************!*\
          !*** ./node_modules/@angular/flex-layout/esm2015/flex.js ***!
          \***********************************************************/
        /*! exports provided: FlexModule, FlexStyleBuilder, FlexDirective, DefaultFlexDirective, FlexAlignStyleBuilder, FlexAlignDirective, DefaultFlexAlignDirective, FlexFillStyleBuilder, FlexFillDirective, FlexOffsetStyleBuilder, FlexOffsetDirective, DefaultFlexOffsetDirective, FlexOrderStyleBuilder, FlexOrderDirective, DefaultFlexOrderDirective, LayoutStyleBuilder, LayoutDirective, DefaultLayoutDirective, LayoutAlignStyleBuilder, LayoutAlignDirective, DefaultLayoutAlignDirective, LayoutGapStyleBuilder, LayoutGapDirective, DefaultLayoutGapDirective */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlexModule", function () { return FlexModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlexStyleBuilder", function () { return FlexStyleBuilder; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlexDirective", function () { return FlexDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultFlexDirective", function () { return DefaultFlexDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlexAlignStyleBuilder", function () { return FlexAlignStyleBuilder; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlexAlignDirective", function () { return FlexAlignDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultFlexAlignDirective", function () { return DefaultFlexAlignDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlexFillStyleBuilder", function () { return FlexFillStyleBuilder; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlexFillDirective", function () { return FlexFillDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlexOffsetStyleBuilder", function () { return FlexOffsetStyleBuilder; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlexOffsetDirective", function () { return FlexOffsetDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultFlexOffsetDirective", function () { return DefaultFlexOffsetDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlexOrderStyleBuilder", function () { return FlexOrderStyleBuilder; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlexOrderDirective", function () { return FlexOrderDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultFlexOrderDirective", function () { return DefaultFlexOrderDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayoutStyleBuilder", function () { return LayoutStyleBuilder; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayoutDirective", function () { return LayoutDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultLayoutDirective", function () { return DefaultLayoutDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayoutAlignStyleBuilder", function () { return LayoutAlignStyleBuilder; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayoutAlignDirective", function () { return LayoutAlignDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultLayoutAlignDirective", function () { return DefaultLayoutAlignDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayoutGapStyleBuilder", function () { return LayoutGapStyleBuilder; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayoutGapDirective", function () { return LayoutGapDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultLayoutGapDirective", function () { return DefaultLayoutGapDirective; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/flex-layout/core */ "./node_modules/@angular/flex-layout/esm2015/core.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             * @type {?}
             */
            var INLINE = 'inline';
            /** @type {?} */
            var LAYOUT_VALUES = ['row', 'column', 'row-reverse', 'column-reverse'];
            /**
             * Validate the direction|'direction wrap' value and then update the host's inline flexbox styles
             * @param {?} value
             * @return {?}
             */
            function buildLayoutCSS(value) {
                var _a = validateValue(value), direction = _a[0], wrap = _a[1], isInline = _a[2];
                return buildCSS(direction, wrap, isInline);
            }
            /**
             * Validate the value to be one of the acceptable value options
             * Use default fallback of 'row'
             * @param {?} value
             * @return {?}
             */
            function validateValue(value) {
                value = value ? value.toLowerCase() : '';
                var _a = value.split(' '), direction = _a[0], wrap = _a[1], inline = _a[2];
                // First value must be the `flex-direction`
                if (!LAYOUT_VALUES.find(( /**
                 * @param {?} x
                 * @return {?}
                 */function (/**
                 * @param {?} x
                 * @return {?}
                 */ x) { return x === direction; }))) {
                    direction = LAYOUT_VALUES[0];
                }
                if (wrap === INLINE) {
                    wrap = (inline !== INLINE) ? inline : '';
                    inline = INLINE;
                }
                return [direction, validateWrapValue(wrap), !!inline];
            }
            /**
             * Determine if the validated, flex-direction value specifies
             * a horizontal/row flow.
             * @param {?} value
             * @return {?}
             */
            function isFlowHorizontal(value) {
                var flow = validateValue(value)[0];
                return flow.indexOf('row') > -1;
            }
            /**
             * Convert layout-wrap='<value>' to expected flex-wrap style
             * @param {?} value
             * @return {?}
             */
            function validateWrapValue(value) {
                if (!!value) {
                    switch (value.toLowerCase()) {
                        case 'reverse':
                        case 'wrap-reverse':
                        case 'reverse-wrap':
                            value = 'wrap-reverse';
                            break;
                        case 'no':
                        case 'none':
                        case 'nowrap':
                            value = 'nowrap';
                            break;
                        // All other values fallback to 'wrap'
                        default:
                            value = 'wrap';
                            break;
                    }
                }
                return value;
            }
            /**
             * Build the CSS that should be assigned to the element instance
             * BUG:
             *   1) min-height on a column flex container won’t apply to its flex item children in IE 10-11.
             *      Use height instead if possible; height : <xxx>vh;
             *
             *  This way any padding or border specified on the child elements are
             *  laid out and drawn inside that element's specified width and height.
             * @param {?} direction
             * @param {?=} wrap
             * @param {?=} inline
             * @return {?}
             */
            function buildCSS(direction, wrap, inline) {
                if (wrap === void 0) { wrap = null; }
                if (inline === void 0) { inline = false; }
                return {
                    'display': inline ? 'inline-flex' : 'flex',
                    'box-sizing': 'border-box',
                    'flex-direction': direction,
                    'flex-wrap': !!wrap ? wrap : null
                };
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var LayoutStyleBuilder = /** @class */ (function (_super) {
                __extends(LayoutStyleBuilder, _super);
                function LayoutStyleBuilder() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                /**
                 * @param {?} input
                 * @return {?}
                 */
                LayoutStyleBuilder.prototype.buildStyles = function (input) {
                    return buildLayoutCSS(input);
                };
                return LayoutStyleBuilder;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleBuilder"]));
            LayoutStyleBuilder.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */ LayoutStyleBuilder.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function LayoutStyleBuilder_Factory() { return new LayoutStyleBuilder(); }, token: LayoutStyleBuilder, providedIn: "root" });
            /** @type {?} */
            var inputs = [
                'fxLayout', 'fxLayout.xs', 'fxLayout.sm', 'fxLayout.md',
                'fxLayout.lg', 'fxLayout.xl', 'fxLayout.lt-sm', 'fxLayout.lt-md',
                'fxLayout.lt-lg', 'fxLayout.lt-xl', 'fxLayout.gt-xs', 'fxLayout.gt-sm',
                'fxLayout.gt-md', 'fxLayout.gt-lg'
            ];
            /** @type {?} */
            var selector = "\n  [fxLayout], [fxLayout.xs], [fxLayout.sm], [fxLayout.md],\n  [fxLayout.lg], [fxLayout.xl], [fxLayout.lt-sm], [fxLayout.lt-md],\n  [fxLayout.lt-lg], [fxLayout.lt-xl], [fxLayout.gt-xs], [fxLayout.gt-sm],\n  [fxLayout.gt-md], [fxLayout.gt-lg]\n";
            /**
             * 'layout' flexbox styling directive
             * Defines the positioning flow direction for the child elements: row or column
             * Optional values: column or row (default)
             * @see https://css-tricks.com/almanac/properties/f/flex-direction/
             *
             */
            var LayoutDirective = /** @class */ (function (_super) {
                __extends(LayoutDirective, _super);
                /**
                 * @param {?} elRef
                 * @param {?} styleUtils
                 * @param {?} styleBuilder
                 * @param {?} marshal
                 */
                function LayoutDirective(elRef, styleUtils, styleBuilder, marshal) {
                    var _this_1 = _super.call(this, elRef, styleBuilder, styleUtils, marshal) || this;
                    _this_1.elRef = elRef;
                    _this_1.styleUtils = styleUtils;
                    _this_1.styleBuilder = styleBuilder;
                    _this_1.marshal = marshal;
                    _this_1.DIRECTIVE_KEY = 'layout';
                    _this_1.styleCache = layoutCache;
                    _this_1.init();
                    return _this_1;
                }
                return LayoutDirective;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["BaseDirective2"]));
            LayoutDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: 'layout-directive' },] },
            ];
            /** @nocollapse */
            LayoutDirective.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleUtils"] },
                { type: LayoutStyleBuilder, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["MediaMarshaller"] }
            ]; };
            var DefaultLayoutDirective = /** @class */ (function (_super) {
                __extends(DefaultLayoutDirective, _super);
                function DefaultLayoutDirective() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.inputs = inputs;
                    return _this_1;
                }
                return DefaultLayoutDirective;
            }(LayoutDirective));
            DefaultLayoutDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: selector, inputs: inputs },] },
            ];
            /** @type {?} */
            var layoutCache = new Map();
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var CLEAR_MARGIN_CSS = {
                'margin-left': null,
                'margin-right': null,
                'margin-top': null,
                'margin-bottom': null
            };
            var LayoutGapStyleBuilder = /** @class */ (function (_super) {
                __extends(LayoutGapStyleBuilder, _super);
                /**
                 * @param {?} _styler
                 */
                function LayoutGapStyleBuilder(_styler) {
                    var _this_1 = _super.call(this) || this;
                    _this_1._styler = _styler;
                    return _this_1;
                }
                /**
                 * @param {?} gapValue
                 * @param {?} parent
                 * @return {?}
                 */
                LayoutGapStyleBuilder.prototype.buildStyles = function (gapValue, parent) {
                    if (gapValue.endsWith(GRID_SPECIFIER)) {
                        gapValue = gapValue.slice(0, gapValue.indexOf(GRID_SPECIFIER));
                        // Add the margin to the host element
                        return buildGridMargin(gapValue, parent.directionality);
                    }
                    else {
                        return {};
                    }
                };
                /**
                 * @param {?} gapValue
                 * @param {?} _styles
                 * @param {?} parent
                 * @return {?}
                 */
                LayoutGapStyleBuilder.prototype.sideEffect = function (gapValue, _styles, parent) {
                    /** @type {?} */
                    var items = parent.items;
                    if (gapValue.endsWith(GRID_SPECIFIER)) {
                        gapValue = gapValue.slice(0, gapValue.indexOf(GRID_SPECIFIER));
                        // For each `element` children, set the padding
                        /** @type {?} */
                        var paddingStyles = buildGridPadding(gapValue, parent.directionality);
                        this._styler.applyStyleToElements(paddingStyles, parent.items);
                    }
                    else {
                        /** @type {?} */
                        var lastItem = ( /** @type {?} */(items.pop()));
                        // For each `element` children EXCEPT the last,
                        // set the margin right/bottom styles...
                        /** @type {?} */
                        var gapCss = buildGapCSS(gapValue, parent);
                        this._styler.applyStyleToElements(gapCss, items);
                        // Clear all gaps for all visible elements
                        this._styler.applyStyleToElements(CLEAR_MARGIN_CSS, [lastItem]);
                    }
                };
                return LayoutGapStyleBuilder;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleBuilder"]));
            LayoutGapStyleBuilder.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */
            LayoutGapStyleBuilder.ctorParameters = function () { return [
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleUtils"] }
            ]; };
            /** @nocollapse */ LayoutGapStyleBuilder.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function LayoutGapStyleBuilder_Factory() { return new LayoutGapStyleBuilder(Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleUtils"])); }, token: LayoutGapStyleBuilder, providedIn: "root" });
            /** @type {?} */
            var inputs$1 = [
                'fxLayoutGap', 'fxLayoutGap.xs', 'fxLayoutGap.sm', 'fxLayoutGap.md',
                'fxLayoutGap.lg', 'fxLayoutGap.xl', 'fxLayoutGap.lt-sm', 'fxLayoutGap.lt-md',
                'fxLayoutGap.lt-lg', 'fxLayoutGap.lt-xl', 'fxLayoutGap.gt-xs', 'fxLayoutGap.gt-sm',
                'fxLayoutGap.gt-md', 'fxLayoutGap.gt-lg'
            ];
            /** @type {?} */
            var selector$1 = "\n  [fxLayoutGap], [fxLayoutGap.xs], [fxLayoutGap.sm], [fxLayoutGap.md],\n  [fxLayoutGap.lg], [fxLayoutGap.xl], [fxLayoutGap.lt-sm], [fxLayoutGap.lt-md],\n  [fxLayoutGap.lt-lg], [fxLayoutGap.lt-xl], [fxLayoutGap.gt-xs], [fxLayoutGap.gt-sm],\n  [fxLayoutGap.gt-md], [fxLayoutGap.gt-lg]\n";
            /**
             * 'layout-padding' styling directive
             *  Defines padding of child elements in a layout container
             */
            var LayoutGapDirective = /** @class */ (function (_super) {
                __extends(LayoutGapDirective, _super);
                /**
                 * @param {?} elRef
                 * @param {?} zone
                 * @param {?} directionality
                 * @param {?} styleUtils
                 * @param {?} styleBuilder
                 * @param {?} marshal
                 */
                function LayoutGapDirective(elRef, zone, directionality, styleUtils, styleBuilder, marshal) {
                    var _this_1 = _super.call(this, elRef, styleBuilder, styleUtils, marshal) || this;
                    _this_1.elRef = elRef;
                    _this_1.zone = zone;
                    _this_1.directionality = directionality;
                    _this_1.styleUtils = styleUtils;
                    _this_1.styleBuilder = styleBuilder;
                    _this_1.marshal = marshal;
                    _this_1.layout = 'row'; // default flex-direction
                    // default flex-direction
                    _this_1.DIRECTIVE_KEY = 'layout-gap';
                    _this_1.observerSubject = new rxjs__WEBPACK_IMPORTED_MODULE_3__["Subject"]();
                    /** @type {?} */
                    var extraTriggers = [_this_1.directionality.change, _this_1.observerSubject.asObservable()];
                    _this_1.init(extraTriggers);
                    _this_1.marshal
                        .trackValue(_this_1.nativeElement, 'layout')
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["takeUntil"])(_this_1.destroySubject))
                        .subscribe(_this_1.onLayoutChange.bind(_this_1));
                    return _this_1;
                }
                Object.defineProperty(LayoutGapDirective.prototype, "childrenNodes", {
                    /**
                     * Special accessor to query for all child 'element' nodes regardless of type, class, etc
                     * @protected
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var obj = this.nativeElement.children;
                        /** @type {?} */
                        var buffer = [];
                        // iterate backwards ensuring that length is an UInt32
                        for (var i = obj.length; i--;) {
                            buffer[i] = obj[i];
                        }
                        return buffer;
                    },
                    enumerable: true,
                    configurable: true
                });
                // *********************************************
                // Lifecycle Methods
                // *********************************************
                /**
                 * @return {?}
                 */
                LayoutGapDirective.prototype.ngAfterContentInit = function () {
                    this.buildChildObservable();
                    this.triggerUpdate();
                };
                /**
                 * @return {?}
                 */
                LayoutGapDirective.prototype.ngOnDestroy = function () {
                    _super.prototype.ngOnDestroy.call(this);
                    if (this.observer) {
                        this.observer.disconnect();
                    }
                };
                // *********************************************
                // Protected methods
                // *********************************************
                /**
                 * Cache the parent container 'flex-direction' and update the 'margin' styles
                 * @protected
                 * @param {?} matcher
                 * @return {?}
                 */
                LayoutGapDirective.prototype.onLayoutChange = function (matcher) {
                    var _this_1 = this;
                    /** @type {?} */
                    var layout = matcher.value;
                    // Make sure to filter out 'wrap' option
                    /** @type {?} */
                    var direction = layout.split(' ');
                    this.layout = direction[0];
                    if (!LAYOUT_VALUES.find(( /**
                     * @param {?} x
                     * @return {?}
                     */function (/**
                     * @param {?} x
                     * @return {?}
                     */ x) { return x === _this_1.layout; }))) {
                        this.layout = 'row';
                    }
                    this.triggerUpdate();
                };
                /**
                 *
                 * @protected
                 * @param {?} value
                 * @return {?}
                 */
                LayoutGapDirective.prototype.updateWithValue = function (value) {
                    var _this_1 = this;
                    // Gather all non-hidden Element nodes
                    /** @type {?} */
                    var items = this.childrenNodes
                        .filter(( /**
                 * @param {?} el
                 * @return {?}
                 */function (/**
                 * @param {?} el
                 * @return {?}
                 */ el) { return el.nodeType === 1 && _this_1.willDisplay(el); }))
                        .sort(( /**
                 * @param {?} a
                 * @param {?} b
                 * @return {?}
                 */function (a, b) {
                        /** @type {?} */
                        var orderA = +_this_1.styler.lookupStyle(a, 'order');
                        /** @type {?} */
                        var orderB = +_this_1.styler.lookupStyle(b, 'order');
                        if (isNaN(orderA) || isNaN(orderB) || orderA === orderB) {
                            return 0;
                        }
                        else {
                            return orderA > orderB ? 1 : -1;
                        }
                    }));
                    if (items.length > 0) {
                        /** @type {?} */
                        var directionality = this.directionality.value;
                        /** @type {?} */
                        var layout = this.layout;
                        if (layout === 'row' && directionality === 'rtl') {
                            this.styleCache = layoutGapCacheRowRtl;
                        }
                        else if (layout === 'row' && directionality !== 'rtl') {
                            this.styleCache = layoutGapCacheRowLtr;
                        }
                        else if (layout === 'column' && directionality === 'rtl') {
                            this.styleCache = layoutGapCacheColumnRtl;
                        }
                        else if (layout === 'column' && directionality !== 'rtl') {
                            this.styleCache = layoutGapCacheColumnLtr;
                        }
                        this.addStyles(value, { directionality: directionality, items: items, layout: layout });
                    }
                };
                /**
                 * We need to override clearStyles because in most cases mru isn't populated
                 * @protected
                 * @return {?}
                 */
                LayoutGapDirective.prototype.clearStyles = function () {
                    var _a;
                    /** @type {?} */
                    var gridMode = Object.keys(this.mru).length > 0;
                    /** @type {?} */
                    var childrenStyle = gridMode ? 'padding' :
                        getMarginType(this.directionality.value, this.layout);
                    // If there are styles on the parent remove them
                    if (gridMode) {
                        _super.prototype.clearStyles.call(this);
                    }
                    // Then remove the children styles too
                    this.styleUtils.applyStyleToElements((_a = {}, _a[childrenStyle] = '', _a), this.childrenNodes);
                };
                /**
                 * Determine if an element will show or hide based on current activation
                 * @protected
                 * @param {?} source
                 * @return {?}
                 */
                LayoutGapDirective.prototype.willDisplay = function (source) {
                    /** @type {?} */
                    var value = this.marshal.getValue(source, 'show-hide');
                    return value === true ||
                        (value === undefined && this.styleUtils.lookupStyle(source, 'display') !== 'none');
                };
                /**
                 * @protected
                 * @return {?}
                 */
                LayoutGapDirective.prototype.buildChildObservable = function () {
                    var _this_1 = this;
                    this.zone.runOutsideAngular(( /**
                     * @return {?}
                     */function () {
                        if (typeof MutationObserver !== 'undefined') {
                            _this_1.observer = new MutationObserver(( /**
                             * @param {?} mutations
                             * @return {?}
                             */function (mutations) {
                                /** @type {?} */
                                var validatedChanges = ( /**
                                 * @param {?} it
                                 * @return {?}
                                 */function (it) {
                                    return (it.addedNodes && it.addedNodes.length > 0) ||
                                        (it.removedNodes && it.removedNodes.length > 0);
                                });
                                // update gap styles only for child 'added' or 'removed' events
                                if (mutations.some(validatedChanges)) {
                                    _this_1.observerSubject.next();
                                }
                            }));
                            _this_1.observer.observe(_this_1.nativeElement, { childList: true });
                        }
                    }));
                };
                return LayoutGapDirective;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["BaseDirective2"]));
            LayoutGapDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: 'layout-gap-directive' },] },
            ];
            /** @nocollapse */
            LayoutGapDirective.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__["Directionality"] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleUtils"] },
                { type: LayoutGapStyleBuilder, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["MediaMarshaller"] }
            ]; };
            var DefaultLayoutGapDirective = /** @class */ (function (_super) {
                __extends(DefaultLayoutGapDirective, _super);
                function DefaultLayoutGapDirective() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.inputs = inputs$1;
                    return _this_1;
                }
                return DefaultLayoutGapDirective;
            }(LayoutGapDirective));
            DefaultLayoutGapDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: selector$1, inputs: inputs$1 },] },
            ];
            /** @type {?} */
            var layoutGapCacheRowRtl = new Map();
            /** @type {?} */
            var layoutGapCacheColumnRtl = new Map();
            /** @type {?} */
            var layoutGapCacheRowLtr = new Map();
            /** @type {?} */
            var layoutGapCacheColumnLtr = new Map();
            /** @type {?} */
            var GRID_SPECIFIER = ' grid';
            /**
             * @param {?} value
             * @param {?} directionality
             * @return {?}
             */
            function buildGridPadding(value, directionality) {
                /** @type {?} */
                var paddingTop = '0px';
                /** @type {?} */
                var paddingRight = '0px';
                /** @type {?} */
                var paddingBottom = value;
                /** @type {?} */
                var paddingLeft = '0px';
                if (directionality === 'rtl') {
                    paddingLeft = value;
                }
                else {
                    paddingRight = value;
                }
                return { 'padding': paddingTop + " " + paddingRight + " " + paddingBottom + " " + paddingLeft };
            }
            /**
             * @param {?} value
             * @param {?} directionality
             * @return {?}
             */
            function buildGridMargin(value, directionality) {
                /** @type {?} */
                var marginTop = '0px';
                /** @type {?} */
                var marginRight = '0px';
                /** @type {?} */
                var marginBottom = '-' + value;
                /** @type {?} */
                var marginLeft = '0px';
                if (directionality === 'rtl') {
                    marginLeft = '-' + value;
                }
                else {
                    marginRight = '-' + value;
                }
                return { 'margin': marginTop + " " + marginRight + " " + marginBottom + " " + marginLeft };
            }
            /**
             * @param {?} directionality
             * @param {?} layout
             * @return {?}
             */
            function getMarginType(directionality, layout) {
                switch (layout) {
                    case 'column':
                        return 'margin-bottom';
                    case 'column-reverse':
                        return 'margin-top';
                    case 'row':
                        return directionality === 'rtl' ? 'margin-left' : 'margin-right';
                    case 'row-reverse':
                        return directionality === 'rtl' ? 'margin-right' : 'margin-left';
                    default:
                        return directionality === 'rtl' ? 'margin-left' : 'margin-right';
                }
            }
            /**
             * @param {?} gapValue
             * @param {?} parent
             * @return {?}
             */
            function buildGapCSS(gapValue, parent) {
                /** @type {?} */
                var key = getMarginType(parent.directionality, parent.layout);
                /** @type {?} */
                var margins = Object.assign({}, CLEAR_MARGIN_CSS);
                margins[key] = gapValue;
                return margins;
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Extends an object with the *enumerable* and *own* properties of one or more source objects,
             * similar to Object.assign.
             *
             * @param {?} dest The object which will have properties copied to it.
             * @param {...?} sources The source objects from which properties will be copied.
             * @return {?}
             */
            function extendObject(dest) {
                var sources = [];
                for (var _a = 1; _a < arguments.length; _a++) {
                    sources[_a - 1] = arguments[_a];
                }
                if (dest == null) {
                    throw TypeError('Cannot convert undefined or null to object');
                }
                for (var _b = 0, sources_2 = sources; _b < sources_2.length; _b++) {
                    var source = sources_2[_b];
                    if (source != null) {
                        for (var key in source) {
                            if (source.hasOwnProperty(key)) {
                                dest[key] = source[key];
                            }
                        }
                    }
                }
                return dest;
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var FlexStyleBuilder = /** @class */ (function (_super) {
                __extends(FlexStyleBuilder, _super);
                /**
                 * @param {?} layoutConfig
                 */
                function FlexStyleBuilder(layoutConfig) {
                    var _this_1 = _super.call(this) || this;
                    _this_1.layoutConfig = layoutConfig;
                    return _this_1;
                }
                /**
                 * @param {?} input
                 * @param {?} parent
                 * @return {?}
                 */
                FlexStyleBuilder.prototype.buildStyles = function (input, parent) {
                    var _a = input.split(' '), grow = _a[0], shrink = _a[1], basisParts = _a.slice(2);
                    /** @type {?} */
                    var basis = basisParts.join(' ');
                    // The flex-direction of this element's flex container. Defaults to 'row'.
                    /** @type {?} */
                    var direction = (parent.direction.indexOf('column') > -1) ? 'column' : 'row';
                    /** @type {?} */
                    var max = isFlowHorizontal(direction) ? 'max-width' : 'max-height';
                    /** @type {?} */
                    var min = isFlowHorizontal(direction) ? 'min-width' : 'min-height';
                    /** @type {?} */
                    var hasCalc = String(basis).indexOf('calc') > -1;
                    /** @type {?} */
                    var usingCalc = hasCalc || (basis === 'auto');
                    /** @type {?} */
                    var isPercent = String(basis).indexOf('%') > -1 && !hasCalc;
                    /** @type {?} */
                    var hasUnits = String(basis).indexOf('px') > -1 || String(basis).indexOf('rem') > -1 ||
                        String(basis).indexOf('em') > -1 || String(basis).indexOf('vw') > -1 ||
                        String(basis).indexOf('vh') > -1;
                    /** @type {?} */
                    var isValue = (hasCalc || hasUnits);
                    grow = (grow == '0') ? 0 : grow;
                    shrink = (shrink == '0') ? 0 : shrink;
                    // make box inflexible when shrink and grow are both zero
                    // should not set a min when the grow is zero
                    // should not set a max when the shrink is zero
                    /** @type {?} */
                    var isFixed = !grow && !shrink;
                    /** @type {?} */
                    var css = {};
                    // flex-basis allows you to specify the initial/starting main-axis size of the element,
                    // before anything else is computed. It can either be a percentage or an absolute value.
                    // It is, however, not the breaking point for flex-grow/shrink properties
                    //
                    // flex-grow can be seen as this:
                    //   0: Do not stretch. Either size to element's content width, or obey 'flex-basis'.
                    //   1: (Default value). Stretch; will be the same size to all other flex items on
                    //       the same row since they have a default value of 1.
                    //   ≥2 (integer n): Stretch. Will be n times the size of other elements
                    //      with 'flex-grow: 1' on the same row.
                    // Use `null` to clear existing styles.
                    /** @type {?} */
                    var clearStyles = {
                        'max-width': null,
                        'max-height': null,
                        'min-width': null,
                        'min-height': null
                    };
                    switch (basis || '') {
                        case '':
                            /** @type {?} */
                            var useColumnBasisZero = this.layoutConfig.useColumnBasisZero !== false;
                            basis = direction === 'row' ? '0%' : (useColumnBasisZero ? '0.000000001px' : 'auto');
                            break;
                        case 'initial': // default
                        case 'nogrow':
                            grow = 0;
                            basis = 'auto';
                            break;
                        case 'grow':
                            basis = '100%';
                            break;
                        case 'noshrink':
                            shrink = 0;
                            basis = 'auto';
                            break;
                        case 'auto':
                            break;
                        case 'none':
                            grow = 0;
                            shrink = 0;
                            basis = 'auto';
                            break;
                        default:
                            // Defaults to percentage sizing unless `px` is explicitly set
                            if (!isValue && !isPercent && !isNaN(( /** @type {?} */(basis)))) {
                                basis = basis + '%';
                            }
                            // Fix for issue 280
                            if (basis === '0%') {
                                isValue = true;
                            }
                            if (basis === '0px') {
                                basis = '0%';
                            }
                            // fix issue #5345
                            if (hasCalc) {
                                css = extendObject(clearStyles, {
                                    'flex-grow': grow,
                                    'flex-shrink': shrink,
                                    'flex-basis': isValue ? basis : '100%'
                                });
                            }
                            else {
                                css = extendObject(clearStyles, {
                                    'flex': grow + " " + shrink + " " + (isValue ? basis : '100%')
                                });
                            }
                            break;
                    }
                    if (!(css['flex'] || css['flex-grow'])) {
                        if (hasCalc) {
                            css = extendObject(clearStyles, {
                                'flex-grow': grow,
                                'flex-shrink': shrink,
                                'flex-basis': basis
                            });
                        }
                        else {
                            css = extendObject(clearStyles, {
                                'flex': grow + " " + shrink + " " + basis
                            });
                        }
                    }
                    // Fix for issues 277, 534, and 728
                    if (basis !== '0%' && basis !== '0px' && basis !== '0.000000001px' && basis !== 'auto') {
                        css[min] = isFixed || (isValue && grow) ? basis : null;
                        css[max] = isFixed || (!usingCalc && shrink) ? basis : null;
                    }
                    // Fix for issue 528
                    if (!css[min] && !css[max]) {
                        if (hasCalc) {
                            css = extendObject(clearStyles, {
                                'flex-grow': grow,
                                'flex-shrink': shrink,
                                'flex-basis': basis
                            });
                        }
                        else {
                            css = extendObject(clearStyles, {
                                'flex': grow + " " + shrink + " " + basis
                            });
                        }
                    }
                    else {
                        // Fix for issue 660
                        if (parent.hasWrap) {
                            css[hasCalc ? 'flex-basis' : 'flex'] = css[max] ?
                                (hasCalc ? css[max] : grow + " " + shrink + " " + css[max]) :
                                (hasCalc ? css[min] : grow + " " + shrink + " " + css[min]);
                        }
                    }
                    return ( /** @type {?} */(extendObject(css, { 'box-sizing': 'border-box' })));
                };
                return FlexStyleBuilder;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleBuilder"]));
            FlexStyleBuilder.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */
            FlexStyleBuilder.ctorParameters = function () { return [
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["LAYOUT_CONFIG"],] }] }
            ]; };
            /** @nocollapse */ FlexStyleBuilder.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function FlexStyleBuilder_Factory() { return new FlexStyleBuilder(Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["LAYOUT_CONFIG"])); }, token: FlexStyleBuilder, providedIn: "root" });
            /** @type {?} */
            var inputs$2 = [
                'fxFlex', 'fxFlex.xs', 'fxFlex.sm', 'fxFlex.md',
                'fxFlex.lg', 'fxFlex.xl', 'fxFlex.lt-sm', 'fxFlex.lt-md',
                'fxFlex.lt-lg', 'fxFlex.lt-xl', 'fxFlex.gt-xs', 'fxFlex.gt-sm',
                'fxFlex.gt-md', 'fxFlex.gt-lg'
            ];
            /** @type {?} */
            var selector$2 = "\n  [fxFlex], [fxFlex.xs], [fxFlex.sm], [fxFlex.md],\n  [fxFlex.lg], [fxFlex.xl], [fxFlex.lt-sm], [fxFlex.lt-md],\n  [fxFlex.lt-lg], [fxFlex.lt-xl], [fxFlex.gt-xs], [fxFlex.gt-sm],\n  [fxFlex.gt-md], [fxFlex.gt-lg]\n";
            /**
             * Directive to control the size of a flex item using flex-basis, flex-grow, and flex-shrink.
             * Corresponds to the css `flex` shorthand property.
             *
             * @see https://css-tricks.com/snippets/css/a-guide-to-flexbox/
             */
            var FlexDirective = /** @class */ (function (_super) {
                __extends(FlexDirective, _super);
                /**
                 * @param {?} elRef
                 * @param {?} styleUtils
                 * @param {?} layoutConfig
                 * @param {?} styleBuilder
                 * @param {?} marshal
                 */
                function FlexDirective(elRef, styleUtils, layoutConfig, styleBuilder, marshal) {
                    var _this_1 = _super.call(this, elRef, styleBuilder, styleUtils, marshal) || this;
                    _this_1.elRef = elRef;
                    _this_1.styleUtils = styleUtils;
                    _this_1.layoutConfig = layoutConfig;
                    _this_1.styleBuilder = styleBuilder;
                    _this_1.marshal = marshal;
                    _this_1.DIRECTIVE_KEY = 'flex';
                    _this_1.direction = '';
                    _this_1.wrap = false;
                    _this_1.flexGrow = '1';
                    _this_1.flexShrink = '1';
                    _this_1.init();
                    if (_this_1.parentElement) {
                        _this_1.marshal.trackValue(_this_1.parentElement, 'layout')
                            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["takeUntil"])(_this_1.destroySubject))
                            .subscribe(_this_1.onLayoutChange.bind(_this_1));
                        _this_1.marshal.trackValue(_this_1.nativeElement, 'layout-align')
                            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["takeUntil"])(_this_1.destroySubject))
                            .subscribe(_this_1.triggerReflow.bind(_this_1));
                    }
                    return _this_1;
                }
                Object.defineProperty(FlexDirective.prototype, "shrink", {
                    /**
                     * @return {?}
                     */
                    get: function () { return this.flexShrink; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this.flexShrink = value || '1';
                        this.triggerReflow();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(FlexDirective.prototype, "grow", {
                    /**
                     * @return {?}
                     */
                    get: function () { return this.flexGrow; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this.flexGrow = value || '1';
                        this.triggerReflow();
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Caches the parent container's 'flex-direction' and updates the element's style.
                 * Used as a handler for layout change events from the parent flex container.
                 * @protected
                 * @param {?} matcher
                 * @return {?}
                 */
                FlexDirective.prototype.onLayoutChange = function (matcher) {
                    /** @type {?} */
                    var layout = matcher.value;
                    /** @type {?} */
                    var layoutParts = layout.split(' ');
                    this.direction = layoutParts[0];
                    this.wrap = layoutParts[1] !== undefined && layoutParts[1] === 'wrap';
                    this.triggerUpdate();
                };
                /**
                 * Input to this is exclusively the basis input value
                 * @protected
                 * @param {?} value
                 * @return {?}
                 */
                FlexDirective.prototype.updateWithValue = function (value) {
                    /** @type {?} */
                    var addFlexToParent = this.layoutConfig.addFlexToParent !== false;
                    if (!this.direction) {
                        this.direction = this.getFlexFlowDirection(( /** @type {?} */(this.parentElement)), addFlexToParent);
                    }
                    /** @type {?} */
                    var direction = this.direction;
                    /** @type {?} */
                    var isHorizontal = direction.startsWith('row');
                    /** @type {?} */
                    var hasWrap = this.wrap;
                    if (isHorizontal && hasWrap) {
                        this.styleCache = flexRowWrapCache;
                    }
                    else if (isHorizontal && !hasWrap) {
                        this.styleCache = flexRowCache;
                    }
                    else if (!isHorizontal && hasWrap) {
                        this.styleCache = flexColumnWrapCache;
                    }
                    else if (!isHorizontal && !hasWrap) {
                        this.styleCache = flexColumnCache;
                    }
                    /** @type {?} */
                    var basis = String(value).replace(';', '');
                    /** @type {?} */
                    var parts = Object(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["validateBasis"])(basis, this.flexGrow, this.flexShrink);
                    this.addStyles(parts.join(' '), { direction: direction, hasWrap: hasWrap });
                };
                /**
                 * Trigger a style reflow, usually based on a shrink/grow input event
                 * @protected
                 * @return {?}
                 */
                FlexDirective.prototype.triggerReflow = function () {
                    /** @type {?} */
                    var activatedValue = this.activatedValue;
                    if (activatedValue !== undefined) {
                        /** @type {?} */
                        var parts = Object(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["validateBasis"])(activatedValue + '', this.flexGrow, this.flexShrink);
                        this.marshal.updateElement(this.nativeElement, this.DIRECTIVE_KEY, parts.join(' '));
                    }
                };
                return FlexDirective;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["BaseDirective2"]));
            FlexDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: 'flex-directive' },] },
            ];
            /** @nocollapse */
            FlexDirective.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleUtils"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["LAYOUT_CONFIG"],] }] },
                { type: FlexStyleBuilder },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["MediaMarshaller"] }
            ]; };
            FlexDirective.propDecorators = {
                shrink: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['fxShrink',] }],
                grow: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['fxGrow',] }]
            };
            var DefaultFlexDirective = /** @class */ (function (_super) {
                __extends(DefaultFlexDirective, _super);
                function DefaultFlexDirective() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.inputs = inputs$2;
                    return _this_1;
                }
                return DefaultFlexDirective;
            }(FlexDirective));
            DefaultFlexDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ inputs: inputs$2, selector: selector$2 },] },
            ];
            /** @type {?} */
            var flexRowCache = new Map();
            /** @type {?} */
            var flexColumnCache = new Map();
            /** @type {?} */
            var flexRowWrapCache = new Map();
            /** @type {?} */
            var flexColumnWrapCache = new Map();
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var FlexOrderStyleBuilder = /** @class */ (function (_super) {
                __extends(FlexOrderStyleBuilder, _super);
                function FlexOrderStyleBuilder() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                /**
                 * @param {?} value
                 * @return {?}
                 */
                FlexOrderStyleBuilder.prototype.buildStyles = function (value) {
                    return { order: (value && parseInt(value, 10)) || '' };
                };
                return FlexOrderStyleBuilder;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleBuilder"]));
            FlexOrderStyleBuilder.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */ FlexOrderStyleBuilder.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function FlexOrderStyleBuilder_Factory() { return new FlexOrderStyleBuilder(); }, token: FlexOrderStyleBuilder, providedIn: "root" });
            /** @type {?} */
            var inputs$3 = [
                'fxFlexOrder', 'fxFlexOrder.xs', 'fxFlexOrder.sm', 'fxFlexOrder.md',
                'fxFlexOrder.lg', 'fxFlexOrder.xl', 'fxFlexOrder.lt-sm', 'fxFlexOrder.lt-md',
                'fxFlexOrder.lt-lg', 'fxFlexOrder.lt-xl', 'fxFlexOrder.gt-xs', 'fxFlexOrder.gt-sm',
                'fxFlexOrder.gt-md', 'fxFlexOrder.gt-lg'
            ];
            /** @type {?} */
            var selector$3 = "\n  [fxFlexOrder], [fxFlexOrder.xs], [fxFlexOrder.sm], [fxFlexOrder.md],\n  [fxFlexOrder.lg], [fxFlexOrder.xl], [fxFlexOrder.lt-sm], [fxFlexOrder.lt-md],\n  [fxFlexOrder.lt-lg], [fxFlexOrder.lt-xl], [fxFlexOrder.gt-xs], [fxFlexOrder.gt-sm],\n  [fxFlexOrder.gt-md], [fxFlexOrder.gt-lg]\n";
            /**
             * 'flex-order' flexbox styling directive
             * Configures the positional ordering of the element in a sorted layout container
             * @see https://css-tricks.com/almanac/properties/o/order/
             */
            var FlexOrderDirective = /** @class */ (function (_super) {
                __extends(FlexOrderDirective, _super);
                /**
                 * @param {?} elRef
                 * @param {?} styleUtils
                 * @param {?} styleBuilder
                 * @param {?} marshal
                 */
                function FlexOrderDirective(elRef, styleUtils, styleBuilder, marshal) {
                    var _this_1 = _super.call(this, elRef, styleBuilder, styleUtils, marshal) || this;
                    _this_1.elRef = elRef;
                    _this_1.styleUtils = styleUtils;
                    _this_1.styleBuilder = styleBuilder;
                    _this_1.marshal = marshal;
                    _this_1.DIRECTIVE_KEY = 'flex-order';
                    _this_1.styleCache = flexOrderCache;
                    _this_1.init();
                    return _this_1;
                }
                return FlexOrderDirective;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["BaseDirective2"]));
            FlexOrderDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: 'flex-order-directive' },] },
            ];
            /** @nocollapse */
            FlexOrderDirective.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleUtils"] },
                { type: FlexOrderStyleBuilder, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["MediaMarshaller"] }
            ]; };
            /** @type {?} */
            var flexOrderCache = new Map();
            var DefaultFlexOrderDirective = /** @class */ (function (_super) {
                __extends(DefaultFlexOrderDirective, _super);
                function DefaultFlexOrderDirective() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.inputs = inputs$3;
                    return _this_1;
                }
                return DefaultFlexOrderDirective;
            }(FlexOrderDirective));
            DefaultFlexOrderDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: selector$3, inputs: inputs$3 },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var FlexOffsetStyleBuilder = /** @class */ (function (_super) {
                __extends(FlexOffsetStyleBuilder, _super);
                function FlexOffsetStyleBuilder() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                /**
                 * @param {?} offset
                 * @param {?} parent
                 * @return {?}
                 */
                FlexOffsetStyleBuilder.prototype.buildStyles = function (offset, parent) {
                    var _a;
                    if (offset === '') {
                        offset = '0';
                    }
                    /** @type {?} */
                    var isPercent = String(offset).indexOf('%') > -1;
                    /** @type {?} */
                    var isPx = String(offset).indexOf('px') > -1;
                    if (!isPx && !isPercent && !isNaN(+offset)) {
                        offset = offset + '%';
                    }
                    /** @type {?} */
                    var horizontalLayoutKey = parent.isRtl ? 'margin-right' : 'margin-left';
                    /** @type {?} */
                    var styles = isFlowHorizontal(parent.layout) ? (_a = {}, _a[horizontalLayoutKey] = "" + offset, _a) : { 'margin-top': "" + offset };
                    return styles;
                };
                return FlexOffsetStyleBuilder;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleBuilder"]));
            FlexOffsetStyleBuilder.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */ FlexOffsetStyleBuilder.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function FlexOffsetStyleBuilder_Factory() { return new FlexOffsetStyleBuilder(); }, token: FlexOffsetStyleBuilder, providedIn: "root" });
            /** @type {?} */
            var inputs$4 = [
                'fxFlexOffset', 'fxFlexOffset.xs', 'fxFlexOffset.sm', 'fxFlexOffset.md',
                'fxFlexOffset.lg', 'fxFlexOffset.xl', 'fxFlexOffset.lt-sm', 'fxFlexOffset.lt-md',
                'fxFlexOffset.lt-lg', 'fxFlexOffset.lt-xl', 'fxFlexOffset.gt-xs', 'fxFlexOffset.gt-sm',
                'fxFlexOffset.gt-md', 'fxFlexOffset.gt-lg'
            ];
            /** @type {?} */
            var selector$4 = "\n  [fxFlexOffset], [fxFlexOffset.xs], [fxFlexOffset.sm], [fxFlexOffset.md],\n  [fxFlexOffset.lg], [fxFlexOffset.xl], [fxFlexOffset.lt-sm], [fxFlexOffset.lt-md],\n  [fxFlexOffset.lt-lg], [fxFlexOffset.lt-xl], [fxFlexOffset.gt-xs], [fxFlexOffset.gt-sm],\n  [fxFlexOffset.gt-md], [fxFlexOffset.gt-lg]\n";
            /**
             * 'flex-offset' flexbox styling directive
             * Configures the 'margin-left' of the element in a layout container
             */
            var FlexOffsetDirective = /** @class */ (function (_super) {
                __extends(FlexOffsetDirective, _super);
                /**
                 * @param {?} elRef
                 * @param {?} directionality
                 * @param {?} styleBuilder
                 * @param {?} marshal
                 * @param {?} styler
                 */
                function FlexOffsetDirective(elRef, directionality, styleBuilder, marshal, styler) {
                    var _this_1 = _super.call(this, elRef, styleBuilder, styler, marshal) || this;
                    _this_1.elRef = elRef;
                    _this_1.directionality = directionality;
                    _this_1.styleBuilder = styleBuilder;
                    _this_1.marshal = marshal;
                    _this_1.styler = styler;
                    _this_1.DIRECTIVE_KEY = 'flex-offset';
                    _this_1.init([_this_1.directionality.change]);
                    // Parent DOM `layout-gap` with affect the nested child with `flex-offset`
                    if (_this_1.parentElement) {
                        _this_1.marshal
                            .trackValue(_this_1.parentElement, 'layout-gap')
                            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["takeUntil"])(_this_1.destroySubject))
                            .subscribe(_this_1.triggerUpdate.bind(_this_1));
                    }
                    return _this_1;
                }
                // *********************************************
                // Protected methods
                // *********************************************
                /**
                 * Using the current fxFlexOffset value, update the inline CSS
                 * NOTE: this will assign `margin-left` if the parent flex-direction == 'row',
                 *       otherwise `margin-top` is used for the offset.
                 * @protected
                 * @param {?=} value
                 * @return {?}
                 */
                FlexOffsetDirective.prototype.updateWithValue = function (value) {
                    if (value === void 0) { value = ''; }
                    // The flex-direction of this element's flex container. Defaults to 'row'.
                    /** @type {?} */
                    var layout = this.getFlexFlowDirection(( /** @type {?} */(this.parentElement)), true);
                    /** @type {?} */
                    var isRtl = this.directionality.value === 'rtl';
                    if (layout === 'row' && isRtl) {
                        this.styleCache = flexOffsetCacheRowRtl;
                    }
                    else if (layout === 'row' && !isRtl) {
                        this.styleCache = flexOffsetCacheRowLtr;
                    }
                    else if (layout === 'column' && isRtl) {
                        this.styleCache = flexOffsetCacheColumnRtl;
                    }
                    else if (layout === 'column' && !isRtl) {
                        this.styleCache = flexOffsetCacheColumnLtr;
                    }
                    this.addStyles(value + '', { layout: layout, isRtl: isRtl });
                };
                return FlexOffsetDirective;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["BaseDirective2"]));
            FlexOffsetDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: 'flex-offset-directive' },] },
            ];
            /** @nocollapse */
            FlexOffsetDirective.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__["Directionality"] },
                { type: FlexOffsetStyleBuilder, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["MediaMarshaller"] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleUtils"] }
            ]; };
            var DefaultFlexOffsetDirective = /** @class */ (function (_super) {
                __extends(DefaultFlexOffsetDirective, _super);
                function DefaultFlexOffsetDirective() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.inputs = inputs$4;
                    return _this_1;
                }
                return DefaultFlexOffsetDirective;
            }(FlexOffsetDirective));
            DefaultFlexOffsetDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: selector$4, inputs: inputs$4 },] },
            ];
            /** @type {?} */
            var flexOffsetCacheRowRtl = new Map();
            /** @type {?} */
            var flexOffsetCacheColumnRtl = new Map();
            /** @type {?} */
            var flexOffsetCacheRowLtr = new Map();
            /** @type {?} */
            var flexOffsetCacheColumnLtr = new Map();
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var FlexAlignStyleBuilder = /** @class */ (function (_super) {
                __extends(FlexAlignStyleBuilder, _super);
                function FlexAlignStyleBuilder() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                /**
                 * @param {?} input
                 * @return {?}
                 */
                FlexAlignStyleBuilder.prototype.buildStyles = function (input) {
                    input = input || 'stretch';
                    /** @type {?} */
                    var styles = {};
                    // Cross-axis
                    switch (input) {
                        case 'start':
                            styles['align-self'] = 'flex-start';
                            break;
                        case 'end':
                            styles['align-self'] = 'flex-end';
                            break;
                        default:
                            styles['align-self'] = input;
                            break;
                    }
                    return styles;
                };
                return FlexAlignStyleBuilder;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleBuilder"]));
            FlexAlignStyleBuilder.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */ FlexAlignStyleBuilder.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function FlexAlignStyleBuilder_Factory() { return new FlexAlignStyleBuilder(); }, token: FlexAlignStyleBuilder, providedIn: "root" });
            /** @type {?} */
            var inputs$5 = [
                'fxFlexAlign', 'fxFlexAlign.xs', 'fxFlexAlign.sm', 'fxFlexAlign.md',
                'fxFlexAlign.lg', 'fxFlexAlign.xl', 'fxFlexAlign.lt-sm', 'fxFlexAlign.lt-md',
                'fxFlexAlign.lt-lg', 'fxFlexAlign.lt-xl', 'fxFlexAlign.gt-xs', 'fxFlexAlign.gt-sm',
                'fxFlexAlign.gt-md', 'fxFlexAlign.gt-lg'
            ];
            /** @type {?} */
            var selector$5 = "\n  [fxFlexAlign], [fxFlexAlign.xs], [fxFlexAlign.sm], [fxFlexAlign.md],\n  [fxFlexAlign.lg], [fxFlexAlign.xl], [fxFlexAlign.lt-sm], [fxFlexAlign.lt-md],\n  [fxFlexAlign.lt-lg], [fxFlexAlign.lt-xl], [fxFlexAlign.gt-xs], [fxFlexAlign.gt-sm],\n  [fxFlexAlign.gt-md], [fxFlexAlign.gt-lg]\n";
            /**
             * 'flex-align' flexbox styling directive
             * Allows element-specific overrides for cross-axis alignments in a layout container
             * @see https://css-tricks.com/almanac/properties/a/align-self/
             */
            var FlexAlignDirective = /** @class */ (function (_super) {
                __extends(FlexAlignDirective, _super);
                /**
                 * @param {?} elRef
                 * @param {?} styleUtils
                 * @param {?} styleBuilder
                 * @param {?} marshal
                 */
                function FlexAlignDirective(elRef, styleUtils, styleBuilder, marshal) {
                    var _this_1 = _super.call(this, elRef, styleBuilder, styleUtils, marshal) || this;
                    _this_1.elRef = elRef;
                    _this_1.styleUtils = styleUtils;
                    _this_1.styleBuilder = styleBuilder;
                    _this_1.marshal = marshal;
                    _this_1.DIRECTIVE_KEY = 'flex-align';
                    _this_1.styleCache = flexAlignCache;
                    _this_1.init();
                    return _this_1;
                }
                return FlexAlignDirective;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["BaseDirective2"]));
            FlexAlignDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: 'flex-align-directive' },] },
            ];
            /** @nocollapse */
            FlexAlignDirective.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleUtils"] },
                { type: FlexAlignStyleBuilder, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["MediaMarshaller"] }
            ]; };
            /** @type {?} */
            var flexAlignCache = new Map();
            var DefaultFlexAlignDirective = /** @class */ (function (_super) {
                __extends(DefaultFlexAlignDirective, _super);
                function DefaultFlexAlignDirective() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.inputs = inputs$5;
                    return _this_1;
                }
                return DefaultFlexAlignDirective;
            }(FlexAlignDirective));
            DefaultFlexAlignDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: selector$5, inputs: inputs$5 },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var FLEX_FILL_CSS = {
                'margin': 0,
                'width': '100%',
                'height': '100%',
                'min-width': '100%',
                'min-height': '100%'
            };
            var FlexFillStyleBuilder = /** @class */ (function (_super) {
                __extends(FlexFillStyleBuilder, _super);
                function FlexFillStyleBuilder() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                /**
                 * @param {?} _input
                 * @return {?}
                 */
                FlexFillStyleBuilder.prototype.buildStyles = function (_input) {
                    return FLEX_FILL_CSS;
                };
                return FlexFillStyleBuilder;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleBuilder"]));
            FlexFillStyleBuilder.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */ FlexFillStyleBuilder.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function FlexFillStyleBuilder_Factory() { return new FlexFillStyleBuilder(); }, token: FlexFillStyleBuilder, providedIn: "root" });
            /**
             * 'fxFill' flexbox styling directive
             *  Maximizes width and height of element in a layout container
             *
             *  NOTE: fxFill is NOT responsive API!!
             */
            var FlexFillDirective = /** @class */ (function (_super) {
                __extends(FlexFillDirective, _super);
                /**
                 * @param {?} elRef
                 * @param {?} styleUtils
                 * @param {?} styleBuilder
                 * @param {?} marshal
                 */
                function FlexFillDirective(elRef, styleUtils, styleBuilder, marshal) {
                    var _this_1 = _super.call(this, elRef, styleBuilder, styleUtils, marshal) || this;
                    _this_1.elRef = elRef;
                    _this_1.styleUtils = styleUtils;
                    _this_1.styleBuilder = styleBuilder;
                    _this_1.marshal = marshal;
                    _this_1.styleCache = flexFillCache;
                    _this_1.addStyles('');
                    return _this_1;
                }
                return FlexFillDirective;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["BaseDirective2"]));
            FlexFillDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: "[fxFill], [fxFlexFill]" },] },
            ];
            /** @nocollapse */
            FlexFillDirective.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleUtils"] },
                { type: FlexFillStyleBuilder },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["MediaMarshaller"] }
            ]; };
            /** @type {?} */
            var flexFillCache = new Map();
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var LayoutAlignStyleBuilder = /** @class */ (function (_super) {
                __extends(LayoutAlignStyleBuilder, _super);
                function LayoutAlignStyleBuilder() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                /**
                 * @param {?} align
                 * @param {?} parent
                 * @return {?}
                 */
                LayoutAlignStyleBuilder.prototype.buildStyles = function (align, parent) {
                    /** @type {?} */
                    var css = {};
                    var _a = align.split(' '), mainAxis = _a[0], crossAxis = _a[1];
                    // Main axis
                    switch (mainAxis) {
                        case 'center':
                            css['justify-content'] = 'center';
                            break;
                        case 'space-around':
                            css['justify-content'] = 'space-around';
                            break;
                        case 'space-between':
                            css['justify-content'] = 'space-between';
                            break;
                        case 'space-evenly':
                            css['justify-content'] = 'space-evenly';
                            break;
                        case 'end':
                        case 'flex-end':
                            css['justify-content'] = 'flex-end';
                            break;
                        case 'start':
                        case 'flex-start':
                        default:
                            css['justify-content'] = 'flex-start'; // default main axis
                            break;
                    }
                    // Cross-axis
                    switch (crossAxis) {
                        case 'start':
                        case 'flex-start':
                            css['align-items'] = css['align-content'] = 'flex-start';
                            break;
                        case 'center':
                            css['align-items'] = css['align-content'] = 'center';
                            break;
                        case 'end':
                        case 'flex-end':
                            css['align-items'] = css['align-content'] = 'flex-end';
                            break;
                        case 'space-between':
                            css['align-content'] = 'space-between';
                            css['align-items'] = 'stretch';
                            break;
                        case 'space-around':
                            css['align-content'] = 'space-around';
                            css['align-items'] = 'stretch';
                            break;
                        case 'baseline':
                            css['align-content'] = 'stretch';
                            css['align-items'] = 'baseline';
                            break;
                        case 'stretch':
                        default: // 'stretch'
                            css['align-items'] = css['align-content'] = 'stretch'; // default cross axis
                            break;
                    }
                    return ( /** @type {?} */(extendObject(css, {
                        'display': parent.inline ? 'inline-flex' : 'flex',
                        'flex-direction': parent.layout,
                        'box-sizing': 'border-box',
                        'max-width': crossAxis === 'stretch' ?
                            !isFlowHorizontal(parent.layout) ? '100%' : null : null,
                        'max-height': crossAxis === 'stretch' ?
                            isFlowHorizontal(parent.layout) ? '100%' : null : null,
                    })));
                };
                return LayoutAlignStyleBuilder;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleBuilder"]));
            LayoutAlignStyleBuilder.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */ LayoutAlignStyleBuilder.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function LayoutAlignStyleBuilder_Factory() { return new LayoutAlignStyleBuilder(); }, token: LayoutAlignStyleBuilder, providedIn: "root" });
            /** @type {?} */
            var inputs$6 = [
                'fxLayoutAlign', 'fxLayoutAlign.xs', 'fxLayoutAlign.sm', 'fxLayoutAlign.md',
                'fxLayoutAlign.lg', 'fxLayoutAlign.xl', 'fxLayoutAlign.lt-sm', 'fxLayoutAlign.lt-md',
                'fxLayoutAlign.lt-lg', 'fxLayoutAlign.lt-xl', 'fxLayoutAlign.gt-xs', 'fxLayoutAlign.gt-sm',
                'fxLayoutAlign.gt-md', 'fxLayoutAlign.gt-lg'
            ];
            /** @type {?} */
            var selector$6 = "\n  [fxLayoutAlign], [fxLayoutAlign.xs], [fxLayoutAlign.sm], [fxLayoutAlign.md],\n  [fxLayoutAlign.lg], [fxLayoutAlign.xl], [fxLayoutAlign.lt-sm], [fxLayoutAlign.lt-md],\n  [fxLayoutAlign.lt-lg], [fxLayoutAlign.lt-xl], [fxLayoutAlign.gt-xs], [fxLayoutAlign.gt-sm],\n  [fxLayoutAlign.gt-md], [fxLayoutAlign.gt-lg]\n";
            /**
             * 'layout-align' flexbox styling directive
             *  Defines positioning of child elements along main and cross axis in a layout container
             *  Optional values: {main-axis} values or {main-axis cross-axis} value pairs
             *
             * @see https://css-tricks.com/almanac/properties/j/justify-content/
             * @see https://css-tricks.com/almanac/properties/a/align-items/
             * @see https://css-tricks.com/almanac/properties/a/align-content/
             */
            var LayoutAlignDirective = /** @class */ (function (_super) {
                __extends(LayoutAlignDirective, _super);
                // default inline value
                /**
                 * @param {?} elRef
                 * @param {?} styleUtils
                 * @param {?} styleBuilder
                 * @param {?} marshal
                 */
                function LayoutAlignDirective(elRef, styleUtils, styleBuilder, marshal) {
                    var _this_1 = _super.call(this, elRef, styleBuilder, styleUtils, marshal) || this;
                    _this_1.elRef = elRef;
                    _this_1.styleUtils = styleUtils;
                    _this_1.styleBuilder = styleBuilder;
                    _this_1.marshal = marshal;
                    _this_1.DIRECTIVE_KEY = 'layout-align';
                    _this_1.layout = 'row'; // default flex-direction
                    // default flex-direction
                    _this_1.inline = false; // default inline value
                    _this_1.init();
                    _this_1.marshal.trackValue(_this_1.nativeElement, 'layout')
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["takeUntil"])(_this_1.destroySubject))
                        .subscribe(_this_1.onLayoutChange.bind(_this_1));
                    return _this_1;
                }
                // *********************************************
                // Protected methods
                // *********************************************
                /**
                 *
                 * @protected
                 * @param {?} value
                 * @return {?}
                 */
                LayoutAlignDirective.prototype.updateWithValue = function (value) {
                    /** @type {?} */
                    var layout = this.layout || 'row';
                    /** @type {?} */
                    var inline = this.inline;
                    if (layout === 'row' && inline) {
                        this.styleCache = layoutAlignHorizontalInlineCache;
                    }
                    else if (layout === 'row' && !inline) {
                        this.styleCache = layoutAlignHorizontalCache;
                    }
                    else if (layout === 'row-reverse' && inline) {
                        this.styleCache = layoutAlignHorizontalRevInlineCache;
                    }
                    else if (layout === 'row-reverse' && !inline) {
                        this.styleCache = layoutAlignHorizontalRevCache;
                    }
                    else if (layout === 'column' && inline) {
                        this.styleCache = layoutAlignVerticalInlineCache;
                    }
                    else if (layout === 'column' && !inline) {
                        this.styleCache = layoutAlignVerticalCache;
                    }
                    else if (layout === 'column-reverse' && inline) {
                        this.styleCache = layoutAlignVerticalRevInlineCache;
                    }
                    else if (layout === 'column-reverse' && !inline) {
                        this.styleCache = layoutAlignVerticalRevCache;
                    }
                    this.addStyles(value, { layout: layout, inline: inline });
                };
                /**
                 * Cache the parent container 'flex-direction' and update the 'flex' styles
                 * @protected
                 * @param {?} matcher
                 * @return {?}
                 */
                LayoutAlignDirective.prototype.onLayoutChange = function (matcher) {
                    var _this_1 = this;
                    /** @type {?} */
                    var layoutKeys = matcher.value.split(' ');
                    this.layout = layoutKeys[0];
                    this.inline = matcher.value.includes('inline');
                    if (!LAYOUT_VALUES.find(( /**
                     * @param {?} x
                     * @return {?}
                     */function (/**
                     * @param {?} x
                     * @return {?}
                     */ x) { return x === _this_1.layout; }))) {
                        this.layout = 'row';
                    }
                    this.triggerUpdate();
                };
                return LayoutAlignDirective;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["BaseDirective2"]));
            LayoutAlignDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: 'layout-align-directive' },] },
            ];
            /** @nocollapse */
            LayoutAlignDirective.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleUtils"] },
                { type: LayoutAlignStyleBuilder, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["MediaMarshaller"] }
            ]; };
            var DefaultLayoutAlignDirective = /** @class */ (function (_super) {
                __extends(DefaultLayoutAlignDirective, _super);
                function DefaultLayoutAlignDirective() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.inputs = inputs$6;
                    return _this_1;
                }
                return DefaultLayoutAlignDirective;
            }(LayoutAlignDirective));
            DefaultLayoutAlignDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: selector$6, inputs: inputs$6 },] },
            ];
            /** @type {?} */
            var layoutAlignHorizontalCache = new Map();
            /** @type {?} */
            var layoutAlignVerticalCache = new Map();
            /** @type {?} */
            var layoutAlignHorizontalRevCache = new Map();
            /** @type {?} */
            var layoutAlignVerticalRevCache = new Map();
            /** @type {?} */
            var layoutAlignHorizontalInlineCache = new Map();
            /** @type {?} */
            var layoutAlignVerticalInlineCache = new Map();
            /** @type {?} */
            var layoutAlignHorizontalRevInlineCache = new Map();
            /** @type {?} */
            var layoutAlignVerticalRevInlineCache = new Map();
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var ALL_DIRECTIVES = [
                DefaultLayoutDirective,
                DefaultLayoutGapDirective,
                DefaultLayoutAlignDirective,
                DefaultFlexOrderDirective,
                DefaultFlexOffsetDirective,
                FlexFillDirective,
                DefaultFlexAlignDirective,
                DefaultFlexDirective,
                FlexDirective,
                FlexAlignDirective,
                FlexOffsetDirective,
                FlexOrderDirective,
                LayoutDirective,
                LayoutAlignDirective,
                LayoutGapDirective,
            ];
            /**
             * *****************************************************************
             * Define module for the Flex API
             * *****************************************************************
             */
            var FlexModule = /** @class */ (function () {
                function FlexModule() {
                }
                return FlexModule;
            }());
            FlexModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["CoreModule"], _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__["BidiModule"]],
                            declarations: ALL_DIRECTIVES.slice(),
                            exports: ALL_DIRECTIVES.slice()
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=flex.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/flex-layout/esm2015/grid.js": 
        /*!***********************************************************!*\
          !*** ./node_modules/@angular/flex-layout/esm2015/grid.js ***!
          \***********************************************************/
        /*! exports provided: GridModule, ɵf2, ɵe2, ɵd2, ɵi2, ɵh2, ɵg2, ɵl2, ɵk2, ɵj2, ɵo2, ɵn2, ɵm2, ɵr2, ɵq2, ɵp2, ɵu2, ɵt2, ɵs2, ɵx2, ɵw2, ɵv2, ɵba2, ɵz2, ɵy2, ɵc2, ɵb2, ɵa2, ɵbd2, ɵbc2, ɵbb2, ɵbg2, ɵbf2, ɵbe2 */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GridModule", function () { return GridModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵf2", function () { return DefaultGridAlignColumnsDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵe2", function () { return GridAlignColumnsDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵd2", function () { return GridAlignColumnsStyleBuilder; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵi2", function () { return DefaultGridAlignRowsDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵh2", function () { return GridAlignRowsDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵg2", function () { return GridAlignRowsStyleBuilder; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵl2", function () { return DefaultGridAreaDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵk2", function () { return GridAreaDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵj2", function () { return GridAreaStyleBuilder; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵo2", function () { return DefaultGridAreasDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵn2", function () { return GridAreasDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵm2", function () { return GridAreasStyleBuiler; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵr2", function () { return DefaultGridAutoDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵq2", function () { return GridAutoDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵp2", function () { return GridAutoStyleBuilder; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵu2", function () { return DefaultGridColumnDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵt2", function () { return GridColumnDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵs2", function () { return GridColumnStyleBuilder; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵx2", function () { return DefaultGridColumnsDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵw2", function () { return GridColumnsDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵv2", function () { return GridColumnsStyleBuilder; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵba2", function () { return DefaultGridGapDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵz2", function () { return GridGapDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵy2", function () { return GridGapStyleBuilder; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵc2", function () { return DefaultGridAlignDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵb2", function () { return GridAlignDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵa2", function () { return GridAlignStyleBuilder; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbd2", function () { return DefaultGridRowDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbc2", function () { return GridRowDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbb2", function () { return GridRowStyleBuilder; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbg2", function () { return DefaultGridRowsDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbf2", function () { return GridRowsDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbe2", function () { return GridRowsStyleBuilder; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/flex-layout/core */ "./node_modules/@angular/flex-layout/esm2015/core.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var ROW_DEFAULT = 'stretch';
            /** @type {?} */
            var COL_DEFAULT = 'stretch';
            var GridAlignStyleBuilder = /** @class */ (function (_super) {
                __extends(GridAlignStyleBuilder, _super);
                function GridAlignStyleBuilder() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                /**
                 * @param {?} input
                 * @return {?}
                 */
                GridAlignStyleBuilder.prototype.buildStyles = function (input) {
                    return buildCss(input || ROW_DEFAULT);
                };
                return GridAlignStyleBuilder;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleBuilder"]));
            GridAlignStyleBuilder.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */ GridAlignStyleBuilder.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function GridAlignStyleBuilder_Factory() { return new GridAlignStyleBuilder(); }, token: GridAlignStyleBuilder, providedIn: "root" });
            var GridAlignDirective = /** @class */ (function (_super) {
                __extends(GridAlignDirective, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} styleBuilder
                 * @param {?} styler
                 * @param {?} marshal
                 */
                function GridAlignDirective(elementRef, styleBuilder, styler, marshal) {
                    var _this_1 = _super.call(this, elementRef, styleBuilder, styler, marshal) || this;
                    _this_1.elementRef = elementRef;
                    _this_1.styleBuilder = styleBuilder;
                    _this_1.styler = styler;
                    _this_1.marshal = marshal;
                    _this_1.DIRECTIVE_KEY = 'grid-align';
                    _this_1.styleCache = alignCache;
                    _this_1.init();
                    return _this_1;
                }
                return GridAlignDirective;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["BaseDirective2"]));
            GridAlignDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: 'grid-align-directive' },] },
            ];
            /** @nocollapse */
            GridAlignDirective.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: GridAlignStyleBuilder, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleUtils"] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["MediaMarshaller"] }
            ]; };
            /** @type {?} */
            var alignCache = new Map();
            /** @type {?} */
            var inputs = [
                'gdGridAlign',
                'gdGridAlign.xs', 'gdGridAlign.sm', 'gdGridAlign.md', 'gdGridAlign.lg', 'gdGridAlign.xl',
                'gdGridAlign.lt-sm', 'gdGridAlign.lt-md', 'gdGridAlign.lt-lg', 'gdGridAlign.lt-xl',
                'gdGridAlign.gt-xs', 'gdGridAlign.gt-sm', 'gdGridAlign.gt-md', 'gdGridAlign.gt-lg'
            ];
            /** @type {?} */
            var selector = "\n  [gdGridAlign],\n  [gdGridAlign.xs], [gdGridAlign.sm], [gdGridAlign.md], [gdGridAlign.lg],[gdGridAlign.xl],\n  [gdGridAlign.lt-sm], [gdGridAlign.lt-md], [gdGridAlign.lt-lg], [gdGridAlign.lt-xl],\n  [gdGridAlign.gt-xs], [gdGridAlign.gt-sm], [gdGridAlign.gt-md], [gdGridAlign.gt-lg]\n";
            /**
             * 'align' CSS Grid styling directive for grid children
             *  Defines positioning of child elements along row and column axis in a grid container
             *  Optional values: {row-axis} values or {row-axis column-axis} value pairs
             *
             * @see https://css-tricks.com/snippets/css/complete-guide-grid/#prop-justify-self
             * @see https://css-tricks.com/snippets/css/complete-guide-grid/#prop-align-self
             */
            var DefaultGridAlignDirective = /** @class */ (function (_super) {
                __extends(DefaultGridAlignDirective, _super);
                function DefaultGridAlignDirective() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.inputs = inputs;
                    return _this_1;
                }
                return DefaultGridAlignDirective;
            }(GridAlignDirective));
            DefaultGridAlignDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: selector, inputs: inputs },] },
            ];
            /**
             * @param {?=} align
             * @return {?}
             */
            function buildCss(align) {
                if (align === void 0) { align = ''; }
                /** @type {?} */
                var css = {};
                var _a = align.split(' '), rowAxis = _a[0], columnAxis = _a[1];
                // Row axis
                switch (rowAxis) {
                    case 'end':
                        css['justify-self'] = 'end';
                        break;
                    case 'center':
                        css['justify-self'] = 'center';
                        break;
                    case 'stretch':
                        css['justify-self'] = 'stretch';
                        break;
                    case 'start':
                        css['justify-self'] = 'start';
                        break;
                    default:
                        css['justify-self'] = ROW_DEFAULT; // default row axis
                        break;
                }
                // Column axis
                switch (columnAxis) {
                    case 'end':
                        css['align-self'] = 'end';
                        break;
                    case 'center':
                        css['align-self'] = 'center';
                        break;
                    case 'stretch':
                        css['align-self'] = 'stretch';
                        break;
                    case 'start':
                        css['align-self'] = 'start';
                        break;
                    default:
                        css['align-self'] = COL_DEFAULT; // default column axis
                        break;
                }
                return css;
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var DEFAULT_MAIN = 'start';
            /** @type {?} */
            var DEFAULT_CROSS = 'stretch';
            var GridAlignColumnsStyleBuilder = /** @class */ (function (_super) {
                __extends(GridAlignColumnsStyleBuilder, _super);
                function GridAlignColumnsStyleBuilder() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                /**
                 * @param {?} input
                 * @param {?} parent
                 * @return {?}
                 */
                GridAlignColumnsStyleBuilder.prototype.buildStyles = function (input, parent) {
                    return buildCss$1(input || DEFAULT_MAIN + " " + DEFAULT_CROSS, parent.inline);
                };
                return GridAlignColumnsStyleBuilder;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleBuilder"]));
            GridAlignColumnsStyleBuilder.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */ GridAlignColumnsStyleBuilder.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function GridAlignColumnsStyleBuilder_Factory() { return new GridAlignColumnsStyleBuilder(); }, token: GridAlignColumnsStyleBuilder, providedIn: "root" });
            var GridAlignColumnsDirective = /** @class */ (function (_super) {
                __extends(GridAlignColumnsDirective, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} styleBuilder
                 * @param {?} styler
                 * @param {?} marshal
                 */
                function GridAlignColumnsDirective(elementRef, styleBuilder, styler, marshal) {
                    var _this_1 = _super.call(this, elementRef, styleBuilder, styler, marshal) || this;
                    _this_1.elementRef = elementRef;
                    _this_1.styleBuilder = styleBuilder;
                    _this_1.styler = styler;
                    _this_1.marshal = marshal;
                    _this_1.DIRECTIVE_KEY = 'grid-align-columns';
                    _this_1._inline = false;
                    _this_1.init();
                    return _this_1;
                }
                Object.defineProperty(GridAlignColumnsDirective.prototype, "inline", {
                    /**
                     * @return {?}
                     */
                    get: function () { return this._inline; },
                    /**
                     * @param {?} val
                     * @return {?}
                     */
                    set: function (val) { this._inline = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(val); },
                    enumerable: true,
                    configurable: true
                });
                // *********************************************
                // Protected methods
                // *********************************************
                /**
                 * @protected
                 * @param {?} value
                 * @return {?}
                 */
                GridAlignColumnsDirective.prototype.updateWithValue = function (value) {
                    this.styleCache = this.inline ? alignColumnsInlineCache : alignColumnsCache;
                    this.addStyles(value, { inline: this.inline });
                };
                return GridAlignColumnsDirective;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["BaseDirective2"]));
            GridAlignColumnsDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: 'grid-align-columns-directive' },] },
            ];
            /** @nocollapse */
            GridAlignColumnsDirective.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: GridAlignColumnsStyleBuilder, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleUtils"] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["MediaMarshaller"] }
            ]; };
            GridAlignColumnsDirective.propDecorators = {
                inline: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['gdInline',] }]
            };
            /** @type {?} */
            var alignColumnsCache = new Map();
            /** @type {?} */
            var alignColumnsInlineCache = new Map();
            /** @type {?} */
            var inputs$1 = [
                'gdAlignColumns',
                'gdAlignColumns.xs', 'gdAlignColumns.sm', 'gdAlignColumns.md',
                'gdAlignColumns.lg', 'gdAlignColumns.xl', 'gdAlignColumns.lt-sm',
                'gdAlignColumns.lt-md', 'gdAlignColumns.lt-lg', 'gdAlignColumns.lt-xl',
                'gdAlignColumns.gt-xs', 'gdAlignColumns.gt-sm', 'gdAlignColumns.gt-md',
                'gdAlignColumns.gt-lg'
            ];
            /** @type {?} */
            var selector$1 = "\n  [gdAlignColumns],\n  [gdAlignColumns.xs], [gdAlignColumns.sm], [gdAlignColumns.md],\n  [gdAlignColumns.lg], [gdAlignColumns.xl], [gdAlignColumns.lt-sm],\n  [gdAlignColumns.lt-md], [gdAlignColumns.lt-lg], [gdAlignColumns.lt-xl],\n  [gdAlignColumns.gt-xs], [gdAlignColumns.gt-sm], [gdAlignColumns.gt-md],\n  [gdAlignColumns.gt-lg]\n";
            /**
             * 'column alignment' CSS Grid styling directive
             * Configures the alignment in the column direction
             * @see https://css-tricks.com/snippets/css/complete-guide-grid/#article-header-id-19
             * @see https://css-tricks.com/snippets/css/complete-guide-grid/#article-header-id-21
             */
            var DefaultGridAlignColumnsDirective = /** @class */ (function (_super) {
                __extends(DefaultGridAlignColumnsDirective, _super);
                function DefaultGridAlignColumnsDirective() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.inputs = inputs$1;
                    return _this_1;
                }
                return DefaultGridAlignColumnsDirective;
            }(GridAlignColumnsDirective));
            DefaultGridAlignColumnsDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: selector$1, inputs: inputs$1 },] },
            ];
            /**
             * @param {?} align
             * @param {?} inline
             * @return {?}
             */
            function buildCss$1(align, inline) {
                /** @type {?} */
                var css = {};
                var _a = align.split(' '), mainAxis = _a[0], crossAxis = _a[1];
                // Main axis
                switch (mainAxis) {
                    case 'center':
                        css['align-content'] = 'center';
                        break;
                    case 'space-around':
                        css['align-content'] = 'space-around';
                        break;
                    case 'space-between':
                        css['align-content'] = 'space-between';
                        break;
                    case 'space-evenly':
                        css['align-content'] = 'space-evenly';
                        break;
                    case 'end':
                        css['align-content'] = 'end';
                        break;
                    case 'start':
                        css['align-content'] = 'start';
                        break;
                    case 'stretch':
                        css['align-content'] = 'stretch';
                        break;
                    default:
                        css['align-content'] = DEFAULT_MAIN; // default main axis
                        break;
                }
                // Cross-axis
                switch (crossAxis) {
                    case 'start':
                        css['align-items'] = 'start';
                        break;
                    case 'center':
                        css['align-items'] = 'center';
                        break;
                    case 'end':
                        css['align-items'] = 'end';
                        break;
                    case 'stretch':
                        css['align-items'] = 'stretch';
                        break;
                    default: // 'stretch'
                        css['align-items'] = DEFAULT_CROSS; // default cross axis
                        break;
                }
                css['display'] = inline ? 'inline-grid' : 'grid';
                return css;
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var DEFAULT_MAIN$1 = 'start';
            /** @type {?} */
            var DEFAULT_CROSS$1 = 'stretch';
            var GridAlignRowsStyleBuilder = /** @class */ (function (_super) {
                __extends(GridAlignRowsStyleBuilder, _super);
                function GridAlignRowsStyleBuilder() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                /**
                 * @param {?} input
                 * @param {?} parent
                 * @return {?}
                 */
                GridAlignRowsStyleBuilder.prototype.buildStyles = function (input, parent) {
                    return buildCss$2(input || DEFAULT_MAIN$1 + " " + DEFAULT_CROSS$1, parent.inline);
                };
                return GridAlignRowsStyleBuilder;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleBuilder"]));
            GridAlignRowsStyleBuilder.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */ GridAlignRowsStyleBuilder.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function GridAlignRowsStyleBuilder_Factory() { return new GridAlignRowsStyleBuilder(); }, token: GridAlignRowsStyleBuilder, providedIn: "root" });
            var GridAlignRowsDirective = /** @class */ (function (_super) {
                __extends(GridAlignRowsDirective, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} styleBuilder
                 * @param {?} styler
                 * @param {?} marshal
                 */
                function GridAlignRowsDirective(elementRef, styleBuilder, styler, marshal) {
                    var _this_1 = _super.call(this, elementRef, styleBuilder, styler, marshal) || this;
                    _this_1.elementRef = elementRef;
                    _this_1.styleBuilder = styleBuilder;
                    _this_1.styler = styler;
                    _this_1.marshal = marshal;
                    _this_1.DIRECTIVE_KEY = 'grid-align-rows';
                    _this_1._inline = false;
                    _this_1.init();
                    return _this_1;
                }
                Object.defineProperty(GridAlignRowsDirective.prototype, "inline", {
                    /**
                     * @return {?}
                     */
                    get: function () { return this._inline; },
                    /**
                     * @param {?} val
                     * @return {?}
                     */
                    set: function (val) { this._inline = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(val); },
                    enumerable: true,
                    configurable: true
                });
                // *********************************************
                // Protected methods
                // *********************************************
                /**
                 * @protected
                 * @param {?} value
                 * @return {?}
                 */
                GridAlignRowsDirective.prototype.updateWithValue = function (value) {
                    this.styleCache = this.inline ? alignRowsInlineCache : alignRowsCache;
                    this.addStyles(value, { inline: this.inline });
                };
                return GridAlignRowsDirective;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["BaseDirective2"]));
            GridAlignRowsDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: 'grid-align-rows-directive' },] },
            ];
            /** @nocollapse */
            GridAlignRowsDirective.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: GridAlignRowsStyleBuilder, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleUtils"] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["MediaMarshaller"] }
            ]; };
            GridAlignRowsDirective.propDecorators = {
                inline: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['gdInline',] }]
            };
            /** @type {?} */
            var alignRowsCache = new Map();
            /** @type {?} */
            var alignRowsInlineCache = new Map();
            /** @type {?} */
            var inputs$2 = [
                'gdAlignRows',
                'gdAlignRows.xs', 'gdAlignRows.sm', 'gdAlignRows.md',
                'gdAlignRows.lg', 'gdAlignRows.xl', 'gdAlignRows.lt-sm',
                'gdAlignRows.lt-md', 'gdAlignRows.lt-lg', 'gdAlignRows.lt-xl',
                'gdAlignRows.gt-xs', 'gdAlignRows.gt-sm', 'gdAlignRows.gt-md',
                'gdAlignRows.gt-lg'
            ];
            /** @type {?} */
            var selector$2 = "\n  [gdAlignRows],\n  [gdAlignRows.xs], [gdAlignRows.sm], [gdAlignRows.md],\n  [gdAlignRows.lg], [gdAlignRows.xl], [gdAlignRows.lt-sm],\n  [gdAlignRows.lt-md], [gdAlignRows.lt-lg], [gdAlignRows.lt-xl],\n  [gdAlignRows.gt-xs], [gdAlignRows.gt-sm], [gdAlignRows.gt-md],\n  [gdAlignRows.gt-lg]\n";
            /**
             * 'row alignment' CSS Grid styling directive
             * Configures the alignment in the row direction
             * @see https://css-tricks.com/snippets/css/complete-guide-grid/#article-header-id-18
             * @see https://css-tricks.com/snippets/css/complete-guide-grid/#article-header-id-20
             */
            var DefaultGridAlignRowsDirective = /** @class */ (function (_super) {
                __extends(DefaultGridAlignRowsDirective, _super);
                function DefaultGridAlignRowsDirective() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.inputs = inputs$2;
                    return _this_1;
                }
                return DefaultGridAlignRowsDirective;
            }(GridAlignRowsDirective));
            DefaultGridAlignRowsDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: selector$2, inputs: inputs$2 },] },
            ];
            /**
             * @param {?} align
             * @param {?} inline
             * @return {?}
             */
            function buildCss$2(align, inline) {
                /** @type {?} */
                var css = {};
                var _a = align.split(' '), mainAxis = _a[0], crossAxis = _a[1];
                // Main axis
                switch (mainAxis) {
                    case 'center':
                    case 'space-around':
                    case 'space-between':
                    case 'space-evenly':
                    case 'end':
                    case 'start':
                    case 'stretch':
                        css['justify-content'] = mainAxis;
                        break;
                    default:
                        css['justify-content'] = DEFAULT_MAIN$1; // default main axis
                        break;
                }
                // Cross-axis
                switch (crossAxis) {
                    case 'start':
                    case 'center':
                    case 'end':
                    case 'stretch':
                        css['justify-items'] = crossAxis;
                        break;
                    default: // 'stretch'
                        css['justify-items'] = DEFAULT_CROSS$1; // default cross axis
                        break;
                }
                css['display'] = inline ? 'inline-grid' : 'grid';
                return css;
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var DEFAULT_VALUE = 'auto';
            var GridAreaStyleBuilder = /** @class */ (function (_super) {
                __extends(GridAreaStyleBuilder, _super);
                function GridAreaStyleBuilder() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                /**
                 * @param {?} input
                 * @return {?}
                 */
                GridAreaStyleBuilder.prototype.buildStyles = function (input) {
                    return { 'grid-area': input || DEFAULT_VALUE };
                };
                return GridAreaStyleBuilder;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleBuilder"]));
            GridAreaStyleBuilder.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */ GridAreaStyleBuilder.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function GridAreaStyleBuilder_Factory() { return new GridAreaStyleBuilder(); }, token: GridAreaStyleBuilder, providedIn: "root" });
            var GridAreaDirective = /** @class */ (function (_super) {
                __extends(GridAreaDirective, _super);
                /**
                 * @param {?} elRef
                 * @param {?} styleUtils
                 * @param {?} styleBuilder
                 * @param {?} marshal
                 */
                function GridAreaDirective(elRef, styleUtils, styleBuilder, marshal) {
                    var _this_1 = _super.call(this, elRef, styleBuilder, styleUtils, marshal) || this;
                    _this_1.elRef = elRef;
                    _this_1.styleUtils = styleUtils;
                    _this_1.styleBuilder = styleBuilder;
                    _this_1.marshal = marshal;
                    _this_1.DIRECTIVE_KEY = 'grid-area';
                    _this_1.styleCache = gridAreaCache;
                    _this_1.init();
                    return _this_1;
                }
                return GridAreaDirective;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["BaseDirective2"]));
            GridAreaDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: 'grid-area-directive' },] },
            ];
            /** @nocollapse */
            GridAreaDirective.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleUtils"] },
                { type: GridAreaStyleBuilder, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["MediaMarshaller"] }
            ]; };
            /** @type {?} */
            var gridAreaCache = new Map();
            /** @type {?} */
            var inputs$3 = [
                'gdArea',
                'gdArea.xs', 'gdArea.sm', 'gdArea.md', 'gdArea.lg', 'gdArea.xl',
                'gdArea.lt-sm', 'gdArea.lt-md', 'gdArea.lt-lg', 'gdArea.lt-xl',
                'gdArea.gt-xs', 'gdArea.gt-sm', 'gdArea.gt-md', 'gdArea.gt-lg'
            ];
            /** @type {?} */
            var selector$3 = "\n  [gdArea],\n  [gdArea.xs], [gdArea.sm], [gdArea.md], [gdArea.lg], [gdArea.xl],\n  [gdArea.lt-sm], [gdArea.lt-md], [gdArea.lt-lg], [gdArea.lt-xl],\n  [gdArea.gt-xs], [gdArea.gt-sm], [gdArea.gt-md], [gdArea.gt-lg]\n";
            /**
             * 'grid-area' CSS Grid styling directive
             * Configures the name or position of an element within the grid
             * @see https://css-tricks.com/snippets/css/complete-guide-grid/#article-header-id-27
             */
            var DefaultGridAreaDirective = /** @class */ (function (_super) {
                __extends(DefaultGridAreaDirective, _super);
                function DefaultGridAreaDirective() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.inputs = inputs$3;
                    return _this_1;
                }
                return DefaultGridAreaDirective;
            }(GridAreaDirective));
            DefaultGridAreaDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: selector$3, inputs: inputs$3 },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var DEFAULT_VALUE$1 = 'none';
            /** @type {?} */
            var DELIMETER = '|';
            var GridAreasStyleBuiler = /** @class */ (function (_super) {
                __extends(GridAreasStyleBuiler, _super);
                function GridAreasStyleBuiler() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                /**
                 * @param {?} input
                 * @param {?} parent
                 * @return {?}
                 */
                GridAreasStyleBuiler.prototype.buildStyles = function (input, parent) {
                    /** @type {?} */
                    var areas = (input || DEFAULT_VALUE$1).split(DELIMETER).map(( /**
                     * @param {?} v
                     * @return {?}
                     */function (/**
                     * @param {?} v
                     * @return {?}
                     */ v) { return "\"" + v.trim() + "\""; }));
                    return {
                        'display': parent.inline ? 'inline-grid' : 'grid',
                        'grid-template-areas': areas.join(' ')
                    };
                };
                return GridAreasStyleBuiler;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleBuilder"]));
            GridAreasStyleBuiler.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */ GridAreasStyleBuiler.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function GridAreasStyleBuiler_Factory() { return new GridAreasStyleBuiler(); }, token: GridAreasStyleBuiler, providedIn: "root" });
            var GridAreasDirective = /** @class */ (function (_super) {
                __extends(GridAreasDirective, _super);
                /**
                 * @param {?} elRef
                 * @param {?} styleUtils
                 * @param {?} styleBuilder
                 * @param {?} marshal
                 */
                function GridAreasDirective(elRef, styleUtils, styleBuilder, marshal) {
                    var _this_1 = _super.call(this, elRef, styleBuilder, styleUtils, marshal) || this;
                    _this_1.elRef = elRef;
                    _this_1.styleUtils = styleUtils;
                    _this_1.styleBuilder = styleBuilder;
                    _this_1.marshal = marshal;
                    _this_1.DIRECTIVE_KEY = 'grid-areas';
                    _this_1._inline = false;
                    _this_1.init();
                    return _this_1;
                }
                Object.defineProperty(GridAreasDirective.prototype, "inline", {
                    /**
                     * @return {?}
                     */
                    get: function () { return this._inline; },
                    /**
                     * @param {?} val
                     * @return {?}
                     */
                    set: function (val) { this._inline = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(val); },
                    enumerable: true,
                    configurable: true
                });
                // *********************************************
                // Protected methods
                // *********************************************
                /**
                 * @protected
                 * @param {?} value
                 * @return {?}
                 */
                GridAreasDirective.prototype.updateWithValue = function (value) {
                    this.styleCache = this.inline ? areasInlineCache : areasCache;
                    this.addStyles(value, { inline: this.inline });
                };
                return GridAreasDirective;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["BaseDirective2"]));
            GridAreasDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: 'grid-areas-directive' },] },
            ];
            /** @nocollapse */
            GridAreasDirective.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleUtils"] },
                { type: GridAreasStyleBuiler, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["MediaMarshaller"] }
            ]; };
            GridAreasDirective.propDecorators = {
                inline: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['gdInline',] }]
            };
            /** @type {?} */
            var areasCache = new Map();
            /** @type {?} */
            var areasInlineCache = new Map();
            /** @type {?} */
            var inputs$4 = [
                'gdAreas',
                'gdAreas.xs', 'gdAreas.sm', 'gdAreas.md', 'gdAreas.lg', 'gdAreas.xl',
                'gdAreas.lt-sm', 'gdAreas.lt-md', 'gdAreas.lt-lg', 'gdAreas.lt-xl',
                'gdAreas.gt-xs', 'gdAreas.gt-sm', 'gdAreas.gt-md', 'gdAreas.gt-lg'
            ];
            /** @type {?} */
            var selector$4 = "\n  [gdAreas],\n  [gdAreas.xs], [gdAreas.sm], [gdAreas.md], [gdAreas.lg], [gdAreas.xl],\n  [gdAreas.lt-sm], [gdAreas.lt-md], [gdAreas.lt-lg], [gdAreas.lt-xl],\n  [gdAreas.gt-xs], [gdAreas.gt-sm], [gdAreas.gt-md], [gdAreas.gt-lg]\n";
            /**
             * 'grid-template-areas' CSS Grid styling directive
             * Configures the names of elements within the grid
             * @see https://css-tricks.com/snippets/css/complete-guide-grid/#article-header-id-14
             */
            var DefaultGridAreasDirective = /** @class */ (function (_super) {
                __extends(DefaultGridAreasDirective, _super);
                function DefaultGridAreasDirective() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.inputs = inputs$4;
                    return _this_1;
                }
                return DefaultGridAreasDirective;
            }(GridAreasDirective));
            DefaultGridAreasDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: selector$4, inputs: inputs$4 },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var DEFAULT_VALUE$2 = 'initial';
            var GridAutoStyleBuilder = /** @class */ (function (_super) {
                __extends(GridAutoStyleBuilder, _super);
                function GridAutoStyleBuilder() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                /**
                 * @param {?} input
                 * @param {?} parent
                 * @return {?}
                 */
                GridAutoStyleBuilder.prototype.buildStyles = function (input, parent) {
                    var _a = (input || DEFAULT_VALUE$2).split(' '), direction = _a[0], dense = _a[1];
                    if (direction !== 'column' && direction !== 'row' && direction !== 'dense') {
                        direction = 'row';
                    }
                    dense = (dense === 'dense' && direction !== 'dense') ? ' dense' : '';
                    return {
                        'display': parent.inline ? 'inline-grid' : 'grid',
                        'grid-auto-flow': direction + dense
                    };
                };
                return GridAutoStyleBuilder;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleBuilder"]));
            GridAutoStyleBuilder.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */ GridAutoStyleBuilder.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function GridAutoStyleBuilder_Factory() { return new GridAutoStyleBuilder(); }, token: GridAutoStyleBuilder, providedIn: "root" });
            var GridAutoDirective = /** @class */ (function (_super) {
                __extends(GridAutoDirective, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} styleBuilder
                 * @param {?} styler
                 * @param {?} marshal
                 */
                function GridAutoDirective(elementRef, styleBuilder, styler, marshal) {
                    var _this_1 = _super.call(this, elementRef, styleBuilder, styler, marshal) || this;
                    _this_1.elementRef = elementRef;
                    _this_1.styleBuilder = styleBuilder;
                    _this_1.styler = styler;
                    _this_1.marshal = marshal;
                    _this_1._inline = false;
                    _this_1.DIRECTIVE_KEY = 'grid-auto';
                    _this_1.init();
                    return _this_1;
                }
                Object.defineProperty(GridAutoDirective.prototype, "inline", {
                    /**
                     * @return {?}
                     */
                    get: function () { return this._inline; },
                    /**
                     * @param {?} val
                     * @return {?}
                     */
                    set: function (val) { this._inline = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(val); },
                    enumerable: true,
                    configurable: true
                });
                // *********************************************
                // Protected methods
                // *********************************************
                /**
                 * @protected
                 * @param {?} value
                 * @return {?}
                 */
                GridAutoDirective.prototype.updateWithValue = function (value) {
                    this.styleCache = this.inline ? autoInlineCache : autoCache;
                    this.addStyles(value, { inline: this.inline });
                };
                return GridAutoDirective;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["BaseDirective2"]));
            GridAutoDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: "grid-auto-directive" },] },
            ];
            /** @nocollapse */
            GridAutoDirective.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: GridAutoStyleBuilder, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleUtils"] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["MediaMarshaller"] }
            ]; };
            GridAutoDirective.propDecorators = {
                inline: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['gdInline',] }]
            };
            /** @type {?} */
            var autoCache = new Map();
            /** @type {?} */
            var autoInlineCache = new Map();
            /** @type {?} */
            var inputs$5 = [
                'gdAuto',
                'gdAuto.xs', 'gdAuto.sm', 'gdAuto.md', 'gdAuto.lg', 'gdAuto.xl',
                'gdAuto.lt-sm', 'gdAuto.lt-md', 'gdAuto.lt-lg', 'gdAuto.lt-xl',
                'gdAuto.gt-xs', 'gdAuto.gt-sm', 'gdAuto.gt-md', 'gdAuto.gt-lg'
            ];
            /** @type {?} */
            var selector$5 = "\n  [gdAuto],\n  [gdAuto.xs], [gdAuto.sm], [gdAuto.md], [gdAuto.lg], [gdAuto.xl],\n  [gdAuto.lt-sm], [gdAuto.lt-md], [gdAuto.lt-lg], [gdAuto.lt-xl],\n  [gdAuto.gt-xs], [gdAuto.gt-sm], [gdAuto.gt-md], [gdAuto.gt-lg]\n";
            /**
             * 'grid-auto-flow' CSS Grid styling directive
             * Configures the auto placement algorithm for the grid
             * @see https://css-tricks.com/snippets/css/complete-guide-grid/#article-header-id-23
             */
            var DefaultGridAutoDirective = /** @class */ (function (_super) {
                __extends(DefaultGridAutoDirective, _super);
                function DefaultGridAutoDirective() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.inputs = inputs$5;
                    return _this_1;
                }
                return DefaultGridAutoDirective;
            }(GridAutoDirective));
            DefaultGridAutoDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: selector$5, inputs: inputs$5 },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var DEFAULT_VALUE$3 = 'auto';
            var GridColumnStyleBuilder = /** @class */ (function (_super) {
                __extends(GridColumnStyleBuilder, _super);
                function GridColumnStyleBuilder() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                /**
                 * @param {?} input
                 * @return {?}
                 */
                GridColumnStyleBuilder.prototype.buildStyles = function (input) {
                    return { 'grid-column': input || DEFAULT_VALUE$3 };
                };
                return GridColumnStyleBuilder;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleBuilder"]));
            GridColumnStyleBuilder.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */ GridColumnStyleBuilder.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function GridColumnStyleBuilder_Factory() { return new GridColumnStyleBuilder(); }, token: GridColumnStyleBuilder, providedIn: "root" });
            var GridColumnDirective = /** @class */ (function (_super) {
                __extends(GridColumnDirective, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} styleBuilder
                 * @param {?} styler
                 * @param {?} marshal
                 */
                function GridColumnDirective(elementRef, styleBuilder, styler, marshal) {
                    var _this_1 = _super.call(this, elementRef, styleBuilder, styler, marshal) || this;
                    _this_1.elementRef = elementRef;
                    _this_1.styleBuilder = styleBuilder;
                    _this_1.styler = styler;
                    _this_1.marshal = marshal;
                    _this_1.DIRECTIVE_KEY = 'grid-column';
                    _this_1.styleCache = columnCache;
                    _this_1.init();
                    return _this_1;
                }
                return GridColumnDirective;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["BaseDirective2"]));
            GridColumnDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: 'grid-column-directive' },] },
            ];
            /** @nocollapse */
            GridColumnDirective.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: GridColumnStyleBuilder, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleUtils"] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["MediaMarshaller"] }
            ]; };
            /** @type {?} */
            var columnCache = new Map();
            /** @type {?} */
            var inputs$6 = [
                'gdColumn',
                'gdColumn.xs', 'gdColumn.sm', 'gdColumn.md', 'gdColumn.lg', 'gdColumn.xl',
                'gdColumn.lt-sm', 'gdColumn.lt-md', 'gdColumn.lt-lg', 'gdColumn.lt-xl',
                'gdColumn.gt-xs', 'gdColumn.gt-sm', 'gdColumn.gt-md', 'gdColumn.gt-lg'
            ];
            /** @type {?} */
            var selector$6 = "\n  [gdColumn],\n  [gdColumn.xs], [gdColumn.sm], [gdColumn.md], [gdColumn.lg], [gdColumn.xl],\n  [gdColumn.lt-sm], [gdColumn.lt-md], [gdColumn.lt-lg], [gdColumn.lt-xl],\n  [gdColumn.gt-xs], [gdColumn.gt-sm], [gdColumn.gt-md], [gdColumn.gt-lg]\n";
            /**
             * 'grid-column' CSS Grid styling directive
             * Configures the name or position of an element within the grid
             * @see https://css-tricks.com/snippets/css/complete-guide-grid/#article-header-id-26
             */
            var DefaultGridColumnDirective = /** @class */ (function (_super) {
                __extends(DefaultGridColumnDirective, _super);
                function DefaultGridColumnDirective() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.inputs = inputs$6;
                    return _this_1;
                }
                return DefaultGridColumnDirective;
            }(GridColumnDirective));
            DefaultGridColumnDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: selector$6, inputs: inputs$6 },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var DEFAULT_VALUE$4 = 'none';
            /** @type {?} */
            var AUTO_SPECIFIER = '!';
            var GridColumnsStyleBuilder = /** @class */ (function (_super) {
                __extends(GridColumnsStyleBuilder, _super);
                function GridColumnsStyleBuilder() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                /**
                 * @param {?} input
                 * @param {?} parent
                 * @return {?}
                 */
                GridColumnsStyleBuilder.prototype.buildStyles = function (input, parent) {
                    input = input || DEFAULT_VALUE$4;
                    /** @type {?} */
                    var auto = false;
                    if (input.endsWith(AUTO_SPECIFIER)) {
                        input = input.substring(0, input.indexOf(AUTO_SPECIFIER));
                        auto = true;
                    }
                    /** @type {?} */
                    var css = {
                        'display': parent.inline ? 'inline-grid' : 'grid',
                        'grid-auto-columns': '',
                        'grid-template-columns': '',
                    };
                    /** @type {?} */
                    var key = (auto ? 'grid-auto-columns' : 'grid-template-columns');
                    css[key] = input;
                    return css;
                };
                return GridColumnsStyleBuilder;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleBuilder"]));
            GridColumnsStyleBuilder.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */ GridColumnsStyleBuilder.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function GridColumnsStyleBuilder_Factory() { return new GridColumnsStyleBuilder(); }, token: GridColumnsStyleBuilder, providedIn: "root" });
            var GridColumnsDirective = /** @class */ (function (_super) {
                __extends(GridColumnsDirective, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} styleBuilder
                 * @param {?} styler
                 * @param {?} marshal
                 */
                function GridColumnsDirective(elementRef, styleBuilder, styler, marshal) {
                    var _this_1 = _super.call(this, elementRef, styleBuilder, styler, marshal) || this;
                    _this_1.elementRef = elementRef;
                    _this_1.styleBuilder = styleBuilder;
                    _this_1.styler = styler;
                    _this_1.marshal = marshal;
                    _this_1.DIRECTIVE_KEY = 'grid-columns';
                    _this_1._inline = false;
                    _this_1.init();
                    return _this_1;
                }
                Object.defineProperty(GridColumnsDirective.prototype, "inline", {
                    /**
                     * @return {?}
                     */
                    get: function () { return this._inline; },
                    /**
                     * @param {?} val
                     * @return {?}
                     */
                    set: function (val) { this._inline = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(val); },
                    enumerable: true,
                    configurable: true
                });
                // *********************************************
                // Protected methods
                // *********************************************
                /**
                 * @protected
                 * @param {?} value
                 * @return {?}
                 */
                GridColumnsDirective.prototype.updateWithValue = function (value) {
                    this.styleCache = this.inline ? columnsInlineCache : columnsCache;
                    this.addStyles(value, { inline: this.inline });
                };
                return GridColumnsDirective;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["BaseDirective2"]));
            GridColumnsDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: 'grid-columns-directive' },] },
            ];
            /** @nocollapse */
            GridColumnsDirective.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: GridColumnsStyleBuilder, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleUtils"] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["MediaMarshaller"] }
            ]; };
            GridColumnsDirective.propDecorators = {
                inline: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['gdInline',] }]
            };
            /** @type {?} */
            var columnsCache = new Map();
            /** @type {?} */
            var columnsInlineCache = new Map();
            /** @type {?} */
            var inputs$7 = [
                'gdColumns',
                'gdColumns.xs', 'gdColumns.sm', 'gdColumns.md', 'gdColumns.lg', 'gdColumns.xl',
                'gdColumns.lt-sm', 'gdColumns.lt-md', 'gdColumns.lt-lg', 'gdColumns.lt-xl',
                'gdColumns.gt-xs', 'gdColumns.gt-sm', 'gdColumns.gt-md', 'gdColumns.gt-lg'
            ];
            /** @type {?} */
            var selector$7 = "\n  [gdColumns],\n  [gdColumns.xs], [gdColumns.sm], [gdColumns.md], [gdColumns.lg], [gdColumns.xl],\n  [gdColumns.lt-sm], [gdColumns.lt-md], [gdColumns.lt-lg], [gdColumns.lt-xl],\n  [gdColumns.gt-xs], [gdColumns.gt-sm], [gdColumns.gt-md], [gdColumns.gt-lg]\n";
            /**
             * 'grid-template-columns' CSS Grid styling directive
             * Configures the sizing for the columns in the grid
             * Syntax: <column value> [auto]
             * @see https://css-tricks.com/snippets/css/complete-guide-grid/#article-header-id-13
             */
            var DefaultGridColumnsDirective = /** @class */ (function (_super) {
                __extends(DefaultGridColumnsDirective, _super);
                function DefaultGridColumnsDirective() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.inputs = inputs$7;
                    return _this_1;
                }
                return DefaultGridColumnsDirective;
            }(GridColumnsDirective));
            DefaultGridColumnsDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: selector$7, inputs: inputs$7 },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var DEFAULT_VALUE$5 = '0';
            var GridGapStyleBuilder = /** @class */ (function (_super) {
                __extends(GridGapStyleBuilder, _super);
                function GridGapStyleBuilder() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                /**
                 * @param {?} input
                 * @param {?} parent
                 * @return {?}
                 */
                GridGapStyleBuilder.prototype.buildStyles = function (input, parent) {
                    return {
                        'display': parent.inline ? 'inline-grid' : 'grid',
                        'grid-gap': input || DEFAULT_VALUE$5
                    };
                };
                return GridGapStyleBuilder;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleBuilder"]));
            GridGapStyleBuilder.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */ GridGapStyleBuilder.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function GridGapStyleBuilder_Factory() { return new GridGapStyleBuilder(); }, token: GridGapStyleBuilder, providedIn: "root" });
            var GridGapDirective = /** @class */ (function (_super) {
                __extends(GridGapDirective, _super);
                /**
                 * @param {?} elRef
                 * @param {?} styleUtils
                 * @param {?} styleBuilder
                 * @param {?} marshal
                 */
                function GridGapDirective(elRef, styleUtils, styleBuilder, marshal) {
                    var _this_1 = _super.call(this, elRef, styleBuilder, styleUtils, marshal) || this;
                    _this_1.elRef = elRef;
                    _this_1.styleUtils = styleUtils;
                    _this_1.styleBuilder = styleBuilder;
                    _this_1.marshal = marshal;
                    _this_1.DIRECTIVE_KEY = 'grid-gap';
                    _this_1._inline = false;
                    _this_1.init();
                    return _this_1;
                }
                Object.defineProperty(GridGapDirective.prototype, "inline", {
                    /**
                     * @return {?}
                     */
                    get: function () { return this._inline; },
                    /**
                     * @param {?} val
                     * @return {?}
                     */
                    set: function (val) { this._inline = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(val); },
                    enumerable: true,
                    configurable: true
                });
                // *********************************************
                // Protected methods
                // *********************************************
                /**
                 * @protected
                 * @param {?} value
                 * @return {?}
                 */
                GridGapDirective.prototype.updateWithValue = function (value) {
                    this.styleCache = this.inline ? gapInlineCache : gapCache;
                    this.addStyles(value, { inline: this.inline });
                };
                return GridGapDirective;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["BaseDirective2"]));
            GridGapDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: 'grid-gap-directive' },] },
            ];
            /** @nocollapse */
            GridGapDirective.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleUtils"] },
                { type: GridGapStyleBuilder, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["MediaMarshaller"] }
            ]; };
            GridGapDirective.propDecorators = {
                inline: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['gdInline',] }]
            };
            /** @type {?} */
            var gapCache = new Map();
            /** @type {?} */
            var gapInlineCache = new Map();
            /** @type {?} */
            var inputs$8 = [
                'gdGap',
                'gdGap.xs', 'gdGap.sm', 'gdGap.md', 'gdGap.lg', 'gdGap.xl',
                'gdGap.lt-sm', 'gdGap.lt-md', 'gdGap.lt-lg', 'gdGap.lt-xl',
                'gdGap.gt-xs', 'gdGap.gt-sm', 'gdGap.gt-md', 'gdGap.gt-lg'
            ];
            /** @type {?} */
            var selector$8 = "\n  [gdGap],\n  [gdGap.xs], [gdGap.sm], [gdGap.md], [gdGap.lg], [gdGap.xl],\n  [gdGap.lt-sm], [gdGap.lt-md], [gdGap.lt-lg], [gdGap.lt-xl],\n  [gdGap.gt-xs], [gdGap.gt-sm], [gdGap.gt-md], [gdGap.gt-lg]\n";
            /**
             * 'grid-gap' CSS Grid styling directive
             * Configures the gap between items in the grid
             * Syntax: <row gap> [<column-gap>]
             * @see https://css-tricks.com/snippets/css/complete-guide-grid/#article-header-id-17
             */
            var DefaultGridGapDirective = /** @class */ (function (_super) {
                __extends(DefaultGridGapDirective, _super);
                function DefaultGridGapDirective() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.inputs = inputs$8;
                    return _this_1;
                }
                return DefaultGridGapDirective;
            }(GridGapDirective));
            DefaultGridGapDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: selector$8, inputs: inputs$8 },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var DEFAULT_VALUE$6 = 'auto';
            var GridRowStyleBuilder = /** @class */ (function (_super) {
                __extends(GridRowStyleBuilder, _super);
                function GridRowStyleBuilder() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                /**
                 * @param {?} input
                 * @return {?}
                 */
                GridRowStyleBuilder.prototype.buildStyles = function (input) {
                    return { 'grid-row': input || DEFAULT_VALUE$6 };
                };
                return GridRowStyleBuilder;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleBuilder"]));
            GridRowStyleBuilder.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */ GridRowStyleBuilder.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function GridRowStyleBuilder_Factory() { return new GridRowStyleBuilder(); }, token: GridRowStyleBuilder, providedIn: "root" });
            var GridRowDirective = /** @class */ (function (_super) {
                __extends(GridRowDirective, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} styleBuilder
                 * @param {?} styler
                 * @param {?} marshal
                 */
                function GridRowDirective(elementRef, styleBuilder, styler, marshal) {
                    var _this_1 = _super.call(this, elementRef, styleBuilder, styler, marshal) || this;
                    _this_1.elementRef = elementRef;
                    _this_1.styleBuilder = styleBuilder;
                    _this_1.styler = styler;
                    _this_1.marshal = marshal;
                    _this_1.DIRECTIVE_KEY = 'grid-row';
                    _this_1.styleCache = rowCache;
                    _this_1.init();
                    return _this_1;
                }
                return GridRowDirective;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["BaseDirective2"]));
            GridRowDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: 'grid-row-directive' },] },
            ];
            /** @nocollapse */
            GridRowDirective.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: GridRowStyleBuilder, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleUtils"] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["MediaMarshaller"] }
            ]; };
            /** @type {?} */
            var rowCache = new Map();
            /** @type {?} */
            var inputs$9 = [
                'gdRow',
                'gdRow.xs', 'gdRow.sm', 'gdRow.md', 'gdRow.lg', 'gdRow.xl',
                'gdRow.lt-sm', 'gdRow.lt-md', 'gdRow.lt-lg', 'gdRow.lt-xl',
                'gdRow.gt-xs', 'gdRow.gt-sm', 'gdRow.gt-md', 'gdRow.gt-lg'
            ];
            /** @type {?} */
            var selector$9 = "\n  [gdRow],\n  [gdRow.xs], [gdRow.sm], [gdRow.md], [gdRow.lg], [gdRow.xl],\n  [gdRow.lt-sm], [gdRow.lt-md], [gdRow.lt-lg], [gdRow.lt-xl],\n  [gdRow.gt-xs], [gdRow.gt-sm], [gdRow.gt-md], [gdRow.gt-lg]\n";
            /**
             * 'grid-row' CSS Grid styling directive
             * Configures the name or position of an element within the grid
             * @see https://css-tricks.com/snippets/css/complete-guide-grid/#article-header-id-26
             */
            var DefaultGridRowDirective = /** @class */ (function (_super) {
                __extends(DefaultGridRowDirective, _super);
                function DefaultGridRowDirective() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.inputs = inputs$9;
                    return _this_1;
                }
                return DefaultGridRowDirective;
            }(GridRowDirective));
            DefaultGridRowDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: selector$9, inputs: inputs$9 },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var DEFAULT_VALUE$7 = 'none';
            /** @type {?} */
            var AUTO_SPECIFIER$1 = '!';
            var GridRowsStyleBuilder = /** @class */ (function (_super) {
                __extends(GridRowsStyleBuilder, _super);
                function GridRowsStyleBuilder() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                /**
                 * @param {?} input
                 * @param {?} parent
                 * @return {?}
                 */
                GridRowsStyleBuilder.prototype.buildStyles = function (input, parent) {
                    input = input || DEFAULT_VALUE$7;
                    /** @type {?} */
                    var auto = false;
                    if (input.endsWith(AUTO_SPECIFIER$1)) {
                        input = input.substring(0, input.indexOf(AUTO_SPECIFIER$1));
                        auto = true;
                    }
                    /** @type {?} */
                    var css = {
                        'display': parent.inline ? 'inline-grid' : 'grid',
                        'grid-auto-rows': '',
                        'grid-template-rows': '',
                    };
                    /** @type {?} */
                    var key = (auto ? 'grid-auto-rows' : 'grid-template-rows');
                    css[key] = input;
                    return css;
                };
                return GridRowsStyleBuilder;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleBuilder"]));
            GridRowsStyleBuilder.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */ GridRowsStyleBuilder.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function GridRowsStyleBuilder_Factory() { return new GridRowsStyleBuilder(); }, token: GridRowsStyleBuilder, providedIn: "root" });
            var GridRowsDirective = /** @class */ (function (_super) {
                __extends(GridRowsDirective, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} styleBuilder
                 * @param {?} styler
                 * @param {?} marshal
                 */
                function GridRowsDirective(elementRef, styleBuilder, styler, marshal) {
                    var _this_1 = _super.call(this, elementRef, styleBuilder, styler, marshal) || this;
                    _this_1.elementRef = elementRef;
                    _this_1.styleBuilder = styleBuilder;
                    _this_1.styler = styler;
                    _this_1.marshal = marshal;
                    _this_1.DIRECTIVE_KEY = 'grid-rows';
                    _this_1._inline = false;
                    _this_1.init();
                    return _this_1;
                }
                Object.defineProperty(GridRowsDirective.prototype, "inline", {
                    /**
                     * @return {?}
                     */
                    get: function () { return this._inline; },
                    /**
                     * @param {?} val
                     * @return {?}
                     */
                    set: function (val) { this._inline = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(val); },
                    enumerable: true,
                    configurable: true
                });
                // *********************************************
                // Protected methods
                // *********************************************
                /**
                 * @protected
                 * @param {?} value
                 * @return {?}
                 */
                GridRowsDirective.prototype.updateWithValue = function (value) {
                    this.styleCache = this.inline ? rowsInlineCache : rowsCache;
                    this.addStyles(value, { inline: this.inline });
                };
                return GridRowsDirective;
            }(_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["BaseDirective2"]));
            GridRowsDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: 'grid-rows-directive' },] },
            ];
            /** @nocollapse */
            GridRowsDirective.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: GridRowsStyleBuilder, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["StyleUtils"] },
                { type: _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["MediaMarshaller"] }
            ]; };
            GridRowsDirective.propDecorators = {
                inline: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['gdInline',] }]
            };
            /** @type {?} */
            var rowsCache = new Map();
            /** @type {?} */
            var rowsInlineCache = new Map();
            /** @type {?} */
            var inputs$10 = [
                'gdRows',
                'gdRows.xs', 'gdRows.sm', 'gdRows.md', 'gdRows.lg', 'gdRows.xl',
                'gdRows.lt-sm', 'gdRows.lt-md', 'gdRows.lt-lg', 'gdRows.lt-xl',
                'gdRows.gt-xs', 'gdRows.gt-sm', 'gdRows.gt-md', 'gdRows.gt-lg'
            ];
            /** @type {?} */
            var selector$10 = "\n  [gdRows],\n  [gdRows.xs], [gdRows.sm], [gdRows.md], [gdRows.lg], [gdRows.xl],\n  [gdRows.lt-sm], [gdRows.lt-md], [gdRows.lt-lg], [gdRows.lt-xl],\n  [gdRows.gt-xs], [gdRows.gt-sm], [gdRows.gt-md], [gdRows.gt-lg]\n";
            /**
             * 'grid-template-rows' CSS Grid styling directive
             * Configures the sizing for the rows in the grid
             * Syntax: <column value> [auto]
             * @see https://css-tricks.com/snippets/css/complete-guide-grid/#article-header-id-13
             */
            var DefaultGridRowsDirective = /** @class */ (function (_super) {
                __extends(DefaultGridRowsDirective, _super);
                function DefaultGridRowsDirective() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.inputs = inputs$10;
                    return _this_1;
                }
                return DefaultGridRowsDirective;
            }(GridRowsDirective));
            DefaultGridRowsDirective.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: selector$10, inputs: inputs$10 },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var ALL_DIRECTIVES = [
                DefaultGridAlignDirective,
                DefaultGridAlignColumnsDirective,
                DefaultGridAlignRowsDirective,
                DefaultGridAreaDirective,
                DefaultGridAreasDirective,
                DefaultGridAutoDirective,
                DefaultGridColumnDirective,
                DefaultGridColumnsDirective,
                DefaultGridGapDirective,
                DefaultGridRowDirective,
                DefaultGridRowsDirective,
                GridAlignColumnsDirective,
                GridAlignRowsDirective,
                GridAreaDirective,
                GridAreasDirective,
                GridAutoDirective,
                GridColumnDirective,
                GridColumnsDirective,
                GridGapDirective,
                GridAlignDirective,
                GridRowDirective,
                GridRowsDirective,
            ];
            /**
             * *****************************************************************
             * Define module for the CSS Grid API
             * *****************************************************************
             */
            var GridModule = /** @class */ (function () {
                function GridModule() {
                }
                return GridModule;
            }());
            GridModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [_angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_1__["CoreModule"]],
                            declarations: ALL_DIRECTIVES.slice(),
                            exports: ALL_DIRECTIVES.slice()
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=grid.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/autocomplete.js": 
        /*!****************************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/autocomplete.js ***!
          \****************************************************************/
        /*! exports provided: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY, MatAutocompleteSelectedEvent, MAT_AUTOCOMPLETE_DEFAULT_OPTIONS, MatAutocomplete, MatAutocompleteModule, MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY, getMatAutocompleteMissingPanelError, AUTOCOMPLETE_OPTION_HEIGHT, AUTOCOMPLETE_PANEL_HEIGHT, MAT_AUTOCOMPLETE_SCROLL_STRATEGY, MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER, MAT_AUTOCOMPLETE_VALUE_ACCESSOR, MatAutocompleteTrigger, MatAutocompleteOrigin */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY", function () { return MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatAutocompleteSelectedEvent", function () { return MatAutocompleteSelectedEvent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_AUTOCOMPLETE_DEFAULT_OPTIONS", function () { return MAT_AUTOCOMPLETE_DEFAULT_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatAutocomplete", function () { return MatAutocomplete; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatAutocompleteModule", function () { return MatAutocompleteModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY", function () { return MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMatAutocompleteMissingPanelError", function () { return getMatAutocompleteMissingPanelError; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AUTOCOMPLETE_OPTION_HEIGHT", function () { return AUTOCOMPLETE_OPTION_HEIGHT; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AUTOCOMPLETE_PANEL_HEIGHT", function () { return AUTOCOMPLETE_PANEL_HEIGHT; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_AUTOCOMPLETE_SCROLL_STRATEGY", function () { return MAT_AUTOCOMPLETE_SCROLL_STRATEGY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER", function () { return MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_AUTOCOMPLETE_VALUE_ACCESSOR", function () { return MAT_AUTOCOMPLETE_VALUE_ACCESSOR; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatAutocompleteTrigger", function () { return MatAutocompleteTrigger; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatAutocompleteOrigin", function () { return MatAutocompleteOrigin; });
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /* harmony import */ var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/overlay */ "./node_modules/@angular/cdk/esm2015/overlay.js");
            /* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/cdk/platform */ "./node_modules/@angular/cdk/esm2015/platform.js");
            /* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/cdk/portal */ "./node_modules/@angular/cdk/esm2015/portal.js");
            /* harmony import */ var _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/cdk/scrolling */ "./node_modules/@angular/cdk/esm2015/scrolling.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
            /* harmony import */ var _angular_material_form_field__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @angular/material/form-field */ "./node_modules/@angular/material/esm2015/form-field.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Autocomplete IDs need to be unique across components, so this counter exists outside of
             * the component definition.
             * @type {?}
             */
            var _uniqueAutocompleteIdCounter = 0;
            /**
             * Event object that is emitted when an autocomplete option is selected.
             */
            var MatAutocompleteSelectedEvent = /** @class */ (function () {
                /**
                 * @param {?} source
                 * @param {?} option
                 */
                function MatAutocompleteSelectedEvent(source, option) {
                    this.source = source;
                    this.option = option;
                }
                return MatAutocompleteSelectedEvent;
            }());
            // Boilerplate for applying mixins to MatAutocomplete.
            /**
             * \@docs-private
             */
            var MatAutocompleteBase = /** @class */ (function () {
                function MatAutocompleteBase() {
                }
                return MatAutocompleteBase;
            }());
            /** @type {?} */
            var _MatAutocompleteMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["mixinDisableRipple"])(MatAutocompleteBase);
            /**
             * Injection token to be used to override the default options for `mat-autocomplete`.
             * @type {?}
             */
            var MAT_AUTOCOMPLETE_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["InjectionToken"]('mat-autocomplete-default-options', {
                providedIn: 'root',
                factory: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY,
            });
            /**
             * \@docs-private
             * @return {?}
             */
            function MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY() {
                return { autoActiveFirstOption: false };
            }
            var MatAutocomplete = /** @class */ (function (_super) {
                __extends(MatAutocomplete, _super);
                /**
                 * @param {?} _changeDetectorRef
                 * @param {?} _elementRef
                 * @param {?} defaults
                 */
                function MatAutocomplete(_changeDetectorRef, _elementRef, defaults) {
                    var _this_1 = _super.call(this) || this;
                    _this_1._changeDetectorRef = _changeDetectorRef;
                    _this_1._elementRef = _elementRef;
                    /**
                     * Whether the autocomplete panel should be visible, depending on option length.
                     */
                    _this_1.showPanel = false;
                    _this_1._isOpen = false;
                    /**
                     * Function that maps an option's control value to its display value in the trigger.
                     */
                    _this_1.displayWith = null;
                    /**
                     * Event that is emitted whenever an option from the list is selected.
                     */
                    _this_1.optionSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
                    /**
                     * Event that is emitted when the autocomplete panel is opened.
                     */
                    _this_1.opened = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
                    /**
                     * Event that is emitted when the autocomplete panel is closed.
                     */
                    _this_1.closed = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
                    _this_1._classList = {};
                    /**
                     * Unique ID to be used by autocomplete trigger's "aria-owns" property.
                     */
                    _this_1.id = "mat-autocomplete-" + _uniqueAutocompleteIdCounter++;
                    _this_1._autoActiveFirstOption = !!defaults.autoActiveFirstOption;
                    return _this_1;
                }
                Object.defineProperty(MatAutocomplete.prototype, "isOpen", {
                    /**
                     * Whether the autocomplete panel is open.
                     * @return {?}
                     */
                    get: function () { return this._isOpen && this.showPanel; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatAutocomplete.prototype, "autoActiveFirstOption", {
                    /**
                     * Whether the first option should be highlighted when the autocomplete panel is opened.
                     * Can be configured globally through the `MAT_AUTOCOMPLETE_DEFAULT_OPTIONS` token.
                     * @return {?}
                     */
                    get: function () { return this._autoActiveFirstOption; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._autoActiveFirstOption = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatAutocomplete.prototype, "classList", {
                    /**
                     * Takes classes set on the host mat-autocomplete element and applies them to the panel
                     * inside the overlay container to allow for easy styling.
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (value && value.length) {
                            this._classList = value.split(' ').reduce(( /**
                             * @param {?} classList
                             * @param {?} className
                             * @return {?}
                             */function (classList, className) {
                                classList[className.trim()] = true;
                                return classList;
                            }), ( /** @type {?} */({})));
                        }
                        else {
                            this._classList = {};
                        }
                        this._setVisibilityClasses(this._classList);
                        this._elementRef.nativeElement.className = '';
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatAutocomplete.prototype.ngAfterContentInit = function () {
                    this._keyManager = new _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__["ActiveDescendantKeyManager"](this.options).withWrap();
                    // Set the initial visibility state.
                    this._setVisibility();
                };
                /**
                 * Sets the panel scrollTop. This allows us to manually scroll to display options
                 * above or below the fold, as they are not actually being focused when active.
                 * @param {?} scrollTop
                 * @return {?}
                 */
                MatAutocomplete.prototype._setScrollTop = function (scrollTop) {
                    if (this.panel) {
                        this.panel.nativeElement.scrollTop = scrollTop;
                    }
                };
                /**
                 * Returns the panel's scrollTop.
                 * @return {?}
                 */
                MatAutocomplete.prototype._getScrollTop = function () {
                    return this.panel ? this.panel.nativeElement.scrollTop : 0;
                };
                /**
                 * Panel should hide itself when the option list is empty.
                 * @return {?}
                 */
                MatAutocomplete.prototype._setVisibility = function () {
                    this.showPanel = !!this.options.length;
                    this._setVisibilityClasses(this._classList);
                    this._changeDetectorRef.markForCheck();
                };
                /**
                 * Emits the `select` event.
                 * @param {?} option
                 * @return {?}
                 */
                MatAutocomplete.prototype._emitSelectEvent = function (option) {
                    /** @type {?} */
                    var event = new MatAutocompleteSelectedEvent(this, option);
                    this.optionSelected.emit(event);
                };
                /**
                 * Sets the autocomplete visibility classes on a classlist based on the panel is visible.
                 * @private
                 * @param {?} classList
                 * @return {?}
                 */
                MatAutocomplete.prototype._setVisibilityClasses = function (classList) {
                    classList['mat-autocomplete-visible'] = this.showPanel;
                    classList['mat-autocomplete-hidden'] = !this.showPanel;
                };
                return MatAutocomplete;
            }(_MatAutocompleteMixinBase));
            MatAutocomplete.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Component"], args: [{ selector: 'mat-autocomplete',
                            template: "<ng-template><div class=\"mat-autocomplete-panel\" role=\"listbox\" [id]=\"id\" [ngClass]=\"_classList\" #panel><ng-content></ng-content></div></ng-template>",
                            styles: [".mat-autocomplete-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;visibility:hidden;max-width:none;max-height:256px;position:relative;width:100%;border-bottom-left-radius:4px;border-bottom-right-radius:4px}.mat-autocomplete-panel.mat-autocomplete-visible{visibility:visible}.mat-autocomplete-panel.mat-autocomplete-hidden{visibility:hidden}.mat-autocomplete-panel-above .mat-autocomplete-panel{border-radius:0;border-top-left-radius:4px;border-top-right-radius:4px}.mat-autocomplete-panel .mat-divider-horizontal{margin-top:-1px}@media (-ms-high-contrast:active){.mat-autocomplete-panel{outline:solid 1px}}"],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ChangeDetectionStrategy"].OnPush,
                            exportAs: 'matAutocomplete',
                            inputs: ['disableRipple'],
                            host: {
                                'class': 'mat-autocomplete'
                            },
                            providers: [
                                { provide: _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MAT_OPTION_PARENT_COMPONENT"], useExisting: MatAutocomplete }
                            ]
                        },] },
            ];
            /** @nocollapse */
            MatAutocomplete.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ChangeDetectorRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ElementRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Inject"], args: [MAT_AUTOCOMPLETE_DEFAULT_OPTIONS,] }] }
            ]; };
            MatAutocomplete.propDecorators = {
                template: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ViewChild"], args: [_angular_core__WEBPACK_IMPORTED_MODULE_2__["TemplateRef"], { static: true },] }],
                panel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ViewChild"], args: ['panel', { static: false },] }],
                options: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ContentChildren"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatOption"], { descendants: true },] }],
                optionGroups: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ContentChildren"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatOptgroup"],] }],
                displayWith: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"] }],
                autoActiveFirstOption: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"] }],
                panelWidth: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"] }],
                optionSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"] }],
                opened: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"] }],
                closed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"] }],
                classList: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['class',] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Directive applied to an element to make it usable
             * as a connection point for an autocomplete panel.
             */
            var MatAutocompleteOrigin = /** @class */ (function () {
                /**
                 * @param {?} elementRef
                 */
                function MatAutocompleteOrigin(elementRef) {
                    this.elementRef = elementRef;
                }
                return MatAutocompleteOrigin;
            }());
            MatAutocompleteOrigin.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Directive"], args: [{
                            selector: '[matAutocompleteOrigin]',
                            exportAs: 'matAutocompleteOrigin',
                        },] },
            ];
            /** @nocollapse */
            MatAutocompleteOrigin.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ElementRef"] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * The height of each autocomplete option.
             * @type {?}
             */
            var AUTOCOMPLETE_OPTION_HEIGHT = 48;
            /**
             * The total height of the autocomplete panel.
             * @type {?}
             */
            var AUTOCOMPLETE_PANEL_HEIGHT = 256;
            /**
             * Injection token that determines the scroll handling while the autocomplete panel is open.
             * @type {?}
             */
            var MAT_AUTOCOMPLETE_SCROLL_STRATEGY = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["InjectionToken"]('mat-autocomplete-scroll-strategy');
            /**
             * \@docs-private
             * @param {?} overlay
             * @return {?}
             */
            function MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY(overlay) {
                return ( /**
                 * @return {?}
                 */function () { return overlay.scrollStrategies.reposition(); });
            }
            /**
             * \@docs-private
             * @type {?}
             */
            var MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = {
                provide: MAT_AUTOCOMPLETE_SCROLL_STRATEGY,
                deps: [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["Overlay"]],
                useFactory: MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY,
            };
            /**
             * Provider that allows the autocomplete to register as a ControlValueAccessor.
             * \@docs-private
             * @type {?}
             */
            var MAT_AUTOCOMPLETE_VALUE_ACCESSOR = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_11__["NG_VALUE_ACCESSOR"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatAutocompleteTrigger; })),
                multi: true
            };
            /**
             * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.
             * \@docs-private
             * @return {?}
             */
            function getMatAutocompleteMissingPanelError() {
                return Error('Attempting to open an undefined instance of `mat-autocomplete`. ' +
                    'Make sure that the id passed to the `matAutocomplete` is correct and that ' +
                    'you\'re attempting to open it after the ngAfterContentInit hook.');
            }
            var MatAutocompleteTrigger = /** @class */ (function () {
                /**
                 * @param {?} _element
                 * @param {?} _overlay
                 * @param {?} _viewContainerRef
                 * @param {?} _zone
                 * @param {?} _changeDetectorRef
                 * @param {?} scrollStrategy
                 * @param {?} _dir
                 * @param {?} _formField
                 * @param {?} _document
                 * @param {?=} _viewportRuler
                 */
                function MatAutocompleteTrigger(_element, _overlay, _viewContainerRef, _zone, _changeDetectorRef, scrollStrategy, _dir, _formField, _document, _viewportRuler) {
                    var _this_1 = this;
                    this._element = _element;
                    this._overlay = _overlay;
                    this._viewContainerRef = _viewContainerRef;
                    this._zone = _zone;
                    this._changeDetectorRef = _changeDetectorRef;
                    this._dir = _dir;
                    this._formField = _formField;
                    this._document = _document;
                    this._viewportRuler = _viewportRuler;
                    this._componentDestroyed = false;
                    this._autocompleteDisabled = false;
                    /**
                     * Whether or not the label state is being overridden.
                     */
                    this._manuallyFloatingLabel = false;
                    /**
                     * Subscription to viewport size changes.
                     */
                    this._viewportSubscription = rxjs__WEBPACK_IMPORTED_MODULE_13__["Subscription"].EMPTY;
                    /**
                     * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,
                     * closed autocomplete from being reopened if the user switches to another browser tab and then
                     * comes back.
                     */
                    this._canOpenOnNextFocus = true;
                    /**
                     * Stream of keyboard events that can close the panel.
                     */
                    this._closeKeyEventStream = new rxjs__WEBPACK_IMPORTED_MODULE_13__["Subject"]();
                    /**
                     * Event handler for when the window is blurred. Needs to be an
                     * arrow function in order to preserve the context.
                     */
                    this._windowBlurHandler = ( /**
                     * @return {?}
                     */function () {
                        // If the user blurred the window while the autocomplete is focused, it means that it'll be
                        // refocused when they come back. In this case we want to skip the first focus event, if the
                        // pane was closed, in order to avoid reopening it unintentionally.
                        _this_1._canOpenOnNextFocus =
                            _this_1._document.activeElement !== _this_1._element.nativeElement || _this_1.panelOpen;
                    });
                    /**
                     * `View -> model callback called when value changes`
                     */
                    this._onChange = ( /**
                     * @return {?}
                     */function () { });
                    /**
                     * `View -> model callback called when autocomplete has been touched`
                     */
                    this._onTouched = ( /**
                     * @return {?}
                     */function () { });
                    /**
                     * Position of the autocomplete panel relative to the trigger element. A position of `auto`
                     * will render the panel underneath the trigger if there is enough space for it to fit in
                     * the viewport, otherwise the panel will be shown above it. If the position is set to
                     * `above` or `below`, the panel will always be shown above or below the trigger. no matter
                     * whether it fits completely in the viewport.
                     */
                    this.position = 'auto';
                    /**
                     * `autocomplete` attribute to be set on the input element.
                     * \@docs-private
                     */
                    this.autocompleteAttribute = 'off';
                    this._overlayAttached = false;
                    /**
                     * Stream of autocomplete option selections.
                     */
                    this.optionSelections = ( /** @type {?} */(Object(rxjs__WEBPACK_IMPORTED_MODULE_13__["defer"])(( /**
                     * @return {?}
                     */function () {
                        if (_this_1.autocomplete && _this_1.autocomplete.options) {
                            return Object(rxjs__WEBPACK_IMPORTED_MODULE_13__["merge"]).apply(void 0, _this_1.autocomplete.options.map(( /**
                             * @param {?} option
                             * @return {?}
                             */function (/**
                             * @param {?} option
                             * @return {?}
                             */ option) { return option.onSelectionChange; })));
                        }
                        // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.
                        // Return a stream that we'll replace with the real one once everything is in place.
                        return _this_1._zone.onStable
                            .asObservable()
                            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["take"])(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["switchMap"])(( /**
                     * @return {?}
                     */function () { return _this_1.optionSelections; })));
                    }))));
                    this._scrollStrategy = scrollStrategy;
                }
                Object.defineProperty(MatAutocompleteTrigger.prototype, "autocompleteDisabled", {
                    /**
                     * Whether the autocomplete is disabled. When disabled, the element will
                     * act as a regular input and the user won't be able to open the panel.
                     * @return {?}
                     */
                    get: function () { return this._autocompleteDisabled; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._autocompleteDisabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype.ngAfterViewInit = function () {
                    var _this_1 = this;
                    if (typeof window !== 'undefined') {
                        this._zone.runOutsideAngular(( /**
                         * @return {?}
                         */function () {
                            window.addEventListener('blur', _this_1._windowBlurHandler);
                        }));
                        if (Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_7__["_supportsShadowDom"])()) {
                            /** @type {?} */
                            var element = this._element.nativeElement;
                            /** @type {?} */
                            var rootNode = element.getRootNode ? element.getRootNode() : null;
                            // We need to take the `ShadowRoot` off of `window`, because the built-in types are
                            // incorrect. See https://github.com/Microsoft/TypeScript/issues/27929.
                            this._isInsideShadowRoot = rootNode instanceof (( /** @type {?} */(window))).ShadowRoot;
                        }
                    }
                };
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype.ngOnChanges = function (changes) {
                    if (changes['position'] && this._positionStrategy) {
                        this._setStrategyPositions(this._positionStrategy);
                        if (this.panelOpen) {
                            ( /** @type {?} */(this._overlayRef)).updatePosition();
                        }
                    }
                };
                /**
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype.ngOnDestroy = function () {
                    if (typeof window !== 'undefined') {
                        window.removeEventListener('blur', this._windowBlurHandler);
                    }
                    this._viewportSubscription.unsubscribe();
                    this._componentDestroyed = true;
                    this._destroyPanel();
                    this._closeKeyEventStream.complete();
                };
                Object.defineProperty(MatAutocompleteTrigger.prototype, "panelOpen", {
                    /**
                     * Whether or not the autocomplete panel is open.
                     * @return {?}
                     */
                    get: function () {
                        return this._overlayAttached && this.autocomplete.showPanel;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Opens the autocomplete suggestion panel.
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype.openPanel = function () {
                    this._attachOverlay();
                    this._floatLabel();
                };
                /**
                 * Closes the autocomplete suggestion panel.
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype.closePanel = function () {
                    this._resetLabel();
                    if (!this._overlayAttached) {
                        return;
                    }
                    if (this.panelOpen) {
                        // Only emit if the panel was visible.
                        this.autocomplete.closed.emit();
                    }
                    this.autocomplete._isOpen = this._overlayAttached = false;
                    if (this._overlayRef && this._overlayRef.hasAttached()) {
                        this._overlayRef.detach();
                        this._closingActionsSubscription.unsubscribe();
                    }
                    // Note that in some cases this can end up being called after the component is destroyed.
                    // Add a check to ensure that we don't try to run change detection on a destroyed view.
                    if (!this._componentDestroyed) {
                        // We need to trigger change detection manually, because
                        // `fromEvent` doesn't seem to do it at the proper time.
                        // This ensures that the label is reset when the
                        // user clicks outside.
                        this._changeDetectorRef.detectChanges();
                    }
                };
                /**
                 * Updates the position of the autocomplete suggestion panel to ensure that it fits all options
                 * within the viewport.
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype.updatePosition = function () {
                    if (this._overlayAttached) {
                        ( /** @type {?} */(this._overlayRef)).updatePosition();
                    }
                };
                Object.defineProperty(MatAutocompleteTrigger.prototype, "panelClosingActions", {
                    /**
                     * A stream of actions that should close the autocomplete panel, including
                     * when an option is selected, on blur, and when TAB is pressed.
                     * @return {?}
                     */
                    get: function () {
                        var _this_1 = this;
                        return Object(rxjs__WEBPACK_IMPORTED_MODULE_13__["merge"])(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["filter"])(( /**
                         * @return {?}
                         */function () { return _this_1._overlayAttached; }))), this._closeKeyEventStream, this._getOutsideClickStream(), this._overlayRef ?
                            this._overlayRef.detachments().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["filter"])(( /**
                             * @return {?}
                             */function () { return _this_1._overlayAttached; }))) :
                            Object(rxjs__WEBPACK_IMPORTED_MODULE_13__["of"])()).pipe(
                        // Normalize the output so we return a consistent type.
                        Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["map"])(( /**
                         * @param {?} event
                         * @return {?}
                         */function (/**
                         * @param {?} event
                         * @return {?}
                         */ event) { return event instanceof _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatOptionSelectionChange"] ? event : null; })));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatAutocompleteTrigger.prototype, "activeOption", {
                    /**
                     * The currently active option, coerced to MatOption type.
                     * @return {?}
                     */
                    get: function () {
                        if (this.autocomplete && this.autocomplete._keyManager) {
                            return this.autocomplete._keyManager.activeItem;
                        }
                        return null;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Stream of clicks outside of the autocomplete panel.
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._getOutsideClickStream = function () {
                    var _this_1 = this;
                    return Object(rxjs__WEBPACK_IMPORTED_MODULE_13__["merge"])(( /** @type {?} */(Object(rxjs__WEBPACK_IMPORTED_MODULE_13__["fromEvent"])(this._document, 'click'))), ( /** @type {?} */(Object(rxjs__WEBPACK_IMPORTED_MODULE_13__["fromEvent"])(this._document, 'touchend'))))
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["filter"])(( /**
                 * @param {?} event
                 * @return {?}
                 */function (/**
                 * @param {?} event
                 * @return {?}
                 */ event) {
                        // If we're in the Shadow DOM, the event target will be the shadow root, so we have to
                        // fall back to check the first element in the path of the click event.
                        /** @type {?} */
                        var clickTarget = ( /** @type {?} */((_this_1._isInsideShadowRoot && event.composedPath ? event.composedPath()[0] :
                            event.target)));
                        /** @type {?} */
                        var formField = _this_1._formField ? _this_1._formField._elementRef.nativeElement : null;
                        return _this_1._overlayAttached && clickTarget !== _this_1._element.nativeElement &&
                            (!formField || !formField.contains(clickTarget)) &&
                            (!!_this_1._overlayRef && !_this_1._overlayRef.overlayElement.contains(clickTarget));
                    })));
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} value
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype.writeValue = function (value) {
                    var _this_1 = this;
                    Promise.resolve(null).then(( /**
                     * @return {?}
                     */function () { return _this_1._setTriggerValue(value); }));
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} fn
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype.registerOnChange = function (fn) {
                    this._onChange = fn;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} fn
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype.registerOnTouched = function (fn) {
                    this._onTouched = fn;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} isDisabled
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype.setDisabledState = function (isDisabled) {
                    this._element.nativeElement.disabled = isDisabled;
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._handleKeydown = function (event) {
                    /** @type {?} */
                    var keyCode = event.keyCode;
                    // Prevent the default action on all escape key presses. This is here primarily to bring IE
                    // in line with other browsers. By default, pressing escape on IE will cause it to revert
                    // the input value to the one that it had on focus, however it won't dispatch any events
                    // which means that the model value will be out of sync with the view.
                    if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["ESCAPE"]) {
                        event.preventDefault();
                    }
                    if (this.activeOption && keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["ENTER"] && this.panelOpen) {
                        this.activeOption._selectViaInteraction();
                        this._resetActiveItem();
                        event.preventDefault();
                    }
                    else if (this.autocomplete) {
                        /** @type {?} */
                        var prevActiveItem = this.autocomplete._keyManager.activeItem;
                        /** @type {?} */
                        var isArrowKey = keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["UP_ARROW"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["DOWN_ARROW"];
                        if (this.panelOpen || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["TAB"]) {
                            this.autocomplete._keyManager.onKeydown(event);
                        }
                        else if (isArrowKey && this._canOpen()) {
                            this.openPanel();
                        }
                        if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {
                            this._scrollToOption();
                        }
                    }
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._handleInput = function (event) {
                    /** @type {?} */
                    var target = ( /** @type {?} */(event.target));
                    /** @type {?} */
                    var value = target.value;
                    // Based on `NumberValueAccessor` from forms.
                    if (target.type === 'number') {
                        value = value == '' ? null : parseFloat(value);
                    }
                    // If the input has a placeholder, IE will fire the `input` event on page load,
                    // focus and blur, in addition to when the user actually changed the value. To
                    // filter out all of the extra events, we save the value on focus and between
                    // `input` events, and we check whether it changed.
                    // See: https://connect.microsoft.com/IE/feedback/details/885747/
                    if (this._previousValue !== value) {
                        this._previousValue = value;
                        this._onChange(value);
                        if (this._canOpen() && this._document.activeElement === event.target) {
                            this.openPanel();
                        }
                    }
                };
                /**
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._handleFocus = function () {
                    if (!this._canOpenOnNextFocus) {
                        this._canOpenOnNextFocus = true;
                    }
                    else if (this._canOpen()) {
                        this._previousValue = this._element.nativeElement.value;
                        this._attachOverlay();
                        this._floatLabel(true);
                    }
                };
                /**
                 * In "auto" mode, the label will animate down as soon as focus is lost.
                 * This causes the value to jump when selecting an option with the mouse.
                 * This method manually floats the label until the panel can be closed.
                 * @private
                 * @param {?=} shouldAnimate Whether the label should be animated when it is floated.
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._floatLabel = function (shouldAnimate) {
                    if (shouldAnimate === void 0) { shouldAnimate = false; }
                    if (this._formField && this._formField.floatLabel === 'auto') {
                        if (shouldAnimate) {
                            this._formField._animateAndLockLabel();
                        }
                        else {
                            this._formField.floatLabel = 'always';
                        }
                        this._manuallyFloatingLabel = true;
                    }
                };
                /**
                 * If the label has been manually elevated, return it to its normal state.
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._resetLabel = function () {
                    if (this._manuallyFloatingLabel) {
                        this._formField.floatLabel = 'auto';
                        this._manuallyFloatingLabel = false;
                    }
                };
                /**
                 * Given that we are not actually focusing active options, we must manually adjust scroll
                 * to reveal options below the fold. First, we find the offset of the option from the top
                 * of the panel. If that offset is below the fold, the new scrollTop will be the offset -
                 * the panel height + the option height, so the active option will be just visible at the
                 * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop
                 * will become the offset. If that offset is visible within the panel already, the scrollTop is
                 * not adjusted.
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._scrollToOption = function () {
                    /** @type {?} */
                    var index = this.autocomplete._keyManager.activeItemIndex || 0;
                    /** @type {?} */
                    var labelCount = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["_countGroupLabelsBeforeOption"])(index, this.autocomplete.options, this.autocomplete.optionGroups);
                    if (index === 0 && labelCount === 1) {
                        // If we've got one group label before the option and we're at the top option,
                        // scroll the list to the top. This is better UX than scrolling the list to the
                        // top of the option, because it allows the user to read the top group's label.
                        this.autocomplete._setScrollTop(0);
                    }
                    else {
                        /** @type {?} */
                        var newScrollPosition = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["_getOptionScrollPosition"])(index + labelCount, AUTOCOMPLETE_OPTION_HEIGHT, this.autocomplete._getScrollTop(), AUTOCOMPLETE_PANEL_HEIGHT);
                        this.autocomplete._setScrollTop(newScrollPosition);
                    }
                };
                /**
                 * This method listens to a stream of panel closing actions and resets the
                 * stream every time the option list changes.
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._subscribeToClosingActions = function () {
                    var _this_1 = this;
                    /** @type {?} */
                    var firstStable = this._zone.onStable.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["take"])(1));
                    /** @type {?} */
                    var optionChanges = this.autocomplete.options.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["tap"])(( /**
                     * @return {?}
                     */function () { return _this_1._positionStrategy.reapplyLastPosition(); })), 
                    // Defer emitting to the stream until the next tick, because changing
                    // bindings in here will cause "changed after checked" errors.
                    Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["delay"])(0));
                    // When the zone is stable initially, and when the option list changes...
                    return Object(rxjs__WEBPACK_IMPORTED_MODULE_13__["merge"])(firstStable, optionChanges)
                        .pipe(
                    // create a new stream of panelClosingActions, replacing any previous streams
                    // that were created, and flatten it so our stream only emits closing events...
                    Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["switchMap"])(( /**
                     * @return {?}
                     */function () {
                        /** @type {?} */
                        var wasOpen = _this_1.panelOpen;
                        _this_1._resetActiveItem();
                        _this_1.autocomplete._setVisibility();
                        if (_this_1.panelOpen) {
                            ( /** @type {?} */(_this_1._overlayRef)).updatePosition();
                            // If the `panelOpen` state changed, we need to make sure to emit the `opened`
                            // event, because we may not have emitted it when the panel was attached. This
                            // can happen if the users opens the panel and there are no options, but the
                            // options come in slightly later or as a result of the value changing.
                            if (wasOpen !== _this_1.panelOpen) {
                                _this_1.autocomplete.opened.emit();
                            }
                        }
                        return _this_1.panelClosingActions;
                    })), 
                    // when the first closing event occurs...
                    Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["take"])(1))
                        // set the value, close the panel, and complete.
                        .subscribe(( /**
                 * @param {?} event
                 * @return {?}
                 */function (/**
                 * @param {?} event
                 * @return {?}
                 */ event) { return _this_1._setValueAndClose(event); }));
                };
                /**
                 * Destroys the autocomplete suggestion panel.
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._destroyPanel = function () {
                    if (this._overlayRef) {
                        this.closePanel();
                        this._overlayRef.dispose();
                        this._overlayRef = null;
                    }
                };
                /**
                 * @private
                 * @param {?} value
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._setTriggerValue = function (value) {
                    /** @type {?} */
                    var toDisplay = this.autocomplete && this.autocomplete.displayWith ?
                        this.autocomplete.displayWith(value) :
                        value;
                    // Simply falling back to an empty string if the display value is falsy does not work properly.
                    // The display value can also be the number zero and shouldn't fall back to an empty string.
                    /** @type {?} */
                    var inputValue = toDisplay != null ? toDisplay : '';
                    // If it's used within a `MatFormField`, we should set it through the property so it can go
                    // through change detection.
                    if (this._formField) {
                        this._formField._control.value = inputValue;
                    }
                    else {
                        this._element.nativeElement.value = inputValue;
                    }
                    this._previousValue = inputValue;
                };
                /**
                 * This method closes the panel, and if a value is specified, also sets the associated
                 * control to that value. It will also mark the control as dirty if this interaction
                 * stemmed from the user.
                 * @private
                 * @param {?} event
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._setValueAndClose = function (event) {
                    if (event && event.source) {
                        this._clearPreviousSelectedOption(event.source);
                        this._setTriggerValue(event.source.value);
                        this._onChange(event.source.value);
                        this._element.nativeElement.focus();
                        this.autocomplete._emitSelectEvent(event.source);
                    }
                    this.closePanel();
                };
                /**
                 * Clear any previous selected option and emit a selection change event for this option
                 * @private
                 * @param {?} skip
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._clearPreviousSelectedOption = function (skip) {
                    this.autocomplete.options.forEach(( /**
                     * @param {?} option
                     * @return {?}
                     */function (/**
                     * @param {?} option
                     * @return {?}
                     */ option) {
                        if (option != skip && option.selected) {
                            option.deselect();
                        }
                    }));
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._attachOverlay = function () {
                    var _this_1 = this;
                    if (!this.autocomplete) {
                        throw getMatAutocompleteMissingPanelError();
                    }
                    /** @type {?} */
                    var overlayRef = this._overlayRef;
                    if (!overlayRef) {
                        this._portal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_8__["TemplatePortal"](this.autocomplete.template, this._viewContainerRef);
                        overlayRef = this._overlay.create(this._getOverlayConfig());
                        this._overlayRef = overlayRef;
                        // Use the `keydownEvents` in order to take advantage of
                        // the overlay event targeting provided by the CDK overlay.
                        overlayRef.keydownEvents().subscribe(( /**
                         * @param {?} event
                         * @return {?}
                         */function (/**
                         * @param {?} event
                         * @return {?}
                         */ event) {
                            // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.
                            // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction
                            if (event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["ESCAPE"] || (event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["UP_ARROW"] && event.altKey)) {
                                _this_1._resetActiveItem();
                                _this_1._closeKeyEventStream.next();
                                // We need to stop propagation, otherwise the event will eventually
                                // reach the input itself and cause the overlay to be reopened.
                                event.stopPropagation();
                                event.preventDefault();
                            }
                        }));
                        if (this._viewportRuler) {
                            this._viewportSubscription = this._viewportRuler.change().subscribe(( /**
                             * @return {?}
                             */function () {
                                if (_this_1.panelOpen && overlayRef) {
                                    overlayRef.updateSize({ width: _this_1._getPanelWidth() });
                                }
                            }));
                        }
                    }
                    else {
                        // Update the trigger, panel width and direction, in case anything has changed.
                        this._positionStrategy.setOrigin(this._getConnectedElement());
                        overlayRef.updateSize({ width: this._getPanelWidth() });
                    }
                    if (overlayRef && !overlayRef.hasAttached()) {
                        overlayRef.attach(this._portal);
                        this._closingActionsSubscription = this._subscribeToClosingActions();
                    }
                    /** @type {?} */
                    var wasOpen = this.panelOpen;
                    this.autocomplete._setVisibility();
                    this.autocomplete._isOpen = this._overlayAttached = true;
                    // We need to do an extra `panelOpen` check in here, because the
                    // autocomplete won't be shown if there are no options.
                    if (this.panelOpen && wasOpen !== this.panelOpen) {
                        this.autocomplete.opened.emit();
                    }
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._getOverlayConfig = function () {
                    return new _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["OverlayConfig"]({
                        positionStrategy: this._getOverlayPosition(),
                        scrollStrategy: this._scrollStrategy(),
                        width: this._getPanelWidth(),
                        direction: this._dir
                    });
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._getOverlayPosition = function () {
                    /** @type {?} */
                    var strategy = this._overlay.position()
                        .flexibleConnectedTo(this._getConnectedElement())
                        .withFlexibleDimensions(false)
                        .withPush(false);
                    this._setStrategyPositions(strategy);
                    this._positionStrategy = strategy;
                    return strategy;
                };
                /**
                 * Sets the positions on a position strategy based on the directive's input state.
                 * @private
                 * @param {?} positionStrategy
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._setStrategyPositions = function (positionStrategy) {
                    /** @type {?} */
                    var belowPosition = {
                        originX: 'start',
                        originY: 'bottom',
                        overlayX: 'start',
                        overlayY: 'top'
                    };
                    /** @type {?} */
                    var abovePosition = {
                        originX: 'start',
                        originY: 'top',
                        overlayX: 'start',
                        overlayY: 'bottom',
                        // The overlay edge connected to the trigger should have squared corners, while
                        // the opposite end has rounded corners. We apply a CSS class to swap the
                        // border-radius based on the overlay position.
                        panelClass: 'mat-autocomplete-panel-above'
                    };
                    /** @type {?} */
                    var positions;
                    if (this.position === 'above') {
                        positions = [abovePosition];
                    }
                    else if (this.position === 'below') {
                        positions = [belowPosition];
                    }
                    else {
                        positions = [belowPosition, abovePosition];
                    }
                    positionStrategy.withPositions(positions);
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._getConnectedElement = function () {
                    if (this.connectedTo) {
                        return this.connectedTo.elementRef;
                    }
                    return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._getPanelWidth = function () {
                    return this.autocomplete.panelWidth || this._getHostWidth();
                };
                /**
                 * Returns the width of the input element, so the panel width can match it.
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._getHostWidth = function () {
                    return this._getConnectedElement().nativeElement.getBoundingClientRect().width;
                };
                /**
                 * Resets the active item to -1 so arrow events will activate the
                 * correct options, or to 0 if the consumer opted into it.
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._resetActiveItem = function () {
                    this.autocomplete._keyManager.setActiveItem(this.autocomplete.autoActiveFirstOption ? 0 : -1);
                };
                /**
                 * Determines whether the panel can be opened.
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._canOpen = function () {
                    /** @type {?} */
                    var element = this._element.nativeElement;
                    return !element.readOnly && !element.disabled && !this._autocompleteDisabled;
                };
                return MatAutocompleteTrigger;
            }());
            MatAutocompleteTrigger.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Directive"], args: [{
                            selector: "input[matAutocomplete], textarea[matAutocomplete]",
                            host: {
                                'class': 'mat-autocomplete-trigger',
                                '[attr.autocomplete]': 'autocompleteAttribute',
                                '[attr.role]': 'autocompleteDisabled ? null : "combobox"',
                                '[attr.aria-autocomplete]': 'autocompleteDisabled ? null : "list"',
                                '[attr.aria-activedescendant]': '(panelOpen && activeOption) ? activeOption.id : null',
                                '[attr.aria-expanded]': 'autocompleteDisabled ? null : panelOpen.toString()',
                                '[attr.aria-owns]': '(autocompleteDisabled || !panelOpen) ? null : autocomplete?.id',
                                '[attr.aria-haspopup]': '!autocompleteDisabled',
                                // Note: we use `focusin`, as opposed to `focus`, in order to open the panel
                                // a little earlier. This avoids issues where IE delays the focusing of the input.
                                '(focusin)': '_handleFocus()',
                                '(blur)': '_onTouched()',
                                '(input)': '_handleInput($event)',
                                '(keydown)': '_handleKeydown($event)',
                            },
                            exportAs: 'matAutocompleteTrigger',
                            providers: [MAT_AUTOCOMPLETE_VALUE_ACCESSOR]
                        },] },
            ];
            /** @nocollapse */
            MatAutocompleteTrigger.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ElementRef"] },
                { type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["Overlay"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ViewContainerRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["NgZone"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ChangeDetectorRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Inject"], args: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY,] }] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_4__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Optional"] }] },
                { type: _angular_material_form_field__WEBPACK_IMPORTED_MODULE_12__["MatFormField"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Host"] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_10__["DOCUMENT"],] }] },
                { type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_9__["ViewportRuler"] }
            ]; };
            MatAutocompleteTrigger.propDecorators = {
                autocomplete: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['matAutocomplete',] }],
                position: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['matAutocompletePosition',] }],
                connectedTo: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['matAutocompleteConnectedTo',] }],
                autocompleteAttribute: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['autocomplete',] }],
                autocompleteDisabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['matAutocompleteDisabled',] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatAutocompleteModule = /** @class */ (function () {
                function MatAutocompleteModule() {
                }
                return MatAutocompleteModule;
            }());
            MatAutocompleteModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["NgModule"], args: [{
                            imports: [_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatOptionModule"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["OverlayModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatCommonModule"], _angular_common__WEBPACK_IMPORTED_MODULE_10__["CommonModule"]],
                            exports: [
                                MatAutocomplete,
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatOptionModule"],
                                MatAutocompleteTrigger,
                                MatAutocompleteOrigin,
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatCommonModule"]
                            ],
                            declarations: [MatAutocomplete, MatAutocompleteTrigger, MatAutocompleteOrigin],
                            providers: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=autocomplete.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/button-toggle.js": 
        /*!*****************************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/button-toggle.js ***!
          \*****************************************************************/
        /*! exports provided: MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS, MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR, MatButtonToggleGroupMultiple, MatButtonToggleChange, MatButtonToggleGroup, MatButtonToggle, MatButtonToggleModule */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS", function () { return MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR", function () { return MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatButtonToggleGroupMultiple", function () { return MatButtonToggleGroupMultiple; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatButtonToggleChange", function () { return MatButtonToggleChange; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatButtonToggleGroup", function () { return MatButtonToggleGroup; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatButtonToggle", function () { return MatButtonToggle; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatButtonToggleModule", function () { return MatButtonToggleModule; });
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/collections */ "./node_modules/@angular/cdk/esm2015/collections.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token that can be used to configure the
             * default options for all button toggles within an app.
             * @type {?}
             */
            var MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["InjectionToken"]('MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS');
            /**
             * Provider Expression that allows mat-button-toggle-group to register as a ControlValueAccessor.
             * This allows it to support [(ngModel)].
             * \@docs-private
             * @type {?}
             */
            var MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_4__["NG_VALUE_ACCESSOR"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatButtonToggleGroup; })),
                multi: true
            };
            /**
             * @deprecated Use `MatButtonToggleGroup` instead.
             * \@breaking-change 8.0.0
             */
            var MatButtonToggleGroupMultiple = /** @class */ (function () {
                function MatButtonToggleGroupMultiple() {
                }
                return MatButtonToggleGroupMultiple;
            }());
            /** @type {?} */
            var _uniqueIdCounter = 0;
            /**
             * Change event object emitted by MatButtonToggle.
             */
            var MatButtonToggleChange = /** @class */ (function () {
                /**
                 * @param {?} source
                 * @param {?} value
                 */
                function MatButtonToggleChange(source, value) {
                    this.source = source;
                    this.value = value;
                }
                return MatButtonToggleChange;
            }());
            /**
             * Exclusive selection button toggle group that behaves like a radio-button group.
             */
            var MatButtonToggleGroup = /** @class */ (function () {
                /**
                 * @param {?} _changeDetector
                 * @param {?=} defaultOptions
                 */
                function MatButtonToggleGroup(_changeDetector, defaultOptions) {
                    this._changeDetector = _changeDetector;
                    this._vertical = false;
                    this._multiple = false;
                    this._disabled = false;
                    /**
                     * The method to be called in order to update ngModel.
                     * Now `ngModel` binding is not supported in multiple selection mode.
                     */
                    this._controlValueAccessorChangeFn = ( /**
                     * @return {?}
                     */function () { });
                    /**
                     * onTouch function registered via registerOnTouch (ControlValueAccessor).
                     */
                    this._onTouched = ( /**
                     * @return {?}
                     */function () { });
                    this._name = "mat-button-toggle-group-" + _uniqueIdCounter++;
                    /**
                     * Event that emits whenever the value of the group changes.
                     * Used to facilitate two-way data binding.
                     * \@docs-private
                     */
                    this.valueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /**
                     * Event emitted when the group's value changes.
                     */
                    this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    this.appearance =
                        defaultOptions && defaultOptions.appearance ? defaultOptions.appearance : 'standard';
                }
                Object.defineProperty(MatButtonToggleGroup.prototype, "name", {
                    /**
                     * `name` attribute for the underlying `input` element.
                     * @return {?}
                     */
                    get: function () { return this._name; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        var _this_1 = this;
                        this._name = value;
                        if (this._buttonToggles) {
                            this._buttonToggles.forEach(( /**
                             * @param {?} toggle
                             * @return {?}
                             */function (/**
                             * @param {?} toggle
                             * @return {?}
                             */ toggle) {
                                toggle.name = _this_1._name;
                                toggle._markForCheck();
                            }));
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatButtonToggleGroup.prototype, "vertical", {
                    /**
                     * Whether the toggle group is vertical.
                     * @return {?}
                     */
                    get: function () { return this._vertical; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._vertical = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatButtonToggleGroup.prototype, "value", {
                    /**
                     * Value of the toggle group.
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var selected = this._selectionModel ? this._selectionModel.selected : [];
                        if (this.multiple) {
                            return selected.map(( /**
                             * @param {?} toggle
                             * @return {?}
                             */function (/**
                             * @param {?} toggle
                             * @return {?}
                             */ toggle) { return toggle.value; }));
                        }
                        return selected[0] ? selected[0].value : undefined;
                    },
                    /**
                     * @param {?} newValue
                     * @return {?}
                     */
                    set: function (newValue) {
                        this._setSelectionByValue(newValue);
                        this.valueChange.emit(this.value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatButtonToggleGroup.prototype, "selected", {
                    /**
                     * Selected button toggles in the group.
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var selected = this._selectionModel ? this._selectionModel.selected : [];
                        return this.multiple ? selected : (selected[0] || null);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatButtonToggleGroup.prototype, "multiple", {
                    /**
                     * Whether multiple button toggles can be selected.
                     * @return {?}
                     */
                    get: function () { return this._multiple; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._multiple = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatButtonToggleGroup.prototype, "disabled", {
                    /**
                     * Whether multiple button toggle group is disabled.
                     * @return {?}
                     */
                    get: function () { return this._disabled; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                        if (this._buttonToggles) {
                            this._buttonToggles.forEach(( /**
                             * @param {?} toggle
                             * @return {?}
                             */function (/**
                             * @param {?} toggle
                             * @return {?}
                             */ toggle) { return toggle._markForCheck(); }));
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype.ngOnInit = function () {
                    this._selectionModel = new _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_2__["SelectionModel"](this.multiple, undefined, false);
                };
                /**
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype.ngAfterContentInit = function () {
                    var _a;
                    (_a = this._selectionModel).select.apply(_a, this._buttonToggles.filter(( /**
                     * @param {?} toggle
                     * @return {?}
                     */function (/**
                     * @param {?} toggle
                     * @return {?}
                     */ toggle) { return toggle.checked; })));
                };
                /**
                 * Sets the model value. Implemented as part of ControlValueAccessor.
                 * @param {?} value Value to be set to the model.
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype.writeValue = function (value) {
                    this.value = value;
                    this._changeDetector.markForCheck();
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} fn
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype.registerOnChange = function (fn) {
                    this._controlValueAccessorChangeFn = fn;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} fn
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype.registerOnTouched = function (fn) {
                    this._onTouched = fn;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} isDisabled
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype.setDisabledState = function (isDisabled) {
                    this.disabled = isDisabled;
                };
                /**
                 * Dispatch change event with current selection and group value.
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype._emitChangeEvent = function () {
                    /** @type {?} */
                    var selected = this.selected;
                    /** @type {?} */
                    var source = Array.isArray(selected) ? selected[selected.length - 1] : selected;
                    /** @type {?} */
                    var event = new MatButtonToggleChange(( /** @type {?} */(source)), this.value);
                    this._controlValueAccessorChangeFn(event.value);
                    this.change.emit(event);
                };
                /**
                 * Syncs a button toggle's selected state with the model value.
                 * @param {?} toggle Toggle to be synced.
                 * @param {?} select Whether the toggle should be selected.
                 * @param {?=} isUserInput Whether the change was a result of a user interaction.
                 * @param {?=} deferEvents Whether to defer emitting the change events.
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype._syncButtonToggle = function (toggle, select, isUserInput, deferEvents) {
                    if (isUserInput === void 0) { isUserInput = false; }
                    if (deferEvents === void 0) { deferEvents = false; }
                    // Deselect the currently-selected toggle, if we're in single-selection
                    // mode and the button being toggled isn't selected at the moment.
                    if (!this.multiple && this.selected && !toggle.checked) {
                        (( /** @type {?} */(this.selected))).checked = false;
                    }
                    if (this._selectionModel) {
                        if (select) {
                            this._selectionModel.select(toggle);
                        }
                        else {
                            this._selectionModel.deselect(toggle);
                        }
                    }
                    else {
                        deferEvents = true;
                    }
                    // We need to defer in some cases in order to avoid "changed after checked errors", however
                    // the side-effect is that we may end up updating the model value out of sequence in others
                    // The `deferEvents` flag allows us to decide whether to do it on a case-by-case basis.
                    if (deferEvents) {
                    }
                    else {
                        this._updateModelValue(isUserInput);
                    }
                };
                /**
                 * Checks whether a button toggle is selected.
                 * @param {?} toggle
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype._isSelected = function (toggle) {
                    return this._selectionModel && this._selectionModel.isSelected(toggle);
                };
                /**
                 * Determines whether a button toggle should be checked on init.
                 * @param {?} toggle
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype._isPrechecked = function (toggle) {
                    if (typeof this._rawValue === 'undefined') {
                        return false;
                    }
                    if (this.multiple && Array.isArray(this._rawValue)) {
                        return this._rawValue.some(( /**
                         * @param {?} value
                         * @return {?}
                         */function (/**
                         * @param {?} value
                         * @return {?}
                         */ value) { return toggle.value != null && value === toggle.value; }));
                    }
                    return toggle.value === this._rawValue;
                };
                /**
                 * Updates the selection state of the toggles in the group based on a value.
                 * @private
                 * @param {?} value
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype._setSelectionByValue = function (value) {
                    var _this_1 = this;
                    this._rawValue = value;
                    if (!this._buttonToggles) {
                        return;
                    }
                    if (this.multiple && value) {
                        if (!Array.isArray(value)) {
                            throw Error('Value must be an array in multiple-selection mode.');
                        }
                        this._clearSelection();
                        value.forEach(( /**
                         * @param {?} currentValue
                         * @return {?}
                         */function (currentValue) { return _this_1._selectValue(currentValue); }));
                    }
                    else {
                        this._clearSelection();
                        this._selectValue(value);
                    }
                };
                /**
                 * Clears the selected toggles.
                 * @private
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype._clearSelection = function () {
                    this._selectionModel.clear();
                    this._buttonToggles.forEach(( /**
                     * @param {?} toggle
                     * @return {?}
                     */function (/**
                     * @param {?} toggle
                     * @return {?}
                     */ toggle) { return toggle.checked = false; }));
                };
                /**
                 * Selects a value if there's a toggle that corresponds to it.
                 * @private
                 * @param {?} value
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype._selectValue = function (value) {
                    /** @type {?} */
                    var correspondingOption = this._buttonToggles.find(( /**
                     * @param {?} toggle
                     * @return {?}
                     */function (/**
                     * @param {?} toggle
                     * @return {?}
                     */ toggle) {
                        return toggle.value != null && toggle.value === value;
                    }));
                    if (correspondingOption) {
                        correspondingOption.checked = true;
                        this._selectionModel.select(correspondingOption);
                    }
                };
                /**
                 * Syncs up the group's value with the model and emits the change event.
                 * @private
                 * @param {?} isUserInput
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype._updateModelValue = function (isUserInput) {
                    // Only emit the change event for user input.
                    if (isUserInput) {
                        this._emitChangeEvent();
                    }
                    // Note: we emit this one no matter whether it was a user interaction, because
                    // it is used by Angular to sync up the two-way data binding.
                    this.valueChange.emit(this.value);
                };
                return MatButtonToggleGroup;
            }());
            MatButtonToggleGroup.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: 'mat-button-toggle-group',
                            providers: [
                                MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR,
                                { provide: MatButtonToggleGroupMultiple, useExisting: MatButtonToggleGroup },
                            ],
                            host: {
                                'role': 'group',
                                'class': 'mat-button-toggle-group',
                                '[attr.aria-disabled]': 'disabled',
                                '[class.mat-button-toggle-vertical]': 'vertical',
                                '[class.mat-button-toggle-group-appearance-standard]': 'appearance === "standard"',
                            },
                            exportAs: 'matButtonToggleGroup',
                        },] },
            ];
            /** @nocollapse */
            MatButtonToggleGroup.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectorRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS,] }] }
            ]; };
            MatButtonToggleGroup.propDecorators = {
                _buttonToggles: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChildren"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["forwardRef"])(( /**
                                         * @return {?}
                                         */function () { return MatButtonToggle; })),] }],
                appearance: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                vertical: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                valueChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                multiple: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                change: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }]
            };
            // Boilerplate for applying mixins to the MatButtonToggle class.
            /**
             * \@docs-private
             */
            var MatButtonToggleBase = /** @class */ (function () {
                function MatButtonToggleBase() {
                }
                return MatButtonToggleBase;
            }());
            /** @type {?} */
            var _MatButtonToggleMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["mixinDisableRipple"])(MatButtonToggleBase);
            /**
             * Single button inside of a toggle group.
             */
            var MatButtonToggle = /** @class */ (function (_super) {
                __extends(MatButtonToggle, _super);
                /**
                 * @param {?} toggleGroup
                 * @param {?} _changeDetectorRef
                 * @param {?} _elementRef
                 * @param {?} _focusMonitor
                 * @param {?} defaultTabIndex
                 * @param {?=} defaultOptions
                 */
                function MatButtonToggle(toggleGroup, _changeDetectorRef, _elementRef, _focusMonitor, 
                // @breaking-change 8.0.0 `defaultTabIndex` to be made a required parameter.
                defaultTabIndex, defaultOptions) {
                    var _this_1 = _super.call(this) || this;
                    _this_1._changeDetectorRef = _changeDetectorRef;
                    _this_1._elementRef = _elementRef;
                    _this_1._focusMonitor = _focusMonitor;
                    _this_1._isSingleSelector = false;
                    _this_1._checked = false;
                    /**
                     * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element
                     */
                    _this_1.ariaLabelledby = null;
                    _this_1._disabled = false;
                    /**
                     * Event emitted when the group value changes.
                     */
                    _this_1.change = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /** @type {?} */
                    var parsedTabIndex = Number(defaultTabIndex);
                    _this_1.tabIndex = (parsedTabIndex || parsedTabIndex === 0) ? parsedTabIndex : null;
                    _this_1.buttonToggleGroup = toggleGroup;
                    _this_1.appearance =
                        defaultOptions && defaultOptions.appearance ? defaultOptions.appearance : 'standard';
                    return _this_1;
                }
                Object.defineProperty(MatButtonToggle.prototype, "buttonId", {
                    /**
                     * Unique ID for the underlying `button` element.
                     * @return {?}
                     */
                    get: function () { return this.id + "-button"; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatButtonToggle.prototype, "appearance", {
                    /**
                     * The appearance style of the button.
                     * @return {?}
                     */
                    get: function () {
                        return this.buttonToggleGroup ? this.buttonToggleGroup.appearance : this._appearance;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._appearance = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatButtonToggle.prototype, "checked", {
                    /**
                     * Whether the button is checked.
                     * @return {?}
                     */
                    get: function () {
                        return this.buttonToggleGroup ? this.buttonToggleGroup._isSelected(this) : this._checked;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                        if (newValue !== this._checked) {
                            this._checked = newValue;
                            if (this.buttonToggleGroup) {
                                this.buttonToggleGroup._syncButtonToggle(this, this._checked);
                            }
                            this._changeDetectorRef.markForCheck();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatButtonToggle.prototype, "disabled", {
                    /**
                     * Whether the button is disabled.
                     * @return {?}
                     */
                    get: function () {
                        return this._disabled || (this.buttonToggleGroup && this.buttonToggleGroup.disabled);
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatButtonToggle.prototype.ngOnInit = function () {
                    this._isSingleSelector = this.buttonToggleGroup && !this.buttonToggleGroup.multiple;
                    this._type = this._isSingleSelector ? 'radio' : 'checkbox';
                    this.id = this.id || "mat-button-toggle-" + _uniqueIdCounter++;
                    if (this._isSingleSelector) {
                        this.name = this.buttonToggleGroup.name;
                    }
                    if (this.buttonToggleGroup && this.buttonToggleGroup._isPrechecked(this)) {
                        this.checked = true;
                    }
                    this._focusMonitor.monitor(this._elementRef, true);
                };
                /**
                 * @return {?}
                 */
                MatButtonToggle.prototype.ngOnDestroy = function () {
                    /** @type {?} */
                    var group = this.buttonToggleGroup;
                    this._focusMonitor.stopMonitoring(this._elementRef);
                    // Remove the toggle from the selection once it's destroyed. Needs to happen
                    // on the next tick in order to avoid "changed after checked" errors.
                    if (group && group._isSelected(this)) {
                        group._syncButtonToggle(this, false, false, true);
                    }
                };
                /**
                 * Focuses the button.
                 * @param {?=} options
                 * @return {?}
                 */
                MatButtonToggle.prototype.focus = function (options) {
                    this._buttonElement.nativeElement.focus(options);
                };
                /**
                 * Checks the button toggle due to an interaction with the underlying native button.
                 * @return {?}
                 */
                MatButtonToggle.prototype._onButtonClick = function () {
                    /** @type {?} */
                    var newChecked = this._isSingleSelector ? true : !this._checked;
                    if (newChecked !== this._checked) {
                        this._checked = newChecked;
                        if (this.buttonToggleGroup) {
                            this.buttonToggleGroup._syncButtonToggle(this, this._checked, true);
                            this.buttonToggleGroup._onTouched();
                        }
                    }
                    // Emit a change event when it's the single selector
                    this.change.emit(new MatButtonToggleChange(this, this.value));
                };
                /**
                 * Marks the button toggle as needing checking for change detection.
                 * This method is exposed because the parent button toggle group will directly
                 * update bound properties of the radio button.
                 * @return {?}
                 */
                MatButtonToggle.prototype._markForCheck = function () {
                    // When the group value changes, the button will not be notified.
                    // Use `markForCheck` to explicit update button toggle's status.
                    this._changeDetectorRef.markForCheck();
                };
                return MatButtonToggle;
            }(_MatButtonToggleMixinBase));
            MatButtonToggle.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Component"], args: [{ selector: 'mat-button-toggle',
                            template: "<button #button class=\"mat-button-toggle-button\" type=\"button\" [id]=\"buttonId\" [attr.tabindex]=\"disabled ? -1 : tabIndex\" [attr.aria-pressed]=\"checked\" [disabled]=\"disabled || null\" [attr.name]=\"name || null\" [attr.aria-label]=\"ariaLabel\" [attr.aria-labelledby]=\"ariaLabelledby\" (click)=\"_onButtonClick()\"><div class=\"mat-button-toggle-label-content\"><ng-content></ng-content></div></button><div class=\"mat-button-toggle-focus-overlay\"></div><div class=\"mat-button-toggle-ripple\" matRipple [matRippleTrigger]=\"button\" [matRippleDisabled]=\"this.disableRipple || this.disabled\"></div>",
                            styles: [".mat-button-toggle-group,.mat-button-toggle-standalone{position:relative;display:inline-flex;flex-direction:row;white-space:nowrap;overflow:hidden;border-radius:2px;-webkit-tap-highlight-color:transparent}@media (-ms-high-contrast:active){.mat-button-toggle-group,.mat-button-toggle-standalone{outline:solid 1px}}.mat-button-toggle-group-appearance-standard,.mat-button-toggle-standalone.mat-button-toggle-appearance-standard{border-radius:4px}@media (-ms-high-contrast:active){.mat-button-toggle-group-appearance-standard,.mat-button-toggle-standalone.mat-button-toggle-appearance-standard{outline:0}}.mat-button-toggle-vertical{flex-direction:column}.mat-button-toggle-vertical .mat-button-toggle-label-content{display:block}.mat-button-toggle{white-space:nowrap;position:relative}.mat-button-toggle .mat-icon svg{vertical-align:top}.mat-button-toggle.cdk-keyboard-focused .mat-button-toggle-focus-overlay{opacity:1}@media (-ms-high-contrast:active){.mat-button-toggle.cdk-keyboard-focused .mat-button-toggle-focus-overlay{opacity:.5}}.mat-button-toggle-appearance-standard:not(.mat-button-toggle-disabled):hover .mat-button-toggle-focus-overlay{opacity:.04}.mat-button-toggle-appearance-standard.cdk-keyboard-focused:not(.mat-button-toggle-disabled) .mat-button-toggle-focus-overlay{opacity:.12}@media (-ms-high-contrast:active){.mat-button-toggle-appearance-standard.cdk-keyboard-focused:not(.mat-button-toggle-disabled) .mat-button-toggle-focus-overlay{opacity:.5}}@media (hover:none){.mat-button-toggle-appearance-standard:not(.mat-button-toggle-disabled):hover .mat-button-toggle-focus-overlay{display:none}}.mat-button-toggle-label-content{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:inline-block;line-height:36px;padding:0 16px;position:relative}.mat-button-toggle-appearance-standard .mat-button-toggle-label-content{line-height:48px;padding:0 12px}.mat-button-toggle-label-content>*{vertical-align:middle}.mat-button-toggle-focus-overlay{border-radius:inherit;pointer-events:none;opacity:0;top:0;left:0;right:0;bottom:0;position:absolute}.mat-button-toggle-checked .mat-button-toggle-focus-overlay{border-bottom:solid 36px}@media (-ms-high-contrast:active){.mat-button-toggle-checked .mat-button-toggle-focus-overlay{opacity:.5;height:0}}@media (-ms-high-contrast:active){.mat-button-toggle-checked.mat-button-toggle-appearance-standard .mat-button-toggle-focus-overlay{border-bottom:solid 48px}}.mat-button-toggle .mat-button-toggle-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-button-toggle-button{border:0;background:0 0;color:inherit;padding:0;margin:0;font:inherit;outline:0;width:100%;cursor:pointer}.mat-button-toggle-disabled .mat-button-toggle-button{cursor:default}.mat-button-toggle-button::-moz-focus-inner{border:0}"],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewEncapsulation"].None,
                            exportAs: 'matButtonToggle',
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectionStrategy"].OnPush,
                            inputs: ['disableRipple'],
                            host: {
                                '[class.mat-button-toggle-standalone]': '!buttonToggleGroup',
                                '[class.mat-button-toggle-checked]': 'checked',
                                '[class.mat-button-toggle-disabled]': 'disabled',
                                '[class.mat-button-toggle-appearance-standard]': 'appearance === "standard"',
                                'class': 'mat-button-toggle',
                                // Always reset the tabindex to -1 so it doesn't conflict with the one on the `button`,
                                // but can still receive focus from things like cdkFocusInitial.
                                '[attr.tabindex]': '-1',
                                '[attr.id]': 'id',
                                '[attr.name]': 'null',
                                '(focus)': 'focus()',
                            }
                        },] },
            ];
            /** @nocollapse */
            MatButtonToggle.ctorParameters = function () { return [
                { type: MatButtonToggleGroup, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectorRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__["FocusMonitor"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Attribute"], args: ['tabindex',] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS,] }] }
            ]; };
            MatButtonToggle.propDecorators = {
                ariaLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['aria-label',] }],
                ariaLabelledby: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['aria-labelledby',] }],
                _buttonElement: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewChild"], args: ['button', { static: false },] }],
                id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                tabIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                appearance: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                checked: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                change: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatButtonToggleModule = /** @class */ (function () {
                function MatButtonToggleModule() {
                }
                return MatButtonToggleModule;
            }());
            MatButtonToggleModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["NgModule"], args: [{
                            imports: [_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["MatCommonModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_5__["MatRippleModule"]],
                            exports: [_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["MatCommonModule"], MatButtonToggleGroup, MatButtonToggle],
                            declarations: [MatButtonToggleGroup, MatButtonToggle],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=button-toggle.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/card.js": 
        /*!********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/card.js ***!
          \********************************************************/
        /*! exports provided: MatCardContent, MatCardTitle, MatCardSubtitle, MatCardActions, MatCardFooter, MatCardImage, MatCardSmImage, MatCardMdImage, MatCardLgImage, MatCardXlImage, MatCardAvatar, MatCard, MatCardHeader, MatCardTitleGroup, MatCardModule */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardContent", function () { return MatCardContent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardTitle", function () { return MatCardTitle; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardSubtitle", function () { return MatCardSubtitle; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardActions", function () { return MatCardActions; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardFooter", function () { return MatCardFooter; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardImage", function () { return MatCardImage; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardSmImage", function () { return MatCardSmImage; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardMdImage", function () { return MatCardMdImage; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardLgImage", function () { return MatCardLgImage; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardXlImage", function () { return MatCardXlImage; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardAvatar", function () { return MatCardAvatar; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCard", function () { return MatCard; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardHeader", function () { return MatCardHeader; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardTitleGroup", function () { return MatCardTitleGroup; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardModule", function () { return MatCardModule; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Content of a card, needed as it's used as a selector in the API.
             * \@docs-private
             */
            var MatCardContent = /** @class */ (function () {
                function MatCardContent() {
                }
                return MatCardContent;
            }());
            MatCardContent.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'mat-card-content',
                            host: { 'class': 'mat-card-content' }
                        },] },
            ];
            /**
             * Title of a card, needed as it's used as a selector in the API.
             * \@docs-private
             */
            var MatCardTitle = /** @class */ (function () {
                function MatCardTitle() {
                }
                return MatCardTitle;
            }());
            MatCardTitle.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: "mat-card-title, [mat-card-title], [matCardTitle]",
                            host: {
                                'class': 'mat-card-title'
                            }
                        },] },
            ];
            /**
             * Sub-title of a card, needed as it's used as a selector in the API.
             * \@docs-private
             */
            var MatCardSubtitle = /** @class */ (function () {
                function MatCardSubtitle() {
                }
                return MatCardSubtitle;
            }());
            MatCardSubtitle.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: "mat-card-subtitle, [mat-card-subtitle], [matCardSubtitle]",
                            host: {
                                'class': 'mat-card-subtitle'
                            }
                        },] },
            ];
            /**
             * Action section of a card, needed as it's used as a selector in the API.
             * \@docs-private
             */
            var MatCardActions = /** @class */ (function () {
                function MatCardActions() {
                    /**
                     * Position of the actions inside the card.
                     */
                    this.align = 'start';
                }
                return MatCardActions;
            }());
            MatCardActions.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'mat-card-actions',
                            exportAs: 'matCardActions',
                            host: {
                                'class': 'mat-card-actions',
                                '[class.mat-card-actions-align-end]': 'align === "end"',
                            }
                        },] },
            ];
            MatCardActions.propDecorators = {
                align: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * Footer of a card, needed as it's used as a selector in the API.
             * \@docs-private
             */
            var MatCardFooter = /** @class */ (function () {
                function MatCardFooter() {
                }
                return MatCardFooter;
            }());
            MatCardFooter.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'mat-card-footer',
                            host: { 'class': 'mat-card-footer' }
                        },] },
            ];
            /**
             * Image used in a card, needed to add the mat- CSS styling.
             * \@docs-private
             */
            var MatCardImage = /** @class */ (function () {
                function MatCardImage() {
                }
                return MatCardImage;
            }());
            MatCardImage.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[mat-card-image], [matCardImage]',
                            host: { 'class': 'mat-card-image' }
                        },] },
            ];
            /**
             * Image used in a card, needed to add the mat- CSS styling.
             * \@docs-private
             */
            var MatCardSmImage = /** @class */ (function () {
                function MatCardSmImage() {
                }
                return MatCardSmImage;
            }());
            MatCardSmImage.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[mat-card-sm-image], [matCardImageSmall]',
                            host: { 'class': 'mat-card-sm-image' }
                        },] },
            ];
            /**
             * Image used in a card, needed to add the mat- CSS styling.
             * \@docs-private
             */
            var MatCardMdImage = /** @class */ (function () {
                function MatCardMdImage() {
                }
                return MatCardMdImage;
            }());
            MatCardMdImage.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[mat-card-md-image], [matCardImageMedium]',
                            host: { 'class': 'mat-card-md-image' }
                        },] },
            ];
            /**
             * Image used in a card, needed to add the mat- CSS styling.
             * \@docs-private
             */
            var MatCardLgImage = /** @class */ (function () {
                function MatCardLgImage() {
                }
                return MatCardLgImage;
            }());
            MatCardLgImage.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[mat-card-lg-image], [matCardImageLarge]',
                            host: { 'class': 'mat-card-lg-image' }
                        },] },
            ];
            /**
             * Large image used in a card, needed to add the mat- CSS styling.
             * \@docs-private
             */
            var MatCardXlImage = /** @class */ (function () {
                function MatCardXlImage() {
                }
                return MatCardXlImage;
            }());
            MatCardXlImage.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[mat-card-xl-image], [matCardImageXLarge]',
                            host: { 'class': 'mat-card-xl-image' }
                        },] },
            ];
            /**
             * Avatar image used in a card, needed to add the mat- CSS styling.
             * \@docs-private
             */
            var MatCardAvatar = /** @class */ (function () {
                function MatCardAvatar() {
                }
                return MatCardAvatar;
            }());
            MatCardAvatar.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[mat-card-avatar], [matCardAvatar]',
                            host: { 'class': 'mat-card-avatar' }
                        },] },
            ];
            /**
             * A basic content container component that adds the styles of a Material design card.
             *
             * While this component can be used alone, it also provides a number
             * of preset styles for common card sections, including:
             * - mat-card-title
             * - mat-card-subtitle
             * - mat-card-content
             * - mat-card-actions
             * - mat-card-footer
             */
            var MatCard = /** @class */ (function () {
                // @breaking-change 9.0.0 `_animationMode` parameter to be made required.
                /**
                 * @param {?=} _animationMode
                 */
                function MatCard(_animationMode) {
                    this._animationMode = _animationMode;
                }
                return MatCard;
            }());
            MatCard.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-card',
                            exportAs: 'matCard',
                            template: "<ng-content></ng-content><ng-content select=\"mat-card-footer\"></ng-content>",
                            styles: [".mat-card{transition:box-shadow 280ms cubic-bezier(.4,0,.2,1);display:block;position:relative;padding:16px;border-radius:4px}._mat-animation-noopable.mat-card{transition:none;animation:none}.mat-card .mat-divider-horizontal{position:absolute;left:0;width:100%}[dir=rtl] .mat-card .mat-divider-horizontal{left:auto;right:0}.mat-card .mat-divider-horizontal.mat-divider-inset{position:static;margin:0}[dir=rtl] .mat-card .mat-divider-horizontal.mat-divider-inset{margin-right:0}@media (-ms-high-contrast:active){.mat-card{outline:solid 1px}}.mat-card-actions,.mat-card-content,.mat-card-subtitle{display:block;margin-bottom:16px}.mat-card-title{display:block;margin-bottom:8px}.mat-card-actions{margin-left:-8px;margin-right:-8px;padding:8px 0}.mat-card-actions-align-end{display:flex;justify-content:flex-end}.mat-card-image{width:calc(100% + 32px);margin:0 -16px 16px -16px}.mat-card-footer{display:block;margin:0 -16px -16px -16px}.mat-card-actions .mat-button,.mat-card-actions .mat-raised-button,.mat-card-actions .mat-stroked-button{margin:0 8px}.mat-card-header{display:flex;flex-direction:row}.mat-card-header .mat-card-title{margin-bottom:12px}.mat-card-header-text{margin:0 16px}.mat-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0;object-fit:cover}.mat-card-title-group{display:flex;justify-content:space-between}.mat-card-sm-image{width:80px;height:80px}.mat-card-md-image{width:112px;height:112px}.mat-card-lg-image{width:152px;height:152px}.mat-card-xl-image{width:240px;height:240px;margin:-8px}.mat-card-title-group>.mat-card-xl-image{margin:-8px 0 8px}@media (max-width:599px){.mat-card-title-group{margin:0}.mat-card-xl-image{margin-left:0;margin-right:0}}.mat-card-content>:first-child,.mat-card>:first-child{margin-top:0}.mat-card-content>:last-child:not(.mat-card-footer),.mat-card>:last-child:not(.mat-card-footer){margin-bottom:0}.mat-card-image:first-child{margin-top:-16px;border-top-left-radius:inherit;border-top-right-radius:inherit}.mat-card>.mat-card-actions:last-child{margin-bottom:-8px;padding-bottom:0}.mat-card-actions .mat-button:first-child,.mat-card-actions .mat-raised-button:first-child,.mat-card-actions .mat-stroked-button:first-child{margin-left:0;margin-right:0}.mat-card-subtitle:not(:first-child),.mat-card-title:not(:first-child){margin-top:-4px}.mat-card-header .mat-card-subtitle:not(:first-child){margin-top:-8px}.mat-card>.mat-card-xl-image:first-child{margin-top:-8px}.mat-card>.mat-card-xl-image:last-child{margin-bottom:-8px}"],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            host: {
                                'class': 'mat-card',
                                '[class._mat-animation-noopable]': '_animationMode === "NoopAnimations"',
                            }
                        },] },
            ];
            /** @nocollapse */
            MatCard.ctorParameters = function () { return [
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_1__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            /**
             * Component intended to be used within the `<mat-card>` component. It adds styles for a
             * preset header section (i.e. a title, subtitle, and avatar layout).
             * \@docs-private
             */
            var MatCardHeader = /** @class */ (function () {
                function MatCardHeader() {
                }
                return MatCardHeader;
            }());
            MatCardHeader.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-card-header',
                            template: "<ng-content select=\"[mat-card-avatar], [matCardAvatar]\"></ng-content><div class=\"mat-card-header-text\"><ng-content select=\"mat-card-title, mat-card-subtitle, [mat-card-title], [mat-card-subtitle], [matCardTitle], [matCardSubtitle]\"></ng-content></div><ng-content></ng-content>",
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            host: { 'class': 'mat-card-header' }
                        },] },
            ];
            /**
             * Component intended to be used within the `<mat-card>` component. It adds styles for a preset
             * layout that groups an image with a title section.
             * \@docs-private
             */
            var MatCardTitleGroup = /** @class */ (function () {
                function MatCardTitleGroup() {
                }
                return MatCardTitleGroup;
            }());
            MatCardTitleGroup.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-card-title-group',
                            template: "<div><ng-content select=\"mat-card-title, mat-card-subtitle, [mat-card-title], [mat-card-subtitle], [matCardTitle], [matCardSubtitle]\"></ng-content></div><ng-content select=\"img\"></ng-content><ng-content></ng-content>",
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            host: { 'class': 'mat-card-title-group' }
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatCardModule = /** @class */ (function () {
                function MatCardModule() {
                }
                return MatCardModule;
            }());
            MatCardModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [_angular_material_core__WEBPACK_IMPORTED_MODULE_2__["MatCommonModule"]],
                            exports: [
                                MatCard,
                                MatCardHeader,
                                MatCardTitleGroup,
                                MatCardContent,
                                MatCardTitle,
                                MatCardSubtitle,
                                MatCardActions,
                                MatCardFooter,
                                MatCardSmImage,
                                MatCardMdImage,
                                MatCardLgImage,
                                MatCardImage,
                                MatCardXlImage,
                                MatCardAvatar,
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_2__["MatCommonModule"],
                            ],
                            declarations: [
                                MatCard, MatCardHeader, MatCardTitleGroup, MatCardContent, MatCardTitle, MatCardSubtitle,
                                MatCardActions, MatCardFooter, MatCardSmImage, MatCardMdImage, MatCardLgImage, MatCardImage,
                                MatCardXlImage, MatCardAvatar,
                            ],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=card.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/checkbox.js": 
        /*!************************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/checkbox.js ***!
          \************************************************************/
        /*! exports provided: MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR, TransitionCheckState, MatCheckboxChange, MatCheckbox, MAT_CHECKBOX_CLICK_ACTION, _MatCheckboxRequiredValidatorModule, MatCheckboxModule, MAT_CHECKBOX_REQUIRED_VALIDATOR, MatCheckboxRequiredValidator */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR", function () { return MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TransitionCheckState", function () { return TransitionCheckState; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCheckboxChange", function () { return MatCheckboxChange; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCheckbox", function () { return MatCheckbox; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_CHECKBOX_CLICK_ACTION", function () { return MAT_CHECKBOX_CLICK_ACTION; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_MatCheckboxRequiredValidatorModule", function () { return _MatCheckboxRequiredValidatorModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCheckboxModule", function () { return MatCheckboxModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_CHECKBOX_REQUIRED_VALIDATOR", function () { return MAT_CHECKBOX_REQUIRED_VALIDATOR; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCheckboxRequiredValidator", function () { return MatCheckboxRequiredValidator; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/observers */ "./node_modules/@angular/cdk/esm2015/observers.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token that can be used to specify the checkbox click behavior.
             * @type {?}
             */
            var MAT_CHECKBOX_CLICK_ACTION = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('mat-checkbox-click-action');
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // Increasing integer for generating unique ids for checkbox components.
            /** @type {?} */
            var nextUniqueId = 0;
            /**
             * Provider Expression that allows mat-checkbox to register as a ControlValueAccessor.
             * This allows it to support [(ngModel)].
             * \@docs-private
             * @type {?}
             */
            var MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_3__["NG_VALUE_ACCESSOR"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatCheckbox; })),
                multi: true
            };
            /** @enum {number} */
            var TransitionCheckState = {
                /** The initial state of the component before any user interaction. */
                Init: 0,
                /** The state representing the component when it's becoming checked. */
                Checked: 1,
                /** The state representing the component when it's becoming unchecked. */
                Unchecked: 2,
                /** The state representing the component when it's becoming indeterminate. */
                Indeterminate: 3,
            };
            TransitionCheckState[TransitionCheckState.Init] = 'Init';
            TransitionCheckState[TransitionCheckState.Checked] = 'Checked';
            TransitionCheckState[TransitionCheckState.Unchecked] = 'Unchecked';
            TransitionCheckState[TransitionCheckState.Indeterminate] = 'Indeterminate';
            /**
             * Change event object emitted by MatCheckbox.
             */
            var MatCheckboxChange = /** @class */ (function () {
                function MatCheckboxChange() {
                }
                return MatCheckboxChange;
            }());
            // Boilerplate for applying mixins to MatCheckbox.
            /**
             * \@docs-private
             */
            var MatCheckboxBase = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 */
                function MatCheckboxBase(_elementRef) {
                    this._elementRef = _elementRef;
                }
                return MatCheckboxBase;
            }());
            /** @type {?} */
            var _MatCheckboxMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["mixinTabIndex"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["mixinColor"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["mixinDisableRipple"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["mixinDisabled"])(MatCheckboxBase)), 'accent'));
            /**
             * A material design checkbox component. Supports all of the functionality of an HTML5 checkbox,
             * and exposes a similar API. A MatCheckbox can be either checked, unchecked, indeterminate, or
             * disabled. Note that all additional accessibility attributes are taken care of by the component,
             * so there is no need to provide them yourself. However, if you want to omit a label and still
             * have the checkbox be accessible, you may supply an [aria-label] input.
             * See: https://material.io/design/components/selection-controls.html
             */
            var MatCheckbox = /** @class */ (function (_super) {
                __extends(MatCheckbox, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} _changeDetectorRef
                 * @param {?} _focusMonitor
                 * @param {?} _ngZone
                 * @param {?} tabIndex
                 * @param {?} _clickAction
                 * @param {?=} _animationMode
                 */
                function MatCheckbox(elementRef, _changeDetectorRef, _focusMonitor, _ngZone, tabIndex, _clickAction, _animationMode) {
                    var _this_1 = _super.call(this, elementRef) || this;
                    _this_1._changeDetectorRef = _changeDetectorRef;
                    _this_1._focusMonitor = _focusMonitor;
                    _this_1._ngZone = _ngZone;
                    _this_1._clickAction = _clickAction;
                    _this_1._animationMode = _animationMode;
                    /**
                     * Attached to the aria-label attribute of the host element. In most cases, aria-labelledby will
                     * take precedence so this may be omitted.
                     */
                    _this_1.ariaLabel = '';
                    /**
                     * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element
                     */
                    _this_1.ariaLabelledby = null;
                    _this_1._uniqueId = "mat-checkbox-" + ++nextUniqueId;
                    /**
                     * A unique id for the checkbox input. If none is supplied, it will be auto-generated.
                     */
                    _this_1.id = _this_1._uniqueId;
                    /**
                     * Whether the label should appear after or before the checkbox. Defaults to 'after'
                     */
                    _this_1.labelPosition = 'after';
                    /**
                     * Name value will be applied to the input element if present
                     */
                    _this_1.name = null;
                    /**
                     * Event emitted when the checkbox's `checked` value changes.
                     */
                    _this_1.change = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Event emitted when the checkbox's `indeterminate` value changes.
                     */
                    _this_1.indeterminateChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Called when the checkbox is blurred. Needed to properly implement ControlValueAccessor.
                     * \@docs-private
                     */
                    _this_1._onTouched = ( /**
                     * @return {?}
                     */function () { });
                    _this_1._currentAnimationClass = '';
                    _this_1._currentCheckState = TransitionCheckState.Init;
                    _this_1._controlValueAccessorChangeFn = ( /**
                     * @return {?}
                     */function () { });
                    _this_1._checked = false;
                    _this_1._disabled = false;
                    _this_1._indeterminate = false;
                    _this_1.tabIndex = parseInt(tabIndex) || 0;
                    _this_1._focusMonitor.monitor(elementRef, true).subscribe(( /**
                     * @param {?} focusOrigin
                     * @return {?}
                     */function (/**
                     * @param {?} focusOrigin
                     * @return {?}
                     */ focusOrigin) {
                        if (!focusOrigin) {
                            // When a focused element becomes disabled, the browser *immediately* fires a blur event.
                            // Angular does not expect events to be raised during change detection, so any state change
                            // (such as a form control's 'ng-touched') will cause a changed-after-checked error.
                            // See https://github.com/angular/angular/issues/17793. To work around this, we defer
                            // telling the form control it has been touched until the next tick.
                            Promise.resolve().then(( /**
                             * @return {?}
                             */function () {
                                _this_1._onTouched();
                                _changeDetectorRef.markForCheck();
                            }));
                        }
                    }));
                    return _this_1;
                }
                Object.defineProperty(MatCheckbox.prototype, "inputId", {
                    /**
                     * Returns the unique id for the visual hidden input.
                     * @return {?}
                     */
                    get: function () { return (this.id || this._uniqueId) + "-input"; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCheckbox.prototype, "required", {
                    /**
                     * Whether the checkbox is required.
                     * @return {?}
                     */
                    get: function () { return this._required; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._required = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                // TODO: Delete next major revision.
                /**
                 * @return {?}
                 */
                MatCheckbox.prototype.ngAfterViewChecked = function () { };
                /**
                 * @return {?}
                 */
                MatCheckbox.prototype.ngOnDestroy = function () {
                    this._focusMonitor.stopMonitoring(this._elementRef);
                };
                Object.defineProperty(MatCheckbox.prototype, "checked", {
                    /**
                     * Whether the checkbox is checked.
                     * @return {?}
                     */
                    get: function () { return this._checked; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (value != this.checked) {
                            this._checked = value;
                            this._changeDetectorRef.markForCheck();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCheckbox.prototype, "disabled", {
                    /**
                     * Whether the checkbox is disabled. This fully overrides the implementation provided by
                     * mixinDisabled, but the mixin is still required because mixinTabIndex requires it.
                     * @return {?}
                     */
                    get: function () { return this._disabled; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(value);
                        if (newValue !== this.disabled) {
                            this._disabled = newValue;
                            this._changeDetectorRef.markForCheck();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCheckbox.prototype, "indeterminate", {
                    /**
                     * Whether the checkbox is indeterminate. This is also known as "mixed" mode and can be used to
                     * represent a checkbox with three states, e.g. a checkbox that represents a nested list of
                     * checkable items. Note that whenever checkbox is manually clicked, indeterminate is immediately
                     * set to false.
                     * @return {?}
                     */
                    get: function () { return this._indeterminate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var changed = value != this._indeterminate;
                        this._indeterminate = value;
                        if (changed) {
                            if (this._indeterminate) {
                                this._transitionCheckState(TransitionCheckState.Indeterminate);
                            }
                            else {
                                this._transitionCheckState(this.checked ? TransitionCheckState.Checked : TransitionCheckState.Unchecked);
                            }
                            this.indeterminateChange.emit(this._indeterminate);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatCheckbox.prototype._isRippleDisabled = function () {
                    return this.disableRipple || this.disabled;
                };
                /**
                 * Method being called whenever the label text changes.
                 * @return {?}
                 */
                MatCheckbox.prototype._onLabelTextChange = function () {
                    // Since the event of the `cdkObserveContent` directive runs outside of the zone, the checkbox
                    // component will be only marked for check, but no actual change detection runs automatically.
                    // Instead of going back into the zone in order to trigger a change detection which causes
                    // *all* components to be checked (if explicitly marked or not using OnPush), we only trigger
                    // an explicit change detection for the checkbox view and its children.
                    this._changeDetectorRef.detectChanges();
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} value
                 * @return {?}
                 */
                MatCheckbox.prototype.writeValue = function (value) {
                    this.checked = !!value;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} fn
                 * @return {?}
                 */
                MatCheckbox.prototype.registerOnChange = function (fn) {
                    this._controlValueAccessorChangeFn = fn;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} fn
                 * @return {?}
                 */
                MatCheckbox.prototype.registerOnTouched = function (fn) {
                    this._onTouched = fn;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} isDisabled
                 * @return {?}
                 */
                MatCheckbox.prototype.setDisabledState = function (isDisabled) {
                    this.disabled = isDisabled;
                };
                /**
                 * @return {?}
                 */
                MatCheckbox.prototype._getAriaChecked = function () {
                    return this.checked ? 'true' : (this.indeterminate ? 'mixed' : 'false');
                };
                /**
                 * @private
                 * @param {?} newState
                 * @return {?}
                 */
                MatCheckbox.prototype._transitionCheckState = function (newState) {
                    /** @type {?} */
                    var oldState = this._currentCheckState;
                    /** @type {?} */
                    var element = this._elementRef.nativeElement;
                    if (oldState === newState) {
                        return;
                    }
                    if (this._currentAnimationClass.length > 0) {
                        element.classList.remove(this._currentAnimationClass);
                    }
                    this._currentAnimationClass = this._getAnimationClassForCheckStateTransition(oldState, newState);
                    this._currentCheckState = newState;
                    if (this._currentAnimationClass.length > 0) {
                        element.classList.add(this._currentAnimationClass);
                        // Remove the animation class to avoid animation when the checkbox is moved between containers
                        /** @type {?} */
                        var animationClass_1 = this._currentAnimationClass;
                        this._ngZone.runOutsideAngular(( /**
                         * @return {?}
                         */function () {
                            setTimeout(( /**
                             * @return {?}
                             */function () {
                                element.classList.remove(animationClass_1);
                            }), 1000);
                        }));
                    }
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatCheckbox.prototype._emitChangeEvent = function () {
                    /** @type {?} */
                    var event = new MatCheckboxChange();
                    event.source = this;
                    event.checked = this.checked;
                    this._controlValueAccessorChangeFn(this.checked);
                    this.change.emit(event);
                };
                /**
                 * Toggles the `checked` state of the checkbox.
                 * @return {?}
                 */
                MatCheckbox.prototype.toggle = function () {
                    this.checked = !this.checked;
                };
                /**
                 * Event handler for checkbox input element.
                 * Toggles checked state if element is not disabled.
                 * Do not toggle on (change) event since IE doesn't fire change event when
                 *   indeterminate checkbox is clicked.
                 * @param {?} event
                 * @return {?}
                 */
                MatCheckbox.prototype._onInputClick = function (event) {
                    var _this_1 = this;
                    // We have to stop propagation for click events on the visual hidden input element.
                    // By default, when a user clicks on a label element, a generated click event will be
                    // dispatched on the associated input element. Since we are using a label element as our
                    // root container, the click event on the `checkbox` will be executed twice.
                    // The real click event will bubble up, and the generated click event also tries to bubble up.
                    // This will lead to multiple click events.
                    // Preventing bubbling for the second event will solve that issue.
                    event.stopPropagation();
                    // If resetIndeterminate is false, and the current state is indeterminate, do nothing on click
                    if (!this.disabled && this._clickAction !== 'noop') {
                        // When user manually click on the checkbox, `indeterminate` is set to false.
                        if (this.indeterminate && this._clickAction !== 'check') {
                            Promise.resolve().then(( /**
                             * @return {?}
                             */function () {
                                _this_1._indeterminate = false;
                                _this_1.indeterminateChange.emit(_this_1._indeterminate);
                            }));
                        }
                        this.toggle();
                        this._transitionCheckState(this._checked ? TransitionCheckState.Checked : TransitionCheckState.Unchecked);
                        // Emit our custom change event if the native input emitted one.
                        // It is important to only emit it, if the native input triggered one, because
                        // we don't want to trigger a change event, when the `checked` variable changes for example.
                        this._emitChangeEvent();
                    }
                    else if (!this.disabled && this._clickAction === 'noop') {
                        // Reset native input when clicked with noop. The native checkbox becomes checked after
                        // click, reset it to be align with `checked` value of `mat-checkbox`.
                        this._inputElement.nativeElement.checked = this.checked;
                        this._inputElement.nativeElement.indeterminate = this.indeterminate;
                    }
                };
                /**
                 * Focuses the checkbox.
                 * @param {?=} origin
                 * @param {?=} options
                 * @return {?}
                 */
                MatCheckbox.prototype.focus = function (origin, options) {
                    if (origin === void 0) { origin = 'keyboard'; }
                    this._focusMonitor.focusVia(this._inputElement, origin, options);
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatCheckbox.prototype._onInteractionEvent = function (event) {
                    // We always have to stop propagation on the change event.
                    // Otherwise the change event, from the input element, will bubble up and
                    // emit its event object to the `change` output.
                    event.stopPropagation();
                };
                /**
                 * @private
                 * @param {?} oldState
                 * @param {?} newState
                 * @return {?}
                 */
                MatCheckbox.prototype._getAnimationClassForCheckStateTransition = function (oldState, newState) {
                    // Don't transition if animations are disabled.
                    if (this._animationMode === 'NoopAnimations') {
                        return '';
                    }
                    /** @type {?} */
                    var animSuffix = '';
                    switch (oldState) {
                        case TransitionCheckState.Init:
                            // Handle edge case where user interacts with checkbox that does not have [(ngModel)] or
                            // [checked] bound to it.
                            if (newState === TransitionCheckState.Checked) {
                                animSuffix = 'unchecked-checked';
                            }
                            else if (newState == TransitionCheckState.Indeterminate) {
                                animSuffix = 'unchecked-indeterminate';
                            }
                            else {
                                return '';
                            }
                            break;
                        case TransitionCheckState.Unchecked:
                            animSuffix = newState === TransitionCheckState.Checked ?
                                'unchecked-checked' : 'unchecked-indeterminate';
                            break;
                        case TransitionCheckState.Checked:
                            animSuffix = newState === TransitionCheckState.Unchecked ?
                                'checked-unchecked' : 'checked-indeterminate';
                            break;
                        case TransitionCheckState.Indeterminate:
                            animSuffix = newState === TransitionCheckState.Checked ?
                                'indeterminate-checked' : 'indeterminate-unchecked';
                            break;
                    }
                    return "mat-checkbox-anim-" + animSuffix;
                };
                return MatCheckbox;
            }(_MatCheckboxMixinBase));
            MatCheckbox.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-checkbox',
                            template: "<label [attr.for]=\"inputId\" class=\"mat-checkbox-layout\" #label><div class=\"mat-checkbox-inner-container\" [class.mat-checkbox-inner-container-no-side-margin]=\"!checkboxLabel.textContent || !checkboxLabel.textContent.trim()\"><input #input class=\"mat-checkbox-input cdk-visually-hidden\" type=\"checkbox\" [id]=\"inputId\" [required]=\"required\" [checked]=\"checked\" [attr.value]=\"value\" [disabled]=\"disabled\" [attr.name]=\"name\" [tabIndex]=\"tabIndex\" [indeterminate]=\"indeterminate\" [attr.aria-label]=\"ariaLabel || null\" [attr.aria-labelledby]=\"ariaLabelledby\" [attr.aria-checked]=\"_getAriaChecked()\" (change)=\"_onInteractionEvent($event)\" (click)=\"_onInputClick($event)\"><div matRipple class=\"mat-checkbox-ripple\" [matRippleTrigger]=\"label\" [matRippleDisabled]=\"_isRippleDisabled()\" [matRippleRadius]=\"20\" [matRippleCentered]=\"true\" [matRippleAnimation]=\"{enterDuration: 150}\"><div class=\"mat-ripple-element mat-checkbox-persistent-ripple\"></div></div><div class=\"mat-checkbox-frame\"></div><div class=\"mat-checkbox-background\"><svg version=\"1.1\" focusable=\"false\" class=\"mat-checkbox-checkmark\" viewBox=\"0 0 24 24\" xml:space=\"preserve\"><path class=\"mat-checkbox-checkmark-path\" fill=\"none\" stroke=\"white\" d=\"M4.1,12.7 9,17.6 20.3,6.3\"/></svg><div class=\"mat-checkbox-mixedmark\"></div></div></div><span class=\"mat-checkbox-label\" #checkboxLabel (cdkObserveContent)=\"_onLabelTextChange()\"><span style=\"display:none\">&nbsp;</span><ng-content></ng-content></span></label>",
                            styles: ["@keyframes mat-checkbox-fade-in-background{0%{opacity:0}50%{opacity:1}}@keyframes mat-checkbox-fade-out-background{0%,50%{opacity:1}100%{opacity:0}}@keyframes mat-checkbox-unchecked-checked-checkmark-path{0%,50%{stroke-dashoffset:22.91026}50%{animation-timing-function:cubic-bezier(0,0,.2,.1)}100%{stroke-dashoffset:0}}@keyframes mat-checkbox-unchecked-indeterminate-mixedmark{0%,68.2%{transform:scaleX(0)}68.2%{animation-timing-function:cubic-bezier(0,0,0,1)}100%{transform:scaleX(1)}}@keyframes mat-checkbox-checked-unchecked-checkmark-path{from{animation-timing-function:cubic-bezier(.4,0,1,1);stroke-dashoffset:0}to{stroke-dashoffset:-22.91026}}@keyframes mat-checkbox-checked-indeterminate-checkmark{from{animation-timing-function:cubic-bezier(0,0,.2,.1);opacity:1;transform:rotate(0)}to{opacity:0;transform:rotate(45deg)}}@keyframes mat-checkbox-indeterminate-checked-checkmark{from{animation-timing-function:cubic-bezier(.14,0,0,1);opacity:0;transform:rotate(45deg)}to{opacity:1;transform:rotate(360deg)}}@keyframes mat-checkbox-checked-indeterminate-mixedmark{from{animation-timing-function:cubic-bezier(0,0,.2,.1);opacity:0;transform:rotate(-45deg)}to{opacity:1;transform:rotate(0)}}@keyframes mat-checkbox-indeterminate-checked-mixedmark{from{animation-timing-function:cubic-bezier(.14,0,0,1);opacity:1;transform:rotate(0)}to{opacity:0;transform:rotate(315deg)}}@keyframes mat-checkbox-indeterminate-unchecked-mixedmark{0%{animation-timing-function:linear;opacity:1;transform:scaleX(1)}100%,32.8%{opacity:0;transform:scaleX(0)}}.mat-checkbox-background,.mat-checkbox-frame{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:2px;box-sizing:border-box;pointer-events:none}.mat-checkbox{transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1);cursor:pointer;-webkit-tap-highlight-color:transparent}._mat-animation-noopable.mat-checkbox{transition:none;animation:none}.mat-checkbox .mat-ripple-element:not(.mat-checkbox-persistent-ripple){opacity:.16}.mat-checkbox-layout{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:inherit;align-items:baseline;vertical-align:middle;display:inline-flex;white-space:nowrap}.mat-checkbox-label{-webkit-user-select:auto;-moz-user-select:auto;-ms-user-select:auto;user-select:auto}.mat-checkbox-inner-container{display:inline-block;height:16px;line-height:0;margin:auto;margin-right:8px;order:0;position:relative;vertical-align:middle;white-space:nowrap;width:16px;flex-shrink:0}[dir=rtl] .mat-checkbox-inner-container{margin-left:8px;margin-right:auto}.mat-checkbox-inner-container-no-side-margin{margin-left:0;margin-right:0}.mat-checkbox-frame{background-color:transparent;transition:border-color 90ms cubic-bezier(0,0,.2,.1);border-width:2px;border-style:solid}._mat-animation-noopable .mat-checkbox-frame{transition:none}@media (-ms-high-contrast:active){.mat-checkbox.cdk-keyboard-focused .mat-checkbox-frame{border-style:dotted}}.mat-checkbox-background{align-items:center;display:inline-flex;justify-content:center;transition:background-color 90ms cubic-bezier(0,0,.2,.1),opacity 90ms cubic-bezier(0,0,.2,.1)}._mat-animation-noopable .mat-checkbox-background{transition:none}.mat-checkbox-persistent-ripple{width:100%;height:100%;transform:none}.mat-checkbox-inner-container:hover .mat-checkbox-persistent-ripple{opacity:.04}.mat-checkbox.cdk-keyboard-focused .mat-checkbox-persistent-ripple{opacity:.12}.mat-checkbox-persistent-ripple,.mat-checkbox.mat-checkbox-disabled .mat-checkbox-inner-container:hover .mat-checkbox-persistent-ripple{opacity:0}@media (hover:none){.mat-checkbox-inner-container:hover .mat-checkbox-persistent-ripple{display:none}}.mat-checkbox-checkmark{top:0;left:0;right:0;bottom:0;position:absolute;width:100%}.mat-checkbox-checkmark-path{stroke-dashoffset:22.91026;stroke-dasharray:22.91026;stroke-width:2.13333px}.mat-checkbox-mixedmark{width:calc(100% - 6px);height:2px;opacity:0;transform:scaleX(0) rotate(0);border-radius:2px}@media (-ms-high-contrast:active){.mat-checkbox-mixedmark{height:0;border-top:solid 2px;margin-top:2px}}.mat-checkbox-label-before .mat-checkbox-inner-container{order:1;margin-left:8px;margin-right:auto}[dir=rtl] .mat-checkbox-label-before .mat-checkbox-inner-container{margin-left:auto;margin-right:8px}.mat-checkbox-checked .mat-checkbox-checkmark{opacity:1}.mat-checkbox-checked .mat-checkbox-checkmark-path{stroke-dashoffset:0}.mat-checkbox-checked .mat-checkbox-mixedmark{transform:scaleX(1) rotate(-45deg)}.mat-checkbox-indeterminate .mat-checkbox-checkmark{opacity:0;transform:rotate(45deg)}.mat-checkbox-indeterminate .mat-checkbox-checkmark-path{stroke-dashoffset:0}.mat-checkbox-indeterminate .mat-checkbox-mixedmark{opacity:1;transform:scaleX(1) rotate(0)}.mat-checkbox-unchecked .mat-checkbox-background{background-color:transparent}.mat-checkbox-disabled{cursor:default}.mat-checkbox-anim-unchecked-checked .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-in-background}.mat-checkbox-anim-unchecked-checked .mat-checkbox-checkmark-path{animation:180ms linear 0s mat-checkbox-unchecked-checked-checkmark-path}.mat-checkbox-anim-unchecked-indeterminate .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-in-background}.mat-checkbox-anim-unchecked-indeterminate .mat-checkbox-mixedmark{animation:90ms linear 0s mat-checkbox-unchecked-indeterminate-mixedmark}.mat-checkbox-anim-checked-unchecked .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-out-background}.mat-checkbox-anim-checked-unchecked .mat-checkbox-checkmark-path{animation:90ms linear 0s mat-checkbox-checked-unchecked-checkmark-path}.mat-checkbox-anim-checked-indeterminate .mat-checkbox-checkmark{animation:90ms linear 0s mat-checkbox-checked-indeterminate-checkmark}.mat-checkbox-anim-checked-indeterminate .mat-checkbox-mixedmark{animation:90ms linear 0s mat-checkbox-checked-indeterminate-mixedmark}.mat-checkbox-anim-indeterminate-checked .mat-checkbox-checkmark{animation:.5s linear 0s mat-checkbox-indeterminate-checked-checkmark}.mat-checkbox-anim-indeterminate-checked .mat-checkbox-mixedmark{animation:.5s linear 0s mat-checkbox-indeterminate-checked-mixedmark}.mat-checkbox-anim-indeterminate-unchecked .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-out-background}.mat-checkbox-anim-indeterminate-unchecked .mat-checkbox-mixedmark{animation:.3s linear 0s mat-checkbox-indeterminate-unchecked-mixedmark}.mat-checkbox-input{bottom:0;left:50%}.mat-checkbox .mat-checkbox-ripple{position:absolute;left:calc(50% - 20px);top:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}"],
                            exportAs: 'matCheckbox',
                            host: {
                                'class': 'mat-checkbox',
                                '[id]': 'id',
                                '[attr.tabindex]': 'null',
                                '[class.mat-checkbox-indeterminate]': 'indeterminate',
                                '[class.mat-checkbox-checked]': 'checked',
                                '[class.mat-checkbox-disabled]': 'disabled',
                                '[class.mat-checkbox-label-before]': 'labelPosition == "before"',
                                '[class._mat-animation-noopable]': "_animationMode === 'NoopAnimations'",
                            },
                            providers: [MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR],
                            inputs: ['disableRipple', 'color', 'tabIndex'],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush
                        },] },
            ];
            /** @nocollapse */
            MatCheckbox.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__["FocusMonitor"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Attribute"], args: ['tabindex',] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [MAT_CHECKBOX_CLICK_ACTION,] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_5__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            MatCheckbox.propDecorators = {
                ariaLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['aria-label',] }],
                ariaLabelledby: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['aria-labelledby',] }],
                id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                required: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                labelPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                change: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                indeterminateChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                _inputElement: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['input', { static: false },] }],
                ripple: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MatRipple"], { static: false },] }],
                checked: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                indeterminate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var MAT_CHECKBOX_REQUIRED_VALIDATOR = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_3__["NG_VALIDATORS"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatCheckboxRequiredValidator; })),
                multi: true
            };
            /**
             * Validator for Material checkbox's required attribute in template-driven checkbox.
             * Current CheckboxRequiredValidator only work with `input type=checkbox` and does not
             * work with `mat-checkbox`.
             */
            var MatCheckboxRequiredValidator = /** @class */ (function (_super) {
                __extends(MatCheckboxRequiredValidator, _super);
                function MatCheckboxRequiredValidator() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatCheckboxRequiredValidator;
            }(_angular_forms__WEBPACK_IMPORTED_MODULE_3__["CheckboxRequiredValidator"]));
            MatCheckboxRequiredValidator.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: "mat-checkbox[required][formControlName],\n             mat-checkbox[required][formControl], mat-checkbox[required][ngModel]",
                            providers: [MAT_CHECKBOX_REQUIRED_VALIDATOR],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * This module is used by both original and MDC-based checkbox implementations.
             */
            // tslint:disable-next-line:class-name
            var _MatCheckboxRequiredValidatorModule = /** @class */ (function () {
                function _MatCheckboxRequiredValidatorModule() {
                }
                return _MatCheckboxRequiredValidatorModule;
            }());
            _MatCheckboxRequiredValidatorModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            exports: [MatCheckboxRequiredValidator],
                            declarations: [MatCheckboxRequiredValidator],
                        },] },
            ];
            var MatCheckboxModule = /** @class */ (function () {
                function MatCheckboxModule() {
                }
                return MatCheckboxModule;
            }());
            MatCheckboxModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [
                                _angular_common__WEBPACK_IMPORTED_MODULE_7__["CommonModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MatRippleModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MatCommonModule"], _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_6__["ObserversModule"],
                                _MatCheckboxRequiredValidatorModule
                            ],
                            exports: [MatCheckbox, _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MatCommonModule"], _MatCheckboxRequiredValidatorModule],
                            declarations: [MatCheckbox],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=checkbox.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/chips.js": 
        /*!*********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/chips.js ***!
          \*********************************************************/
        /*! exports provided: MatChipsModule, MatChipListChange, MatChipList, MatChipSelectionChange, MatChipAvatar, MatChipTrailingIcon, MatChip, MatChipRemove, MatChipInput, MAT_CHIPS_DEFAULT_OPTIONS */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatChipsModule", function () { return MatChipsModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatChipListChange", function () { return MatChipListChange; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatChipList", function () { return MatChipList; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatChipSelectionChange", function () { return MatChipSelectionChange; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatChipAvatar", function () { return MatChipAvatar; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatChipTrailingIcon", function () { return MatChipTrailingIcon; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatChip", function () { return MatChip; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatChipRemove", function () { return MatChipRemove; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatChipInput", function () { return MatChipInput; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_CHIPS_DEFAULT_OPTIONS", function () { return MAT_CHIPS_DEFAULT_OPTIONS; });
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/platform */ "./node_modules/@angular/cdk/esm2015/platform.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/cdk/collections */ "./node_modules/@angular/cdk/esm2015/collections.js");
            /* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
            /* harmony import */ var _angular_material_form_field__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @angular/material/form-field */ "./node_modules/@angular/material/esm2015/form-field.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Event object emitted by MatChip when selected or deselected.
             */
            var MatChipSelectionChange = /** @class */ (function () {
                /**
                 * @param {?} source
                 * @param {?} selected
                 * @param {?=} isUserInput
                 */
                function MatChipSelectionChange(source, selected, isUserInput) {
                    if (isUserInput === void 0) { isUserInput = false; }
                    this.source = source;
                    this.selected = selected;
                    this.isUserInput = isUserInput;
                }
                return MatChipSelectionChange;
            }());
            // Boilerplate for applying mixins to MatChip.
            /**
             * \@docs-private
             */
            var MatChipBase = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 */
                function MatChipBase(_elementRef) {
                    this._elementRef = _elementRef;
                }
                return MatChipBase;
            }());
            /** @type {?} */
            var _MatChipMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["mixinColor"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["mixinDisableRipple"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["mixinDisabled"])(MatChipBase)), 'primary');
            /**
             * Dummy directive to add CSS class to chip avatar.
             * \@docs-private
             */
            var MatChipAvatar = /** @class */ (function () {
                function MatChipAvatar() {
                }
                return MatChipAvatar;
            }());
            MatChipAvatar.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: 'mat-chip-avatar, [matChipAvatar]',
                            host: { 'class': 'mat-chip-avatar' }
                        },] },
            ];
            /**
             * Dummy directive to add CSS class to chip trailing icon.
             * \@docs-private
             */
            var MatChipTrailingIcon = /** @class */ (function () {
                function MatChipTrailingIcon() {
                }
                return MatChipTrailingIcon;
            }());
            MatChipTrailingIcon.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: 'mat-chip-trailing-icon, [matChipTrailingIcon]',
                            host: { 'class': 'mat-chip-trailing-icon' }
                        },] },
            ];
            /**
             * Material design styled Chip component. Used inside the MatChipList component.
             */
            var MatChip = /** @class */ (function (_super) {
                __extends(MatChip, _super);
                /**
                 * @param {?} _elementRef
                 * @param {?} _ngZone
                 * @param {?} platform
                 * @param {?} globalRippleOptions
                 * @param {?=} animationMode
                 * @param {?=} _changeDetectorRef
                 */
                function MatChip(_elementRef, _ngZone, platform, globalRippleOptions, 
                // @breaking-change 8.0.0 `animationMode` parameter to become required.
                animationMode, _changeDetectorRef) {
                    var _this_1 = _super.call(this, _elementRef) || this;
                    _this_1._elementRef = _elementRef;
                    _this_1._ngZone = _ngZone;
                    _this_1._changeDetectorRef = _changeDetectorRef;
                    /**
                     * Whether the chip has focus.
                     */
                    _this_1._hasFocus = false;
                    /**
                     * Whether the chip list is selectable
                     */
                    _this_1.chipListSelectable = true;
                    /**
                     * Whether the chip list is in multi-selection mode.
                     */
                    _this_1._chipListMultiple = false;
                    _this_1._selected = false;
                    _this_1._selectable = true;
                    _this_1._removable = true;
                    /**
                     * Emits when the chip is focused.
                     */
                    _this_1._onFocus = new rxjs__WEBPACK_IMPORTED_MODULE_5__["Subject"]();
                    /**
                     * Emits when the chip is blured.
                     */
                    _this_1._onBlur = new rxjs__WEBPACK_IMPORTED_MODULE_5__["Subject"]();
                    /**
                     * Emitted when the chip is selected or deselected.
                     */
                    _this_1.selectionChange = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /**
                     * Emitted when the chip is destroyed.
                     */
                    _this_1.destroyed = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /**
                     * Emitted when a chip is to be removed.
                     */
                    _this_1.removed = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    _this_1._addHostClassName();
                    _this_1._chipRipple = new _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["RippleRenderer"](_this_1, _ngZone, _elementRef, platform);
                    _this_1._chipRipple.setupTriggerEvents(_elementRef);
                    _this_1.rippleConfig = globalRippleOptions || {};
                    _this_1._animationsDisabled = animationMode === 'NoopAnimations';
                    return _this_1;
                }
                Object.defineProperty(MatChip.prototype, "rippleDisabled", {
                    /**
                     * Whether ripples are disabled on interaction
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () {
                        return this.disabled || this.disableRipple || !!this.rippleConfig.disabled;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChip.prototype, "selected", {
                    /**
                     * Whether the chip is selected.
                     * @return {?}
                     */
                    get: function () { return this._selected; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var coercedValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value);
                        if (coercedValue !== this._selected) {
                            this._selected = coercedValue;
                            this._dispatchSelectionChange();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChip.prototype, "value", {
                    /**
                     * The value of the chip. Defaults to the content inside `<mat-chip>` tags.
                     * @return {?}
                     */
                    get: function () {
                        return this._value !== undefined
                            ? this._value
                            : this._elementRef.nativeElement.textContent;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._value = value; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChip.prototype, "selectable", {
                    /**
                     * Whether or not the chip is selectable. When a chip is not selectable,
                     * changes to its selected state are always ignored. By default a chip is
                     * selectable, and it becomes non-selectable if its parent chip list is
                     * not selectable.
                     * @return {?}
                     */
                    get: function () { return this._selectable && this.chipListSelectable; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._selectable = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChip.prototype, "removable", {
                    /**
                     * Determines whether or not the chip displays the remove styling and emits (removed) events.
                     * @return {?}
                     */
                    get: function () { return this._removable; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._removable = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChip.prototype, "ariaSelected", {
                    /**
                     * The ARIA selected applied to the chip.
                     * @return {?}
                     */
                    get: function () {
                        // Remove the `aria-selected` when the chip is deselected in single-selection mode, because
                        // it adds noise to NVDA users where "not selected" will be read out for each chip.
                        return this.selectable && (this._chipListMultiple || this.selected) ?
                            this.selected.toString() : null;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatChip.prototype._addHostClassName = function () {
                    /** @type {?} */
                    var basicChipAttrName = 'mat-basic-chip';
                    /** @type {?} */
                    var element = ( /** @type {?} */(this._elementRef.nativeElement));
                    if (element.hasAttribute(basicChipAttrName) ||
                        element.tagName.toLowerCase() === basicChipAttrName) {
                        element.classList.add(basicChipAttrName);
                        return;
                    }
                    else {
                        element.classList.add('mat-standard-chip');
                    }
                };
                /**
                 * @return {?}
                 */
                MatChip.prototype.ngOnDestroy = function () {
                    this.destroyed.emit({ chip: this });
                    this._chipRipple._removeTriggerEvents();
                };
                /**
                 * Selects the chip.
                 * @return {?}
                 */
                MatChip.prototype.select = function () {
                    if (!this._selected) {
                        this._selected = true;
                        this._dispatchSelectionChange();
                        this._markForCheck();
                    }
                };
                /**
                 * Deselects the chip.
                 * @return {?}
                 */
                MatChip.prototype.deselect = function () {
                    if (this._selected) {
                        this._selected = false;
                        this._dispatchSelectionChange();
                        this._markForCheck();
                    }
                };
                /**
                 * Select this chip and emit selected event
                 * @return {?}
                 */
                MatChip.prototype.selectViaInteraction = function () {
                    if (!this._selected) {
                        this._selected = true;
                        this._dispatchSelectionChange(true);
                        this._markForCheck();
                    }
                };
                /**
                 * Toggles the current selected state of this chip.
                 * @param {?=} isUserInput
                 * @return {?}
                 */
                MatChip.prototype.toggleSelected = function (isUserInput) {
                    if (isUserInput === void 0) { isUserInput = false; }
                    this._selected = !this.selected;
                    this._dispatchSelectionChange(isUserInput);
                    this._markForCheck();
                    return this.selected;
                };
                /**
                 * Allows for programmatic focusing of the chip.
                 * @return {?}
                 */
                MatChip.prototype.focus = function () {
                    if (!this._hasFocus) {
                        this._elementRef.nativeElement.focus();
                        this._onFocus.next({ chip: this });
                    }
                    this._hasFocus = true;
                };
                /**
                 * Allows for programmatic removal of the chip. Called by the MatChipList when the DELETE or
                 * BACKSPACE keys are pressed.
                 *
                 * Informs any listeners of the removal request. Does not remove the chip from the DOM.
                 * @return {?}
                 */
                MatChip.prototype.remove = function () {
                    if (this.removable) {
                        this.removed.emit({ chip: this });
                    }
                };
                /**
                 * Handles click events on the chip.
                 * @param {?} event
                 * @return {?}
                 */
                MatChip.prototype._handleClick = function (event) {
                    if (this.disabled) {
                        event.preventDefault();
                    }
                    else {
                        event.stopPropagation();
                    }
                };
                /**
                 * Handle custom key presses.
                 * @param {?} event
                 * @return {?}
                 */
                MatChip.prototype._handleKeydown = function (event) {
                    if (this.disabled) {
                        return;
                    }
                    switch (event.keyCode) {
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["DELETE"]:
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["BACKSPACE"]:
                            // If we are removable, remove the focused chip
                            this.remove();
                            // Always prevent so page navigation does not occur
                            event.preventDefault();
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["SPACE"]:
                            // If we are selectable, toggle the focused chip
                            if (this.selectable) {
                                this.toggleSelected(true);
                            }
                            // Always prevent space from scrolling the page since the list has focus
                            event.preventDefault();
                            break;
                    }
                };
                /**
                 * @return {?}
                 */
                MatChip.prototype._blur = function () {
                    var _this_1 = this;
                    // When animations are enabled, Angular may end up removing the chip from the DOM a little
                    // earlier than usual, causing it to be blurred and throwing off the logic in the chip list
                    // that moves focus not the next item. To work around the issue, we defer marking the chip
                    // as not focused until the next time the zone stabilizes.
                    this._ngZone.onStable
                        .asObservable()
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["take"])(1))
                        .subscribe(( /**
                 * @return {?}
                 */function () {
                        _this_1._ngZone.run(( /**
                         * @return {?}
                         */function () {
                            _this_1._hasFocus = false;
                            _this_1._onBlur.next({ chip: _this_1 });
                        }));
                    }));
                };
                /**
                 * @private
                 * @param {?=} isUserInput
                 * @return {?}
                 */
                MatChip.prototype._dispatchSelectionChange = function (isUserInput) {
                    if (isUserInput === void 0) { isUserInput = false; }
                    this.selectionChange.emit({
                        source: this,
                        isUserInput: isUserInput,
                        selected: this._selected
                    });
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatChip.prototype._markForCheck = function () {
                    // @breaking-change 9.0.0 Remove this method once the _changeDetectorRef is a required param.
                    if (this._changeDetectorRef) {
                        this._changeDetectorRef.markForCheck();
                    }
                };
                return MatChip;
            }(_MatChipMixinBase));
            MatChip.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: "mat-basic-chip, [mat-basic-chip], mat-chip, [mat-chip]",
                            inputs: ['color', 'disabled', 'disableRipple'],
                            exportAs: 'matChip',
                            host: {
                                'class': 'mat-chip',
                                '[attr.tabindex]': 'disabled ? null : -1',
                                'role': 'option',
                                '[class.mat-chip-selected]': 'selected',
                                '[class.mat-chip-with-avatar]': 'avatar',
                                '[class.mat-chip-with-trailing-icon]': 'trailingIcon || removeIcon',
                                '[class.mat-chip-disabled]': 'disabled',
                                '[class._mat-animation-noopable]': '_animationsDisabled',
                                '[attr.disabled]': 'disabled || null',
                                '[attr.aria-disabled]': 'disabled.toString()',
                                '[attr.aria-selected]': 'ariaSelected',
                                '(click)': '_handleClick($event)',
                                '(keydown)': '_handleKeydown($event)',
                                '(focus)': 'focus()',
                                '(blur)': '_blur()',
                            },
                        },] },
            ];
            /** @nocollapse */
            MatChip.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["NgZone"] },
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_2__["Platform"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MAT_RIPPLE_GLOBAL_OPTIONS"],] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_7__["ANIMATION_MODULE_TYPE"],] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectorRef"] }
            ]; };
            MatChip.propDecorators = {
                avatar: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChild"], args: [MatChipAvatar, { static: false },] }],
                trailingIcon: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChild"], args: [MatChipTrailingIcon, { static: false },] }],
                removeIcon: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChild"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["forwardRef"])(( /**
                                         * @return {?}
                                         */function () { return MatChipRemove; })), { static: false },] }],
                selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                selectable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                removable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                selectionChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                destroyed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                removed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }]
            };
            /**
             * Applies proper (click) support and adds styling for use with the Material Design "cancel" icon
             * available at https://material.io/icons/#ic_cancel.
             *
             * Example:
             *
             *     `<mat-chip>
             *       <mat-icon matChipRemove>cancel</mat-icon>
             *     </mat-chip>`
             *
             * You *may* use a custom icon, but you may need to override the `mat-chip-remove` positioning
             * styles to properly center the icon within the chip.
             */
            var MatChipRemove = /** @class */ (function () {
                /**
                 * @param {?} _parentChip
                 */
                function MatChipRemove(_parentChip) {
                    this._parentChip = _parentChip;
                }
                /**
                 * Calls the parent chip's public `remove()` method if applicable.
                 * @param {?} event
                 * @return {?}
                 */
                MatChipRemove.prototype._handleClick = function (event) {
                    /** @type {?} */
                    var parentChip = this._parentChip;
                    if (parentChip.removable && !parentChip.disabled) {
                        parentChip.remove();
                    }
                    // We need to stop event propagation because otherwise the event will bubble up to the
                    // form field and cause the `onContainerClick` method to be invoked. This method would then
                    // reset the focused chip that has been focused after chip removal. Usually the parent
                    // the parent click listener of the `MatChip` would prevent propagation, but it can happen
                    // that the chip is being removed before the event bubbles up.
                    event.stopPropagation();
                };
                return MatChipRemove;
            }());
            MatChipRemove.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: '[matChipRemove]',
                            host: {
                                'class': 'mat-chip-remove mat-chip-trailing-icon',
                                '(click)': '_handleClick($event)',
                            }
                        },] },
            ];
            /** @nocollapse */
            MatChipRemove.ctorParameters = function () { return [
                { type: MatChip }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token to be used to override the default options for the chips module.
             * @type {?}
             */
            var MAT_CHIPS_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["InjectionToken"]('mat-chips-default-options');
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // Boilerplate for applying mixins to MatChipList.
            /**
             * \@docs-private
             */
            var MatChipListBase = /** @class */ (function () {
                /**
                 * @param {?} _defaultErrorStateMatcher
                 * @param {?} _parentForm
                 * @param {?} _parentFormGroup
                 * @param {?} ngControl
                 */
                function MatChipListBase(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {
                    this._defaultErrorStateMatcher = _defaultErrorStateMatcher;
                    this._parentForm = _parentForm;
                    this._parentFormGroup = _parentFormGroup;
                    this.ngControl = ngControl;
                }
                return MatChipListBase;
            }());
            /** @type {?} */
            var _MatChipListMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["mixinErrorState"])(MatChipListBase);
            // Increasing integer for generating unique ids for chip-list components.
            /** @type {?} */
            var nextUniqueId = 0;
            /**
             * Change event object that is emitted when the chip list value has changed.
             */
            var MatChipListChange = /** @class */ (function () {
                /**
                 * @param {?} source
                 * @param {?} value
                 */
                function MatChipListChange(source, value) {
                    this.source = source;
                    this.value = value;
                }
                return MatChipListChange;
            }());
            /**
             * A material design chips component (named ChipList for its similarity to the List component).
             */
            var MatChipList = /** @class */ (function (_super) {
                __extends(MatChipList, _super);
                /**
                 * @param {?} _elementRef
                 * @param {?} _changeDetectorRef
                 * @param {?} _dir
                 * @param {?} _parentForm
                 * @param {?} _parentFormGroup
                 * @param {?} _defaultErrorStateMatcher
                 * @param {?} ngControl
                 */
                function MatChipList(_elementRef, _changeDetectorRef, _dir, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, ngControl) {
                    var _this_1 = _super.call(this, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) || this;
                    _this_1._elementRef = _elementRef;
                    _this_1._changeDetectorRef = _changeDetectorRef;
                    _this_1._dir = _dir;
                    _this_1.ngControl = ngControl;
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     */
                    _this_1.controlType = 'mat-chip-list';
                    /**
                     * When a chip is destroyed, we store the index of the destroyed chip until the chips
                     * query list notifies about the update. This is necessary because we cannot determine an
                     * appropriate chip that should receive focus until the array of chips updated completely.
                     */
                    _this_1._lastDestroyedChipIndex = null;
                    /**
                     * Subject that emits when the component has been destroyed.
                     */
                    _this_1._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_5__["Subject"]();
                    /**
                     * Uid of the chip list
                     */
                    _this_1._uid = "mat-chip-list-" + nextUniqueId++;
                    /**
                     * Tab index for the chip list.
                     */
                    _this_1._tabIndex = 0;
                    /**
                     * User defined tab index.
                     * When it is not null, use user defined tab index. Otherwise use _tabIndex
                     */
                    _this_1._userTabIndex = null;
                    /**
                     * Function when touched
                     */
                    _this_1._onTouched = ( /**
                     * @return {?}
                     */function () { });
                    /**
                     * Function when changed
                     */
                    _this_1._onChange = ( /**
                     * @return {?}
                     */function () { });
                    _this_1._multiple = false;
                    _this_1._compareWith = ( /**
                     * @param {?} o1
                     * @param {?} o2
                     * @return {?}
                     */function (o1, o2) { return o1 === o2; });
                    _this_1._required = false;
                    _this_1._disabled = false;
                    /**
                     * Orientation of the chip list.
                     */
                    _this_1.ariaOrientation = 'horizontal';
                    _this_1._selectable = true;
                    /**
                     * Event emitted when the selected chip list value has been changed by the user.
                     */
                    _this_1.change = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /**
                     * Event that emits whenever the raw value of the chip-list changes. This is here primarily
                     * to facilitate the two-way binding for the `value` input.
                     * \@docs-private
                     */
                    _this_1.valueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    if (_this_1.ngControl) {
                        _this_1.ngControl.valueAccessor = _this_1;
                    }
                    return _this_1;
                }
                Object.defineProperty(MatChipList.prototype, "selected", {
                    /**
                     * The array of selected chips inside chip list.
                     * @return {?}
                     */
                    get: function () {
                        return this.multiple ? this._selectionModel.selected : this._selectionModel.selected[0];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "role", {
                    /**
                     * The ARIA role applied to the chip list.
                     * @return {?}
                     */
                    get: function () { return this.empty ? null : 'listbox'; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "multiple", {
                    /**
                     * Whether the user should be allowed to select multiple chips.
                     * @return {?}
                     */
                    get: function () { return this._multiple; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._multiple = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value);
                        this._syncChipsState();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "compareWith", {
                    /**
                     * A function to compare the option values with the selected values. The first argument
                     * is a value from an option. The second is a value from the selection. A boolean
                     * should be returned.
                     * @return {?}
                     */
                    get: function () { return this._compareWith; },
                    /**
                     * @param {?} fn
                     * @return {?}
                     */
                    set: function (fn) {
                        this._compareWith = fn;
                        if (this._selectionModel) {
                            // A different comparator means the selection could change.
                            this._initializeSelection();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "value", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () { return this._value; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this.writeValue(value);
                        this._value = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "id", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () {
                        return this._chipInput ? this._chipInput.id : this._uid;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "required", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () { return this._required; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._required = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value);
                        this.stateChanges.next();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "placeholder", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () {
                        return this._chipInput ? this._chipInput.placeholder : this._placeholder;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._placeholder = value;
                        this.stateChanges.next();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "focused", {
                    /**
                     * Whether any chips or the matChipInput inside of this chip-list has focus.
                     * @return {?}
                     */
                    get: function () {
                        return (this._chipInput && this._chipInput.focused) || this._hasFocusedChip();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "empty", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () {
                        return (!this._chipInput || this._chipInput.empty) && this.chips.length === 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "shouldLabelFloat", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () { return !this.empty || this.focused; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "disabled", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () { return this.ngControl ? !!this.ngControl.disabled : this._disabled; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value);
                        this._syncChipsState();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "selectable", {
                    /**
                     * Whether or not this chip list is selectable. When a chip list is not selectable,
                     * the selected states for all the chips inside the chip list are always ignored.
                     * @return {?}
                     */
                    get: function () { return this._selectable; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        var _this_1 = this;
                        this._selectable = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value);
                        if (this.chips) {
                            this.chips.forEach(( /**
                             * @param {?} chip
                             * @return {?}
                             */function (/**
                             * @param {?} chip
                             * @return {?}
                             */ chip) { return chip.chipListSelectable = _this_1._selectable; }));
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "tabIndex", {
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._userTabIndex = value;
                        this._tabIndex = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "chipSelectionChanges", {
                    /**
                     * Combined stream of all of the child chips' selection change events.
                     * @return {?}
                     */
                    get: function () {
                        return Object(rxjs__WEBPACK_IMPORTED_MODULE_5__["merge"]).apply(void 0, this.chips.map(( /**
                         * @param {?} chip
                         * @return {?}
                         */function (/**
                         * @param {?} chip
                         * @return {?}
                         */ chip) { return chip.selectionChange; })));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "chipFocusChanges", {
                    /**
                     * Combined stream of all of the child chips' focus change events.
                     * @return {?}
                     */
                    get: function () {
                        return Object(rxjs__WEBPACK_IMPORTED_MODULE_5__["merge"]).apply(void 0, this.chips.map(( /**
                         * @param {?} chip
                         * @return {?}
                         */function (/**
                         * @param {?} chip
                         * @return {?}
                         */ chip) { return chip._onFocus; })));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "chipBlurChanges", {
                    /**
                     * Combined stream of all of the child chips' blur change events.
                     * @return {?}
                     */
                    get: function () {
                        return Object(rxjs__WEBPACK_IMPORTED_MODULE_5__["merge"]).apply(void 0, this.chips.map(( /**
                         * @param {?} chip
                         * @return {?}
                         */function (/**
                         * @param {?} chip
                         * @return {?}
                         */ chip) { return chip._onBlur; })));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "chipRemoveChanges", {
                    /**
                     * Combined stream of all of the child chips' remove change events.
                     * @return {?}
                     */
                    get: function () {
                        return Object(rxjs__WEBPACK_IMPORTED_MODULE_5__["merge"]).apply(void 0, this.chips.map(( /**
                         * @param {?} chip
                         * @return {?}
                         */function (/**
                         * @param {?} chip
                         * @return {?}
                         */ chip) { return chip.destroyed; })));
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatChipList.prototype.ngAfterContentInit = function () {
                    var _this_1 = this;
                    this._keyManager = new _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_8__["FocusKeyManager"](this.chips)
                        .withWrap()
                        .withVerticalOrientation()
                        .withHorizontalOrientation(this._dir ? this._dir.value : 'ltr');
                    if (this._dir) {
                        this._dir.change
                            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["takeUntil"])(this._destroyed))
                            .subscribe(( /**
                     * @param {?} dir
                     * @return {?}
                     */function (/**
                     * @param {?} dir
                     * @return {?}
                     */ dir) { return _this_1._keyManager.withHorizontalOrientation(dir); }));
                    }
                    this._keyManager.tabOut.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["takeUntil"])(this._destroyed)).subscribe(( /**
                     * @return {?}
                     */function () {
                        _this_1._allowFocusEscape();
                    }));
                    // When the list changes, re-subscribe
                    this.chips.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["startWith"])(null), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["takeUntil"])(this._destroyed)).subscribe(( /**
                     * @return {?}
                     */function () {
                        if (_this_1.disabled) {
                            // Since this happens after the content has been
                            // checked, we need to defer it to the next tick.
                            Promise.resolve().then(( /**
                             * @return {?}
                             */function () {
                                _this_1._syncChipsState();
                            }));
                        }
                        _this_1._resetChips();
                        // Reset chips selected/deselected status
                        _this_1._initializeSelection();
                        // Check to see if we need to update our tab index
                        _this_1._updateTabIndex();
                        // Check to see if we have a destroyed chip and need to refocus
                        _this_1._updateFocusForDestroyedChips();
                        _this_1.stateChanges.next();
                    }));
                };
                /**
                 * @return {?}
                 */
                MatChipList.prototype.ngOnInit = function () {
                    this._selectionModel = new _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_10__["SelectionModel"](this.multiple, undefined, false);
                    this.stateChanges.next();
                };
                /**
                 * @return {?}
                 */
                MatChipList.prototype.ngDoCheck = function () {
                    if (this.ngControl) {
                        // We need to re-evaluate this on every change detection cycle, because there are some
                        // error triggers that we can't subscribe to (e.g. parent form submissions). This means
                        // that whatever logic is in here has to be super lean or we risk destroying the performance.
                        this.updateErrorState();
                    }
                };
                /**
                 * @return {?}
                 */
                MatChipList.prototype.ngOnDestroy = function () {
                    this._destroyed.next();
                    this._destroyed.complete();
                    this.stateChanges.complete();
                    this._dropSubscriptions();
                };
                /**
                 * Associates an HTML input element with this chip list.
                 * @param {?} inputElement
                 * @return {?}
                 */
                MatChipList.prototype.registerInput = function (inputElement) {
                    this._chipInput = inputElement;
                };
                /**
                 * Implemented as part of MatFormFieldControl.
                 * \@docs-private
                 * @param {?} ids
                 * @return {?}
                 */
                MatChipList.prototype.setDescribedByIds = function (ids) { this._ariaDescribedby = ids.join(' '); };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} value
                 * @return {?}
                 */
                MatChipList.prototype.writeValue = function (value) {
                    if (this.chips) {
                        this._setSelectionByValue(value, false);
                    }
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} fn
                 * @return {?}
                 */
                MatChipList.prototype.registerOnChange = function (fn) {
                    this._onChange = fn;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} fn
                 * @return {?}
                 */
                MatChipList.prototype.registerOnTouched = function (fn) {
                    this._onTouched = fn;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} isDisabled
                 * @return {?}
                 */
                MatChipList.prototype.setDisabledState = function (isDisabled) {
                    this.disabled = isDisabled;
                    this.stateChanges.next();
                };
                /**
                 * Implemented as part of MatFormFieldControl.
                 * \@docs-private
                 * @param {?} event
                 * @return {?}
                 */
                MatChipList.prototype.onContainerClick = function (event) {
                    if (!this._originatesFromChip(event)) {
                        this.focus();
                    }
                };
                /**
                 * Focuses the first non-disabled chip in this chip list, or the associated input when there
                 * are no eligible chips.
                 * @param {?=} options
                 * @return {?}
                 */
                MatChipList.prototype.focus = function (options) {
                    if (this.disabled) {
                        return;
                    }
                    // TODO: ARIA says this should focus the first `selected` chip if any are selected.
                    // Focus on first element if there's no chipInput inside chip-list
                    if (this._chipInput && this._chipInput.focused) {
                        // do nothing
                    }
                    else if (this.chips.length > 0) {
                        this._keyManager.setFirstItemActive();
                        this.stateChanges.next();
                    }
                    else {
                        this._focusInput(options);
                        this.stateChanges.next();
                    }
                };
                /**
                 * Attempt to focus an input if we have one.
                 * @param {?=} options
                 * @return {?}
                 */
                MatChipList.prototype._focusInput = function (options) {
                    if (this._chipInput) {
                        this._chipInput.focus(options);
                    }
                };
                /**
                 * Pass events to the keyboard manager. Available here for tests.
                 * @param {?} event
                 * @return {?}
                 */
                MatChipList.prototype._keydown = function (event) {
                    /** @type {?} */
                    var target = ( /** @type {?} */(event.target));
                    // If they are on an empty input and hit backspace, focus the last chip
                    if (event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["BACKSPACE"] && this._isInputEmpty(target)) {
                        this._keyManager.setLastItemActive();
                        event.preventDefault();
                    }
                    else if (target && target.classList.contains('mat-chip')) {
                        if (event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["HOME"]) {
                            this._keyManager.setFirstItemActive();
                            event.preventDefault();
                        }
                        else if (event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["END"]) {
                            this._keyManager.setLastItemActive();
                            event.preventDefault();
                        }
                        else {
                            this._keyManager.onKeydown(event);
                        }
                        this.stateChanges.next();
                    }
                };
                /**
                 * Check the tab index as you should not be allowed to focus an empty list.
                 * @protected
                 * @return {?}
                 */
                MatChipList.prototype._updateTabIndex = function () {
                    // If we have 0 chips, we should not allow keyboard focus
                    this._tabIndex = this._userTabIndex || (this.chips.length === 0 ? -1 : 0);
                };
                /**
                 * If the amount of chips changed, we need to update the
                 * key manager state and focus the next closest chip.
                 * @protected
                 * @return {?}
                 */
                MatChipList.prototype._updateFocusForDestroyedChips = function () {
                    // Move focus to the closest chip. If no other chips remain, focus the chip-list itself.
                    if (this._lastDestroyedChipIndex != null) {
                        if (this.chips.length) {
                            /** @type {?} */
                            var newChipIndex = Math.min(this._lastDestroyedChipIndex, this.chips.length - 1);
                            this._keyManager.setActiveItem(newChipIndex);
                        }
                        else {
                            this.focus();
                        }
                    }
                    this._lastDestroyedChipIndex = null;
                };
                /**
                 * Utility to ensure all indexes are valid.
                 *
                 * @private
                 * @param {?} index The index to be checked.
                 * @return {?} True if the index is valid for our list of chips.
                 */
                MatChipList.prototype._isValidIndex = function (index) {
                    return index >= 0 && index < this.chips.length;
                };
                /**
                 * @private
                 * @param {?} element
                 * @return {?}
                 */
                MatChipList.prototype._isInputEmpty = function (element) {
                    if (element && element.nodeName.toLowerCase() === 'input') {
                        /** @type {?} */
                        var input = ( /** @type {?} */(element));
                        return !input.value;
                    }
                    return false;
                };
                /**
                 * @param {?} value
                 * @param {?=} isUserInput
                 * @return {?}
                 */
                MatChipList.prototype._setSelectionByValue = function (value, isUserInput) {
                    var _this_1 = this;
                    if (isUserInput === void 0) { isUserInput = true; }
                    this._clearSelection();
                    this.chips.forEach(( /**
                     * @param {?} chip
                     * @return {?}
                     */function (/**
                     * @param {?} chip
                     * @return {?}
                     */ chip) { return chip.deselect(); }));
                    if (Array.isArray(value)) {
                        value.forEach(( /**
                         * @param {?} currentValue
                         * @return {?}
                         */function (/**
                         * @param {?} currentValue
                         * @return {?}
                         */ currentValue) { return _this_1._selectValue(currentValue, isUserInput); }));
                        this._sortValues();
                    }
                    else {
                        /** @type {?} */
                        var correspondingChip = this._selectValue(value, isUserInput);
                        // Shift focus to the active item. Note that we shouldn't do this in multiple
                        // mode, because we don't know what chip the user interacted with last.
                        if (correspondingChip) {
                            if (isUserInput) {
                                this._keyManager.setActiveItem(correspondingChip);
                            }
                        }
                    }
                };
                /**
                 * Finds and selects the chip based on its value.
                 * @private
                 * @param {?} value
                 * @param {?=} isUserInput
                 * @return {?} Chip that has the corresponding value.
                 */
                MatChipList.prototype._selectValue = function (value, isUserInput) {
                    var _this_1 = this;
                    if (isUserInput === void 0) { isUserInput = true; }
                    /** @type {?} */
                    var correspondingChip = this.chips.find(( /**
                     * @param {?} chip
                     * @return {?}
                     */function (/**
                     * @param {?} chip
                     * @return {?}
                     */ chip) {
                        return chip.value != null && _this_1._compareWith(chip.value, value);
                    }));
                    if (correspondingChip) {
                        isUserInput ? correspondingChip.selectViaInteraction() : correspondingChip.select();
                        this._selectionModel.select(correspondingChip);
                    }
                    return correspondingChip;
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatChipList.prototype._initializeSelection = function () {
                    var _this_1 = this;
                    // Defer setting the value in order to avoid the "Expression
                    // has changed after it was checked" errors from Angular.
                    Promise.resolve().then(( /**
                     * @return {?}
                     */function () {
                        if (_this_1.ngControl || _this_1._value) {
                            _this_1._setSelectionByValue(_this_1.ngControl ? _this_1.ngControl.value : _this_1._value, false);
                            _this_1.stateChanges.next();
                        }
                    }));
                };
                /**
                 * Deselects every chip in the list.
                 * @private
                 * @param {?=} skip Chip that should not be deselected.
                 * @return {?}
                 */
                MatChipList.prototype._clearSelection = function (skip) {
                    this._selectionModel.clear();
                    this.chips.forEach(( /**
                     * @param {?} chip
                     * @return {?}
                     */function (/**
                     * @param {?} chip
                     * @return {?}
                     */ chip) {
                        if (chip !== skip) {
                            chip.deselect();
                        }
                    }));
                    this.stateChanges.next();
                };
                /**
                 * Sorts the model values, ensuring that they keep the same
                 * order that they have in the panel.
                 * @private
                 * @return {?}
                 */
                MatChipList.prototype._sortValues = function () {
                    var _this_1 = this;
                    if (this._multiple) {
                        this._selectionModel.clear();
                        this.chips.forEach(( /**
                         * @param {?} chip
                         * @return {?}
                         */function (/**
                         * @param {?} chip
                         * @return {?}
                         */ chip) {
                            if (chip.selected) {
                                _this_1._selectionModel.select(chip);
                            }
                        }));
                        this.stateChanges.next();
                    }
                };
                /**
                 * Emits change event to set the model value.
                 * @private
                 * @param {?=} fallbackValue
                 * @return {?}
                 */
                MatChipList.prototype._propagateChanges = function (fallbackValue) {
                    /** @type {?} */
                    var valueToEmit = null;
                    if (Array.isArray(this.selected)) {
                        valueToEmit = this.selected.map(( /**
                         * @param {?} chip
                         * @return {?}
                         */function (/**
                         * @param {?} chip
                         * @return {?}
                         */ chip) { return chip.value; }));
                    }
                    else {
                        valueToEmit = this.selected ? this.selected.value : fallbackValue;
                    }
                    this._value = valueToEmit;
                    this.change.emit(new MatChipListChange(this, valueToEmit));
                    this.valueChange.emit(valueToEmit);
                    this._onChange(valueToEmit);
                    this._changeDetectorRef.markForCheck();
                };
                /**
                 * When blurred, mark the field as touched when focus moved outside the chip list.
                 * @return {?}
                 */
                MatChipList.prototype._blur = function () {
                    var _this_1 = this;
                    if (!this._hasFocusedChip()) {
                        this._keyManager.setActiveItem(-1);
                    }
                    if (!this.disabled) {
                        if (this._chipInput) {
                            // If there's a chip input, we should check whether the focus moved to chip input.
                            // If the focus is not moved to chip input, mark the field as touched. If the focus moved
                            // to chip input, do nothing.
                            // Timeout is needed to wait for the focus() event trigger on chip input.
                            setTimeout(( /**
                             * @return {?}
                             */function () {
                                if (!_this_1.focused) {
                                    _this_1._markAsTouched();
                                }
                            }));
                        }
                        else {
                            // If there's no chip input, then mark the field as touched.
                            this._markAsTouched();
                        }
                    }
                };
                /**
                 * Mark the field as touched
                 * @return {?}
                 */
                MatChipList.prototype._markAsTouched = function () {
                    this._onTouched();
                    this._changeDetectorRef.markForCheck();
                    this.stateChanges.next();
                };
                /**
                 * Removes the `tabindex` from the chip list and resets it back afterwards, allowing the
                 * user to tab out of it. This prevents the list from capturing focus and redirecting
                 * it back to the first chip, creating a focus trap, if it user tries to tab away.
                 * @return {?}
                 */
                MatChipList.prototype._allowFocusEscape = function () {
                    var _this_1 = this;
                    if (this._tabIndex !== -1) {
                        this._tabIndex = -1;
                        setTimeout(( /**
                         * @return {?}
                         */function () {
                            _this_1._tabIndex = _this_1._userTabIndex || 0;
                            _this_1._changeDetectorRef.markForCheck();
                        }));
                    }
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatChipList.prototype._resetChips = function () {
                    this._dropSubscriptions();
                    this._listenToChipsFocus();
                    this._listenToChipsSelection();
                    this._listenToChipsRemoved();
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatChipList.prototype._dropSubscriptions = function () {
                    if (this._chipFocusSubscription) {
                        this._chipFocusSubscription.unsubscribe();
                        this._chipFocusSubscription = null;
                    }
                    if (this._chipBlurSubscription) {
                        this._chipBlurSubscription.unsubscribe();
                        this._chipBlurSubscription = null;
                    }
                    if (this._chipSelectionSubscription) {
                        this._chipSelectionSubscription.unsubscribe();
                        this._chipSelectionSubscription = null;
                    }
                    if (this._chipRemoveSubscription) {
                        this._chipRemoveSubscription.unsubscribe();
                        this._chipRemoveSubscription = null;
                    }
                };
                /**
                 * Listens to user-generated selection events on each chip.
                 * @private
                 * @return {?}
                 */
                MatChipList.prototype._listenToChipsSelection = function () {
                    var _this_1 = this;
                    this._chipSelectionSubscription = this.chipSelectionChanges.subscribe(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) {
                        event.source.selected
                            ? _this_1._selectionModel.select(event.source)
                            : _this_1._selectionModel.deselect(event.source);
                        // For single selection chip list, make sure the deselected value is unselected.
                        if (!_this_1.multiple) {
                            _this_1.chips.forEach(( /**
                             * @param {?} chip
                             * @return {?}
                             */function (/**
                             * @param {?} chip
                             * @return {?}
                             */ chip) {
                                if (!_this_1._selectionModel.isSelected(chip) && chip.selected) {
                                    chip.deselect();
                                }
                            }));
                        }
                        if (event.isUserInput) {
                            _this_1._propagateChanges();
                        }
                    }));
                };
                /**
                 * Listens to user-generated selection events on each chip.
                 * @private
                 * @return {?}
                 */
                MatChipList.prototype._listenToChipsFocus = function () {
                    var _this_1 = this;
                    this._chipFocusSubscription = this.chipFocusChanges.subscribe(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) {
                        /** @type {?} */
                        var chipIndex = _this_1.chips.toArray().indexOf(event.chip);
                        if (_this_1._isValidIndex(chipIndex)) {
                            _this_1._keyManager.updateActiveItemIndex(chipIndex);
                        }
                        _this_1.stateChanges.next();
                    }));
                    this._chipBlurSubscription = this.chipBlurChanges.subscribe(( /**
                     * @return {?}
                     */function () {
                        _this_1._blur();
                        _this_1.stateChanges.next();
                    }));
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatChipList.prototype._listenToChipsRemoved = function () {
                    var _this_1 = this;
                    this._chipRemoveSubscription = this.chipRemoveChanges.subscribe(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) {
                        /** @type {?} */
                        var chip = event.chip;
                        /** @type {?} */
                        var chipIndex = _this_1.chips.toArray().indexOf(event.chip);
                        // In case the chip that will be removed is currently focused, we temporarily store
                        // the index in order to be able to determine an appropriate sibling chip that will
                        // receive focus.
                        if (_this_1._isValidIndex(chipIndex) && chip._hasFocus) {
                            _this_1._lastDestroyedChipIndex = chipIndex;
                        }
                    }));
                };
                /**
                 * Checks whether an event comes from inside a chip element.
                 * @private
                 * @param {?} event
                 * @return {?}
                 */
                MatChipList.prototype._originatesFromChip = function (event) {
                    /** @type {?} */
                    var currentElement = ( /** @type {?} */(event.target));
                    while (currentElement && currentElement !== this._elementRef.nativeElement) {
                        if (currentElement.classList.contains('mat-chip')) {
                            return true;
                        }
                        currentElement = currentElement.parentElement;
                    }
                    return false;
                };
                /**
                 * Checks whether any of the chips is focused.
                 * @private
                 * @return {?}
                 */
                MatChipList.prototype._hasFocusedChip = function () {
                    return this.chips.some(( /**
                     * @param {?} chip
                     * @return {?}
                     */function (/**
                     * @param {?} chip
                     * @return {?}
                     */ chip) { return chip._hasFocus; }));
                };
                /**
                 * Syncs the list's state with the individual chips.
                 * @private
                 * @return {?}
                 */
                MatChipList.prototype._syncChipsState = function () {
                    var _this_1 = this;
                    if (this.chips) {
                        this.chips.forEach(( /**
                         * @param {?} chip
                         * @return {?}
                         */function (/**
                         * @param {?} chip
                         * @return {?}
                         */ chip) {
                            chip.disabled = _this_1._disabled;
                            chip._chipListMultiple = _this_1.multiple;
                        }));
                    }
                };
                return MatChipList;
            }(_MatChipListMixinBase));
            MatChipList.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Component"], args: [{ selector: 'mat-chip-list',
                            template: "<div class=\"mat-chip-list-wrapper\"><ng-content></ng-content></div>",
                            exportAs: 'matChipList',
                            host: {
                                '[attr.tabindex]': 'disabled ? null : _tabIndex',
                                '[attr.aria-describedby]': '_ariaDescribedby || null',
                                '[attr.aria-required]': 'required.toString()',
                                '[attr.aria-disabled]': 'disabled.toString()',
                                '[attr.aria-invalid]': 'errorState',
                                '[attr.aria-multiselectable]': 'multiple',
                                '[attr.role]': 'role',
                                '[class.mat-chip-list-disabled]': 'disabled',
                                '[class.mat-chip-list-invalid]': 'errorState',
                                '[class.mat-chip-list-required]': 'required',
                                '[attr.aria-orientation]': 'ariaOrientation',
                                'class': 'mat-chip-list',
                                '(focus)': 'focus()',
                                '(blur)': '_blur()',
                                '(keydown)': '_keydown($event)',
                                '[id]': '_uid',
                            },
                            providers: [{ provide: _angular_material_form_field__WEBPACK_IMPORTED_MODULE_12__["MatFormFieldControl"], useExisting: MatChipList }],
                            styles: [".mat-chip{position:relative;overflow:hidden;box-sizing:border-box;-webkit-tap-highlight-color:transparent;transform:translateZ(0)}.mat-standard-chip{transition:box-shadow 280ms cubic-bezier(.4,0,.2,1);display:inline-flex;padding:7px 12px;border-radius:16px;align-items:center;cursor:default;min-height:32px;height:1px}._mat-animation-noopable.mat-standard-chip{transition:none;animation:none}.mat-standard-chip .mat-chip-remove.mat-icon{width:18px;height:18px}.mat-standard-chip::after{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:inherit;opacity:0;content:'';pointer-events:none;transition:opacity .2s cubic-bezier(.35,0,.25,1)}.mat-standard-chip:hover::after{opacity:.12}.mat-standard-chip:focus{outline:0}.mat-standard-chip:focus::after{opacity:.16}@media (-ms-high-contrast:active){.mat-standard-chip{outline:solid 1px}.mat-standard-chip:focus{outline:dotted 2px}}.mat-standard-chip.mat-chip-disabled::after{opacity:0}.mat-standard-chip.mat-chip-disabled .mat-chip-remove,.mat-standard-chip.mat-chip-disabled .mat-chip-trailing-icon{cursor:default}.mat-standard-chip.mat-chip-with-avatar,.mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-top:0;padding-bottom:0}.mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-right:8px;padding-left:0}[dir=rtl] .mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-left:8px;padding-right:0}.mat-standard-chip.mat-chip-with-trailing-icon{padding-top:7px;padding-bottom:7px;padding-right:8px;padding-left:12px}[dir=rtl] .mat-standard-chip.mat-chip-with-trailing-icon{padding-left:8px;padding-right:12px}.mat-standard-chip.mat-chip-with-avatar{padding-left:0;padding-right:12px}[dir=rtl] .mat-standard-chip.mat-chip-with-avatar{padding-right:0;padding-left:12px}.mat-standard-chip .mat-chip-avatar{width:24px;height:24px;margin-right:8px;margin-left:4px}[dir=rtl] .mat-standard-chip .mat-chip-avatar{margin-left:8px;margin-right:4px}.mat-standard-chip .mat-chip-remove,.mat-standard-chip .mat-chip-trailing-icon{width:18px;height:18px;cursor:pointer}.mat-standard-chip .mat-chip-remove,.mat-standard-chip .mat-chip-trailing-icon{margin-left:8px;margin-right:0}[dir=rtl] .mat-standard-chip .mat-chip-remove,[dir=rtl] .mat-standard-chip .mat-chip-trailing-icon{margin-right:8px;margin-left:0}.mat-chip-list-wrapper{display:flex;flex-direction:row;flex-wrap:wrap;align-items:center;margin:-4px}.mat-chip-list-wrapper .mat-standard-chip,.mat-chip-list-wrapper input.mat-input-element{margin:4px}.mat-chip-list-stacked .mat-chip-list-wrapper{flex-direction:column;align-items:flex-start}.mat-chip-list-stacked .mat-chip-list-wrapper .mat-standard-chip{width:100%}.mat-chip-avatar{border-radius:50%;justify-content:center;align-items:center;display:flex;overflow:hidden;object-fit:cover}input.mat-chip-input{width:150px;margin:4px;flex:1 0 150px}"],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectionStrategy"].OnPush
                        },] },
            ];
            /** @nocollapse */
            MatChipList.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectorRef"] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_9__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }] },
                { type: _angular_forms__WEBPACK_IMPORTED_MODULE_11__["NgForm"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }] },
                { type: _angular_forms__WEBPACK_IMPORTED_MODULE_11__["FormGroupDirective"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }] },
                { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["ErrorStateMatcher"] },
                { type: _angular_forms__WEBPACK_IMPORTED_MODULE_11__["NgControl"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Self"] }] }
            ]; };
            MatChipList.propDecorators = {
                errorStateMatcher: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                multiple: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                compareWith: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                required: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                placeholder: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                ariaOrientation: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['aria-orientation',] }],
                selectable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                tabIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                change: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                valueChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                chips: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChildren"], args: [MatChip, {
                                // We need to use `descendants: true`, because Ivy will no longer match
                                // indirect descendants if it's left as false.
                                descendants: true
                            },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // Increasing integer for generating unique ids.
            /** @type {?} */
            var nextUniqueId$1 = 0;
            /**
             * Directive that adds chip-specific behaviors to an input element inside `<mat-form-field>`.
             * May be placed inside or outside of an `<mat-chip-list>`.
             */
            var MatChipInput = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 * @param {?} _defaultOptions
                 */
                function MatChipInput(_elementRef, _defaultOptions) {
                    this._elementRef = _elementRef;
                    this._defaultOptions = _defaultOptions;
                    /**
                     * Whether the control is focused.
                     */
                    this.focused = false;
                    this._addOnBlur = false;
                    /**
                     * The list of key codes that will trigger a chipEnd event.
                     *
                     * Defaults to `[ENTER]`.
                     */
                    this.separatorKeyCodes = this._defaultOptions.separatorKeyCodes;
                    /**
                     * Emitted when a chip is to be added.
                     */
                    this.chipEnd = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /**
                     * The input's placeholder text.
                     */
                    this.placeholder = '';
                    /**
                     * Unique id for the input.
                     */
                    this.id = "mat-chip-list-input-" + nextUniqueId$1++;
                    this._disabled = false;
                    this._inputElement = ( /** @type {?} */(this._elementRef.nativeElement));
                }
                Object.defineProperty(MatChipInput.prototype, "chipList", {
                    /**
                     * Register input for chip list
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (value) {
                            this._chipList = value;
                            this._chipList.registerInput(this);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipInput.prototype, "addOnBlur", {
                    /**
                     * Whether or not the chipEnd event will be emitted when the input is blurred.
                     * @return {?}
                     */
                    get: function () { return this._addOnBlur; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._addOnBlur = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipInput.prototype, "disabled", {
                    /**
                     * Whether the input is disabled.
                     * @return {?}
                     */
                    get: function () { return this._disabled || (this._chipList && this._chipList.disabled); },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipInput.prototype, "empty", {
                    /**
                     * Whether the input is empty.
                     * @return {?}
                     */
                    get: function () { return !this._inputElement.value; },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatChipInput.prototype.ngOnChanges = function () {
                    this._chipList.stateChanges.next();
                };
                /**
                 * Utility method to make host definition/tests more clear.
                 * @param {?=} event
                 * @return {?}
                 */
                MatChipInput.prototype._keydown = function (event) {
                    // Allow the user's focus to escape when they're tabbing forward. Note that we don't
                    // want to do this when going backwards, because focus should go back to the first chip.
                    if (event && event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["TAB"] && !Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["hasModifierKey"])(event, 'shiftKey')) {
                        this._chipList._allowFocusEscape();
                    }
                    this._emitChipEnd(event);
                };
                /**
                 * Checks to see if the blur should emit the (chipEnd) event.
                 * @return {?}
                 */
                MatChipInput.prototype._blur = function () {
                    if (this.addOnBlur) {
                        this._emitChipEnd();
                    }
                    this.focused = false;
                    // Blur the chip list if it is not focused
                    if (!this._chipList.focused) {
                        this._chipList._blur();
                    }
                    this._chipList.stateChanges.next();
                };
                /**
                 * @return {?}
                 */
                MatChipInput.prototype._focus = function () {
                    this.focused = true;
                    this._chipList.stateChanges.next();
                };
                /**
                 * Checks to see if the (chipEnd) event needs to be emitted.
                 * @param {?=} event
                 * @return {?}
                 */
                MatChipInput.prototype._emitChipEnd = function (event) {
                    if (!this._inputElement.value && !!event) {
                        this._chipList._keydown(event);
                    }
                    if (!event || this._isSeparatorKey(event)) {
                        this.chipEnd.emit({ input: this._inputElement, value: this._inputElement.value });
                        if (event) {
                            event.preventDefault();
                        }
                    }
                };
                /**
                 * @return {?}
                 */
                MatChipInput.prototype._onInput = function () {
                    // Let chip list know whenever the value changes.
                    this._chipList.stateChanges.next();
                };
                /**
                 * Focuses the input.
                 * @param {?=} options
                 * @return {?}
                 */
                MatChipInput.prototype.focus = function (options) {
                    this._inputElement.focus(options);
                };
                /**
                 * Checks whether a keycode is one of the configured separators.
                 * @private
                 * @param {?} event
                 * @return {?}
                 */
                MatChipInput.prototype._isSeparatorKey = function (event) {
                    if (Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["hasModifierKey"])(event)) {
                        return false;
                    }
                    /** @type {?} */
                    var separators = this.separatorKeyCodes;
                    /** @type {?} */
                    var keyCode = event.keyCode;
                    return Array.isArray(separators) ? separators.indexOf(keyCode) > -1 : separators.has(keyCode);
                };
                return MatChipInput;
            }());
            MatChipInput.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: 'input[matChipInputFor]',
                            exportAs: 'matChipInput, matChipInputFor',
                            host: {
                                'class': 'mat-chip-input mat-input-element',
                                '(keydown)': '_keydown($event)',
                                '(blur)': '_blur()',
                                '(focus)': '_focus()',
                                '(input)': '_onInput()',
                                '[id]': 'id',
                                '[attr.disabled]': 'disabled || null',
                                '[attr.placeholder]': 'placeholder || null',
                                '[attr.aria-invalid]': '_chipList && _chipList.ngControl ? _chipList.ngControl.invalid : null',
                            }
                        },] },
            ];
            /** @nocollapse */
            MatChipInput.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [MAT_CHIPS_DEFAULT_OPTIONS,] }] }
            ]; };
            MatChipInput.propDecorators = {
                chipList: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['matChipInputFor',] }],
                addOnBlur: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['matChipInputAddOnBlur',] }],
                separatorKeyCodes: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['matChipInputSeparatorKeyCodes',] }],
                chipEnd: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"], args: ['matChipInputTokenEnd',] }],
                placeholder: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var CHIP_DECLARATIONS = [
                MatChipList,
                MatChip,
                MatChipInput,
                MatChipRemove,
                MatChipAvatar,
                MatChipTrailingIcon,
            ];
            var ɵ0 = ({
                separatorKeyCodes: [_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["ENTER"]]
            });
            var MatChipsModule = /** @class */ (function () {
                function MatChipsModule() {
                }
                return MatChipsModule;
            }());
            MatChipsModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["NgModule"], args: [{
                            exports: CHIP_DECLARATIONS,
                            declarations: CHIP_DECLARATIONS,
                            providers: [
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["ErrorStateMatcher"],
                                {
                                    provide: MAT_CHIPS_DEFAULT_OPTIONS,
                                    useValue: ( /** @type {?} */(ɵ0))
                                }
                            ]
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=chips.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/datepicker.js": 
        /*!**************************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/datepicker.js ***!
          \**************************************************************/
        /*! exports provided: MatMultiYearView, yearsPerPage, yearsPerRow, MatDatepickerModule, MatCalendarHeader, MatCalendar, MatCalendarCell, MatCalendarBody, MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY, MAT_DATEPICKER_SCROLL_STRATEGY, MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER, MatDatepickerContent, MatDatepicker, matDatepickerAnimations, MAT_DATEPICKER_VALUE_ACCESSOR, MAT_DATEPICKER_VALIDATORS, MatDatepickerInputEvent, MatDatepickerInput, MatDatepickerIntl, MatDatepickerToggleIcon, MatDatepickerToggle, MatMonthView, MatYearView */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatMultiYearView", function () { return MatMultiYearView; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "yearsPerPage", function () { return yearsPerPage; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "yearsPerRow", function () { return yearsPerRow; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerModule", function () { return MatDatepickerModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCalendarHeader", function () { return MatCalendarHeader; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCalendar", function () { return MatCalendar; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCalendarCell", function () { return MatCalendarCell; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCalendarBody", function () { return MatCalendarBody; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY", function () { return MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_DATEPICKER_SCROLL_STRATEGY", function () { return MAT_DATEPICKER_SCROLL_STRATEGY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER", function () { return MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerContent", function () { return MatDatepickerContent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDatepicker", function () { return MatDatepicker; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matDatepickerAnimations", function () { return matDatepickerAnimations; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_DATEPICKER_VALUE_ACCESSOR", function () { return MAT_DATEPICKER_VALUE_ACCESSOR; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_DATEPICKER_VALIDATORS", function () { return MAT_DATEPICKER_VALIDATORS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerInputEvent", function () { return MatDatepickerInputEvent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerInput", function () { return MatDatepickerInput; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerIntl", function () { return MatDatepickerIntl; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerToggleIcon", function () { return MatDatepickerToggleIcon; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerToggle", function () { return MatDatepickerToggle; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatMonthView", function () { return MatMonthView; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatYearView", function () { return MatYearView; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/portal */ "./node_modules/@angular/cdk/esm2015/portal.js");
            /* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/animations */ "./node_modules/@angular/animations/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/cdk/overlay */ "./node_modules/@angular/cdk/esm2015/overlay.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_material_dialog__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/material/dialog */ "./node_modules/@angular/material/esm2015/dialog.js");
            /* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
            /* harmony import */ var _angular_material_form_field__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @angular/material/form-field */ "./node_modules/@angular/material/esm2015/form-field.js");
            /* harmony import */ var _angular_material_input__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @angular/material/input */ "./node_modules/@angular/material/esm2015/input.js");
            /* harmony import */ var _angular_material_button__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @angular/material/button */ "./node_modules/@angular/material/esm2015/button.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * \@docs-private
             * @param {?} provider
             * @return {?}
             */
            function createMissingDateImplError(provider) {
                return Error("MatDatepicker: No provider found for " + provider + ". You must import one of the following " +
                    "modules at your application root: MatNativeDateModule, MatMomentDateModule, or provide a " +
                    "custom implementation.");
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Datepicker data that requires internationalization.
             */
            var MatDatepickerIntl = /** @class */ (function () {
                function MatDatepickerIntl() {
                    /**
                     * Stream that emits whenever the labels here are changed. Use this to notify
                     * components if the labels have changed after initialization.
                     */
                    this.changes = new rxjs__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
                    /**
                     * A label for the calendar popup (used by screen readers).
                     */
                    this.calendarLabel = 'Calendar';
                    /**
                     * A label for the button used to open the calendar popup (used by screen readers).
                     */
                    this.openCalendarLabel = 'Open calendar';
                    /**
                     * A label for the previous month button (used by screen readers).
                     */
                    this.prevMonthLabel = 'Previous month';
                    /**
                     * A label for the next month button (used by screen readers).
                     */
                    this.nextMonthLabel = 'Next month';
                    /**
                     * A label for the previous year button (used by screen readers).
                     */
                    this.prevYearLabel = 'Previous year';
                    /**
                     * A label for the next year button (used by screen readers).
                     */
                    this.nextYearLabel = 'Next year';
                    /**
                     * A label for the previous multi-year button (used by screen readers).
                     */
                    this.prevMultiYearLabel = 'Previous 20 years';
                    /**
                     * A label for the next multi-year button (used by screen readers).
                     */
                    this.nextMultiYearLabel = 'Next 20 years';
                    /**
                     * A label for the 'switch to month view' button (used by screen readers).
                     */
                    this.switchToMonthViewLabel = 'Choose date';
                    /**
                     * A label for the 'switch to year view' button (used by screen readers).
                     */
                    this.switchToMultiYearViewLabel = 'Choose month and year';
                }
                /**
                 * Formats a range of years.
                 * @param {?} start
                 * @param {?} end
                 * @return {?}
                 */
                MatDatepickerIntl.prototype.formatYearRange = function (start, end) {
                    return start + " \u2013 " + end;
                };
                return MatDatepickerIntl;
            }());
            MatDatepickerIntl.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */ MatDatepickerIntl.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function MatDatepickerIntl_Factory() { return new MatDatepickerIntl(); }, token: MatDatepickerIntl, providedIn: "root" });
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * An internal class that represents the data corresponding to a single calendar cell.
             * \@docs-private
             */
            var MatCalendarCell = /** @class */ (function () {
                /**
                 * @param {?} value
                 * @param {?} displayValue
                 * @param {?} ariaLabel
                 * @param {?} enabled
                 * @param {?=} cssClasses
                 */
                function MatCalendarCell(value, displayValue, ariaLabel, enabled, cssClasses) {
                    this.value = value;
                    this.displayValue = displayValue;
                    this.ariaLabel = ariaLabel;
                    this.enabled = enabled;
                    this.cssClasses = cssClasses;
                }
                return MatCalendarCell;
            }());
            /**
             * An internal component used to display calendar data in a table.
             * \@docs-private
             */
            var MatCalendarBody = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 * @param {?} _ngZone
                 */
                function MatCalendarBody(_elementRef, _ngZone) {
                    this._elementRef = _elementRef;
                    this._ngZone = _ngZone;
                    /**
                     * The number of columns in the table.
                     */
                    this.numCols = 7;
                    /**
                     * The cell number of the active cell in the table.
                     */
                    this.activeCell = 0;
                    /**
                     * The aspect ratio (width / height) to use for the cells in the table. This aspect ratio will be
                     * maintained even as the table resizes.
                     */
                    this.cellAspectRatio = 1;
                    /**
                     * Emits when a new value is selected.
                     */
                    this.selectedValueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                }
                /**
                 * @param {?} cell
                 * @return {?}
                 */
                MatCalendarBody.prototype._cellClicked = function (cell) {
                    if (cell.enabled) {
                        this.selectedValueChange.emit(cell.value);
                    }
                };
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                MatCalendarBody.prototype.ngOnChanges = function (changes) {
                    /** @type {?} */
                    var columnChanges = changes['numCols'];
                    var _a = this, rows = _a.rows, numCols = _a.numCols;
                    if (changes['rows'] || columnChanges) {
                        this._firstRowOffset = rows && rows.length && rows[0].length ? numCols - rows[0].length : 0;
                    }
                    if (changes['cellAspectRatio'] || columnChanges || !this._cellPadding) {
                        this._cellPadding = 50 * this.cellAspectRatio / numCols + "%";
                    }
                    if (columnChanges || !this._cellWidth) {
                        this._cellWidth = 100 / numCols + "%";
                    }
                };
                /**
                 * @param {?} rowIndex
                 * @param {?} colIndex
                 * @return {?}
                 */
                MatCalendarBody.prototype._isActiveCell = function (rowIndex, colIndex) {
                    /** @type {?} */
                    var cellNumber = rowIndex * this.numCols + colIndex;
                    // Account for the fact that the first row may not have as many cells.
                    if (rowIndex) {
                        cellNumber -= this._firstRowOffset;
                    }
                    return cellNumber == this.activeCell;
                };
                /**
                 * Focuses the active cell after the microtask queue is empty.
                 * @return {?}
                 */
                MatCalendarBody.prototype._focusActiveCell = function () {
                    var _this_1 = this;
                    this._ngZone.runOutsideAngular(( /**
                     * @return {?}
                     */function () {
                        _this_1._ngZone.onStable.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["take"])(1)).subscribe(( /**
                         * @return {?}
                         */function () {
                            /** @type {?} */
                            var activeCell = _this_1._elementRef.nativeElement.querySelector('.mat-calendar-body-active');
                            if (activeCell) {
                                activeCell.focus();
                            }
                        }));
                    }));
                };
                return MatCalendarBody;
            }());
            MatCalendarBody.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: '[mat-calendar-body]',
                            template: "<tr *ngIf=\"_firstRowOffset < labelMinRequiredCells\" aria-hidden=\"true\"><td class=\"mat-calendar-body-label\" [attr.colspan]=\"numCols\" [style.paddingTop]=\"_cellPadding\" [style.paddingBottom]=\"_cellPadding\">{{label}}</td></tr><tr *ngFor=\"let row of rows; let rowIndex = index\" role=\"row\"><td *ngIf=\"rowIndex === 0 && _firstRowOffset\" aria-hidden=\"true\" class=\"mat-calendar-body-label\" [attr.colspan]=\"_firstRowOffset\" [style.paddingTop]=\"_cellPadding\" [style.paddingBottom]=\"_cellPadding\">{{_firstRowOffset >= labelMinRequiredCells ? label : ''}}</td><td *ngFor=\"let item of row; let colIndex = index\" role=\"gridcell\" class=\"mat-calendar-body-cell\" [ngClass]=\"item.cssClasses\" [tabindex]=\"_isActiveCell(rowIndex, colIndex) ? 0 : -1\" [class.mat-calendar-body-disabled]=\"!item.enabled\" [class.mat-calendar-body-active]=\"_isActiveCell(rowIndex, colIndex)\" [attr.aria-label]=\"item.ariaLabel\" [attr.aria-disabled]=\"!item.enabled || null\" [attr.aria-selected]=\"selectedValue === item.value\" (click)=\"_cellClicked(item)\" [style.width]=\"_cellWidth\" [style.paddingTop]=\"_cellPadding\" role=\"button\" [style.paddingBottom]=\"_cellPadding\"><div class=\"mat-calendar-body-cell-content\" [class.mat-calendar-body-selected]=\"selectedValue === item.value\" [class.mat-calendar-body-today]=\"todayValue === item.value\">{{item.displayValue}}</div></td></tr>",
                            styles: [".mat-calendar-body{min-width:224px}.mat-calendar-body-label{height:0;line-height:0;text-align:left;padding-left:4.71429%;padding-right:4.71429%}.mat-calendar-body-cell{position:relative;height:0;line-height:0;text-align:center;outline:0;cursor:pointer}.mat-calendar-body-disabled{cursor:default}.mat-calendar-body-cell-content{position:absolute;top:5%;left:5%;display:flex;align-items:center;justify-content:center;box-sizing:border-box;width:90%;height:90%;line-height:1;border-width:1px;border-style:solid;border-radius:999px}@media (-ms-high-contrast:active){.mat-calendar-body-cell-content{border:none}}@media (-ms-high-contrast:active){.mat-calendar-body-selected,.mat-datepicker-popup:not(:empty){outline:solid 1px}.mat-calendar-body-today{outline:dotted 1px}.cdk-keyboard-focused .mat-calendar-body-active>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected),.cdk-program-focused .mat-calendar-body-active>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected){outline:dotted 2px}}[dir=rtl] .mat-calendar-body-label{text-align:right}"],
                            host: {
                                'class': 'mat-calendar-body',
                                'role': 'grid',
                                'aria-readonly': 'true'
                            },
                            exportAs: 'matCalendarBody',
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatCalendarBody.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] }
            ]; };
            MatCalendarBody.propDecorators = {
                label: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                rows: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                todayValue: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selectedValue: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                labelMinRequiredCells: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                numCols: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                activeCell: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                cellAspectRatio: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selectedValueChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var DAYS_PER_WEEK = 7;
            /**
             * An internal component used to display a single month in the datepicker.
             * \@docs-private
             * @template D
             */
            var MatMonthView = /** @class */ (function () {
                /**
                 * @param {?} _changeDetectorRef
                 * @param {?} _dateFormats
                 * @param {?} _dateAdapter
                 * @param {?=} _dir
                 */
                function MatMonthView(_changeDetectorRef, _dateFormats, _dateAdapter, _dir) {
                    this._changeDetectorRef = _changeDetectorRef;
                    this._dateFormats = _dateFormats;
                    this._dateAdapter = _dateAdapter;
                    this._dir = _dir;
                    /**
                     * Emits when a new date is selected.
                     */
                    this.selectedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits when any date is selected.
                     */
                    this._userSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits when any date is activated.
                     */
                    this.activeDateChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    if (!this._dateAdapter) {
                        throw createMissingDateImplError('DateAdapter');
                    }
                    if (!this._dateFormats) {
                        throw createMissingDateImplError('MAT_DATE_FORMATS');
                    }
                    this._activeDate = this._dateAdapter.today();
                }
                Object.defineProperty(MatMonthView.prototype, "activeDate", {
                    /**
                     * The date to display in this month view (everything other than the month and year is ignored).
                     * @return {?}
                     */
                    get: function () { return this._activeDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var oldActiveDate = this._activeDate;
                        /** @type {?} */
                        var validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();
                        this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);
                        if (!this._hasSameMonthAndYear(oldActiveDate, this._activeDate)) {
                            this._init();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatMonthView.prototype, "selected", {
                    /**
                     * The currently selected date.
                     * @return {?}
                     */
                    get: function () { return this._selected; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                        this._selectedDate = this._getDateInCurrentMonth(this._selected);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatMonthView.prototype, "minDate", {
                    /**
                     * The minimum selectable date.
                     * @return {?}
                     */
                    get: function () { return this._minDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatMonthView.prototype, "maxDate", {
                    /**
                     * The maximum selectable date.
                     * @return {?}
                     */
                    get: function () { return this._maxDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatMonthView.prototype.ngAfterContentInit = function () {
                    this._init();
                };
                /**
                 * Handles when a new date is selected.
                 * @param {?} date
                 * @return {?}
                 */
                MatMonthView.prototype._dateSelected = function (date) {
                    if (this._selectedDate != date) {
                        /** @type {?} */
                        var selectedYear = this._dateAdapter.getYear(this.activeDate);
                        /** @type {?} */
                        var selectedMonth = this._dateAdapter.getMonth(this.activeDate);
                        /** @type {?} */
                        var selectedDate = this._dateAdapter.createDate(selectedYear, selectedMonth, date);
                        this.selectedChange.emit(selectedDate);
                    }
                    this._userSelection.emit();
                };
                /**
                 * Handles keydown events on the calendar body when calendar is in month view.
                 * @param {?} event
                 * @return {?}
                 */
                MatMonthView.prototype._handleCalendarBodyKeydown = function (event) {
                    // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent
                    // disabled ones from being selected. This may not be ideal, we should look into whether
                    // navigation should skip over disabled dates, and if so, how to implement that efficiently.
                    // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent
                    // disabled ones from being selected. This may not be ideal, we should look into whether
                    // navigation should skip over disabled dates, and if so, how to implement that efficiently.
                    /** @type {?} */
                    var oldActiveDate = this._activeDate;
                    /** @type {?} */
                    var isRtl = this._isRtl();
                    switch (event.keyCode) {
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["LEFT_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, isRtl ? 1 : -1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["RIGHT_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, isRtl ? -1 : 1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["UP_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, -7);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["DOWN_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 7);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["HOME"]:
                            this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 1 - this._dateAdapter.getDate(this._activeDate));
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["END"]:
                            this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, (this._dateAdapter.getNumDaysInMonth(this._activeDate) -
                                this._dateAdapter.getDate(this._activeDate)));
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["PAGE_UP"]:
                            this.activeDate = event.altKey ?
                                this._dateAdapter.addCalendarYears(this._activeDate, -1) :
                                this._dateAdapter.addCalendarMonths(this._activeDate, -1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["PAGE_DOWN"]:
                            this.activeDate = event.altKey ?
                                this._dateAdapter.addCalendarYears(this._activeDate, 1) :
                                this._dateAdapter.addCalendarMonths(this._activeDate, 1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["ENTER"]:
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["SPACE"]:
                            if (!this.dateFilter || this.dateFilter(this._activeDate)) {
                                this._dateSelected(this._dateAdapter.getDate(this._activeDate));
                                this._userSelection.emit();
                                // Prevent unexpected default actions such as form submission.
                                event.preventDefault();
                            }
                            return;
                        default:
                            // Don't prevent default or focus active cell on keys that we don't explicitly handle.
                            return;
                    }
                    if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {
                        this.activeDateChange.emit(this.activeDate);
                    }
                    this._focusActiveCell();
                    // Prevent unexpected default actions such as form submission.
                    event.preventDefault();
                };
                /**
                 * Initializes this month view.
                 * @return {?}
                 */
                MatMonthView.prototype._init = function () {
                    this._selectedDate = this._getDateInCurrentMonth(this.selected);
                    this._todayDate = this._getDateInCurrentMonth(this._dateAdapter.today());
                    this._monthLabel =
                        this._dateAdapter.getMonthNames('short')[this._dateAdapter.getMonth(this.activeDate)]
                            .toLocaleUpperCase();
                    /** @type {?} */
                    var firstOfMonth = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), 1);
                    this._firstWeekOffset =
                        (DAYS_PER_WEEK + this._dateAdapter.getDayOfWeek(firstOfMonth) -
                            this._dateAdapter.getFirstDayOfWeek()) % DAYS_PER_WEEK;
                    this._initWeekdays();
                    this._createWeekCells();
                    this._changeDetectorRef.markForCheck();
                };
                /**
                 * Focuses the active cell after the microtask queue is empty.
                 * @return {?}
                 */
                MatMonthView.prototype._focusActiveCell = function () {
                    this._matCalendarBody._focusActiveCell();
                };
                /**
                 * Initializes the weekdays.
                 * @private
                 * @return {?}
                 */
                MatMonthView.prototype._initWeekdays = function () {
                    /** @type {?} */
                    var firstDayOfWeek = this._dateAdapter.getFirstDayOfWeek();
                    /** @type {?} */
                    var narrowWeekdays = this._dateAdapter.getDayOfWeekNames('narrow');
                    /** @type {?} */
                    var longWeekdays = this._dateAdapter.getDayOfWeekNames('long');
                    // Rotate the labels for days of the week based on the configured first day of the week.
                    /** @type {?} */
                    var weekdays = longWeekdays.map(( /**
                     * @param {?} long
                     * @param {?} i
                     * @return {?}
                     */function (long, i) {
                        return { long: long, narrow: narrowWeekdays[i] };
                    }));
                    this._weekdays = weekdays.slice(firstDayOfWeek).concat(weekdays.slice(0, firstDayOfWeek));
                };
                /**
                 * Creates MatCalendarCells for the dates in this month.
                 * @private
                 * @return {?}
                 */
                MatMonthView.prototype._createWeekCells = function () {
                    /** @type {?} */
                    var daysInMonth = this._dateAdapter.getNumDaysInMonth(this.activeDate);
                    /** @type {?} */
                    var dateNames = this._dateAdapter.getDateNames();
                    this._weeks = [[]];
                    for (var i = 0, cell = this._firstWeekOffset; i < daysInMonth; i++, cell++) {
                        if (cell == DAYS_PER_WEEK) {
                            this._weeks.push([]);
                            cell = 0;
                        }
                        /** @type {?} */
                        var date = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), i + 1);
                        /** @type {?} */
                        var enabled = this._shouldEnableDate(date);
                        /** @type {?} */
                        var ariaLabel = this._dateAdapter.format(date, this._dateFormats.display.dateA11yLabel);
                        /** @type {?} */
                        var cellClasses = this.dateClass ? this.dateClass(date) : undefined;
                        this._weeks[this._weeks.length - 1]
                            .push(new MatCalendarCell(i + 1, dateNames[i], ariaLabel, enabled, cellClasses));
                    }
                };
                /**
                 * Date filter for the month
                 * @private
                 * @param {?} date
                 * @return {?}
                 */
                MatMonthView.prototype._shouldEnableDate = function (date) {
                    return !!date &&
                        (!this.dateFilter || this.dateFilter(date)) &&
                        (!this.minDate || this._dateAdapter.compareDate(date, this.minDate) >= 0) &&
                        (!this.maxDate || this._dateAdapter.compareDate(date, this.maxDate) <= 0);
                };
                /**
                 * Gets the date in this month that the given Date falls on.
                 * Returns null if the given Date is in another month.
                 * @private
                 * @param {?} date
                 * @return {?}
                 */
                MatMonthView.prototype._getDateInCurrentMonth = function (date) {
                    return date && this._hasSameMonthAndYear(date, this.activeDate) ?
                        this._dateAdapter.getDate(date) : null;
                };
                /**
                 * Checks whether the 2 dates are non-null and fall within the same month of the same year.
                 * @private
                 * @param {?} d1
                 * @param {?} d2
                 * @return {?}
                 */
                MatMonthView.prototype._hasSameMonthAndYear = function (d1, d2) {
                    return !!(d1 && d2 && this._dateAdapter.getMonth(d1) == this._dateAdapter.getMonth(d2) &&
                        this._dateAdapter.getYear(d1) == this._dateAdapter.getYear(d2));
                };
                /**
                 * @private
                 * @param {?} obj The object to check.
                 * @return {?} The given object if it is both a date instance and valid, otherwise null.
                 */
                MatMonthView.prototype._getValidDateOrNull = function (obj) {
                    return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
                };
                /**
                 * Determines whether the user has the RTL layout direction.
                 * @private
                 * @return {?}
                 */
                MatMonthView.prototype._isRtl = function () {
                    return this._dir && this._dir.value === 'rtl';
                };
                return MatMonthView;
            }());
            MatMonthView.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-month-view',
                            template: "<table class=\"mat-calendar-table\" role=\"presentation\"><thead class=\"mat-calendar-table-header\"><tr><th scope=\"col\" *ngFor=\"let day of _weekdays\" [attr.aria-label]=\"day.long\">{{day.narrow}}</th></tr><tr><th class=\"mat-calendar-table-header-divider\" colspan=\"7\" aria-hidden=\"true\"></th></tr></thead><tbody mat-calendar-body [label]=\"_monthLabel\" [rows]=\"_weeks\" [todayValue]=\"_todayDate\" [selectedValue]=\"_selectedDate\" [labelMinRequiredCells]=\"3\" [activeCell]=\"_dateAdapter.getDate(activeDate) - 1\" (selectedValueChange)=\"_dateSelected($event)\" (keydown)=\"_handleCalendarBodyKeydown($event)\"></tbody></table>",
                            exportAs: 'matMonthView',
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush
                        },] },
            ];
            /** @nocollapse */
            MatMonthView.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MAT_DATE_FORMATS"],] }] },
                { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["DateAdapter"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] }
            ]; };
            MatMonthView.propDecorators = {
                activeDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                minDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                maxDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                dateFilter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                dateClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selectedChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                _userSelection: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                activeDateChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                _matCalendarBody: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [MatCalendarBody, { static: false },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var yearsPerPage = 24;
            /** @type {?} */
            var yearsPerRow = 4;
            /**
             * An internal component used to display a year selector in the datepicker.
             * \@docs-private
             * @template D
             */
            var MatMultiYearView = /** @class */ (function () {
                /**
                 * @param {?} _changeDetectorRef
                 * @param {?} _dateAdapter
                 * @param {?=} _dir
                 */
                function MatMultiYearView(_changeDetectorRef, _dateAdapter, _dir) {
                    this._changeDetectorRef = _changeDetectorRef;
                    this._dateAdapter = _dateAdapter;
                    this._dir = _dir;
                    /**
                     * Emits when a new year is selected.
                     */
                    this.selectedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits the selected year. This doesn't imply a change on the selected date
                     */
                    this.yearSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits when any date is activated.
                     */
                    this.activeDateChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    if (!this._dateAdapter) {
                        throw createMissingDateImplError('DateAdapter');
                    }
                    this._activeDate = this._dateAdapter.today();
                }
                Object.defineProperty(MatMultiYearView.prototype, "activeDate", {
                    /**
                     * The date to display in this multi-year view (everything other than the year is ignored).
                     * @return {?}
                     */
                    get: function () { return this._activeDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var oldActiveDate = this._activeDate;
                        /** @type {?} */
                        var validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();
                        this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);
                        if (!isSameMultiYearView(this._dateAdapter, oldActiveDate, this._activeDate, this.minDate, this.maxDate)) {
                            this._init();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatMultiYearView.prototype, "selected", {
                    /**
                     * The currently selected date.
                     * @return {?}
                     */
                    get: function () { return this._selected; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                        this._selectedYear = this._selected && this._dateAdapter.getYear(this._selected);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatMultiYearView.prototype, "minDate", {
                    /**
                     * The minimum selectable date.
                     * @return {?}
                     */
                    get: function () { return this._minDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatMultiYearView.prototype, "maxDate", {
                    /**
                     * The maximum selectable date.
                     * @return {?}
                     */
                    get: function () { return this._maxDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatMultiYearView.prototype.ngAfterContentInit = function () {
                    this._init();
                };
                /**
                 * Initializes this multi-year view.
                 * @return {?}
                 */
                MatMultiYearView.prototype._init = function () {
                    var _this_1 = this;
                    this._todayYear = this._dateAdapter.getYear(this._dateAdapter.today());
                    // We want a range years such that we maximize the number of
                    // enabled dates visible at once. This prevents issues where the minimum year
                    // is the last item of a page OR the maximum year is the first item of a page.
                    // The offset from the active year to the "slot" for the starting year is the
                    // *actual* first rendered year in the multi-year view.
                    /** @type {?} */
                    var activeYear = this._dateAdapter.getYear(this._activeDate);
                    /** @type {?} */
                    var minYearOfPage = activeYear - getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate);
                    this._years = [];
                    for (var i = 0, row = []; i < yearsPerPage; i++) {
                        row.push(minYearOfPage + i);
                        if (row.length == yearsPerRow) {
                            this._years.push(row.map(( /**
                             * @param {?} year
                             * @return {?}
                             */function (/**
                             * @param {?} year
                             * @return {?}
                             */ year) { return _this_1._createCellForYear(year); })));
                            row = [];
                        }
                    }
                    this._changeDetectorRef.markForCheck();
                };
                /**
                 * Handles when a new year is selected.
                 * @param {?} year
                 * @return {?}
                 */
                MatMultiYearView.prototype._yearSelected = function (year) {
                    this.yearSelected.emit(this._dateAdapter.createDate(year, 0, 1));
                    /** @type {?} */
                    var month = this._dateAdapter.getMonth(this.activeDate);
                    /** @type {?} */
                    var daysInMonth = this._dateAdapter.getNumDaysInMonth(this._dateAdapter.createDate(year, month, 1));
                    this.selectedChange.emit(this._dateAdapter.createDate(year, month, Math.min(this._dateAdapter.getDate(this.activeDate), daysInMonth)));
                };
                /**
                 * Handles keydown events on the calendar body when calendar is in multi-year view.
                 * @param {?} event
                 * @return {?}
                 */
                MatMultiYearView.prototype._handleCalendarBodyKeydown = function (event) {
                    /** @type {?} */
                    var oldActiveDate = this._activeDate;
                    /** @type {?} */
                    var isRtl = this._isRtl();
                    switch (event.keyCode) {
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["LEFT_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, isRtl ? 1 : -1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["RIGHT_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, isRtl ? -1 : 1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["UP_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, -yearsPerRow);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["DOWN_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, yearsPerRow);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["HOME"]:
                            this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, -getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate));
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["END"]:
                            this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, yearsPerPage - getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate) - 1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["PAGE_UP"]:
                            this.activeDate =
                                this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? -yearsPerPage * 10 : -yearsPerPage);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["PAGE_DOWN"]:
                            this.activeDate =
                                this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? yearsPerPage * 10 : yearsPerPage);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["ENTER"]:
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["SPACE"]:
                            this._yearSelected(this._dateAdapter.getYear(this._activeDate));
                            break;
                        default:
                            // Don't prevent default or focus active cell on keys that we don't explicitly handle.
                            return;
                    }
                    if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {
                        this.activeDateChange.emit(this.activeDate);
                    }
                    this._focusActiveCell();
                    // Prevent unexpected default actions such as form submission.
                    event.preventDefault();
                };
                /**
                 * @return {?}
                 */
                MatMultiYearView.prototype._getActiveCell = function () {
                    return getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate);
                };
                /**
                 * Focuses the active cell after the microtask queue is empty.
                 * @return {?}
                 */
                MatMultiYearView.prototype._focusActiveCell = function () {
                    this._matCalendarBody._focusActiveCell();
                };
                /**
                 * Creates an MatCalendarCell for the given year.
                 * @private
                 * @param {?} year
                 * @return {?}
                 */
                MatMultiYearView.prototype._createCellForYear = function (year) {
                    /** @type {?} */
                    var yearName = this._dateAdapter.getYearName(this._dateAdapter.createDate(year, 0, 1));
                    return new MatCalendarCell(year, yearName, yearName, this._shouldEnableYear(year));
                };
                /**
                 * Whether the given year is enabled.
                 * @private
                 * @param {?} year
                 * @return {?}
                 */
                MatMultiYearView.prototype._shouldEnableYear = function (year) {
                    // disable if the year is greater than maxDate lower than minDate
                    if (year === undefined || year === null ||
                        (this.maxDate && year > this._dateAdapter.getYear(this.maxDate)) ||
                        (this.minDate && year < this._dateAdapter.getYear(this.minDate))) {
                        return false;
                    }
                    // enable if it reaches here and there's no filter defined
                    if (!this.dateFilter) {
                        return true;
                    }
                    /** @type {?} */
                    var firstOfYear = this._dateAdapter.createDate(year, 0, 1);
                    // If any date in the year is enabled count the year as enabled.
                    for (var date = firstOfYear; this._dateAdapter.getYear(date) == year; date = this._dateAdapter.addCalendarDays(date, 1)) {
                        if (this.dateFilter(date)) {
                            return true;
                        }
                    }
                    return false;
                };
                /**
                 * @private
                 * @param {?} obj The object to check.
                 * @return {?} The given object if it is both a date instance and valid, otherwise null.
                 */
                MatMultiYearView.prototype._getValidDateOrNull = function (obj) {
                    return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
                };
                /**
                 * Determines whether the user has the RTL layout direction.
                 * @private
                 * @return {?}
                 */
                MatMultiYearView.prototype._isRtl = function () {
                    return this._dir && this._dir.value === 'rtl';
                };
                return MatMultiYearView;
            }());
            MatMultiYearView.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-multi-year-view',
                            template: "<table class=\"mat-calendar-table\" role=\"presentation\"><thead class=\"mat-calendar-table-header\"><tr><th class=\"mat-calendar-table-header-divider\" colspan=\"4\"></th></tr></thead><tbody mat-calendar-body [rows]=\"_years\" [todayValue]=\"_todayYear\" [selectedValue]=\"_selectedYear\" [numCols]=\"4\" [cellAspectRatio]=\"4 / 7\" [activeCell]=\"_getActiveCell()\" (selectedValueChange)=\"_yearSelected($event)\" (keydown)=\"_handleCalendarBodyKeydown($event)\"></tbody></table>",
                            exportAs: 'matMultiYearView',
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush
                        },] },
            ];
            /** @nocollapse */
            MatMultiYearView.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["DateAdapter"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] }
            ]; };
            MatMultiYearView.propDecorators = {
                activeDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                minDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                maxDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                dateFilter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selectedChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                yearSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                activeDateChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                _matCalendarBody: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [MatCalendarBody, { static: false },] }]
            };
            /**
             * @template D
             * @param {?} dateAdapter
             * @param {?} date1
             * @param {?} date2
             * @param {?} minDate
             * @param {?} maxDate
             * @return {?}
             */
            function isSameMultiYearView(dateAdapter, date1, date2, minDate, maxDate) {
                /** @type {?} */
                var year1 = dateAdapter.getYear(date1);
                /** @type {?} */
                var year2 = dateAdapter.getYear(date2);
                /** @type {?} */
                var startingYear = getStartingYear(dateAdapter, minDate, maxDate);
                return Math.floor((year1 - startingYear) / yearsPerPage) ===
                    Math.floor((year2 - startingYear) / yearsPerPage);
            }
            /**
             * When the multi-year view is first opened, the active year will be in view.
             * So we compute how many years are between the active year and the *slot* where our
             * "startingYear" will render when paged into view.
             * @template D
             * @param {?} dateAdapter
             * @param {?} activeDate
             * @param {?} minDate
             * @param {?} maxDate
             * @return {?}
             */
            function getActiveOffset(dateAdapter, activeDate, minDate, maxDate) {
                /** @type {?} */
                var activeYear = dateAdapter.getYear(activeDate);
                return euclideanModulo((activeYear - getStartingYear(dateAdapter, minDate, maxDate)), yearsPerPage);
            }
            /**
             * We pick a "starting" year such that either the maximum year would be at the end
             * or the minimum year would be at the beginning of a page.
             * @template D
             * @param {?} dateAdapter
             * @param {?} minDate
             * @param {?} maxDate
             * @return {?}
             */
            function getStartingYear(dateAdapter, minDate, maxDate) {
                /** @type {?} */
                var startingYear = 0;
                if (maxDate) {
                    /** @type {?} */
                    var maxYear = dateAdapter.getYear(maxDate);
                    startingYear = maxYear - yearsPerPage + 1;
                }
                else if (minDate) {
                    startingYear = dateAdapter.getYear(minDate);
                }
                return startingYear;
            }
            /**
             * Gets remainder that is non-negative, even if first number is negative
             * @param {?} a
             * @param {?} b
             * @return {?}
             */
            function euclideanModulo(a, b) {
                return (a % b + b) % b;
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * An internal component used to display a single year in the datepicker.
             * \@docs-private
             * @template D
             */
            var MatYearView = /** @class */ (function () {
                /**
                 * @param {?} _changeDetectorRef
                 * @param {?} _dateFormats
                 * @param {?} _dateAdapter
                 * @param {?=} _dir
                 */
                function MatYearView(_changeDetectorRef, _dateFormats, _dateAdapter, _dir) {
                    this._changeDetectorRef = _changeDetectorRef;
                    this._dateFormats = _dateFormats;
                    this._dateAdapter = _dateAdapter;
                    this._dir = _dir;
                    /**
                     * Emits when a new month is selected.
                     */
                    this.selectedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits the selected month. This doesn't imply a change on the selected date
                     */
                    this.monthSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits when any date is activated.
                     */
                    this.activeDateChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    if (!this._dateAdapter) {
                        throw createMissingDateImplError('DateAdapter');
                    }
                    if (!this._dateFormats) {
                        throw createMissingDateImplError('MAT_DATE_FORMATS');
                    }
                    this._activeDate = this._dateAdapter.today();
                }
                Object.defineProperty(MatYearView.prototype, "activeDate", {
                    /**
                     * The date to display in this year view (everything other than the year is ignored).
                     * @return {?}
                     */
                    get: function () { return this._activeDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var oldActiveDate = this._activeDate;
                        /** @type {?} */
                        var validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();
                        this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);
                        if (this._dateAdapter.getYear(oldActiveDate) !== this._dateAdapter.getYear(this._activeDate)) {
                            this._init();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatYearView.prototype, "selected", {
                    /**
                     * The currently selected date.
                     * @return {?}
                     */
                    get: function () { return this._selected; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                        this._selectedMonth = this._getMonthInCurrentYear(this._selected);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatYearView.prototype, "minDate", {
                    /**
                     * The minimum selectable date.
                     * @return {?}
                     */
                    get: function () { return this._minDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatYearView.prototype, "maxDate", {
                    /**
                     * The maximum selectable date.
                     * @return {?}
                     */
                    get: function () { return this._maxDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatYearView.prototype.ngAfterContentInit = function () {
                    this._init();
                };
                /**
                 * Handles when a new month is selected.
                 * @param {?} month
                 * @return {?}
                 */
                MatYearView.prototype._monthSelected = function (month) {
                    /** @type {?} */
                    var normalizedDate = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, 1);
                    this.monthSelected.emit(normalizedDate);
                    /** @type {?} */
                    var daysInMonth = this._dateAdapter.getNumDaysInMonth(normalizedDate);
                    this.selectedChange.emit(this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, Math.min(this._dateAdapter.getDate(this.activeDate), daysInMonth)));
                };
                /**
                 * Handles keydown events on the calendar body when calendar is in year view.
                 * @param {?} event
                 * @return {?}
                 */
                MatYearView.prototype._handleCalendarBodyKeydown = function (event) {
                    // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent
                    // disabled ones from being selected. This may not be ideal, we should look into whether
                    // navigation should skip over disabled dates, and if so, how to implement that efficiently.
                    // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent
                    // disabled ones from being selected. This may not be ideal, we should look into whether
                    // navigation should skip over disabled dates, and if so, how to implement that efficiently.
                    /** @type {?} */
                    var oldActiveDate = this._activeDate;
                    /** @type {?} */
                    var isRtl = this._isRtl();
                    switch (event.keyCode) {
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["LEFT_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, isRtl ? 1 : -1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["RIGHT_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, isRtl ? -1 : 1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["UP_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -4);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["DOWN_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 4);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["HOME"]:
                            this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -this._dateAdapter.getMonth(this._activeDate));
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["END"]:
                            this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 11 - this._dateAdapter.getMonth(this._activeDate));
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["PAGE_UP"]:
                            this.activeDate =
                                this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? -10 : -1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["PAGE_DOWN"]:
                            this.activeDate =
                                this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? 10 : 1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["ENTER"]:
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["SPACE"]:
                            this._monthSelected(this._dateAdapter.getMonth(this._activeDate));
                            break;
                        default:
                            // Don't prevent default or focus active cell on keys that we don't explicitly handle.
                            return;
                    }
                    if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {
                        this.activeDateChange.emit(this.activeDate);
                    }
                    this._focusActiveCell();
                    // Prevent unexpected default actions such as form submission.
                    event.preventDefault();
                };
                /**
                 * Initializes this year view.
                 * @return {?}
                 */
                MatYearView.prototype._init = function () {
                    var _this_1 = this;
                    this._selectedMonth = this._getMonthInCurrentYear(this.selected);
                    this._todayMonth = this._getMonthInCurrentYear(this._dateAdapter.today());
                    this._yearLabel = this._dateAdapter.getYearName(this.activeDate);
                    /** @type {?} */
                    var monthNames = this._dateAdapter.getMonthNames('short');
                    // First row of months only contains 5 elements so we can fit the year label on the same row.
                    this._months = [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]].map(( /**
                     * @param {?} row
                     * @return {?}
                     */function (/**
                     * @param {?} row
                     * @return {?}
                     */ row) { return row.map(( /**
                     * @param {?} month
                     * @return {?}
                     */function (/**
                     * @param {?} month
                     * @return {?}
                     */ month) { return _this_1._createCellForMonth(month, monthNames[month]); })); }));
                    this._changeDetectorRef.markForCheck();
                };
                /**
                 * Focuses the active cell after the microtask queue is empty.
                 * @return {?}
                 */
                MatYearView.prototype._focusActiveCell = function () {
                    this._matCalendarBody._focusActiveCell();
                };
                /**
                 * Gets the month in this year that the given Date falls on.
                 * Returns null if the given Date is in another year.
                 * @private
                 * @param {?} date
                 * @return {?}
                 */
                MatYearView.prototype._getMonthInCurrentYear = function (date) {
                    return date && this._dateAdapter.getYear(date) == this._dateAdapter.getYear(this.activeDate) ?
                        this._dateAdapter.getMonth(date) : null;
                };
                /**
                 * Creates an MatCalendarCell for the given month.
                 * @private
                 * @param {?} month
                 * @param {?} monthName
                 * @return {?}
                 */
                MatYearView.prototype._createCellForMonth = function (month, monthName) {
                    /** @type {?} */
                    var ariaLabel = this._dateAdapter.format(this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, 1), this._dateFormats.display.monthYearA11yLabel);
                    return new MatCalendarCell(month, monthName.toLocaleUpperCase(), ariaLabel, this._shouldEnableMonth(month));
                };
                /**
                 * Whether the given month is enabled.
                 * @private
                 * @param {?} month
                 * @return {?}
                 */
                MatYearView.prototype._shouldEnableMonth = function (month) {
                    /** @type {?} */
                    var activeYear = this._dateAdapter.getYear(this.activeDate);
                    if (month === undefined || month === null ||
                        this._isYearAndMonthAfterMaxDate(activeYear, month) ||
                        this._isYearAndMonthBeforeMinDate(activeYear, month)) {
                        return false;
                    }
                    if (!this.dateFilter) {
                        return true;
                    }
                    /** @type {?} */
                    var firstOfMonth = this._dateAdapter.createDate(activeYear, month, 1);
                    // If any date in the month is enabled count the month as enabled.
                    for (var date = firstOfMonth; this._dateAdapter.getMonth(date) == month; date = this._dateAdapter.addCalendarDays(date, 1)) {
                        if (this.dateFilter(date)) {
                            return true;
                        }
                    }
                    return false;
                };
                /**
                 * Tests whether the combination month/year is after this.maxDate, considering
                 * just the month and year of this.maxDate
                 * @private
                 * @param {?} year
                 * @param {?} month
                 * @return {?}
                 */
                MatYearView.prototype._isYearAndMonthAfterMaxDate = function (year, month) {
                    if (this.maxDate) {
                        /** @type {?} */
                        var maxYear = this._dateAdapter.getYear(this.maxDate);
                        /** @type {?} */
                        var maxMonth = this._dateAdapter.getMonth(this.maxDate);
                        return year > maxYear || (year === maxYear && month > maxMonth);
                    }
                    return false;
                };
                /**
                 * Tests whether the combination month/year is before this.minDate, considering
                 * just the month and year of this.minDate
                 * @private
                 * @param {?} year
                 * @param {?} month
                 * @return {?}
                 */
                MatYearView.prototype._isYearAndMonthBeforeMinDate = function (year, month) {
                    if (this.minDate) {
                        /** @type {?} */
                        var minYear = this._dateAdapter.getYear(this.minDate);
                        /** @type {?} */
                        var minMonth = this._dateAdapter.getMonth(this.minDate);
                        return year < minYear || (year === minYear && month < minMonth);
                    }
                    return false;
                };
                /**
                 * @private
                 * @param {?} obj The object to check.
                 * @return {?} The given object if it is both a date instance and valid, otherwise null.
                 */
                MatYearView.prototype._getValidDateOrNull = function (obj) {
                    return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
                };
                /**
                 * Determines whether the user has the RTL layout direction.
                 * @private
                 * @return {?}
                 */
                MatYearView.prototype._isRtl = function () {
                    return this._dir && this._dir.value === 'rtl';
                };
                return MatYearView;
            }());
            MatYearView.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-year-view',
                            template: "<table class=\"mat-calendar-table\" role=\"presentation\"><thead class=\"mat-calendar-table-header\"><tr><th class=\"mat-calendar-table-header-divider\" colspan=\"4\"></th></tr></thead><tbody mat-calendar-body [label]=\"_yearLabel\" [rows]=\"_months\" [todayValue]=\"_todayMonth\" [selectedValue]=\"_selectedMonth\" [labelMinRequiredCells]=\"2\" [numCols]=\"4\" [cellAspectRatio]=\"4 / 7\" [activeCell]=\"_dateAdapter.getMonth(activeDate)\" (selectedValueChange)=\"_monthSelected($event)\" (keydown)=\"_handleCalendarBodyKeydown($event)\"></tbody></table>",
                            exportAs: 'matYearView',
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush
                        },] },
            ];
            /** @nocollapse */
            MatYearView.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MAT_DATE_FORMATS"],] }] },
                { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["DateAdapter"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] }
            ]; };
            MatYearView.propDecorators = {
                activeDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                minDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                maxDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                dateFilter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selectedChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                monthSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                activeDateChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                _matCalendarBody: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [MatCalendarBody, { static: false },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Default header for MatCalendar
             * @template D
             */
            var MatCalendarHeader = /** @class */ (function () {
                /**
                 * @param {?} _intl
                 * @param {?} calendar
                 * @param {?} _dateAdapter
                 * @param {?} _dateFormats
                 * @param {?} changeDetectorRef
                 */
                function MatCalendarHeader(_intl, calendar, _dateAdapter, _dateFormats, changeDetectorRef) {
                    this._intl = _intl;
                    this.calendar = calendar;
                    this._dateAdapter = _dateAdapter;
                    this._dateFormats = _dateFormats;
                    this.calendar.stateChanges.subscribe(( /**
                     * @return {?}
                     */function () { return changeDetectorRef.markForCheck(); }));
                }
                Object.defineProperty(MatCalendarHeader.prototype, "periodButtonText", {
                    /**
                     * The label for the current calendar view.
                     * @return {?}
                     */
                    get: function () {
                        if (this.calendar.currentView == 'month') {
                            return this._dateAdapter
                                .format(this.calendar.activeDate, this._dateFormats.display.monthYearLabel)
                                .toLocaleUpperCase();
                        }
                        if (this.calendar.currentView == 'year') {
                            return this._dateAdapter.getYearName(this.calendar.activeDate);
                        }
                        // The offset from the active year to the "slot" for the starting year is the
                        // *actual* first rendered year in the multi-year view, and the last year is
                        // just yearsPerPage - 1 away.
                        /** @type {?} */
                        var activeYear = this._dateAdapter.getYear(this.calendar.activeDate);
                        /** @type {?} */
                        var minYearOfPage = activeYear - getActiveOffset(this._dateAdapter, this.calendar.activeDate, this.calendar.minDate, this.calendar.maxDate);
                        /** @type {?} */
                        var maxYearOfPage = minYearOfPage + yearsPerPage - 1;
                        /** @type {?} */
                        var minYearName = this._dateAdapter.getYearName(this._dateAdapter.createDate(minYearOfPage, 0, 1));
                        /** @type {?} */
                        var maxYearName = this._dateAdapter.getYearName(this._dateAdapter.createDate(maxYearOfPage, 0, 1));
                        return this._intl.formatYearRange(minYearName, maxYearName);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCalendarHeader.prototype, "periodButtonLabel", {
                    /**
                     * @return {?}
                     */
                    get: function () {
                        return this.calendar.currentView == 'month' ?
                            this._intl.switchToMultiYearViewLabel : this._intl.switchToMonthViewLabel;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCalendarHeader.prototype, "prevButtonLabel", {
                    /**
                     * The label for the previous button.
                     * @return {?}
                     */
                    get: function () {
                        return {
                            'month': this._intl.prevMonthLabel,
                            'year': this._intl.prevYearLabel,
                            'multi-year': this._intl.prevMultiYearLabel
                        }[this.calendar.currentView];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCalendarHeader.prototype, "nextButtonLabel", {
                    /**
                     * The label for the next button.
                     * @return {?}
                     */
                    get: function () {
                        return {
                            'month': this._intl.nextMonthLabel,
                            'year': this._intl.nextYearLabel,
                            'multi-year': this._intl.nextMultiYearLabel
                        }[this.calendar.currentView];
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Handles user clicks on the period label.
                 * @return {?}
                 */
                MatCalendarHeader.prototype.currentPeriodClicked = function () {
                    this.calendar.currentView = this.calendar.currentView == 'month' ? 'multi-year' : 'month';
                };
                /**
                 * Handles user clicks on the previous button.
                 * @return {?}
                 */
                MatCalendarHeader.prototype.previousClicked = function () {
                    this.calendar.activeDate = this.calendar.currentView == 'month' ?
                        this._dateAdapter.addCalendarMonths(this.calendar.activeDate, -1) :
                        this._dateAdapter.addCalendarYears(this.calendar.activeDate, this.calendar.currentView == 'year' ? -1 : -yearsPerPage);
                };
                /**
                 * Handles user clicks on the next button.
                 * @return {?}
                 */
                MatCalendarHeader.prototype.nextClicked = function () {
                    this.calendar.activeDate = this.calendar.currentView == 'month' ?
                        this._dateAdapter.addCalendarMonths(this.calendar.activeDate, 1) :
                        this._dateAdapter.addCalendarYears(this.calendar.activeDate, this.calendar.currentView == 'year' ? 1 : yearsPerPage);
                };
                /**
                 * Whether the previous period button is enabled.
                 * @return {?}
                 */
                MatCalendarHeader.prototype.previousEnabled = function () {
                    if (!this.calendar.minDate) {
                        return true;
                    }
                    return !this.calendar.minDate ||
                        !this._isSameView(this.calendar.activeDate, this.calendar.minDate);
                };
                /**
                 * Whether the next period button is enabled.
                 * @return {?}
                 */
                MatCalendarHeader.prototype.nextEnabled = function () {
                    return !this.calendar.maxDate ||
                        !this._isSameView(this.calendar.activeDate, this.calendar.maxDate);
                };
                /**
                 * Whether the two dates represent the same view in the current view mode (month or year).
                 * @private
                 * @param {?} date1
                 * @param {?} date2
                 * @return {?}
                 */
                MatCalendarHeader.prototype._isSameView = function (date1, date2) {
                    if (this.calendar.currentView == 'month') {
                        return this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2) &&
                            this._dateAdapter.getMonth(date1) == this._dateAdapter.getMonth(date2);
                    }
                    if (this.calendar.currentView == 'year') {
                        return this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2);
                    }
                    // Otherwise we are in 'multi-year' view.
                    return isSameMultiYearView(this._dateAdapter, date1, date2, this.calendar.minDate, this.calendar.maxDate);
                };
                return MatCalendarHeader;
            }());
            MatCalendarHeader.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-calendar-header',
                            template: "<div class=\"mat-calendar-header\"><div class=\"mat-calendar-controls\"><button mat-button type=\"button\" class=\"mat-calendar-period-button\" (click)=\"currentPeriodClicked()\" [attr.aria-label]=\"periodButtonLabel\" cdkAriaLive=\"polite\">{{periodButtonText}}<div class=\"mat-calendar-arrow\" [class.mat-calendar-invert]=\"calendar.currentView != 'month'\"></div></button><div class=\"mat-calendar-spacer\"></div><ng-content></ng-content><button mat-icon-button type=\"button\" class=\"mat-calendar-previous-button\" [disabled]=\"!previousEnabled()\" (click)=\"previousClicked()\" [attr.aria-label]=\"prevButtonLabel\"></button> <button mat-icon-button type=\"button\" class=\"mat-calendar-next-button\" [disabled]=\"!nextEnabled()\" (click)=\"nextClicked()\" [attr.aria-label]=\"nextButtonLabel\"></button></div></div>",
                            exportAs: 'matCalendarHeader',
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatCalendarHeader.ctorParameters = function () { return [
                { type: MatDatepickerIntl },
                { type: MatCalendar, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                                                 * @return {?}
                                                 */function () { return MatCalendar; })),] }] },
                { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["DateAdapter"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MAT_DATE_FORMATS"],] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] }
            ]; };
            /**
             * A calendar that is used as part of the datepicker.
             * \@docs-private
             * @template D
             */
            var MatCalendar = /** @class */ (function () {
                /**
                 * @param {?} _intl
                 * @param {?} _dateAdapter
                 * @param {?} _dateFormats
                 * @param {?} _changeDetectorRef
                 */
                function MatCalendar(_intl, _dateAdapter, _dateFormats, _changeDetectorRef) {
                    var _this_1 = this;
                    this._dateAdapter = _dateAdapter;
                    this._dateFormats = _dateFormats;
                    this._changeDetectorRef = _changeDetectorRef;
                    /**
                     * Used for scheduling that focus should be moved to the active cell on the next tick.
                     * We need to schedule it, rather than do it immediately, because we have to wait
                     * for Angular to re-evaluate the view children.
                     */
                    this._moveFocusOnNextTick = false;
                    /**
                     * Whether the calendar should be started in month or year view.
                     */
                    this.startView = 'month';
                    /**
                     * Emits when the currently selected date changes.
                     */
                    this.selectedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits the year chosen in multiyear view.
                     * This doesn't imply a change on the selected date.
                     */
                    this.yearSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits the month chosen in year view.
                     * This doesn't imply a change on the selected date.
                     */
                    this.monthSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits when any date is selected.
                     */
                    this._userSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits whenever there is a state change that the header may need to respond to.
                     */
                    this.stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
                    if (!this._dateAdapter) {
                        throw createMissingDateImplError('DateAdapter');
                    }
                    if (!this._dateFormats) {
                        throw createMissingDateImplError('MAT_DATE_FORMATS');
                    }
                    this._intlChanges = _intl.changes.subscribe(( /**
                     * @return {?}
                     */function () {
                        _changeDetectorRef.markForCheck();
                        _this_1.stateChanges.next();
                    }));
                }
                Object.defineProperty(MatCalendar.prototype, "startAt", {
                    /**
                     * A date representing the period (month or year) to start the calendar in.
                     * @return {?}
                     */
                    get: function () { return this._startAt; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._startAt = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCalendar.prototype, "selected", {
                    /**
                     * The currently selected date.
                     * @return {?}
                     */
                    get: function () { return this._selected; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCalendar.prototype, "minDate", {
                    /**
                     * The minimum selectable date.
                     * @return {?}
                     */
                    get: function () { return this._minDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCalendar.prototype, "maxDate", {
                    /**
                     * The maximum selectable date.
                     * @return {?}
                     */
                    get: function () { return this._maxDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCalendar.prototype, "activeDate", {
                    /**
                     * The current active date. This determines which time period is shown and which date is
                     * highlighted when using keyboard navigation.
                     * @return {?}
                     */
                    get: function () { return this._clampedActiveDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._clampedActiveDate = this._dateAdapter.clampDate(value, this.minDate, this.maxDate);
                        this.stateChanges.next();
                        this._changeDetectorRef.markForCheck();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCalendar.prototype, "currentView", {
                    /**
                     * Whether the calendar is in month view.
                     * @return {?}
                     */
                    get: function () { return this._currentView; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._currentView = value;
                        this._moveFocusOnNextTick = true;
                        this._changeDetectorRef.markForCheck();
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatCalendar.prototype.ngAfterContentInit = function () {
                    this._calendarHeaderPortal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_6__["ComponentPortal"](this.headerComponent || MatCalendarHeader);
                    this.activeDate = this.startAt || this._dateAdapter.today();
                    // Assign to the private property since we don't want to move focus on init.
                    this._currentView = this.startView;
                };
                /**
                 * @return {?}
                 */
                MatCalendar.prototype.ngAfterViewChecked = function () {
                    if (this._moveFocusOnNextTick) {
                        this._moveFocusOnNextTick = false;
                        this.focusActiveCell();
                    }
                };
                /**
                 * @return {?}
                 */
                MatCalendar.prototype.ngOnDestroy = function () {
                    this._intlChanges.unsubscribe();
                    this.stateChanges.complete();
                };
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                MatCalendar.prototype.ngOnChanges = function (changes) {
                    /** @type {?} */
                    var change = changes['minDate'] || changes['maxDate'] || changes['dateFilter'];
                    if (change && !change.firstChange) {
                        /** @type {?} */
                        var view = this._getCurrentViewComponent();
                        if (view) {
                            // We need to `detectChanges` manually here, because the `minDate`, `maxDate` etc. are
                            // passed down to the view via data bindings which won't be up-to-date when we call `_init`.
                            this._changeDetectorRef.detectChanges();
                            view._init();
                        }
                    }
                    this.stateChanges.next();
                };
                /**
                 * @return {?}
                 */
                MatCalendar.prototype.focusActiveCell = function () {
                    this._getCurrentViewComponent()._focusActiveCell();
                };
                /**
                 * Updates today's date after an update of the active date
                 * @return {?}
                 */
                MatCalendar.prototype.updateTodaysDate = function () {
                    /** @type {?} */
                    var view = this.currentView == 'month' ? this.monthView :
                        (this.currentView == 'year' ? this.yearView : this.multiYearView);
                    view.ngAfterContentInit();
                };
                /**
                 * Handles date selection in the month view.
                 * @param {?} date
                 * @return {?}
                 */
                MatCalendar.prototype._dateSelected = function (date) {
                    if (!this._dateAdapter.sameDate(date, this.selected)) {
                        this.selectedChange.emit(date);
                    }
                };
                /**
                 * Handles year selection in the multiyear view.
                 * @param {?} normalizedYear
                 * @return {?}
                 */
                MatCalendar.prototype._yearSelectedInMultiYearView = function (normalizedYear) {
                    this.yearSelected.emit(normalizedYear);
                };
                /**
                 * Handles month selection in the year view.
                 * @param {?} normalizedMonth
                 * @return {?}
                 */
                MatCalendar.prototype._monthSelectedInYearView = function (normalizedMonth) {
                    this.monthSelected.emit(normalizedMonth);
                };
                /**
                 * @return {?}
                 */
                MatCalendar.prototype._userSelected = function () {
                    this._userSelection.emit();
                };
                /**
                 * Handles year/month selection in the multi-year/year views.
                 * @param {?} date
                 * @param {?} view
                 * @return {?}
                 */
                MatCalendar.prototype._goToDateInView = function (date, view) {
                    this.activeDate = date;
                    this.currentView = view;
                };
                /**
                 * @private
                 * @param {?} obj The object to check.
                 * @return {?} The given object if it is both a date instance and valid, otherwise null.
                 */
                MatCalendar.prototype._getValidDateOrNull = function (obj) {
                    return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
                };
                /**
                 * Returns the component instance that corresponds to the current calendar view.
                 * @private
                 * @return {?}
                 */
                MatCalendar.prototype._getCurrentViewComponent = function () {
                    return this.monthView || this.yearView || this.multiYearView;
                };
                return MatCalendar;
            }());
            MatCalendar.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-calendar',
                            template: "<ng-template [cdkPortalOutlet]=\"_calendarHeaderPortal\"></ng-template><div class=\"mat-calendar-content\" [ngSwitch]=\"currentView\" cdkMonitorSubtreeFocus tabindex=\"-1\"><mat-month-view *ngSwitchCase=\"'month'\" [(activeDate)]=\"activeDate\" [selected]=\"selected\" [dateFilter]=\"dateFilter\" [maxDate]=\"maxDate\" [minDate]=\"minDate\" [dateClass]=\"dateClass\" (selectedChange)=\"_dateSelected($event)\" (_userSelection)=\"_userSelected()\"></mat-month-view><mat-year-view *ngSwitchCase=\"'year'\" [(activeDate)]=\"activeDate\" [selected]=\"selected\" [dateFilter]=\"dateFilter\" [maxDate]=\"maxDate\" [minDate]=\"minDate\" (monthSelected)=\"_monthSelectedInYearView($event)\" (selectedChange)=\"_goToDateInView($event, 'month')\"></mat-year-view><mat-multi-year-view *ngSwitchCase=\"'multi-year'\" [(activeDate)]=\"activeDate\" [selected]=\"selected\" [dateFilter]=\"dateFilter\" [maxDate]=\"maxDate\" [minDate]=\"minDate\" (yearSelected)=\"_yearSelectedInMultiYearView($event)\" (selectedChange)=\"_goToDateInView($event, 'year')\"></mat-multi-year-view></div>",
                            styles: [".mat-calendar{display:block}.mat-calendar-header{padding:8px 8px 0 8px}.mat-calendar-content{padding:0 8px 8px 8px;outline:0}.mat-calendar-controls{display:flex;margin:5% calc(33% / 7 - 16px)}.mat-calendar-spacer{flex:1 1 auto}.mat-calendar-period-button{min-width:0}.mat-calendar-arrow{display:inline-block;width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top-width:5px;border-top-style:solid;margin:0 0 0 5px;vertical-align:middle}.mat-calendar-arrow.mat-calendar-invert{transform:rotate(180deg)}[dir=rtl] .mat-calendar-arrow{margin:0 5px 0 0}.mat-calendar-next-button,.mat-calendar-previous-button{position:relative}.mat-calendar-next-button::after,.mat-calendar-previous-button::after{top:0;left:0;right:0;bottom:0;position:absolute;content:'';margin:15.5px;border:0 solid currentColor;border-top-width:2px}[dir=rtl] .mat-calendar-next-button,[dir=rtl] .mat-calendar-previous-button{transform:rotate(180deg)}.mat-calendar-previous-button::after{border-left-width:2px;transform:translateX(2px) rotate(-45deg)}.mat-calendar-next-button::after{border-right-width:2px;transform:translateX(-2px) rotate(45deg)}.mat-calendar-table{border-spacing:0;border-collapse:collapse;width:100%}.mat-calendar-table-header th{text-align:center;padding:0 0 8px 0}.mat-calendar-table-header-divider{position:relative;height:1px}.mat-calendar-table-header-divider::after{content:'';position:absolute;top:0;left:-8px;right:-8px;height:1px}"],
                            host: {
                                'class': 'mat-calendar',
                            },
                            exportAs: 'matCalendar',
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatCalendar.ctorParameters = function () { return [
                { type: MatDatepickerIntl },
                { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["DateAdapter"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MAT_DATE_FORMATS"],] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] }
            ]; };
            MatCalendar.propDecorators = {
                headerComponent: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                startAt: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                startView: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                minDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                maxDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                dateFilter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                dateClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selectedChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                yearSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                monthSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                _userSelection: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                monthView: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [MatMonthView, { static: false },] }],
                yearView: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [MatYearView, { static: false },] }],
                multiYearView: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [MatMultiYearView, { static: false },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Animations used by the Material datepicker.
             * \@docs-private
             * @type {?}
             */
            var matDatepickerAnimations = {
                /**
                 * Transforms the height of the datepicker's calendar.
                 */
                transformPanel: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["trigger"])('transformPanel', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["state"])('void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["style"])({
                        opacity: 0,
                        transform: 'scale(1, 0.8)'
                    })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["transition"])('void => enter', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["animate"])('120ms cubic-bezier(0, 0, 0.2, 1)', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["style"])({
                        opacity: 1,
                        transform: 'scale(1, 1)'
                    }))),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["transition"])('* => void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["animate"])('100ms linear', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["style"])({ opacity: 0 })))
                ]),
                /**
                 * Fades in the content of the calendar.
                 */
                fadeInCalendar: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["trigger"])('fadeInCalendar', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["state"])('void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["style"])({ opacity: 0 })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["state"])('enter', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["style"])({ opacity: 1 })),
                    // TODO(crisbeto): this animation should be removed since it isn't quite on spec, but we
                    // need to keep it until #12440 gets in, otherwise the exit animation will look glitchy.
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["transition"])('void => *', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["animate"])('120ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)'))
                ])
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Used to generate a unique ID for each datepicker instance.
             * @type {?}
             */
            var datepickerUid = 0;
            /**
             * Injection token that determines the scroll handling while the calendar is open.
             * @type {?}
             */
            var MAT_DATEPICKER_SCROLL_STRATEGY = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('mat-datepicker-scroll-strategy');
            /**
             * \@docs-private
             * @param {?} overlay
             * @return {?}
             */
            function MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY(overlay) {
                return ( /**
                 * @return {?}
                 */function () { return overlay.scrollStrategies.reposition(); });
            }
            /**
             * \@docs-private
             * @type {?}
             */
            var MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER = {
                provide: MAT_DATEPICKER_SCROLL_STRATEGY,
                deps: [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_9__["Overlay"]],
                useFactory: MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY,
            };
            // Boilerplate for applying mixins to MatDatepickerContent.
            /**
             * \@docs-private
             */
            var MatDatepickerContentBase = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 */
                function MatDatepickerContentBase(_elementRef) {
                    this._elementRef = _elementRef;
                }
                return MatDatepickerContentBase;
            }());
            /** @type {?} */
            var _MatDatepickerContentMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["mixinColor"])(MatDatepickerContentBase);
            /**
             * Component used as the content for the datepicker dialog and popup. We use this instead of using
             * MatCalendar directly as the content so we can control the initial focus. This also gives us a
             * place to put additional features of the popup that are not part of the calendar itself in the
             * future. (e.g. confirmation buttons).
             * \@docs-private
             * @template D
             */
            var MatDatepickerContent = /** @class */ (function (_super) {
                __extends(MatDatepickerContent, _super);
                /**
                 * @param {?} elementRef
                 */
                function MatDatepickerContent(elementRef) {
                    return _super.call(this, elementRef) || this;
                }
                /**
                 * @return {?}
                 */
                MatDatepickerContent.prototype.ngAfterViewInit = function () {
                    this._calendar.focusActiveCell();
                };
                return MatDatepickerContent;
            }(_MatDatepickerContentMixinBase));
            MatDatepickerContent.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-datepicker-content',
                            template: "<mat-calendar cdkTrapFocus [id]=\"datepicker.id\" [ngClass]=\"datepicker.panelClass\" [startAt]=\"datepicker.startAt\" [startView]=\"datepicker.startView\" [minDate]=\"datepicker._minDate\" [maxDate]=\"datepicker._maxDate\" [dateFilter]=\"datepicker._dateFilter\" [headerComponent]=\"datepicker.calendarHeaderComponent\" [selected]=\"datepicker._selected\" [dateClass]=\"datepicker.dateClass\" [@fadeInCalendar]=\"'enter'\" (selectedChange)=\"datepicker.select($event)\" (yearSelected)=\"datepicker._selectYear($event)\" (monthSelected)=\"datepicker._selectMonth($event)\" (_userSelection)=\"datepicker.close()\"></mat-calendar>",
                            styles: [".mat-datepicker-content{display:block;border-radius:4px}.mat-datepicker-content .mat-calendar{width:296px;height:354px}.mat-datepicker-content-touch{display:block;max-height:80vh;overflow:auto;margin:-24px}.mat-datepicker-content-touch .mat-calendar{min-width:250px;min-height:312px;max-width:750px;max-height:788px}@media all and (orientation:landscape){.mat-datepicker-content-touch .mat-calendar{width:64vh;height:80vh}}@media all and (orientation:portrait){.mat-datepicker-content-touch .mat-calendar{width:80vw;height:100vw}}"],
                            host: {
                                'class': 'mat-datepicker-content',
                                '[@transformPanel]': '"enter"',
                                '[class.mat-datepicker-content-touch]': 'datepicker.touchUi',
                            },
                            animations: [
                                matDatepickerAnimations.transformPanel,
                                matDatepickerAnimations.fadeInCalendar,
                            ],
                            exportAs: 'matDatepickerContent',
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            inputs: ['color'],
                        },] },
            ];
            /** @nocollapse */
            MatDatepickerContent.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] }
            ]; };
            MatDatepickerContent.propDecorators = {
                _calendar: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [MatCalendar, { static: false },] }]
            };
            // TODO(mmalerba): We use a component instead of a directive here so the user can use implicit
            // template reference variables (e.g. #d vs #d="matDatepicker"). We can change this to a directive
            // if angular adds support for `exportAs: '$implicit'` on directives.
            /**
             * Component responsible for managing the datepicker popup/dialog.
             * @template D
             */
            var MatDatepicker = /** @class */ (function () {
                /**
                 * @param {?} _dialog
                 * @param {?} _overlay
                 * @param {?} _ngZone
                 * @param {?} _viewContainerRef
                 * @param {?} scrollStrategy
                 * @param {?} _dateAdapter
                 * @param {?} _dir
                 * @param {?} _document
                 */
                function MatDatepicker(_dialog, _overlay, _ngZone, _viewContainerRef, scrollStrategy, _dateAdapter, _dir, _document) {
                    this._dialog = _dialog;
                    this._overlay = _overlay;
                    this._ngZone = _ngZone;
                    this._viewContainerRef = _viewContainerRef;
                    this._dateAdapter = _dateAdapter;
                    this._dir = _dir;
                    this._document = _document;
                    /**
                     * The view that the calendar should start in.
                     */
                    this.startView = 'month';
                    this._touchUi = false;
                    /**
                     * Emits selected year in multiyear view.
                     * This doesn't imply a change on the selected date.
                     */
                    this.yearSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits selected month in year view.
                     * This doesn't imply a change on the selected date.
                     */
                    this.monthSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits when the datepicker has been opened.
                     */
                    this.openedStream = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits when the datepicker has been closed.
                     */
                    this.closedStream = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    this._opened = false;
                    /**
                     * The id for the datepicker calendar.
                     */
                    this.id = "mat-datepicker-" + datepickerUid++;
                    this._validSelected = null;
                    /**
                     * The element that was focused before the datepicker was opened.
                     */
                    this._focusedElementBeforeOpen = null;
                    /**
                     * Subscription to value changes in the associated input element.
                     */
                    this._inputSubscription = rxjs__WEBPACK_IMPORTED_MODULE_1__["Subscription"].EMPTY;
                    /**
                     * Emits when the datepicker is disabled.
                     */
                    this._disabledChange = new rxjs__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
                    /**
                     * Emits new selected date when selected date changes.
                     */
                    this._selectedChanged = new rxjs__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
                    if (!this._dateAdapter) {
                        throw createMissingDateImplError('DateAdapter');
                    }
                    this._scrollStrategy = scrollStrategy;
                }
                Object.defineProperty(MatDatepicker.prototype, "startAt", {
                    /**
                     * The date to open the calendar to initially.
                     * @return {?}
                     */
                    get: function () {
                        // If an explicit startAt is set we start there, otherwise we start at whatever the currently
                        // selected value is.
                        return this._startAt || (this._datepickerInput ? this._datepickerInput.value : null);
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._startAt = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepicker.prototype, "color", {
                    /**
                     * Color palette to use on the datepicker's calendar.
                     * @return {?}
                     */
                    get: function () {
                        return this._color ||
                            (this._datepickerInput ? this._datepickerInput._getThemePalette() : undefined);
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._color = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepicker.prototype, "touchUi", {
                    /**
                     * Whether the calendar UI is in touch mode. In touch mode the calendar opens in a dialog rather
                     * than a popup and elements have more padding to allow for bigger touch targets.
                     * @return {?}
                     */
                    get: function () { return this._touchUi; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._touchUi = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepicker.prototype, "disabled", {
                    /**
                     * Whether the datepicker pop-up should be disabled.
                     * @return {?}
                     */
                    get: function () {
                        return this._disabled === undefined && this._datepickerInput ?
                            this._datepickerInput.disabled : !!this._disabled;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__["coerceBooleanProperty"])(value);
                        if (newValue !== this._disabled) {
                            this._disabled = newValue;
                            this._disabledChange.next(newValue);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepicker.prototype, "opened", {
                    /**
                     * Whether the calendar is open.
                     * @return {?}
                     */
                    get: function () { return this._opened; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { value ? this.open() : this.close(); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepicker.prototype, "_selected", {
                    /**
                     * The currently selected date.
                     * @return {?}
                     */
                    get: function () { return this._validSelected; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._validSelected = value; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepicker.prototype, "_minDate", {
                    /**
                     * The minimum selectable date.
                     * @return {?}
                     */
                    get: function () {
                        return this._datepickerInput && this._datepickerInput.min;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepicker.prototype, "_maxDate", {
                    /**
                     * The maximum selectable date.
                     * @return {?}
                     */
                    get: function () {
                        return this._datepickerInput && this._datepickerInput.max;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepicker.prototype, "_dateFilter", {
                    /**
                     * @return {?}
                     */
                    get: function () {
                        return this._datepickerInput && this._datepickerInput._dateFilter;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatDatepicker.prototype.ngOnDestroy = function () {
                    this.close();
                    this._inputSubscription.unsubscribe();
                    this._disabledChange.complete();
                    if (this._popupRef) {
                        this._popupRef.dispose();
                        this._popupComponentRef = null;
                    }
                };
                /**
                 * Selects the given date
                 * @param {?} date
                 * @return {?}
                 */
                MatDatepicker.prototype.select = function (date) {
                    /** @type {?} */
                    var oldValue = this._selected;
                    this._selected = date;
                    if (!this._dateAdapter.sameDate(oldValue, this._selected)) {
                        this._selectedChanged.next(date);
                    }
                };
                /**
                 * Emits the selected year in multiyear view
                 * @param {?} normalizedYear
                 * @return {?}
                 */
                MatDatepicker.prototype._selectYear = function (normalizedYear) {
                    this.yearSelected.emit(normalizedYear);
                };
                /**
                 * Emits selected month in year view
                 * @param {?} normalizedMonth
                 * @return {?}
                 */
                MatDatepicker.prototype._selectMonth = function (normalizedMonth) {
                    this.monthSelected.emit(normalizedMonth);
                };
                /**
                 * Register an input with this datepicker.
                 * @param {?} input The datepicker input to register with this datepicker.
                 * @return {?}
                 */
                MatDatepicker.prototype._registerInput = function (input) {
                    var _this_1 = this;
                    if (this._datepickerInput) {
                        throw Error('A MatDatepicker can only be associated with a single input.');
                    }
                    this._datepickerInput = input;
                    this._inputSubscription =
                        this._datepickerInput._valueChange.subscribe(( /**
                         * @param {?} value
                         * @return {?}
                         */function (value) { return _this_1._selected = value; }));
                };
                /**
                 * Open the calendar.
                 * @return {?}
                 */
                MatDatepicker.prototype.open = function () {
                    if (this._opened || this.disabled) {
                        return;
                    }
                    if (!this._datepickerInput) {
                        throw Error('Attempted to open an MatDatepicker with no associated input.');
                    }
                    if (this._document) {
                        this._focusedElementBeforeOpen = this._document.activeElement;
                    }
                    this.touchUi ? this._openAsDialog() : this._openAsPopup();
                    this._opened = true;
                    this.openedStream.emit();
                };
                /**
                 * Close the calendar.
                 * @return {?}
                 */
                MatDatepicker.prototype.close = function () {
                    var _this_1 = this;
                    if (!this._opened) {
                        return;
                    }
                    if (this._popupRef && this._popupRef.hasAttached()) {
                        this._popupRef.detach();
                    }
                    if (this._dialogRef) {
                        this._dialogRef.close();
                        this._dialogRef = null;
                    }
                    if (this._calendarPortal && this._calendarPortal.isAttached) {
                        this._calendarPortal.detach();
                    }
                    /** @type {?} */
                    var completeClose = ( /**
                     * @return {?}
                     */function () {
                        // The `_opened` could've been reset already if
                        // we got two events in quick succession.
                        if (_this_1._opened) {
                            _this_1._opened = false;
                            _this_1.closedStream.emit();
                            _this_1._focusedElementBeforeOpen = null;
                        }
                    });
                    if (this._focusedElementBeforeOpen &&
                        typeof this._focusedElementBeforeOpen.focus === 'function') {
                        // Because IE moves focus asynchronously, we can't count on it being restored before we've
                        // marked the datepicker as closed. If the event fires out of sequence and the element that
                        // we're refocusing opens the datepicker on focus, the user could be stuck with not being
                        // able to close the calendar at all. We work around it by making the logic, that marks
                        // the datepicker as closed, async as well.
                        this._focusedElementBeforeOpen.focus();
                        setTimeout(completeClose);
                    }
                    else {
                        completeClose();
                    }
                };
                /**
                 * Open the calendar as a dialog.
                 * @private
                 * @return {?}
                 */
                MatDatepicker.prototype._openAsDialog = function () {
                    var _this_1 = this;
                    // Usually this would be handled by `open` which ensures that we can only have one overlay
                    // open at a time, however since we reset the variables in async handlers some overlays
                    // may slip through if the user opens and closes multiple times in quick succession (e.g.
                    // by holding down the enter key).
                    if (this._dialogRef) {
                        this._dialogRef.close();
                    }
                    this._dialogRef = this._dialog.open(MatDatepickerContent, {
                        direction: this._dir ? this._dir.value : 'ltr',
                        viewContainerRef: this._viewContainerRef,
                        panelClass: 'mat-datepicker-dialog',
                    });
                    this._dialogRef.afterClosed().subscribe(( /**
                     * @return {?}
                     */function () { return _this_1.close(); }));
                    this._dialogRef.componentInstance.datepicker = this;
                    this._setColor();
                };
                /**
                 * Open the calendar as a popup.
                 * @private
                 * @return {?}
                 */
                MatDatepicker.prototype._openAsPopup = function () {
                    var _this_1 = this;
                    if (!this._calendarPortal) {
                        this._calendarPortal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_6__["ComponentPortal"](MatDatepickerContent, this._viewContainerRef);
                    }
                    if (!this._popupRef) {
                        this._createPopup();
                    }
                    if (!this._popupRef.hasAttached()) {
                        this._popupComponentRef = this._popupRef.attach(this._calendarPortal);
                        this._popupComponentRef.instance.datepicker = this;
                        this._setColor();
                        // Update the position once the calendar has rendered.
                        this._ngZone.onStable.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["take"])(1)).subscribe(( /**
                         * @return {?}
                         */function () {
                            _this_1._popupRef.updatePosition();
                        }));
                    }
                };
                /**
                 * Create the popup.
                 * @private
                 * @return {?}
                 */
                MatDatepicker.prototype._createPopup = function () {
                    var _this_1 = this;
                    /** @type {?} */
                    var overlayConfig = new _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_9__["OverlayConfig"]({
                        positionStrategy: this._createPopupPositionStrategy(),
                        hasBackdrop: true,
                        backdropClass: 'mat-overlay-transparent-backdrop',
                        direction: this._dir,
                        scrollStrategy: this._scrollStrategy(),
                        panelClass: 'mat-datepicker-popup',
                    });
                    this._popupRef = this._overlay.create(overlayConfig);
                    this._popupRef.overlayElement.setAttribute('role', 'dialog');
                    Object(rxjs__WEBPACK_IMPORTED_MODULE_1__["merge"])(this._popupRef.backdropClick(), this._popupRef.detachments(), this._popupRef.keydownEvents().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["filter"])(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) {
                        // Closing on alt + up is only valid when there's an input associated with the datepicker.
                        return event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["ESCAPE"] ||
                            (_this_1._datepickerInput && event.altKey && event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["UP_ARROW"]);
                    })))).subscribe(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) {
                        if (event) {
                            event.preventDefault();
                        }
                        _this_1.close();
                    }));
                };
                /**
                 * Create the popup PositionStrategy.
                 * @private
                 * @return {?}
                 */
                MatDatepicker.prototype._createPopupPositionStrategy = function () {
                    return this._overlay.position()
                        .flexibleConnectedTo(this._datepickerInput.getConnectedOverlayOrigin())
                        .withTransformOriginOn('.mat-datepicker-content')
                        .withFlexibleDimensions(false)
                        .withViewportMargin(8)
                        .withLockedPosition()
                        .withPositions([
                        {
                            originX: 'start',
                            originY: 'bottom',
                            overlayX: 'start',
                            overlayY: 'top'
                        },
                        {
                            originX: 'start',
                            originY: 'top',
                            overlayX: 'start',
                            overlayY: 'bottom'
                        },
                        {
                            originX: 'end',
                            originY: 'bottom',
                            overlayX: 'end',
                            overlayY: 'top'
                        },
                        {
                            originX: 'end',
                            originY: 'top',
                            overlayX: 'end',
                            overlayY: 'bottom'
                        }
                    ]);
                };
                /**
                 * @private
                 * @param {?} obj The object to check.
                 * @return {?} The given object if it is both a date instance and valid, otherwise null.
                 */
                MatDatepicker.prototype._getValidDateOrNull = function (obj) {
                    return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
                };
                /**
                 * Passes the current theme color along to the calendar overlay.
                 * @private
                 * @return {?}
                 */
                MatDatepicker.prototype._setColor = function () {
                    /** @type {?} */
                    var color = this.color;
                    if (this._popupComponentRef) {
                        this._popupComponentRef.instance.color = color;
                    }
                    if (this._dialogRef) {
                        this._dialogRef.componentInstance.color = color;
                    }
                };
                return MatDatepicker;
            }());
            MatDatepicker.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-datepicker',
                            template: '',
                            exportAs: 'matDatepicker',
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                        },] },
            ];
            /** @nocollapse */
            MatDatepicker.ctorParameters = function () { return [
                { type: _angular_material_dialog__WEBPACK_IMPORTED_MODULE_11__["MatDialog"] },
                { type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_9__["Overlay"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [MAT_DATEPICKER_SCROLL_STRATEGY,] }] },
                { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["DateAdapter"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_10__["DOCUMENT"],] }] }
            ]; };
            MatDatepicker.propDecorators = {
                calendarHeaderComponent: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                startAt: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                startView: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                color: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                touchUi: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                yearSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                monthSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                panelClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                dateClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                openedStream: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"], args: ['opened',] }],
                closedStream: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"], args: ['closed',] }],
                opened: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * \@docs-private
             * @type {?}
             */
            var MAT_DATEPICKER_VALUE_ACCESSOR = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_12__["NG_VALUE_ACCESSOR"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatDatepickerInput; })),
                multi: true
            };
            /**
             * \@docs-private
             * @type {?}
             */
            var MAT_DATEPICKER_VALIDATORS = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_12__["NG_VALIDATORS"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatDatepickerInput; })),
                multi: true
            };
            /**
             * An event used for datepicker input and change events. We don't always have access to a native
             * input or change event because the event may have been triggered by the user clicking on the
             * calendar popup. For consistency, we always use MatDatepickerInputEvent instead.
             * @template D
             */
            var MatDatepickerInputEvent = /** @class */ (function () {
                /**
                 * @param {?} target
                 * @param {?} targetElement
                 */
                function MatDatepickerInputEvent(target, targetElement) {
                    this.target = target;
                    this.targetElement = targetElement;
                    this.value = this.target.value;
                }
                return MatDatepickerInputEvent;
            }());
            /**
             * Directive used to connect an input to a MatDatepicker.
             * @template D
             */
            var MatDatepickerInput = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 * @param {?} _dateAdapter
                 * @param {?} _dateFormats
                 * @param {?} _formField
                 */
                function MatDatepickerInput(_elementRef, _dateAdapter, _dateFormats, _formField) {
                    var _this_1 = this;
                    this._elementRef = _elementRef;
                    this._dateAdapter = _dateAdapter;
                    this._dateFormats = _dateFormats;
                    this._formField = _formField;
                    /**
                     * Emits when a `change` event is fired on this `<input>`.
                     */
                    this.dateChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits when an `input` event is fired on this `<input>`.
                     */
                    this.dateInput = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits when the value changes (either due to user input or programmatic change).
                     */
                    this._valueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits when the disabled state has changed
                     */
                    this._disabledChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    this._onTouched = ( /**
                     * @return {?}
                     */function () { });
                    this._cvaOnChange = ( /**
                     * @return {?}
                     */function () { });
                    this._validatorOnChange = ( /**
                     * @return {?}
                     */function () { });
                    this._datepickerSubscription = rxjs__WEBPACK_IMPORTED_MODULE_1__["Subscription"].EMPTY;
                    this._localeSubscription = rxjs__WEBPACK_IMPORTED_MODULE_1__["Subscription"].EMPTY;
                    /**
                     * The form control validator for whether the input parses.
                     */
                    this._parseValidator = ( /**
                     * @return {?}
                     */function () {
                        return _this_1._lastValueValid ?
                            null : { 'matDatepickerParse': { 'text': _this_1._elementRef.nativeElement.value } };
                    });
                    /**
                     * The form control validator for the min date.
                     */
                    this._minValidator = ( /**
                     * @param {?} control
                     * @return {?}
                     */function (control) {
                        /** @type {?} */
                        var controlValue = _this_1._getValidDateOrNull(_this_1._dateAdapter.deserialize(control.value));
                        return (!_this_1.min || !controlValue ||
                            _this_1._dateAdapter.compareDate(_this_1.min, controlValue) <= 0) ?
                            null : { 'matDatepickerMin': { 'min': _this_1.min, 'actual': controlValue } };
                    });
                    /**
                     * The form control validator for the max date.
                     */
                    this._maxValidator = ( /**
                     * @param {?} control
                     * @return {?}
                     */function (control) {
                        /** @type {?} */
                        var controlValue = _this_1._getValidDateOrNull(_this_1._dateAdapter.deserialize(control.value));
                        return (!_this_1.max || !controlValue ||
                            _this_1._dateAdapter.compareDate(_this_1.max, controlValue) >= 0) ?
                            null : { 'matDatepickerMax': { 'max': _this_1.max, 'actual': controlValue } };
                    });
                    /**
                     * The form control validator for the date filter.
                     */
                    this._filterValidator = ( /**
                     * @param {?} control
                     * @return {?}
                     */function (control) {
                        /** @type {?} */
                        var controlValue = _this_1._getValidDateOrNull(_this_1._dateAdapter.deserialize(control.value));
                        return !_this_1._dateFilter || !controlValue || _this_1._dateFilter(controlValue) ?
                            null : { 'matDatepickerFilter': true };
                    });
                    /**
                     * The combined form control validator for this input.
                     */
                    this._validator = _angular_forms__WEBPACK_IMPORTED_MODULE_12__["Validators"].compose([this._parseValidator, this._minValidator, this._maxValidator, this._filterValidator]);
                    /**
                     * Whether the last value set on the input was valid.
                     */
                    this._lastValueValid = false;
                    if (!this._dateAdapter) {
                        throw createMissingDateImplError('DateAdapter');
                    }
                    if (!this._dateFormats) {
                        throw createMissingDateImplError('MAT_DATE_FORMATS');
                    }
                    // Update the displayed date when the locale changes.
                    this._localeSubscription = _dateAdapter.localeChanges.subscribe(( /**
                     * @return {?}
                     */function () {
                        _this_1.value = _this_1.value;
                    }));
                }
                Object.defineProperty(MatDatepickerInput.prototype, "matDatepicker", {
                    /**
                     * The datepicker that this input is associated with.
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        var _this_1 = this;
                        if (!value) {
                            return;
                        }
                        this._datepicker = value;
                        this._datepicker._registerInput(this);
                        this._datepickerSubscription.unsubscribe();
                        this._datepickerSubscription = this._datepicker._selectedChanged.subscribe(( /**
                         * @param {?} selected
                         * @return {?}
                         */function (selected) {
                            _this_1.value = selected;
                            _this_1._cvaOnChange(selected);
                            _this_1._onTouched();
                            _this_1.dateInput.emit(new MatDatepickerInputEvent(_this_1, _this_1._elementRef.nativeElement));
                            _this_1.dateChange.emit(new MatDatepickerInputEvent(_this_1, _this_1._elementRef.nativeElement));
                        }));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepickerInput.prototype, "matDatepickerFilter", {
                    /**
                     * Function that can be used to filter out dates within the datepicker.
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._dateFilter = value;
                        this._validatorOnChange();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepickerInput.prototype, "value", {
                    /**
                     * The value of the input.
                     * @return {?}
                     */
                    get: function () { return this._value; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        value = this._dateAdapter.deserialize(value);
                        this._lastValueValid = !value || this._dateAdapter.isValid(value);
                        value = this._getValidDateOrNull(value);
                        /** @type {?} */
                        var oldDate = this.value;
                        this._value = value;
                        this._formatValue(value);
                        if (!this._dateAdapter.sameDate(oldDate, value)) {
                            this._valueChange.emit(value);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepickerInput.prototype, "min", {
                    /**
                     * The minimum valid date.
                     * @return {?}
                     */
                    get: function () { return this._min; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._min = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                        this._validatorOnChange();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepickerInput.prototype, "max", {
                    /**
                     * The maximum valid date.
                     * @return {?}
                     */
                    get: function () { return this._max; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._max = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                        this._validatorOnChange();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepickerInput.prototype, "disabled", {
                    /**
                     * Whether the datepicker-input is disabled.
                     * @return {?}
                     */
                    get: function () { return !!this._disabled; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__["coerceBooleanProperty"])(value);
                        /** @type {?} */
                        var element = this._elementRef.nativeElement;
                        if (this._disabled !== newValue) {
                            this._disabled = newValue;
                            this._disabledChange.emit(newValue);
                        }
                        // We need to null check the `blur` method, because it's undefined during SSR.
                        if (newValue && element.blur) {
                            // Normally, native input elements automatically blur if they turn disabled. This behavior
                            // is problematic, because it would mean that it triggers another change detection cycle,
                            // which then causes a changed after checked error if the input element was focused before.
                            element.blur();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatDatepickerInput.prototype.ngOnDestroy = function () {
                    this._datepickerSubscription.unsubscribe();
                    this._localeSubscription.unsubscribe();
                    this._valueChange.complete();
                    this._disabledChange.complete();
                };
                /**
                 * \@docs-private
                 * @param {?} fn
                 * @return {?}
                 */
                MatDatepickerInput.prototype.registerOnValidatorChange = function (fn) {
                    this._validatorOnChange = fn;
                };
                /**
                 * \@docs-private
                 * @param {?} c
                 * @return {?}
                 */
                MatDatepickerInput.prototype.validate = function (c) {
                    return this._validator ? this._validator(c) : null;
                };
                /**
                 * @deprecated
                 * \@breaking-change 8.0.0 Use `getConnectedOverlayOrigin` instead
                 * @return {?}
                 */
                MatDatepickerInput.prototype.getPopupConnectionElementRef = function () {
                    return this.getConnectedOverlayOrigin();
                };
                /**
                 * Gets the element that the datepicker popup should be connected to.
                 * @return {?} The element to connect the popup to.
                 */
                MatDatepickerInput.prototype.getConnectedOverlayOrigin = function () {
                    return this._formField ? this._formField.getConnectedOverlayOrigin() : this._elementRef;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} value
                 * @return {?}
                 */
                MatDatepickerInput.prototype.writeValue = function (value) {
                    this.value = value;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} fn
                 * @return {?}
                 */
                MatDatepickerInput.prototype.registerOnChange = function (fn) {
                    this._cvaOnChange = fn;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} fn
                 * @return {?}
                 */
                MatDatepickerInput.prototype.registerOnTouched = function (fn) {
                    this._onTouched = fn;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} isDisabled
                 * @return {?}
                 */
                MatDatepickerInput.prototype.setDisabledState = function (isDisabled) {
                    this.disabled = isDisabled;
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatDatepickerInput.prototype._onKeydown = function (event) {
                    /** @type {?} */
                    var isAltDownArrow = event.altKey && event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["DOWN_ARROW"];
                    if (this._datepicker && isAltDownArrow && !this._elementRef.nativeElement.readOnly) {
                        this._datepicker.open();
                        event.preventDefault();
                    }
                };
                /**
                 * @param {?} value
                 * @return {?}
                 */
                MatDatepickerInput.prototype._onInput = function (value) {
                    /** @type {?} */
                    var date = this._dateAdapter.parse(value, this._dateFormats.parse.dateInput);
                    this._lastValueValid = !date || this._dateAdapter.isValid(date);
                    date = this._getValidDateOrNull(date);
                    if (!this._dateAdapter.sameDate(date, this._value)) {
                        this._value = date;
                        this._cvaOnChange(date);
                        this._valueChange.emit(date);
                        this.dateInput.emit(new MatDatepickerInputEvent(this, this._elementRef.nativeElement));
                    }
                    else {
                        this._validatorOnChange();
                    }
                };
                /**
                 * @return {?}
                 */
                MatDatepickerInput.prototype._onChange = function () {
                    this.dateChange.emit(new MatDatepickerInputEvent(this, this._elementRef.nativeElement));
                };
                /**
                 * Returns the palette used by the input's form field, if any.
                 * @return {?}
                 */
                MatDatepickerInput.prototype._getThemePalette = function () {
                    return this._formField ? this._formField.color : undefined;
                };
                /**
                 * Handles blur events on the input.
                 * @return {?}
                 */
                MatDatepickerInput.prototype._onBlur = function () {
                    // Reformat the input only if we have a valid value.
                    if (this.value) {
                        this._formatValue(this.value);
                    }
                    this._onTouched();
                };
                /**
                 * Formats a value and sets it on the input element.
                 * @private
                 * @param {?} value
                 * @return {?}
                 */
                MatDatepickerInput.prototype._formatValue = function (value) {
                    this._elementRef.nativeElement.value =
                        value ? this._dateAdapter.format(value, this._dateFormats.display.dateInput) : '';
                };
                /**
                 * @private
                 * @param {?} obj The object to check.
                 * @return {?} The given object if it is both a date instance and valid, otherwise null.
                 */
                MatDatepickerInput.prototype._getValidDateOrNull = function (obj) {
                    return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
                };
                return MatDatepickerInput;
            }());
            MatDatepickerInput.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'input[matDatepicker]',
                            providers: [
                                MAT_DATEPICKER_VALUE_ACCESSOR,
                                MAT_DATEPICKER_VALIDATORS,
                                { provide: _angular_material_input__WEBPACK_IMPORTED_MODULE_14__["MAT_INPUT_VALUE_ACCESSOR"], useExisting: MatDatepickerInput },
                            ],
                            host: {
                                '[attr.aria-haspopup]': '_datepicker ? "dialog" : null',
                                '[attr.aria-owns]': '(_datepicker?.opened && _datepicker.id) || null',
                                '[attr.min]': 'min ? _dateAdapter.toIso8601(min) : null',
                                '[attr.max]': 'max ? _dateAdapter.toIso8601(max) : null',
                                '[disabled]': 'disabled',
                                '(input)': '_onInput($event.target.value)',
                                '(change)': '_onChange()',
                                '(blur)': '_onBlur()',
                                '(keydown)': '_onKeydown($event)',
                            },
                            exportAs: 'matDatepickerInput',
                        },] },
            ];
            /** @nocollapse */
            MatDatepickerInput.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["DateAdapter"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MAT_DATE_FORMATS"],] }] },
                { type: _angular_material_form_field__WEBPACK_IMPORTED_MODULE_13__["MatFormField"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] }
            ]; };
            MatDatepickerInput.propDecorators = {
                matDatepicker: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                matDatepickerFilter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                min: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                max: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                dateChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                dateInput: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Can be used to override the icon of a `matDatepickerToggle`.
             */
            var MatDatepickerToggleIcon = /** @class */ (function () {
                function MatDatepickerToggleIcon() {
                }
                return MatDatepickerToggleIcon;
            }());
            MatDatepickerToggleIcon.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[matDatepickerToggleIcon]'
                        },] },
            ];
            /**
             * @template D
             */
            var MatDatepickerToggle = /** @class */ (function () {
                /**
                 * @param {?} _intl
                 * @param {?} _changeDetectorRef
                 * @param {?} defaultTabIndex
                 */
                function MatDatepickerToggle(_intl, _changeDetectorRef, defaultTabIndex) {
                    this._intl = _intl;
                    this._changeDetectorRef = _changeDetectorRef;
                    this._stateChanges = rxjs__WEBPACK_IMPORTED_MODULE_1__["Subscription"].EMPTY;
                    /** @type {?} */
                    var parsedTabIndex = Number(defaultTabIndex);
                    this.tabIndex = (parsedTabIndex || parsedTabIndex === 0) ? parsedTabIndex : null;
                }
                Object.defineProperty(MatDatepickerToggle.prototype, "disabled", {
                    /**
                     * Whether the toggle button is disabled.
                     * @return {?}
                     */
                    get: function () {
                        if (this._disabled === undefined && this.datepicker) {
                            return this.datepicker.disabled;
                        }
                        return !!this._disabled;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                MatDatepickerToggle.prototype.ngOnChanges = function (changes) {
                    if (changes['datepicker']) {
                        this._watchStateChanges();
                    }
                };
                /**
                 * @return {?}
                 */
                MatDatepickerToggle.prototype.ngOnDestroy = function () {
                    this._stateChanges.unsubscribe();
                };
                /**
                 * @return {?}
                 */
                MatDatepickerToggle.prototype.ngAfterContentInit = function () {
                    this._watchStateChanges();
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatDatepickerToggle.prototype._open = function (event) {
                    if (this.datepicker && !this.disabled) {
                        this.datepicker.open();
                        event.stopPropagation();
                    }
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatDatepickerToggle.prototype._watchStateChanges = function () {
                    var _this_1 = this;
                    /** @type {?} */
                    var datepickerDisabled = this.datepicker ? this.datepicker._disabledChange : Object(rxjs__WEBPACK_IMPORTED_MODULE_1__["of"])();
                    /** @type {?} */
                    var inputDisabled = this.datepicker && this.datepicker._datepickerInput ?
                        this.datepicker._datepickerInput._disabledChange : Object(rxjs__WEBPACK_IMPORTED_MODULE_1__["of"])();
                    /** @type {?} */
                    var datepickerToggled = this.datepicker ?
                        Object(rxjs__WEBPACK_IMPORTED_MODULE_1__["merge"])(this.datepicker.openedStream, this.datepicker.closedStream) :
                        Object(rxjs__WEBPACK_IMPORTED_MODULE_1__["of"])();
                    this._stateChanges.unsubscribe();
                    this._stateChanges = Object(rxjs__WEBPACK_IMPORTED_MODULE_1__["merge"])(this._intl.changes, datepickerDisabled, inputDisabled, datepickerToggled).subscribe(( /**
                     * @return {?}
                     */function () { return _this_1._changeDetectorRef.markForCheck(); }));
                };
                return MatDatepickerToggle;
            }());
            MatDatepickerToggle.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-datepicker-toggle',
                            template: "<button #button mat-icon-button type=\"button\" [attr.aria-haspopup]=\"datepicker ? 'dialog' : null\" [attr.aria-label]=\"_intl.openCalendarLabel\" [attr.tabindex]=\"disabled ? -1 : tabIndex\" [disabled]=\"disabled\" [disableRipple]=\"disableRipple\" (click)=\"_open($event)\"><svg *ngIf=\"!_customIcon\" class=\"mat-datepicker-toggle-default-icon\" viewBox=\"0 0 24 24\" width=\"24px\" height=\"24px\" fill=\"currentColor\" focusable=\"false\"><path d=\"M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z\"/></svg><ng-content select=\"[matDatepickerToggleIcon]\"></ng-content></button>",
                            styles: [".mat-form-field-appearance-legacy .mat-form-field-prefix .mat-datepicker-toggle-default-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-datepicker-toggle-default-icon{width:1em}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-datepicker-toggle-default-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-datepicker-toggle-default-icon{display:block;width:1.5em;height:1.5em}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-datepicker-toggle-default-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-datepicker-toggle-default-icon{margin:auto}"],
                            host: {
                                'class': 'mat-datepicker-toggle',
                                // Always set the tabindex to -1 so that it doesn't overlap with any custom tabindex the
                                // consumer may have provided, while still being able to receive focus.
                                '[attr.tabindex]': '-1',
                                '[class.mat-datepicker-toggle-active]': 'datepicker && datepicker.opened',
                                '[class.mat-accent]': 'datepicker && datepicker.color === "accent"',
                                '[class.mat-warn]': 'datepicker && datepicker.color === "warn"',
                                '(focus)': '_button.focus()',
                            },
                            exportAs: 'matDatepickerToggle',
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatDatepickerToggle.ctorParameters = function () { return [
                { type: MatDatepickerIntl },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Attribute"], args: ['tabindex',] }] }
            ]; };
            MatDatepickerToggle.propDecorators = {
                datepicker: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['for',] }],
                tabIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                disableRipple: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                _customIcon: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChild"], args: [MatDatepickerToggleIcon, { static: false },] }],
                _button: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['button', { static: false },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatDatepickerModule = /** @class */ (function () {
                function MatDatepickerModule() {
                }
                return MatDatepickerModule;
            }());
            MatDatepickerModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [
                                _angular_common__WEBPACK_IMPORTED_MODULE_10__["CommonModule"],
                                _angular_material_button__WEBPACK_IMPORTED_MODULE_15__["MatButtonModule"],
                                _angular_material_dialog__WEBPACK_IMPORTED_MODULE_11__["MatDialogModule"],
                                _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_9__["OverlayModule"],
                                _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_16__["A11yModule"],
                                _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_6__["PortalModule"],
                            ],
                            exports: [
                                MatCalendar,
                                MatCalendarBody,
                                MatDatepicker,
                                MatDatepickerContent,
                                MatDatepickerInput,
                                MatDatepickerToggle,
                                MatDatepickerToggleIcon,
                                MatMonthView,
                                MatYearView,
                                MatMultiYearView,
                                MatCalendarHeader,
                            ],
                            declarations: [
                                MatCalendar,
                                MatCalendarBody,
                                MatDatepicker,
                                MatDatepickerContent,
                                MatDatepickerInput,
                                MatDatepickerToggle,
                                MatDatepickerToggleIcon,
                                MatMonthView,
                                MatYearView,
                                MatMultiYearView,
                                MatCalendarHeader,
                            ],
                            providers: [
                                MatDatepickerIntl,
                                MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER,
                            ],
                            entryComponents: [
                                MatDatepickerContent,
                                MatCalendarHeader,
                            ]
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=datepicker.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/dialog.js": 
        /*!**********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/dialog.js ***!
          \**********************************************************/
        /*! exports provided: MatDialogModule, MAT_DIALOG_SCROLL_STRATEGY_FACTORY, MAT_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY, MAT_DIALOG_DATA, MAT_DIALOG_DEFAULT_OPTIONS, MAT_DIALOG_SCROLL_STRATEGY, MAT_DIALOG_SCROLL_STRATEGY_PROVIDER, MatDialog, throwMatDialogContentAlreadyAttachedError, MatDialogContainer, MatDialogClose, MatDialogTitle, MatDialogContent, MatDialogActions, MatDialogConfig, MatDialogRef, matDialogAnimations */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDialogModule", function () { return MatDialogModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_DIALOG_SCROLL_STRATEGY_FACTORY", function () { return MAT_DIALOG_SCROLL_STRATEGY_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY", function () { return MAT_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_DIALOG_DATA", function () { return MAT_DIALOG_DATA; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_DIALOG_DEFAULT_OPTIONS", function () { return MAT_DIALOG_DEFAULT_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_DIALOG_SCROLL_STRATEGY", function () { return MAT_DIALOG_SCROLL_STRATEGY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_DIALOG_SCROLL_STRATEGY_PROVIDER", function () { return MAT_DIALOG_SCROLL_STRATEGY_PROVIDER; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDialog", function () { return MatDialog; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "throwMatDialogContentAlreadyAttachedError", function () { return throwMatDialogContentAlreadyAttachedError; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDialogContainer", function () { return MatDialogContainer; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDialogClose", function () { return MatDialogClose; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDialogTitle", function () { return MatDialogTitle; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDialogContent", function () { return MatDialogContent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDialogActions", function () { return MatDialogActions; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDialogConfig", function () { return MatDialogConfig; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDialogRef", function () { return MatDialogRef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matDialogAnimations", function () { return matDialogAnimations; });
            /* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/animations */ "./node_modules/@angular/animations/fesm2015/animations.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/portal */ "./node_modules/@angular/cdk/esm2015/portal.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/cdk/overlay */ "./node_modules/@angular/cdk/esm2015/overlay.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Configuration for opening a modal dialog with the MatDialog service.
             * @template D
             */
            var MatDialogConfig = /** @class */ (function () {
                function MatDialogConfig() {
                    /**
                     * The ARIA role of the dialog element.
                     */
                    this.role = 'dialog';
                    /**
                     * Custom class for the overlay pane.
                     */
                    this.panelClass = '';
                    /**
                     * Whether the dialog has a backdrop.
                     */
                    this.hasBackdrop = true;
                    /**
                     * Custom class for the backdrop.
                     */
                    this.backdropClass = '';
                    /**
                     * Whether the user can use escape or clicking on the backdrop to close the modal.
                     */
                    this.disableClose = false;
                    /**
                     * Width of the dialog.
                     */
                    this.width = '';
                    /**
                     * Height of the dialog.
                     */
                    this.height = '';
                    /**
                     * Max-width of the dialog. If a number is provided, assumes pixel units. Defaults to 80vw.
                     */
                    this.maxWidth = '80vw';
                    /**
                     * Data being injected into the child component.
                     */
                    this.data = null;
                    /**
                     * ID of the element that describes the dialog.
                     */
                    this.ariaDescribedBy = null;
                    /**
                     * ID of the element that labels the dialog.
                     */
                    this.ariaLabelledBy = null;
                    /**
                     * Aria label to assign to the dialog element.
                     */
                    this.ariaLabel = null;
                    /**
                     * Whether the dialog should focus the first focusable element on open.
                     */
                    this.autoFocus = true;
                    /**
                     * Whether the dialog should restore focus to the
                     * previously-focused element, after it's closed.
                     */
                    this.restoreFocus = true;
                    /**
                     * Whether the dialog should close when the user goes backwards/forwards in history.
                     * Note that this usually doesn't include clicking on links (unless the user is using
                     * the `HashLocationStrategy`).
                     */
                    this.closeOnNavigation = true;
                    // TODO(jelbourn): add configuration for lifecycle hooks, ARIA labelling.
                }
                return MatDialogConfig;
            }());
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var animationBody = [
                // Note: The `enter` animation transitions to `transform: none`, because for some reason
                // specifying the transform explicitly, causes IE both to blur the dialog content and
                // decimate the animation performance. Leaving it as `none` solves both issues.
                Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["state"])('void, exit', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ opacity: 0, transform: 'scale(0.7)' })),
                Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["state"])('enter', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ transform: 'none' })),
                Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('* => enter', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])('150ms cubic-bezier(0, 0, 0.2, 1)', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ transform: 'none', opacity: 1 }))),
                Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('* => void, * => exit', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])('75ms cubic-bezier(0.4, 0.0, 0.2, 1)', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ opacity: 0 }))),
            ];
            /**
             * Animations used by MatDialog.
             * \@docs-private
             * @type {?}
             */
            var matDialogAnimations = {
                /**
                 * Animation that is applied on the dialog container by defalt.
                 */
                dialogContainer: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["trigger"])('dialogContainer', animationBody),
                /**
                 * @deprecated \@breaking-change 8.0.0 Use `matDialogAnimations.dialogContainer` instead.
                 */
                slideDialog: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["trigger"])('slideDialog', animationBody)
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Throws an exception for the case when a ComponentPortal is
             * attached to a DomPortalOutlet without an origin.
             * \@docs-private
             * @return {?}
             */
            function throwMatDialogContentAlreadyAttachedError() {
                throw Error('Attempting to attach dialog content after content is already attached');
            }
            /**
             * Internal component that wraps user-provided dialog content.
             * Animation is based on https://material.io/guidelines/motion/choreography.html.
             * \@docs-private
             */
            var MatDialogContainer = /** @class */ (function (_super) {
                __extends(MatDialogContainer, _super);
                /**
                 * @param {?} _elementRef
                 * @param {?} _focusTrapFactory
                 * @param {?} _changeDetectorRef
                 * @param {?} _document
                 * @param {?} _config
                 */
                function MatDialogContainer(_elementRef, _focusTrapFactory, _changeDetectorRef, _document, _config) {
                    var _this_1 = _super.call(this) || this;
                    _this_1._elementRef = _elementRef;
                    _this_1._focusTrapFactory = _focusTrapFactory;
                    _this_1._changeDetectorRef = _changeDetectorRef;
                    _this_1._document = _document;
                    _this_1._config = _config;
                    /**
                     * Element that was focused before the dialog was opened. Save this to restore upon close.
                     */
                    _this_1._elementFocusedBeforeDialogWasOpened = null;
                    /**
                     * State of the dialog animation.
                     */
                    _this_1._state = 'enter';
                    /**
                     * Emits when an animation state changes.
                     */
                    _this_1._animationStateChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
                    _this_1._ariaLabelledBy = _config.ariaLabelledBy || null;
                    return _this_1;
                }
                /**
                 * Attach a ComponentPortal as content to this dialog container.
                 * @template T
                 * @param {?} portal Portal to be attached as the dialog content.
                 * @return {?}
                 */
                MatDialogContainer.prototype.attachComponentPortal = function (portal) {
                    if (this._portalOutlet.hasAttached()) {
                        throwMatDialogContentAlreadyAttachedError();
                    }
                    this._savePreviouslyFocusedElement();
                    return this._portalOutlet.attachComponentPortal(portal);
                };
                /**
                 * Attach a TemplatePortal as content to this dialog container.
                 * @template C
                 * @param {?} portal Portal to be attached as the dialog content.
                 * @return {?}
                 */
                MatDialogContainer.prototype.attachTemplatePortal = function (portal) {
                    if (this._portalOutlet.hasAttached()) {
                        throwMatDialogContentAlreadyAttachedError();
                    }
                    this._savePreviouslyFocusedElement();
                    return this._portalOutlet.attachTemplatePortal(portal);
                };
                /**
                 * Moves the focus inside the focus trap.
                 * @private
                 * @return {?}
                 */
                MatDialogContainer.prototype._trapFocus = function () {
                    /** @type {?} */
                    var element = this._elementRef.nativeElement;
                    if (!this._focusTrap) {
                        this._focusTrap = this._focusTrapFactory.create(element);
                    }
                    // If we were to attempt to focus immediately, then the content of the dialog would not yet be
                    // ready in instances where change detection has to run first. To deal with this, we simply
                    // wait for the microtask queue to be empty.
                    if (this._config.autoFocus) {
                        this._focusTrap.focusInitialElementWhenReady();
                    }
                    else {
                        /** @type {?} */
                        var activeElement = this._document.activeElement;
                        // Otherwise ensure that focus is on the dialog container. It's possible that a different
                        // component tried to move focus while the open animation was running. See:
                        // https://github.com/angular/components/issues/16215. Note that we only want to do this
                        // if the focus isn't inside the dialog already, because it's possible that the consumer
                        // turned off `autoFocus` in order to move focus themselves.
                        if (activeElement !== element && !element.contains(activeElement)) {
                            element.focus();
                        }
                    }
                };
                /**
                 * Restores focus to the element that was focused before the dialog opened.
                 * @private
                 * @return {?}
                 */
                MatDialogContainer.prototype._restoreFocus = function () {
                    /** @type {?} */
                    var toFocus = this._elementFocusedBeforeDialogWasOpened;
                    // We need the extra check, because IE can set the `activeElement` to null in some cases.
                    if (this._config.restoreFocus && toFocus && typeof toFocus.focus === 'function') {
                        toFocus.focus();
                    }
                    if (this._focusTrap) {
                        this._focusTrap.destroy();
                    }
                };
                /**
                 * Saves a reference to the element that was focused before the dialog was opened.
                 * @private
                 * @return {?}
                 */
                MatDialogContainer.prototype._savePreviouslyFocusedElement = function () {
                    var _this_1 = this;
                    if (this._document) {
                        this._elementFocusedBeforeDialogWasOpened = ( /** @type {?} */(this._document.activeElement));
                        // Note that there is no focus method when rendering on the server.
                        if (this._elementRef.nativeElement.focus) {
                            // Move focus onto the dialog immediately in order to prevent the user from accidentally
                            // opening multiple dialogs at the same time. Needs to be async, because the element
                            // may not be focusable immediately.
                            Promise.resolve().then(( /**
                             * @return {?}
                             */function () { return _this_1._elementRef.nativeElement.focus(); }));
                        }
                    }
                };
                /**
                 * Callback, invoked whenever an animation on the host completes.
                 * @param {?} event
                 * @return {?}
                 */
                MatDialogContainer.prototype._onAnimationDone = function (event) {
                    if (event.toState === 'enter') {
                        this._trapFocus();
                    }
                    else if (event.toState === 'exit') {
                        this._restoreFocus();
                    }
                    this._animationStateChanged.emit(event);
                };
                /**
                 * Callback, invoked when an animation on the host starts.
                 * @param {?} event
                 * @return {?}
                 */
                MatDialogContainer.prototype._onAnimationStart = function (event) {
                    this._animationStateChanged.emit(event);
                };
                /**
                 * Starts the dialog exit animation.
                 * @return {?}
                 */
                MatDialogContainer.prototype._startExitAnimation = function () {
                    this._state = 'exit';
                    // Mark the container for check so it can react if the
                    // view container is using OnPush change detection.
                    this._changeDetectorRef.markForCheck();
                };
                return MatDialogContainer;
            }(_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["BasePortalOutlet"]));
            MatDialogContainer.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: 'mat-dialog-container',
                            template: "<ng-template cdkPortalOutlet></ng-template>",
                            styles: [".mat-dialog-container{display:block;padding:24px;border-radius:4px;box-sizing:border-box;overflow:auto;outline:0;width:100%;height:100%;min-height:inherit;max-height:inherit}@media (-ms-high-contrast:active){.mat-dialog-container{outline:solid 1px}}.mat-dialog-content{display:block;margin:0 -24px;padding:0 24px;max-height:65vh;overflow:auto;-webkit-overflow-scrolling:touch}.mat-dialog-title{margin:0 0 20px;display:block}.mat-dialog-actions{padding:8px 0;display:flex;flex-wrap:wrap;min-height:52px;align-items:center;margin-bottom:-24px}.mat-dialog-actions[align=end]{justify-content:flex-end}.mat-dialog-actions[align=center]{justify-content:center}.mat-dialog-actions .mat-button-base+.mat-button-base{margin-left:8px}[dir=rtl] .mat-dialog-actions .mat-button-base+.mat-button-base{margin-left:0;margin-right:8px}"],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                            // Using OnPush for dialogs caused some G3 sync issues. Disabled until we can track them down.
                            // tslint:disable-next-line:validate-decorators
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].Default,
                            animations: [matDialogAnimations.dialogContainer],
                            host: {
                                'class': 'mat-dialog-container',
                                'tabindex': '-1',
                                'aria-modal': 'true',
                                '[attr.id]': '_id',
                                '[attr.role]': '_config.role',
                                '[attr.aria-labelledby]': '_config.ariaLabel ? null : _ariaLabelledBy',
                                '[attr.aria-label]': '_config.ariaLabel',
                                '[attr.aria-describedby]': '_config.ariaDescribedBy || null',
                                '[@dialogContainer]': '_state',
                                '(@dialogContainer.start)': '_onAnimationStart($event)',
                                '(@dialogContainer.done)': '_onAnimationDone($event)',
                            },
                        },] },
            ];
            /** @nocollapse */
            MatDialogContainer.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_4__["FocusTrapFactory"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"],] }] },
                { type: MatDialogConfig }
            ]; };
            MatDialogContainer.propDecorators = {
                _portalOutlet: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["CdkPortalOutlet"], { static: true },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // TODO(jelbourn): resizing
            // Counter for unique dialog ids.
            /** @type {?} */
            var uniqueId = 0;
            /**
             * Reference to a dialog opened via the MatDialog service.
             * @template T, R
             */
            var MatDialogRef = /** @class */ (function () {
                /**
                 * @param {?} _overlayRef
                 * @param {?} _containerInstance
                 * @param {?=} _location
                 * @param {?=} id
                 */
                function MatDialogRef(_overlayRef, _containerInstance, 
                // @breaking-change 8.0.0 `_location` parameter to be removed.
                _location, id) {
                    var _this_1 = this;
                    if (id === void 0) { id = "mat-dialog-" + uniqueId++; }
                    this._overlayRef = _overlayRef;
                    this._containerInstance = _containerInstance;
                    this.id = id;
                    /**
                     * Whether the user is allowed to close the dialog.
                     */
                    this.disableClose = this._containerInstance._config.disableClose;
                    /**
                     * Subject for notifying the user that the dialog has finished opening.
                     */
                    this._afterOpened = new rxjs__WEBPACK_IMPORTED_MODULE_6__["Subject"]();
                    /**
                     * Subject for notifying the user that the dialog has finished closing.
                     */
                    this._afterClosed = new rxjs__WEBPACK_IMPORTED_MODULE_6__["Subject"]();
                    /**
                     * Subject for notifying the user that the dialog has started closing.
                     */
                    this._beforeClosed = new rxjs__WEBPACK_IMPORTED_MODULE_6__["Subject"]();
                    /**
                     * Current state of the dialog.
                     */
                    this._state = 0 /* OPEN */;
                    // Pass the id along to the container.
                    _containerInstance._id = id;
                    // Emit when opening animation completes
                    _containerInstance._animationStateChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["filter"])(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) { return event.phaseName === 'done' && event.toState === 'enter'; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["take"])(1))
                        .subscribe(( /**
                 * @return {?}
                 */function () {
                        _this_1._afterOpened.next();
                        _this_1._afterOpened.complete();
                    }));
                    // Dispose overlay when closing animation is complete
                    _containerInstance._animationStateChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["filter"])(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) { return event.phaseName === 'done' && event.toState === 'exit'; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["take"])(1)).subscribe(( /**
                     * @return {?}
                     */function () {
                        clearTimeout(_this_1._closeFallbackTimeout);
                        _this_1._overlayRef.dispose();
                    }));
                    _overlayRef.detachments().subscribe(( /**
                     * @return {?}
                     */function () {
                        _this_1._beforeClosed.next(_this_1._result);
                        _this_1._beforeClosed.complete();
                        _this_1._afterClosed.next(_this_1._result);
                        _this_1._afterClosed.complete();
                        _this_1.componentInstance = ( /** @type {?} */(null));
                        _this_1._overlayRef.dispose();
                    }));
                    _overlayRef.keydownEvents()
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["filter"])(( /**
                 * @param {?} event
                 * @return {?}
                 */function (/**
                 * @param {?} event
                 * @return {?}
                 */ event) {
                        return event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["ESCAPE"] && !_this_1.disableClose && !Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["hasModifierKey"])(event);
                    })))
                        .subscribe(( /**
                 * @param {?} event
                 * @return {?}
                 */function (/**
                 * @param {?} event
                 * @return {?}
                 */ event) {
                        event.preventDefault();
                        _this_1.close();
                    }));
                }
                /**
                 * Close the dialog.
                 * @param {?=} dialogResult Optional result to return to the dialog opener.
                 * @return {?}
                 */
                MatDialogRef.prototype.close = function (dialogResult) {
                    var _this_1 = this;
                    this._result = dialogResult;
                    // Transition the backdrop in parallel to the dialog.
                    this._containerInstance._animationStateChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["filter"])(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) { return event.phaseName === 'start'; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["take"])(1))
                        .subscribe(( /**
                 * @param {?} event
                 * @return {?}
                 */function (/**
                 * @param {?} event
                 * @return {?}
                 */ event) {
                        _this_1._beforeClosed.next(dialogResult);
                        _this_1._beforeClosed.complete();
                        _this_1._state = 2 /* CLOSED */;
                        _this_1._overlayRef.detachBackdrop();
                        // The logic that disposes of the overlay depends on the exit animation completing, however
                        // it isn't guaranteed if the parent view is destroyed while it's running. Add a fallback
                        // timeout which will clean everything up if the animation hasn't fired within the specified
                        // amount of time plus 100ms. We don't need to run this outside the NgZone, because for the
                        // vast majority of cases the timeout will have been cleared before it has the chance to fire.
                        _this_1._closeFallbackTimeout = setTimeout(( /**
                         * @return {?}
                         */function () {
                            _this_1._overlayRef.dispose();
                        }), event.totalTime + 100);
                    }));
                    this._containerInstance._startExitAnimation();
                    this._state = 1 /* CLOSING */;
                };
                /**
                 * Gets an observable that is notified when the dialog is finished opening.
                 * @return {?}
                 */
                MatDialogRef.prototype.afterOpened = function () {
                    return this._afterOpened.asObservable();
                };
                /**
                 * Gets an observable that is notified when the dialog is finished closing.
                 * @return {?}
                 */
                MatDialogRef.prototype.afterClosed = function () {
                    return this._afterClosed.asObservable();
                };
                /**
                 * Gets an observable that is notified when the dialog has started closing.
                 * @return {?}
                 */
                MatDialogRef.prototype.beforeClosed = function () {
                    return this._beforeClosed.asObservable();
                };
                /**
                 * Gets an observable that emits when the overlay's backdrop has been clicked.
                 * @return {?}
                 */
                MatDialogRef.prototype.backdropClick = function () {
                    return this._overlayRef.backdropClick();
                };
                /**
                 * Gets an observable that emits when keydown events are targeted on the overlay.
                 * @return {?}
                 */
                MatDialogRef.prototype.keydownEvents = function () {
                    return this._overlayRef.keydownEvents();
                };
                /**
                 * Updates the dialog's position.
                 * @template THIS
                 * @this {THIS}
                 * @param {?=} position New dialog position.
                 * @return {THIS}
                 */
                MatDialogRef.prototype.updatePosition = function (position) {
                    /** @type {?} */
                    var strategy = ( /** @type {?} */(this))._getPositionStrategy();
                    if (position && (position.left || position.right)) {
                        position.left ? strategy.left(position.left) : strategy.right(position.right);
                    }
                    else {
                        strategy.centerHorizontally();
                    }
                    if (position && (position.top || position.bottom)) {
                        position.top ? strategy.top(position.top) : strategy.bottom(position.bottom);
                    }
                    else {
                        strategy.centerVertically();
                    }
                    ( /** @type {?} */(this))._overlayRef.updatePosition();
                    return ( /** @type {?} */(this));
                };
                /**
                 * Updates the dialog's width and height.
                 * @template THIS
                 * @this {THIS}
                 * @param {?=} width New width of the dialog.
                 * @param {?=} height New height of the dialog.
                 * @return {THIS}
                 */
                MatDialogRef.prototype.updateSize = function (width, height) {
                    if (width === void 0) { width = ''; }
                    if (height === void 0) { height = ''; }
                    ( /** @type {?} */(this))._getPositionStrategy().width(width).height(height);
                    ( /** @type {?} */(this))._overlayRef.updatePosition();
                    return ( /** @type {?} */(this));
                };
                /**
                 * Add a CSS class or an array of classes to the overlay pane.
                 * @template THIS
                 * @this {THIS}
                 * @param {?} classes
                 * @return {THIS}
                 */
                MatDialogRef.prototype.addPanelClass = function (classes) {
                    ( /** @type {?} */(this))._overlayRef.addPanelClass(classes);
                    return ( /** @type {?} */(this));
                };
                /**
                 * Remove a CSS class or an array of classes from the overlay pane.
                 * @template THIS
                 * @this {THIS}
                 * @param {?} classes
                 * @return {THIS}
                 */
                MatDialogRef.prototype.removePanelClass = function (classes) {
                    ( /** @type {?} */(this))._overlayRef.removePanelClass(classes);
                    return ( /** @type {?} */(this));
                };
                /**
                 * Gets an observable that is notified when the dialog is finished opening.
                 * @deprecated Use `afterOpened` instead.
                 * \@breaking-change 8.0.0
                 * @return {?}
                 */
                MatDialogRef.prototype.afterOpen = function () {
                    return this.afterOpened();
                };
                /**
                 * Gets an observable that is notified when the dialog has started closing.
                 * @deprecated Use `beforeClosed` instead.
                 * \@breaking-change 8.0.0
                 * @return {?}
                 */
                MatDialogRef.prototype.beforeClose = function () {
                    return this.beforeClosed();
                };
                /**
                 * Gets the current state of the dialog's lifecycle.
                 * @return {?}
                 */
                MatDialogRef.prototype.getState = function () {
                    return this._state;
                };
                /**
                 * Fetches the position strategy object from the overlay ref.
                 * @private
                 * @return {?}
                 */
                MatDialogRef.prototype._getPositionStrategy = function () {
                    return ( /** @type {?} */(this._overlayRef.getConfig().positionStrategy));
                };
                return MatDialogRef;
            }());
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token that can be used to access the data that was passed in to a dialog.
             * @type {?}
             */
            var MAT_DIALOG_DATA = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["InjectionToken"]('MatDialogData');
            /**
             * Injection token that can be used to specify default dialog options.
             * @type {?}
             */
            var MAT_DIALOG_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["InjectionToken"]('mat-dialog-default-options');
            /**
             * Injection token that determines the scroll handling while the dialog is open.
             * @type {?}
             */
            var MAT_DIALOG_SCROLL_STRATEGY = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["InjectionToken"]('mat-dialog-scroll-strategy');
            /**
             * \@docs-private
             * @param {?} overlay
             * @return {?}
             */
            function MAT_DIALOG_SCROLL_STRATEGY_FACTORY(overlay) {
                return ( /**
                 * @return {?}
                 */function () { return overlay.scrollStrategies.block(); });
            }
            /**
             * \@docs-private
             * @param {?} overlay
             * @return {?}
             */
            function MAT_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {
                return ( /**
                 * @return {?}
                 */function () { return overlay.scrollStrategies.block(); });
            }
            /**
             * \@docs-private
             * @type {?}
             */
            var MAT_DIALOG_SCROLL_STRATEGY_PROVIDER = {
                provide: MAT_DIALOG_SCROLL_STRATEGY,
                deps: [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_9__["Overlay"]],
                useFactory: MAT_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY,
            };
            /**
             * Service to open Material Design modal dialogs.
             */
            var MatDialog = /** @class */ (function () {
                /**
                 * @param {?} _overlay
                 * @param {?} _injector
                 * @param {?} _location
                 * @param {?} _defaultOptions
                 * @param {?} scrollStrategy
                 * @param {?} _parentDialog
                 * @param {?} _overlayContainer
                 */
                function MatDialog(_overlay, _injector, _location, _defaultOptions, scrollStrategy, _parentDialog, _overlayContainer) {
                    var _this_1 = this;
                    this._overlay = _overlay;
                    this._injector = _injector;
                    this._location = _location;
                    this._defaultOptions = _defaultOptions;
                    this._parentDialog = _parentDialog;
                    this._overlayContainer = _overlayContainer;
                    this._openDialogsAtThisLevel = [];
                    this._afterAllClosedAtThisLevel = new rxjs__WEBPACK_IMPORTED_MODULE_6__["Subject"]();
                    this._afterOpenedAtThisLevel = new rxjs__WEBPACK_IMPORTED_MODULE_6__["Subject"]();
                    this._ariaHiddenElements = new Map();
                    // TODO (jelbourn): tighten the typing right-hand side of this expression.
                    /**
                     * Stream that emits when all open dialog have finished closing.
                     * Will emit on subscribe if there are no open dialogs to begin with.
                     */
                    this.afterAllClosed = ( /** @type {?} */(Object(rxjs__WEBPACK_IMPORTED_MODULE_6__["defer"])(( /**
                     * @return {?}
                     */function () { return _this_1.openDialogs.length ?
                        _this_1._afterAllClosed :
                        _this_1._afterAllClosed.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["startWith"])(undefined)); }))));
                    this._scrollStrategy = scrollStrategy;
                }
                Object.defineProperty(MatDialog.prototype, "openDialogs", {
                    /**
                     * Keeps track of the currently-open dialogs.
                     * @return {?}
                     */
                    get: function () {
                        return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDialog.prototype, "afterOpened", {
                    /**
                     * Stream that emits when a dialog has been opened.
                     * @return {?}
                     */
                    get: function () {
                        return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDialog.prototype, "afterOpen", {
                    /**
                     * Stream that emits when a dialog has been opened.
                     * @deprecated Use `afterOpened` instead.
                     * \@breaking-change 8.0.0
                     * @return {?}
                     */
                    get: function () {
                        return this.afterOpened;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDialog.prototype, "_afterAllClosed", {
                    /**
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var parent = this._parentDialog;
                        return parent ? parent._afterAllClosed : this._afterAllClosedAtThisLevel;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Opens a modal dialog containing the given component.
                 * @template T, D, R
                 * @param {?} componentOrTemplateRef Type of the component to load into the dialog,
                 *     or a TemplateRef to instantiate as the dialog content.
                 * @param {?=} config Extra configuration options.
                 * @return {?} Reference to the newly-opened dialog.
                 */
                MatDialog.prototype.open = function (componentOrTemplateRef, config) {
                    var _this_1 = this;
                    config = _applyConfigDefaults(config, this._defaultOptions || new MatDialogConfig());
                    if (config.id && this.getDialogById(config.id)) {
                        throw Error("Dialog with id \"" + config.id + "\" exists already. The dialog id must be unique.");
                    }
                    /** @type {?} */
                    var overlayRef = this._createOverlay(config);
                    /** @type {?} */
                    var dialogContainer = this._attachDialogContainer(overlayRef, config);
                    /** @type {?} */
                    var dialogRef = this._attachDialogContent(componentOrTemplateRef, dialogContainer, overlayRef, config);
                    // If this is the first dialog that we're opening, hide all the non-overlay content.
                    if (!this.openDialogs.length) {
                        this._hideNonDialogContentFromAssistiveTechnology();
                    }
                    this.openDialogs.push(dialogRef);
                    dialogRef.afterClosed().subscribe(( /**
                     * @return {?}
                     */function () { return _this_1._removeOpenDialog(dialogRef); }));
                    this.afterOpened.next(dialogRef);
                    return dialogRef;
                };
                /**
                 * Closes all of the currently-open dialogs.
                 * @return {?}
                 */
                MatDialog.prototype.closeAll = function () {
                    this._closeDialogs(this.openDialogs);
                };
                /**
                 * Finds an open dialog by its id.
                 * @param {?} id ID to use when looking up the dialog.
                 * @return {?}
                 */
                MatDialog.prototype.getDialogById = function (id) {
                    return this.openDialogs.find(( /**
                     * @param {?} dialog
                     * @return {?}
                     */function (/**
                     * @param {?} dialog
                     * @return {?}
                     */ dialog) { return dialog.id === id; }));
                };
                /**
                 * @return {?}
                 */
                MatDialog.prototype.ngOnDestroy = function () {
                    // Only close the dialogs at this level on destroy
                    // since the parent service may still be active.
                    this._closeDialogs(this._openDialogsAtThisLevel);
                    this._afterAllClosedAtThisLevel.complete();
                    this._afterOpenedAtThisLevel.complete();
                };
                /**
                 * Creates the overlay into which the dialog will be loaded.
                 * @private
                 * @param {?} config The dialog configuration.
                 * @return {?} A promise resolving to the OverlayRef for the created overlay.
                 */
                MatDialog.prototype._createOverlay = function (config) {
                    /** @type {?} */
                    var overlayConfig = this._getOverlayConfig(config);
                    return this._overlay.create(overlayConfig);
                };
                /**
                 * Creates an overlay config from a dialog config.
                 * @private
                 * @param {?} dialogConfig The dialog configuration.
                 * @return {?} The overlay configuration.
                 */
                MatDialog.prototype._getOverlayConfig = function (dialogConfig) {
                    /** @type {?} */
                    var state$$1 = new _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_9__["OverlayConfig"]({
                        positionStrategy: this._overlay.position().global(),
                        scrollStrategy: dialogConfig.scrollStrategy || this._scrollStrategy(),
                        panelClass: dialogConfig.panelClass,
                        hasBackdrop: dialogConfig.hasBackdrop,
                        direction: dialogConfig.direction,
                        minWidth: dialogConfig.minWidth,
                        minHeight: dialogConfig.minHeight,
                        maxWidth: dialogConfig.maxWidth,
                        maxHeight: dialogConfig.maxHeight,
                        disposeOnNavigation: dialogConfig.closeOnNavigation
                    });
                    if (dialogConfig.backdropClass) {
                        state$$1.backdropClass = dialogConfig.backdropClass;
                    }
                    return state$$1;
                };
                /**
                 * Attaches an MatDialogContainer to a dialog's already-created overlay.
                 * @private
                 * @param {?} overlay Reference to the dialog's underlying overlay.
                 * @param {?} config The dialog configuration.
                 * @return {?} A promise resolving to a ComponentRef for the attached container.
                 */
                MatDialog.prototype._attachDialogContainer = function (overlay, config) {
                    /** @type {?} */
                    var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
                    /** @type {?} */
                    var injector = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["PortalInjector"](userInjector || this._injector, new WeakMap([
                        [MatDialogConfig, config]
                    ]));
                    /** @type {?} */
                    var containerPortal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["ComponentPortal"](MatDialogContainer, config.viewContainerRef, injector, config.componentFactoryResolver);
                    /** @type {?} */
                    var containerRef = overlay.attach(containerPortal);
                    return containerRef.instance;
                };
                /**
                 * Attaches the user-provided component to the already-created MatDialogContainer.
                 * @private
                 * @template T, R
                 * @param {?} componentOrTemplateRef The type of component being loaded into the dialog,
                 *     or a TemplateRef to instantiate as the content.
                 * @param {?} dialogContainer Reference to the wrapping MatDialogContainer.
                 * @param {?} overlayRef Reference to the overlay in which the dialog resides.
                 * @param {?} config The dialog configuration.
                 * @return {?} A promise resolving to the MatDialogRef that should be returned to the user.
                 */
                MatDialog.prototype._attachDialogContent = function (componentOrTemplateRef, dialogContainer, overlayRef, config) {
                    // Create a reference to the dialog we're creating in order to give the user a handle
                    // to modify and close it.
                    /** @type {?} */
                    var dialogRef = new MatDialogRef(overlayRef, dialogContainer, this._location, config.id);
                    // When the dialog backdrop is clicked, we want to close it.
                    if (config.hasBackdrop) {
                        overlayRef.backdropClick().subscribe(( /**
                         * @return {?}
                         */function () {
                            if (!dialogRef.disableClose) {
                                dialogRef.close();
                            }
                        }));
                    }
                    if (componentOrTemplateRef instanceof _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]) {
                        dialogContainer.attachTemplatePortal(new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["TemplatePortal"](componentOrTemplateRef, ( /** @type {?} */(null)), ( /** @type {?} */({ $implicit: config.data, dialogRef: dialogRef }))));
                    }
                    else {
                        /** @type {?} */
                        var injector = this._createInjector(config, dialogRef, dialogContainer);
                        /** @type {?} */
                        var contentRef = dialogContainer.attachComponentPortal(new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["ComponentPortal"](componentOrTemplateRef, undefined, injector));
                        dialogRef.componentInstance = contentRef.instance;
                    }
                    dialogRef
                        .updateSize(config.width, config.height)
                        .updatePosition(config.position);
                    return dialogRef;
                };
                /**
                 * Creates a custom injector to be used inside the dialog. This allows a component loaded inside
                 * of a dialog to close itself and, optionally, to return a value.
                 * @private
                 * @template T
                 * @param {?} config Config object that is used to construct the dialog.
                 * @param {?} dialogRef Reference to the dialog.
                 * @param {?} dialogContainer
                 * @return {?} The custom injector that can be used inside the dialog.
                 */
                MatDialog.prototype._createInjector = function (config, dialogRef, dialogContainer) {
                    /** @type {?} */
                    var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
                    // The MatDialogContainer is injected in the portal as the MatDialogContainer and the dialog's
                    // content are created out of the same ViewContainerRef and as such, are siblings for injector
                    // purposes. To allow the hierarchy that is expected, the MatDialogContainer is explicitly
                    // added to the injection tokens.
                    /** @type {?} */
                    var injectionTokens = new WeakMap([
                        [MatDialogContainer, dialogContainer],
                        [MAT_DIALOG_DATA, config.data],
                        [MatDialogRef, dialogRef]
                    ]);
                    if (config.direction &&
                        (!userInjector || !userInjector.get(_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_8__["Directionality"], null))) {
                        injectionTokens.set(_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_8__["Directionality"], {
                            value: config.direction,
                            change: Object(rxjs__WEBPACK_IMPORTED_MODULE_6__["of"])()
                        });
                    }
                    return new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["PortalInjector"](userInjector || this._injector, injectionTokens);
                };
                /**
                 * Removes a dialog from the array of open dialogs.
                 * @private
                 * @param {?} dialogRef Dialog to be removed.
                 * @return {?}
                 */
                MatDialog.prototype._removeOpenDialog = function (dialogRef) {
                    /** @type {?} */
                    var index = this.openDialogs.indexOf(dialogRef);
                    if (index > -1) {
                        this.openDialogs.splice(index, 1);
                        // If all the dialogs were closed, remove/restore the `aria-hidden`
                        // to a the siblings and emit to the `afterAllClosed` stream.
                        if (!this.openDialogs.length) {
                            this._ariaHiddenElements.forEach(( /**
                             * @param {?} previousValue
                             * @param {?} element
                             * @return {?}
                             */function (previousValue, element) {
                                if (previousValue) {
                                    element.setAttribute('aria-hidden', previousValue);
                                }
                                else {
                                    element.removeAttribute('aria-hidden');
                                }
                            }));
                            this._ariaHiddenElements.clear();
                            this._afterAllClosed.next();
                        }
                    }
                };
                /**
                 * Hides all of the content that isn't an overlay from assistive technology.
                 * @private
                 * @return {?}
                 */
                MatDialog.prototype._hideNonDialogContentFromAssistiveTechnology = function () {
                    /** @type {?} */
                    var overlayContainer = this._overlayContainer.getContainerElement();
                    // Ensure that the overlay container is attached to the DOM.
                    if (overlayContainer.parentElement) {
                        /** @type {?} */
                        var siblings = overlayContainer.parentElement.children;
                        for (var i = siblings.length - 1; i > -1; i--) {
                            /** @type {?} */
                            var sibling = siblings[i];
                            if (sibling !== overlayContainer &&
                                sibling.nodeName !== 'SCRIPT' &&
                                sibling.nodeName !== 'STYLE' &&
                                !sibling.hasAttribute('aria-live')) {
                                this._ariaHiddenElements.set(sibling, sibling.getAttribute('aria-hidden'));
                                sibling.setAttribute('aria-hidden', 'true');
                            }
                        }
                    }
                };
                /**
                 * Closes all of the dialogs in an array.
                 * @private
                 * @param {?} dialogs
                 * @return {?}
                 */
                MatDialog.prototype._closeDialogs = function (dialogs) {
                    /** @type {?} */
                    var i = dialogs.length;
                    while (i--) {
                        // The `_openDialogs` property isn't updated after close until the rxjs subscription
                        // runs on the next microtask, in addition to modifying the array as we're going
                        // through it. We loop through all of them and call close without assuming that
                        // they'll be removed from the list instantaneously.
                        dialogs[i].close();
                    }
                };
                return MatDialog;
            }());
            MatDialog.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"] },
            ];
            /** @nocollapse */
            MatDialog.ctorParameters = function () { return [
                { type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_9__["Overlay"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injector"] },
                { type: _angular_common__WEBPACK_IMPORTED_MODULE_2__["Location"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] },
                { type: MatDialogConfig, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [MAT_DIALOG_DEFAULT_OPTIONS,] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [MAT_DIALOG_SCROLL_STRATEGY,] }] },
                { type: MatDialog, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["SkipSelf"] }] },
                { type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_9__["OverlayContainer"] }
            ]; };
            /**
             * Applies default options to the dialog config.
             * @param {?=} config Config to be modified.
             * @param {?=} defaultOptions Default options provided.
             * @return {?} The new configuration object.
             */
            function _applyConfigDefaults(config, defaultOptions) {
                return Object.assign({}, defaultOptions, config);
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Counter used to generate unique IDs for dialog elements.
             * @type {?}
             */
            var dialogElementUid = 0;
            /**
             * Button that will close the current dialog.
             */
            var MatDialogClose = /** @class */ (function () {
                /**
                 * @param {?} dialogRef
                 * @param {?} _elementRef
                 * @param {?} _dialog
                 */
                function MatDialogClose(dialogRef, _elementRef, _dialog) {
                    this.dialogRef = dialogRef;
                    this._elementRef = _elementRef;
                    this._dialog = _dialog;
                    /**
                     * Default to "button" to prevents accidental form submits.
                     */
                    this.type = 'button';
                }
                /**
                 * @return {?}
                 */
                MatDialogClose.prototype.ngOnInit = function () {
                    if (!this.dialogRef) {
                        // When this directive is included in a dialog via TemplateRef (rather than being
                        // in a Component), the DialogRef isn't available via injection because embedded
                        // views cannot be given a custom injector. Instead, we look up the DialogRef by
                        // ID. This must occur in `onInit`, as the ID binding for the dialog container won't
                        // be resolved at constructor time.
                        this.dialogRef = ( /** @type {?} */(getClosestDialog(this._elementRef, this._dialog.openDialogs)));
                    }
                };
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                MatDialogClose.prototype.ngOnChanges = function (changes) {
                    /** @type {?} */
                    var proxiedChange = changes['_matDialogClose'] || changes['_matDialogCloseResult'];
                    if (proxiedChange) {
                        this.dialogResult = proxiedChange.currentValue;
                    }
                };
                return MatDialogClose;
            }());
            MatDialogClose.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[mat-dialog-close], [matDialogClose]',
                            exportAs: 'matDialogClose',
                            host: {
                                '(click)': 'dialogRef.close(dialogResult)',
                                '[attr.aria-label]': 'ariaLabel || null',
                                '[attr.type]': 'type',
                            }
                        },] },
            ];
            /** @nocollapse */
            MatDialogClose.ctorParameters = function () { return [
                { type: MatDialogRef, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
                { type: MatDialog }
            ]; };
            MatDialogClose.propDecorators = {
                ariaLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['aria-label',] }],
                type: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                dialogResult: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['mat-dialog-close',] }],
                _matDialogClose: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['matDialogClose',] }]
            };
            /**
             * Title of a dialog element. Stays fixed to the top of the dialog when scrolling.
             */
            var MatDialogTitle = /** @class */ (function () {
                /**
                 * @param {?} _dialogRef
                 * @param {?} _elementRef
                 * @param {?} _dialog
                 */
                function MatDialogTitle(_dialogRef, _elementRef, _dialog) {
                    this._dialogRef = _dialogRef;
                    this._elementRef = _elementRef;
                    this._dialog = _dialog;
                    this.id = "mat-dialog-title-" + dialogElementUid++;
                }
                /**
                 * @return {?}
                 */
                MatDialogTitle.prototype.ngOnInit = function () {
                    var _this_1 = this;
                    if (!this._dialogRef) {
                        this._dialogRef = ( /** @type {?} */(getClosestDialog(this._elementRef, this._dialog.openDialogs)));
                    }
                    if (this._dialogRef) {
                        Promise.resolve().then(( /**
                         * @return {?}
                         */function () {
                            /** @type {?} */
                            var container = _this_1._dialogRef._containerInstance;
                            if (container && !container._ariaLabelledBy) {
                                container._ariaLabelledBy = _this_1.id;
                            }
                        }));
                    }
                };
                return MatDialogTitle;
            }());
            MatDialogTitle.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[mat-dialog-title], [matDialogTitle]',
                            exportAs: 'matDialogTitle',
                            host: {
                                'class': 'mat-dialog-title',
                                '[id]': 'id',
                            },
                        },] },
            ];
            /** @nocollapse */
            MatDialogTitle.ctorParameters = function () { return [
                { type: MatDialogRef, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
                { type: MatDialog }
            ]; };
            MatDialogTitle.propDecorators = {
                id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
            };
            /**
             * Scrollable content container of a dialog.
             */
            var MatDialogContent = /** @class */ (function () {
                function MatDialogContent() {
                }
                return MatDialogContent;
            }());
            MatDialogContent.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: "[mat-dialog-content], mat-dialog-content, [matDialogContent]",
                            host: { 'class': 'mat-dialog-content' }
                        },] },
            ];
            /**
             * Container for the bottom action buttons in a dialog.
             * Stays fixed to the bottom when scrolling.
             */
            var MatDialogActions = /** @class */ (function () {
                function MatDialogActions() {
                }
                return MatDialogActions;
            }());
            MatDialogActions.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: "[mat-dialog-actions], mat-dialog-actions, [matDialogActions]",
                            host: { 'class': 'mat-dialog-actions' }
                        },] },
            ];
            /**
             * Finds the closest MatDialogRef to an element by looking at the DOM.
             * @param {?} element Element relative to which to look for a dialog.
             * @param {?} openDialogs References to the currently-open dialogs.
             * @return {?}
             */
            function getClosestDialog(element, openDialogs) {
                /** @type {?} */
                var parent = element.nativeElement.parentElement;
                while (parent && !parent.classList.contains('mat-dialog-container')) {
                    parent = parent.parentElement;
                }
                return parent ? openDialogs.find(( /**
                 * @param {?} dialog
                 * @return {?}
                 */function (/**
                 * @param {?} dialog
                 * @return {?}
                 */ dialog) { return dialog.id === ( /** @type {?} */(parent)).id; })) : null;
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatDialogModule = /** @class */ (function () {
                function MatDialogModule() {
                }
                return MatDialogModule;
            }());
            MatDialogModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                            imports: [
                                _angular_common__WEBPACK_IMPORTED_MODULE_2__["CommonModule"],
                                _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_9__["OverlayModule"],
                                _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["PortalModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_10__["MatCommonModule"],
                            ],
                            exports: [
                                MatDialogContainer,
                                MatDialogClose,
                                MatDialogTitle,
                                MatDialogContent,
                                MatDialogActions,
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_10__["MatCommonModule"],
                            ],
                            declarations: [
                                MatDialogContainer,
                                MatDialogClose,
                                MatDialogTitle,
                                MatDialogActions,
                                MatDialogContent,
                            ],
                            providers: [
                                MatDialog,
                                MAT_DIALOG_SCROLL_STRATEGY_PROVIDER,
                            ],
                            entryComponents: [MatDialogContainer],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=dialog.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/expansion.js": 
        /*!*************************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/expansion.js ***!
          \*************************************************************/
        /*! exports provided: MatExpansionModule, MatAccordion, MAT_ACCORDION, MAT_EXPANSION_PANEL_DEFAULT_OPTIONS, MatExpansionPanel, MatExpansionPanelActionRow, MatExpansionPanelHeader, MatExpansionPanelDescription, MatExpansionPanelTitle, MatExpansionPanelContent, EXPANSION_PANEL_ANIMATION_TIMING, matExpansionAnimations */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatExpansionModule", function () { return MatExpansionModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatAccordion", function () { return MatAccordion; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_ACCORDION", function () { return MAT_ACCORDION; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_EXPANSION_PANEL_DEFAULT_OPTIONS", function () { return MAT_EXPANSION_PANEL_DEFAULT_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatExpansionPanel", function () { return MatExpansionPanel; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatExpansionPanelActionRow", function () { return MatExpansionPanelActionRow; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatExpansionPanelHeader", function () { return MatExpansionPanelHeader; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatExpansionPanelDescription", function () { return MatExpansionPanelDescription; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatExpansionPanelTitle", function () { return MatExpansionPanelTitle; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatExpansionPanelContent", function () { return MatExpansionPanelContent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EXPANSION_PANEL_ANIMATION_TIMING", function () { return EXPANSION_PANEL_ANIMATION_TIMING; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matExpansionAnimations", function () { return matExpansionAnimations; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/animations */ "./node_modules/@angular/animations/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_accordion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/accordion */ "./node_modules/@angular/cdk/esm2015/accordion.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/collections */ "./node_modules/@angular/cdk/esm2015/collections.js");
            /* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/portal */ "./node_modules/@angular/cdk/esm2015/portal.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Token used to provide a `MatAccordion` to `MatExpansionPanel`.
             * Used primarily to avoid circular imports between `MatAccordion` and `MatExpansionPanel`.
             * @type {?}
             */
            var MAT_ACCORDION = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('MAT_ACCORDION');
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Time and timing curve for expansion panel animations.
             * @type {?}
             */
            var EXPANSION_PANEL_ANIMATION_TIMING = '225ms cubic-bezier(0.4,0.0,0.2,1)';
            /**
             * Animations used by the Material expansion panel.
             *
             * A bug in angular animation's `state` when ViewContainers are moved using ViewContainerRef.move()
             * causes the animation state of moved components to become `void` upon exit, and not update again
             * upon reentry into the DOM.  This can lead a to situation for the expansion panel where the state
             * of the panel is `expanded` or `collapsed` but the animation state is `void`.
             *
             * To correctly handle animating to the next state, we animate between `void` and `collapsed` which
             * are defined to have the same styles. Since angular animates from the current styles to the
             * destination state's style definition, in situations where we are moving from `void`'s styles to
             * `collapsed` this acts a noop since no style values change.
             *
             * In the case where angular's animation state is out of sync with the expansion panel's state, the
             * expansion panel being `expanded` and angular animations being `void`, the animation from the
             * `expanded`'s effective styles (though in a `void` animation state) to the collapsed state will
             * occur as expected.
             *
             * Angular Bug: https://github.com/angular/angular/issues/18847
             *
             * \@docs-private
             * @type {?}
             */
            var matExpansionAnimations = {
                /**
                 * Animation that rotates the indicator arrow.
                 */
                indicatorRotate: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["trigger"])('indicatorRotate', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["state"])('collapsed, void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["style"])({ transform: 'rotate(0deg)' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["state"])('expanded', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["style"])({ transform: 'rotate(180deg)' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["transition"])('expanded <=> collapsed, void => collapsed', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["animate"])(EXPANSION_PANEL_ANIMATION_TIMING)),
                ]),
                /**
                 * Animation that expands and collapses the panel header height.
                 */
                expansionHeaderHeight: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["trigger"])('expansionHeight', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["state"])('collapsed, void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["style"])({
                        height: '{{collapsedHeight}}',
                    }), {
                        params: { collapsedHeight: '48px' },
                    }),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["state"])('expanded', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["style"])({
                        height: '{{expandedHeight}}'
                    }), {
                        params: { expandedHeight: '64px' }
                    }),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["transition"])('expanded <=> collapsed, void => collapsed', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["group"])([
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["query"])('@indicatorRotate', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["animateChild"])(), { optional: true }),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["animate"])(EXPANSION_PANEL_ANIMATION_TIMING),
                    ])),
                ]),
                /**
                 * Animation that expands and collapses the panel content.
                 */
                bodyExpansion: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["trigger"])('bodyExpansion', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["state"])('collapsed, void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["style"])({ height: '0px', visibility: 'hidden' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["state"])('expanded', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["style"])({ height: '*', visibility: 'visible' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["transition"])('expanded <=> collapsed, void => collapsed', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["animate"])(EXPANSION_PANEL_ANIMATION_TIMING)),
                ])
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Expansion panel content that will be rendered lazily
             * after the panel is opened for the first time.
             */
            var MatExpansionPanelContent = /** @class */ (function () {
                /**
                 * @param {?} _template
                 */
                function MatExpansionPanelContent(_template) {
                    this._template = _template;
                }
                return MatExpansionPanelContent;
            }());
            MatExpansionPanelContent.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'ng-template[matExpansionPanelContent]'
                        },] },
            ];
            /** @nocollapse */
            MatExpansionPanelContent.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Counter for generating unique element ids.
             * @type {?}
             */
            var uniqueId = 0;
            /**
             * Injection token that can be used to configure the defalt
             * options for the expansion panel component.
             * @type {?}
             */
            var MAT_EXPANSION_PANEL_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('MAT_EXPANSION_PANEL_DEFAULT_OPTIONS');
            var ɵ0 = undefined;
            /**
             * `<mat-expansion-panel>`
             *
             * This component can be used as a single element to show expandable content, or as one of
             * multiple children of an element with the MatAccordion directive attached.
             */
            var MatExpansionPanel = /** @class */ (function (_super) {
                __extends(MatExpansionPanel, _super);
                /**
                 * @param {?} accordion
                 * @param {?} _changeDetectorRef
                 * @param {?} _uniqueSelectionDispatcher
                 * @param {?} _viewContainerRef
                 * @param {?} _document
                 * @param {?} _animationMode
                 * @param {?=} defaultOptions
                 */
                function MatExpansionPanel(accordion, _changeDetectorRef, _uniqueSelectionDispatcher, _viewContainerRef, _document, _animationMode, defaultOptions) {
                    var _this_1 = _super.call(this, accordion, _changeDetectorRef, _uniqueSelectionDispatcher) || this;
                    _this_1._viewContainerRef = _viewContainerRef;
                    _this_1._animationMode = _animationMode;
                    _this_1._hideToggle = false;
                    /**
                     * An event emitted after the body's expansion animation happens.
                     */
                    _this_1.afterExpand = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * An event emitted after the body's collapse animation happens.
                     */
                    _this_1.afterCollapse = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Stream that emits for changes in `\@Input` properties.
                     */
                    _this_1._inputChanges = new rxjs__WEBPACK_IMPORTED_MODULE_8__["Subject"]();
                    /**
                     * ID for the associated header element. Used for a11y labelling.
                     */
                    _this_1._headerId = "mat-expansion-panel-header-" + uniqueId++;
                    /**
                     * Stream of body animation done events.
                     */
                    _this_1._bodyAnimationDone = new rxjs__WEBPACK_IMPORTED_MODULE_8__["Subject"]();
                    _this_1.accordion = accordion;
                    _this_1._document = _document;
                    // We need a Subject with distinctUntilChanged, because the `done` event
                    // fires twice on some browsers. See https://github.com/angular/angular/issues/24084
                    _this_1._bodyAnimationDone.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["distinctUntilChanged"])(( /**
                     * @param {?} x
                     * @param {?} y
                     * @return {?}
                     */function (x, y) {
                        return x.fromState === y.fromState && x.toState === y.toState;
                    }))).subscribe(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) {
                        if (event.fromState !== 'void') {
                            if (event.toState === 'expanded') {
                                _this_1.afterExpand.emit();
                            }
                            else if (event.toState === 'collapsed') {
                                _this_1.afterCollapse.emit();
                            }
                        }
                    }));
                    if (defaultOptions) {
                        _this_1.hideToggle = defaultOptions.hideToggle;
                    }
                    return _this_1;
                }
                Object.defineProperty(MatExpansionPanel.prototype, "hideToggle", {
                    /**
                     * Whether the toggle indicator should be hidden.
                     * @return {?}
                     */
                    get: function () {
                        return this._hideToggle || (this.accordion && this.accordion.hideToggle);
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._hideToggle = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatExpansionPanel.prototype, "togglePosition", {
                    /**
                     * The position of the expansion indicator.
                     * @return {?}
                     */
                    get: function () {
                        return this._togglePosition || (this.accordion && this.accordion.togglePosition);
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._togglePosition = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Determines whether the expansion panel should have spacing between it and its siblings.
                 * @return {?}
                 */
                MatExpansionPanel.prototype._hasSpacing = function () {
                    if (this.accordion) {
                        // We don't need to subscribe to the `stateChanges` of the parent accordion because each time
                        // the [displayMode] input changes, the change detection will also cover the host bindings
                        // of this expansion panel.
                        return (this.expanded ? this.accordion.displayMode : this._getExpandedState()) === 'default';
                    }
                    return false;
                };
                /**
                 * Gets the expanded state string.
                 * @return {?}
                 */
                MatExpansionPanel.prototype._getExpandedState = function () {
                    return this.expanded ? 'expanded' : 'collapsed';
                };
                /**
                 * @return {?}
                 */
                MatExpansionPanel.prototype.ngAfterContentInit = function () {
                    var _this_1 = this;
                    if (this._lazyContent) {
                        // Render the content as soon as the panel becomes open.
                        this.opened.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["startWith"])(( /** @type {?} */(null))), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["filter"])(( /**
                         * @return {?}
                         */function () { return _this_1.expanded && !_this_1._portal; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["take"])(1)).subscribe(( /**
                         * @return {?}
                         */function () {
                            _this_1._portal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__["TemplatePortal"](_this_1._lazyContent._template, _this_1._viewContainerRef);
                        }));
                    }
                };
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                MatExpansionPanel.prototype.ngOnChanges = function (changes) {
                    this._inputChanges.next(changes);
                };
                /**
                 * @return {?}
                 */
                MatExpansionPanel.prototype.ngOnDestroy = function () {
                    _super.prototype.ngOnDestroy.call(this);
                    this._bodyAnimationDone.complete();
                    this._inputChanges.complete();
                };
                /**
                 * Checks whether the expansion panel's content contains the currently-focused element.
                 * @return {?}
                 */
                MatExpansionPanel.prototype._containsFocus = function () {
                    if (this._body) {
                        /** @type {?} */
                        var focusedElement = this._document.activeElement;
                        /** @type {?} */
                        var bodyElement = this._body.nativeElement;
                        return focusedElement === bodyElement || bodyElement.contains(focusedElement);
                    }
                    return false;
                };
                return MatExpansionPanel;
            }(_angular_cdk_accordion__WEBPACK_IMPORTED_MODULE_2__["CdkAccordionItem"]));
            MatExpansionPanel.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ styles: [".mat-expansion-panel{box-sizing:content-box;display:block;margin:0;border-radius:4px;overflow:hidden;transition:margin 225ms cubic-bezier(.4,0,.2,1),box-shadow 280ms cubic-bezier(.4,0,.2,1)}.mat-accordion .mat-expansion-panel:not(.mat-expanded),.mat-accordion .mat-expansion-panel:not(.mat-expansion-panel-spacing){border-radius:0}.mat-accordion .mat-expansion-panel:first-of-type{border-top-right-radius:4px;border-top-left-radius:4px}.mat-accordion .mat-expansion-panel:last-of-type{border-bottom-right-radius:4px;border-bottom-left-radius:4px}@media (-ms-high-contrast:active){.mat-expansion-panel{outline:solid 1px}}.mat-expansion-panel._mat-animation-noopable,.mat-expansion-panel.ng-animate-disabled,.ng-animate-disabled .mat-expansion-panel{transition:none}.mat-expansion-panel-content{display:flex;flex-direction:column;overflow:visible}.mat-expansion-panel-body{padding:0 24px 16px}.mat-expansion-panel-spacing{margin:16px 0}.mat-accordion>.mat-expansion-panel-spacing:first-child,.mat-accordion>:first-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-top:0}.mat-accordion>.mat-expansion-panel-spacing:last-child,.mat-accordion>:last-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-bottom:0}.mat-action-row{border-top-style:solid;border-top-width:1px;display:flex;flex-direction:row;justify-content:flex-end;padding:16px 8px 16px 24px}.mat-action-row button.mat-button-base{margin-left:8px}[dir=rtl] .mat-action-row button.mat-button-base{margin-left:0;margin-right:8px}"],
                            selector: 'mat-expansion-panel',
                            exportAs: 'matExpansionPanel',
                            template: "<ng-content select=\"mat-expansion-panel-header\"></ng-content><div class=\"mat-expansion-panel-content\" role=\"region\" [@bodyExpansion]=\"_getExpandedState()\" (@bodyExpansion.done)=\"_bodyAnimationDone.next($event)\" [attr.aria-labelledby]=\"_headerId\" [id]=\"id\" #body><div class=\"mat-expansion-panel-body\"><ng-content></ng-content><ng-template [cdkPortalOutlet]=\"_portal\"></ng-template></div><ng-content select=\"mat-action-row\"></ng-content></div>",
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            inputs: ['disabled', 'expanded'],
                            outputs: ['opened', 'closed', 'expandedChange'],
                            animations: [matExpansionAnimations.bodyExpansion],
                            providers: [
                                // Provide MatAccordion as undefined to prevent nested expansion panels from registering
                                // to the same accordion.
                                { provide: MAT_ACCORDION, useValue: ɵ0 },
                            ],
                            host: {
                                'class': 'mat-expansion-panel',
                                '[class.mat-expanded]': 'expanded',
                                '[class._mat-animation-noopable]': '_animationMode === "NoopAnimations"',
                                '[class.mat-expansion-panel-spacing]': '_hasSpacing()',
                            }
                        },] },
            ];
            /** @nocollapse */
            MatExpansionPanel.ctorParameters = function () { return [
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["SkipSelf"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [MAT_ACCORDION,] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_4__["UniqueSelectionDispatcher"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_6__["DOCUMENT"],] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_7__["ANIMATION_MODULE_TYPE"],] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [MAT_EXPANSION_PANEL_DEFAULT_OPTIONS,] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] }
            ]; };
            MatExpansionPanel.propDecorators = {
                hideToggle: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                togglePosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                afterExpand: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                afterCollapse: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                _lazyContent: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChild"], args: [MatExpansionPanelContent, { static: false },] }],
                _body: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['body', { static: false },] }]
            };
            var MatExpansionPanelActionRow = /** @class */ (function () {
                function MatExpansionPanelActionRow() {
                }
                return MatExpansionPanelActionRow;
            }());
            MatExpansionPanelActionRow.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'mat-action-row',
                            host: {
                                class: 'mat-action-row'
                            }
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * `<mat-expansion-panel-header>`
             *
             * This component corresponds to the header element of an `<mat-expansion-panel>`.
             */
            var MatExpansionPanelHeader = /** @class */ (function () {
                /**
                 * @param {?} panel
                 * @param {?} _element
                 * @param {?} _focusMonitor
                 * @param {?} _changeDetectorRef
                 * @param {?=} defaultOptions
                 */
                function MatExpansionPanelHeader(panel, _element, _focusMonitor, _changeDetectorRef, defaultOptions) {
                    var _this_1 = this;
                    this.panel = panel;
                    this._element = _element;
                    this._focusMonitor = _focusMonitor;
                    this._changeDetectorRef = _changeDetectorRef;
                    this._parentChangeSubscription = rxjs__WEBPACK_IMPORTED_MODULE_8__["Subscription"].EMPTY;
                    /**
                     * Whether Angular animations in the panel header should be disabled.
                     */
                    this._animationsDisabled = true;
                    /** @type {?} */
                    var accordionHideToggleChange = panel.accordion ?
                        panel.accordion._stateChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["filter"])(( /**
                         * @param {?} changes
                         * @return {?}
                         */function (/**
                         * @param {?} changes
                         * @return {?}
                         */ changes) { return !!(changes['hideToggle'] || changes['togglePosition']); }))) :
                        rxjs__WEBPACK_IMPORTED_MODULE_8__["EMPTY"];
                    // Since the toggle state depends on an @Input on the panel, we
                    // need to subscribe and trigger change detection manually.
                    this._parentChangeSubscription =
                        Object(rxjs__WEBPACK_IMPORTED_MODULE_8__["merge"])(panel.opened, panel.closed, accordionHideToggleChange, panel._inputChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["filter"])(( /**
                         * @param {?} changes
                         * @return {?}
                         */function (/**
                         * @param {?} changes
                         * @return {?}
                         */ changes) {
                            return !!(changes['hideToggle'] ||
                                changes['disabled'] ||
                                changes['togglePosition']);
                        }))))
                            .subscribe(( /**
                     * @return {?}
                     */function () { return _this_1._changeDetectorRef.markForCheck(); }));
                    // Avoids focus being lost if the panel contained the focused element and was closed.
                    panel.closed
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["filter"])(( /**
                 * @return {?}
                 */function () { return panel._containsFocus(); })))
                        .subscribe(( /**
                 * @return {?}
                 */function () { return _focusMonitor.focusVia(_element, 'program'); }));
                    _focusMonitor.monitor(_element).subscribe(( /**
                     * @param {?} origin
                     * @return {?}
                     */function (/**
                     * @param {?} origin
                     * @return {?}
                     */ origin) {
                        if (origin && panel.accordion) {
                            panel.accordion._handleHeaderFocus(_this_1);
                        }
                    }));
                    if (defaultOptions) {
                        this.expandedHeight = defaultOptions.expandedHeight;
                        this.collapsedHeight = defaultOptions.collapsedHeight;
                    }
                }
                /**
                 * @return {?}
                 */
                MatExpansionPanelHeader.prototype._animationStarted = function () {
                    // Currently the `expansionHeight` animation has a `void => collapsed` transition which is
                    // there to work around a bug in Angular (see #13088), however this introduces a different
                    // issue. The new transition will cause the header to animate in on init (see #16067), if the
                    // consumer has set a header height that is different from the default one. We work around it
                    // by disabling animations on the header and re-enabling them after the first animation has run.
                    // Note that Angular dispatches animation events even if animations are disabled. Ideally this
                    // wouldn't be necessary if we remove the `void => collapsed` transition, but we have to wait
                    // for https://github.com/angular/angular/issues/18847 to be resolved.
                    this._animationsDisabled = false;
                };
                Object.defineProperty(MatExpansionPanelHeader.prototype, "disabled", {
                    /**
                     * Whether the associated panel is disabled. Implemented as a part of `FocusableOption`.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () {
                        return this.panel.disabled;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Toggles the expanded state of the panel.
                 * @return {?}
                 */
                MatExpansionPanelHeader.prototype._toggle = function () {
                    this.panel.toggle();
                };
                /**
                 * Gets whether the panel is expanded.
                 * @return {?}
                 */
                MatExpansionPanelHeader.prototype._isExpanded = function () {
                    return this.panel.expanded;
                };
                /**
                 * Gets the expanded state string of the panel.
                 * @return {?}
                 */
                MatExpansionPanelHeader.prototype._getExpandedState = function () {
                    return this.panel._getExpandedState();
                };
                /**
                 * Gets the panel id.
                 * @return {?}
                 */
                MatExpansionPanelHeader.prototype._getPanelId = function () {
                    return this.panel.id;
                };
                /**
                 * Gets the toggle position for the header.
                 * @return {?}
                 */
                MatExpansionPanelHeader.prototype._getTogglePosition = function () {
                    return this.panel.togglePosition;
                };
                /**
                 * Gets whether the expand indicator should be shown.
                 * @return {?}
                 */
                MatExpansionPanelHeader.prototype._showToggle = function () {
                    return !this.panel.hideToggle && !this.panel.disabled;
                };
                /**
                 * Handle keydown event calling to toggle() if appropriate.
                 * @param {?} event
                 * @return {?}
                 */
                MatExpansionPanelHeader.prototype._keydown = function (event) {
                    switch (event.keyCode) {
                        // Toggle for space and enter keys.
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["SPACE"]:
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["ENTER"]:
                            if (!Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["hasModifierKey"])(event)) {
                                event.preventDefault();
                                this._toggle();
                            }
                            break;
                        default:
                            if (this.panel.accordion) {
                                this.panel.accordion._handleHeaderKeydown(event);
                            }
                            return;
                    }
                };
                /**
                 * Focuses the panel header. Implemented as a part of `FocusableOption`.
                 * \@docs-private
                 * @param {?=} origin Origin of the action that triggered the focus.
                 * @param {?=} options
                 * @return {?}
                 */
                MatExpansionPanelHeader.prototype.focus = function (origin, options) {
                    if (origin === void 0) { origin = 'program'; }
                    this._focusMonitor.focusVia(this._element, origin, options);
                };
                /**
                 * @return {?}
                 */
                MatExpansionPanelHeader.prototype.ngOnDestroy = function () {
                    this._parentChangeSubscription.unsubscribe();
                    this._focusMonitor.stopMonitoring(this._element);
                };
                return MatExpansionPanelHeader;
            }());
            MatExpansionPanelHeader.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-expansion-panel-header',
                            styles: [".mat-expansion-panel-header{display:flex;flex-direction:row;align-items:center;padding:0 24px;border-radius:inherit}.mat-expansion-panel-header:focus,.mat-expansion-panel-header:hover{outline:0}.mat-expansion-panel-header.mat-expanded:focus,.mat-expansion-panel-header.mat-expanded:hover{background:inherit}.mat-expansion-panel-header:not([aria-disabled=true]){cursor:pointer}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before{flex-direction:row-reverse}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 16px 0 0}[dir=rtl] .mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 0 0 16px}.mat-content{display:flex;flex:1;flex-direction:row;overflow:hidden}.mat-expansion-panel-header-description,.mat-expansion-panel-header-title{display:flex;flex-grow:1;margin-right:16px}[dir=rtl] .mat-expansion-panel-header-description,[dir=rtl] .mat-expansion-panel-header-title{margin-right:0;margin-left:16px}.mat-expansion-panel-header-description{flex-grow:2}.mat-expansion-indicator::after{border-style:solid;border-width:0 2px 2px 0;content:'';display:inline-block;padding:3px;transform:rotate(45deg);vertical-align:middle}"],
                            template: "<span class=\"mat-content\"><ng-content select=\"mat-panel-title\"></ng-content><ng-content select=\"mat-panel-description\"></ng-content><ng-content></ng-content></span><span [@indicatorRotate]=\"_getExpandedState()\" *ngIf=\"_showToggle()\" class=\"mat-expansion-indicator\"></span>",
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            animations: [
                                matExpansionAnimations.indicatorRotate,
                                matExpansionAnimations.expansionHeaderHeight
                            ],
                            host: {
                                'class': 'mat-expansion-panel-header',
                                'role': 'button',
                                '[attr.id]': 'panel._headerId',
                                '[attr.tabindex]': 'disabled ? -1 : 0',
                                '[attr.aria-controls]': '_getPanelId()',
                                '[attr.aria-expanded]': '_isExpanded()',
                                '[attr.aria-disabled]': 'panel.disabled',
                                '[class.mat-expanded]': '_isExpanded()',
                                '[class.mat-expansion-toggle-indicator-after]': "_getTogglePosition() === 'after'",
                                '[class.mat-expansion-toggle-indicator-before]': "_getTogglePosition() === 'before'",
                                '(click)': '_toggle()',
                                '(keydown)': '_keydown($event)',
                                '[@.disabled]': '_animationsDisabled',
                                '(@expansionHeight.start)': '_animationStarted()',
                                '[@expansionHeight]': "{\n        value: _getExpandedState(),\n        params: {\n          collapsedHeight: collapsedHeight,\n          expandedHeight: expandedHeight\n        }\n    }",
                            },
                        },] },
            ];
            /** @nocollapse */
            MatExpansionPanelHeader.ctorParameters = function () { return [
                { type: MatExpansionPanel, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Host"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_10__["FocusMonitor"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [MAT_EXPANSION_PANEL_DEFAULT_OPTIONS,] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] }
            ]; };
            MatExpansionPanelHeader.propDecorators = {
                expandedHeight: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                collapsedHeight: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * `<mat-panel-description>`
             *
             * This directive is to be used inside of the MatExpansionPanelHeader component.
             */
            var MatExpansionPanelDescription = /** @class */ (function () {
                function MatExpansionPanelDescription() {
                }
                return MatExpansionPanelDescription;
            }());
            MatExpansionPanelDescription.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'mat-panel-description',
                            host: {
                                class: 'mat-expansion-panel-header-description'
                            }
                        },] },
            ];
            /**
             * `<mat-panel-title>`
             *
             * This directive is to be used inside of the MatExpansionPanelHeader component.
             */
            var MatExpansionPanelTitle = /** @class */ (function () {
                function MatExpansionPanelTitle() {
                }
                return MatExpansionPanelTitle;
            }());
            MatExpansionPanelTitle.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'mat-panel-title',
                            host: {
                                class: 'mat-expansion-panel-header-title'
                            }
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Directive for a Material Design Accordion.
             */
            var MatAccordion = /** @class */ (function (_super) {
                __extends(MatAccordion, _super);
                function MatAccordion() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1._hideToggle = false;
                    /**
                     * Display mode used for all expansion panels in the accordion. Currently two display
                     * modes exist:
                     *  default - a gutter-like spacing is placed around any expanded panel, placing the expanded
                     *     panel at a different elevation from the rest of the accordion.
                     *  flat - no spacing is placed around expanded panels, showing all panels at the same
                     *     elevation.
                     */
                    _this_1.displayMode = 'default';
                    /**
                     * The position of the expansion indicator.
                     */
                    _this_1.togglePosition = 'after';
                    return _this_1;
                }
                Object.defineProperty(MatAccordion.prototype, "hideToggle", {
                    /**
                     * Whether the expansion indicator should be hidden.
                     * @return {?}
                     */
                    get: function () { return this._hideToggle; },
                    /**
                     * @param {?} show
                     * @return {?}
                     */
                    set: function (show) { this._hideToggle = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(show); },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatAccordion.prototype.ngAfterContentInit = function () {
                    this._keyManager = new _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_10__["FocusKeyManager"](this._headers).withWrap();
                };
                /**
                 * Handles keyboard events coming in from the panel headers.
                 * @param {?} event
                 * @return {?}
                 */
                MatAccordion.prototype._handleHeaderKeydown = function (event) {
                    var keyCode = event.keyCode;
                    /** @type {?} */
                    var manager = this._keyManager;
                    if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["HOME"]) {
                        if (!Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["hasModifierKey"])(event)) {
                            manager.setFirstItemActive();
                            event.preventDefault();
                        }
                    }
                    else if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["END"]) {
                        if (!Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["hasModifierKey"])(event)) {
                            manager.setLastItemActive();
                            event.preventDefault();
                        }
                    }
                    else {
                        this._keyManager.onKeydown(event);
                    }
                };
                /**
                 * @param {?} header
                 * @return {?}
                 */
                MatAccordion.prototype._handleHeaderFocus = function (header) {
                    this._keyManager.updateActiveItem(header);
                };
                return MatAccordion;
            }(_angular_cdk_accordion__WEBPACK_IMPORTED_MODULE_2__["CdkAccordion"]));
            MatAccordion.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'mat-accordion',
                            exportAs: 'matAccordion',
                            inputs: ['multi'],
                            providers: [{
                                    provide: MAT_ACCORDION,
                                    useExisting: MatAccordion
                                }],
                            host: {
                                class: 'mat-accordion'
                            }
                        },] },
            ];
            MatAccordion.propDecorators = {
                _headers: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChildren"], args: [MatExpansionPanelHeader, { descendants: true },] }],
                hideToggle: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                displayMode: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                togglePosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatExpansionModule = /** @class */ (function () {
                function MatExpansionModule() {
                }
                return MatExpansionModule;
            }());
            MatExpansionModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [_angular_common__WEBPACK_IMPORTED_MODULE_6__["CommonModule"], _angular_cdk_accordion__WEBPACK_IMPORTED_MODULE_2__["CdkAccordionModule"], _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__["PortalModule"]],
                            exports: [
                                MatAccordion,
                                MatExpansionPanel,
                                MatExpansionPanelActionRow,
                                MatExpansionPanelHeader,
                                MatExpansionPanelTitle,
                                MatExpansionPanelDescription,
                                MatExpansionPanelContent,
                            ],
                            declarations: [
                                MatAccordion,
                                MatExpansionPanel,
                                MatExpansionPanelActionRow,
                                MatExpansionPanelHeader,
                                MatExpansionPanelTitle,
                                MatExpansionPanelDescription,
                                MatExpansionPanelContent,
                            ],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=expansion.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/input.js": 
        /*!*********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/input.js ***!
          \*********************************************************/
        /*! exports provided: MatTextareaAutosize, MatInput, getMatInputUnsupportedTypeError, MatInputModule, MAT_INPUT_VALUE_ACCESSOR */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTextareaAutosize", function () { return MatTextareaAutosize; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatInput", function () { return MatInput; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMatInputUnsupportedTypeError", function () { return getMatInputUnsupportedTypeError; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatInputModule", function () { return MatInputModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_INPUT_VALUE_ACCESSOR", function () { return MAT_INPUT_VALUE_ACCESSOR; });
            /* harmony import */ var _angular_cdk_text_field__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/text-field */ "./node_modules/@angular/cdk/esm2015/text-field.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/platform */ "./node_modules/@angular/cdk/esm2015/platform.js");
            /* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_material_form_field__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/material/form-field */ "./node_modules/@angular/material/esm2015/form-field.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Directive to automatically resize a textarea to fit its content.
             * @deprecated Use `cdkTextareaAutosize` from `\@angular/cdk/text-field` instead.
             * \@breaking-change 8.0.0
             */
            var MatTextareaAutosize = /** @class */ (function (_super) {
                __extends(MatTextareaAutosize, _super);
                function MatTextareaAutosize() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                Object.defineProperty(MatTextareaAutosize.prototype, "matAutosizeMinRows", {
                    /**
                     * @return {?}
                     */
                    get: function () { return this.minRows; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this.minRows = value; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatTextareaAutosize.prototype, "matAutosizeMaxRows", {
                    /**
                     * @return {?}
                     */
                    get: function () { return this.maxRows; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this.maxRows = value; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatTextareaAutosize.prototype, "matAutosize", {
                    /**
                     * @return {?}
                     */
                    get: function () { return this.enabled; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this.enabled = value; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatTextareaAutosize.prototype, "matTextareaAutosize", {
                    /**
                     * @return {?}
                     */
                    get: function () { return this.enabled; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this.enabled = value; },
                    enumerable: true,
                    configurable: true
                });
                return MatTextareaAutosize;
            }(_angular_cdk_text_field__WEBPACK_IMPORTED_MODULE_0__["CdkTextareaAutosize"]));
            MatTextareaAutosize.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: 'textarea[mat-autosize], textarea[matTextareaAutosize]',
                            exportAs: 'matTextareaAutosize',
                            inputs: ['cdkAutosizeMinRows', 'cdkAutosizeMaxRows'],
                            host: {
                                'class': 'cdk-textarea-autosize mat-autosize',
                                // Textarea elements that have the directive applied should have a single row by default.
                                // Browsers normally show two rows by default and therefore this limits the minRows binding.
                                'rows': '1',
                                '(input)': '_noopInputHandler()',
                            },
                        },] },
            ];
            MatTextareaAutosize.propDecorators = {
                matAutosizeMinRows: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                matAutosizeMaxRows: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                matAutosize: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['mat-autosize',] }],
                matTextareaAutosize: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * \@docs-private
             * @param {?} type
             * @return {?}
             */
            function getMatInputUnsupportedTypeError(type) {
                return Error("Input type \"" + type + "\" isn't supported by matInput.");
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * This token is used to inject the object whose value should be set into `MatInput`. If none is
             * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide
             * themselves for this token, in order to make `MatInput` delegate the getting and setting of the
             * value to them.
             * @type {?}
             */
            var MAT_INPUT_VALUE_ACCESSOR = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["InjectionToken"]('MAT_INPUT_VALUE_ACCESSOR');
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.
            /** @type {?} */
            var MAT_INPUT_INVALID_TYPES = [
                'button',
                'checkbox',
                'file',
                'hidden',
                'image',
                'radio',
                'range',
                'reset',
                'submit'
            ];
            /** @type {?} */
            var nextUniqueId = 0;
            // Boilerplate for applying mixins to MatInput.
            /**
             * \@docs-private
             */
            var MatInputBase = /** @class */ (function () {
                /**
                 * @param {?} _defaultErrorStateMatcher
                 * @param {?} _parentForm
                 * @param {?} _parentFormGroup
                 * @param {?} ngControl
                 */
                function MatInputBase(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {
                    this._defaultErrorStateMatcher = _defaultErrorStateMatcher;
                    this._parentForm = _parentForm;
                    this._parentFormGroup = _parentFormGroup;
                    this.ngControl = ngControl;
                }
                return MatInputBase;
            }());
            /** @type {?} */
            var _MatInputMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["mixinErrorState"])(MatInputBase);
            /**
             * Directive that allows a native input to work inside a `MatFormField`.
             */
            var MatInput = /** @class */ (function (_super) {
                __extends(MatInput, _super);
                /**
                 * @param {?} _elementRef
                 * @param {?} _platform
                 * @param {?} ngControl
                 * @param {?} _parentForm
                 * @param {?} _parentFormGroup
                 * @param {?} _defaultErrorStateMatcher
                 * @param {?} inputValueAccessor
                 * @param {?} _autofillMonitor
                 * @param {?} ngZone
                 */
                function MatInput(_elementRef, _platform, ngControl, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, inputValueAccessor, _autofillMonitor, ngZone) {
                    var _this_1 = _super.call(this, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) || this;
                    _this_1._elementRef = _elementRef;
                    _this_1._platform = _platform;
                    _this_1.ngControl = ngControl;
                    _this_1._autofillMonitor = _autofillMonitor;
                    _this_1._uid = "mat-input-" + nextUniqueId++;
                    /**
                     * Whether the component is being rendered on the server.
                     */
                    _this_1._isServer = false;
                    /**
                     * Whether the component is a native html select.
                     */
                    _this_1._isNativeSelect = false;
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     */
                    _this_1.focused = false;
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     */
                    _this_1.stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_7__["Subject"]();
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     */
                    _this_1.controlType = 'mat-input';
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     */
                    _this_1.autofilled = false;
                    _this_1._disabled = false;
                    _this_1._required = false;
                    _this_1._type = 'text';
                    _this_1._readonly = false;
                    _this_1._neverEmptyInputTypes = [
                        'date',
                        'datetime',
                        'datetime-local',
                        'month',
                        'time',
                        'week'
                    ].filter(( /**
                     * @param {?} t
                     * @return {?}
                     */function (/**
                     * @param {?} t
                     * @return {?}
                     */ t) { return Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_3__["getSupportedInputTypes"])().has(t); }));
                    /** @type {?} */
                    var element = _this_1._elementRef.nativeElement;
                    // If no input value accessor was explicitly specified, use the element as the input value
                    // accessor.
                    _this_1._inputValueAccessor = inputValueAccessor || element;
                    _this_1._previousNativeValue = _this_1.value;
                    // Force setter to be called in case id was not specified.
                    _this_1.id = _this_1.id;
                    // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete
                    // key. In order to get around this we need to "jiggle" the caret loose. Since this bug only
                    // exists on iOS, we only bother to install the listener on iOS.
                    if (_platform.IOS) {
                        ngZone.runOutsideAngular(( /**
                         * @return {?}
                         */function () {
                            _elementRef.nativeElement.addEventListener('keyup', ( /**
                             * @param {?} event
                             * @return {?}
                             */function (event) {
                                /** @type {?} */
                                var el = ( /** @type {?} */(event.target));
                                if (!el.value && !el.selectionStart && !el.selectionEnd) {
                                    // Note: Just setting `0, 0` doesn't fix the issue. Setting
                                    // `1, 1` fixes it for the first time that you type text and
                                    // then hold delete. Toggling to `1, 1` and then back to
                                    // `0, 0` seems to completely fix it.
                                    el.setSelectionRange(1, 1);
                                    el.setSelectionRange(0, 0);
                                }
                            }));
                        }));
                    }
                    _this_1._isServer = !_this_1._platform.isBrowser;
                    _this_1._isNativeSelect = element.nodeName.toLowerCase() === 'select';
                    if (_this_1._isNativeSelect) {
                        _this_1.controlType = (( /** @type {?} */(element))).multiple ? 'mat-native-select-multiple' :
                            'mat-native-select';
                    }
                    return _this_1;
                }
                Object.defineProperty(MatInput.prototype, "disabled", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () {
                        if (this.ngControl && this.ngControl.disabled !== null) {
                            return this.ngControl.disabled;
                        }
                        return this._disabled;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(value);
                        // Browsers may not fire the blur event if the input is disabled too quickly.
                        // Reset from here to ensure that the element doesn't become stuck.
                        if (this.focused) {
                            this.focused = false;
                            this.stateChanges.next();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatInput.prototype, "id", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () { return this._id; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._id = value || this._uid; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatInput.prototype, "required", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () { return this._required; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._required = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatInput.prototype, "type", {
                    /**
                     * Input type of the element.
                     * @return {?}
                     */
                    get: function () { return this._type; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._type = value || 'text';
                        this._validateType();
                        // When using Angular inputs, developers are no longer able to set the properties on the native
                        // input element. To ensure that bindings for `type` work, we need to sync the setter
                        // with the native property. Textarea elements don't support the type property or attribute.
                        if (!this._isTextarea() && Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_3__["getSupportedInputTypes"])().has(this._type)) {
                            (( /** @type {?} */(this._elementRef.nativeElement))).type = this._type;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatInput.prototype, "value", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () { return this._inputValueAccessor.value; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (value !== this.value) {
                            this._inputValueAccessor.value = value;
                            this.stateChanges.next();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatInput.prototype, "readonly", {
                    /**
                     * Whether the element is readonly.
                     * @return {?}
                     */
                    get: function () { return this._readonly; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._readonly = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatInput.prototype.ngOnInit = function () {
                    var _this_1 = this;
                    if (this._platform.isBrowser) {
                        this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(( /**
                         * @param {?} event
                         * @return {?}
                         */function (/**
                         * @param {?} event
                         * @return {?}
                         */ event) {
                            _this_1.autofilled = event.isAutofilled;
                            _this_1.stateChanges.next();
                        }));
                    }
                };
                /**
                 * @return {?}
                 */
                MatInput.prototype.ngOnChanges = function () {
                    this.stateChanges.next();
                };
                /**
                 * @return {?}
                 */
                MatInput.prototype.ngOnDestroy = function () {
                    this.stateChanges.complete();
                    if (this._platform.isBrowser) {
                        this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);
                    }
                };
                /**
                 * @return {?}
                 */
                MatInput.prototype.ngDoCheck = function () {
                    if (this.ngControl) {
                        // We need to re-evaluate this on every change detection cycle, because there are some
                        // error triggers that we can't subscribe to (e.g. parent form submissions). This means
                        // that whatever logic is in here has to be super lean or we risk destroying the performance.
                        this.updateErrorState();
                    }
                    // We need to dirty-check the native element's value, because there are some cases where
                    // we won't be notified when it changes (e.g. the consumer isn't using forms or they're
                    // updating the value using `emitEvent: false`).
                    this._dirtyCheckNativeValue();
                };
                /**
                 * Focuses the input.
                 * @param {?=} options
                 * @return {?}
                 */
                MatInput.prototype.focus = function (options) {
                    this._elementRef.nativeElement.focus(options);
                };
                /**
                 * Callback for the cases where the focused state of the input changes.
                 * @param {?} isFocused
                 * @return {?}
                 */
                MatInput.prototype._focusChanged = function (isFocused) {
                    if (isFocused !== this.focused && (!this.readonly || !isFocused)) {
                        this.focused = isFocused;
                        this.stateChanges.next();
                    }
                };
                /**
                 * @return {?}
                 */
                MatInput.prototype._onInput = function () {
                    // This is a noop function and is used to let Angular know whenever the value changes.
                    // Angular will run a new change detection each time the `input` event has been dispatched.
                    // It's necessary that Angular recognizes the value change, because when floatingLabel
                    // is set to false and Angular forms aren't used, the placeholder won't recognize the
                    // value changes and will not disappear.
                    // Listening to the input event wouldn't be necessary when the input is using the
                    // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.
                };
                /**
                 * Does some manual dirty checking on the native input `value` property.
                 * @protected
                 * @return {?}
                 */
                MatInput.prototype._dirtyCheckNativeValue = function () {
                    /** @type {?} */
                    var newValue = this._elementRef.nativeElement.value;
                    if (this._previousNativeValue !== newValue) {
                        this._previousNativeValue = newValue;
                        this.stateChanges.next();
                    }
                };
                /**
                 * Make sure the input is a supported type.
                 * @protected
                 * @return {?}
                 */
                MatInput.prototype._validateType = function () {
                    if (MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1) {
                        throw getMatInputUnsupportedTypeError(this._type);
                    }
                };
                /**
                 * Checks whether the input type is one of the types that are never empty.
                 * @protected
                 * @return {?}
                 */
                MatInput.prototype._isNeverEmpty = function () {
                    return this._neverEmptyInputTypes.indexOf(this._type) > -1;
                };
                /**
                 * Checks whether the input is invalid based on the native validation.
                 * @protected
                 * @return {?}
                 */
                MatInput.prototype._isBadInput = function () {
                    // The `validity` property won't be present on platform-server.
                    /** @type {?} */
                    var validity = (( /** @type {?} */(this._elementRef.nativeElement))).validity;
                    return validity && validity.badInput;
                };
                /**
                 * Determines if the component host is a textarea.
                 * @protected
                 * @return {?}
                 */
                MatInput.prototype._isTextarea = function () {
                    return this._elementRef.nativeElement.nodeName.toLowerCase() === 'textarea';
                };
                Object.defineProperty(MatInput.prototype, "empty", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () {
                        return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput() &&
                            !this.autofilled;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatInput.prototype, "shouldLabelFloat", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () {
                        if (this._isNativeSelect) {
                            // For a single-selection `<select>`, the label should float when the selected option has
                            // a non-empty display value. For a `<select multiple>`, the label *always* floats to avoid
                            // overlapping the label with the options.
                            /** @type {?} */
                            var selectElement = ( /** @type {?} */(this._elementRef.nativeElement));
                            /** @type {?} */
                            var firstOption = selectElement.options[0];
                            // On most browsers the `selectedIndex` will always be 0, however on IE and Edge it'll be
                            // -1 if the `value` is set to something, that isn't in the list of options, at a later point.
                            return this.focused || selectElement.multiple || !this.empty ||
                                !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label);
                        }
                        else {
                            return this.focused || !this.empty;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Implemented as part of MatFormFieldControl.
                 * \@docs-private
                 * @param {?} ids
                 * @return {?}
                 */
                MatInput.prototype.setDescribedByIds = function (ids) {
                    this._ariaDescribedby = ids.join(' ');
                };
                /**
                 * Implemented as part of MatFormFieldControl.
                 * \@docs-private
                 * @return {?}
                 */
                MatInput.prototype.onContainerClick = function () {
                    // Do not re-focus the input element if the element is already focused. Otherwise it can happen
                    // that someone clicks on a time input and the cursor resets to the "hours" field while the
                    // "minutes" field was actually clicked. See: https://github.com/angular/components/issues/12849
                    if (!this.focused) {
                        this.focus();
                    }
                };
                return MatInput;
            }(_MatInputMixinBase));
            MatInput.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: "input[matInput], textarea[matInput], select[matNativeControl],\n      input[matNativeControl], textarea[matNativeControl]",
                            exportAs: 'matInput',
                            host: {
                                /**
                                 * \@breaking-change 8.0.0 remove .mat-form-field-autofill-control in favor of AutofillMonitor.
                                 */
                                'class': 'mat-input-element mat-form-field-autofill-control',
                                '[class.mat-input-server]': '_isServer',
                                // Native input properties that are overwritten by Angular inputs need to be synced with
                                // the native input element. Otherwise property bindings for those don't work.
                                '[attr.id]': 'id',
                                '[attr.placeholder]': 'placeholder',
                                '[disabled]': 'disabled',
                                '[required]': 'required',
                                '[attr.readonly]': 'readonly && !_isNativeSelect || null',
                                '[attr.aria-describedby]': '_ariaDescribedby || null',
                                '[attr.aria-invalid]': 'errorState',
                                '[attr.aria-required]': 'required.toString()',
                                '(blur)': '_focusChanged(false)',
                                '(focus)': '_focusChanged(true)',
                                '(input)': '_onInput()',
                            },
                            providers: [{ provide: _angular_material_form_field__WEBPACK_IMPORTED_MODULE_6__["MatFormFieldControl"], useExisting: MatInput }],
                        },] },
            ];
            /** @nocollapse */
            MatInput.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_3__["Platform"] },
                { type: _angular_forms__WEBPACK_IMPORTED_MODULE_4__["NgControl"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Self"] }] },
                { type: _angular_forms__WEBPACK_IMPORTED_MODULE_4__["NgForm"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] },
                { type: _angular_forms__WEBPACK_IMPORTED_MODULE_4__["FormGroupDirective"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] },
                { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_5__["ErrorStateMatcher"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Self"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [MAT_INPUT_VALUE_ACCESSOR,] }] },
                { type: _angular_cdk_text_field__WEBPACK_IMPORTED_MODULE_0__["AutofillMonitor"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] }
            ]; };
            MatInput.propDecorators = {
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                placeholder: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                required: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                type: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                errorStateMatcher: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                readonly: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatInputModule = /** @class */ (function () {
                function MatInputModule() {
                }
                return MatInputModule;
            }());
            MatInputModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                            declarations: [MatInput, MatTextareaAutosize],
                            imports: [
                                _angular_common__WEBPACK_IMPORTED_MODULE_8__["CommonModule"],
                                _angular_cdk_text_field__WEBPACK_IMPORTED_MODULE_0__["TextFieldModule"],
                                _angular_material_form_field__WEBPACK_IMPORTED_MODULE_6__["MatFormFieldModule"],
                            ],
                            exports: [
                                _angular_cdk_text_field__WEBPACK_IMPORTED_MODULE_0__["TextFieldModule"],
                                // We re-export the `MatFormFieldModule` since `MatInput` will almost always
                                // be used together with `MatFormField`.
                                _angular_material_form_field__WEBPACK_IMPORTED_MODULE_6__["MatFormFieldModule"],
                                MatInput,
                                MatTextareaAutosize,
                            ],
                            providers: [_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["ErrorStateMatcher"]],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=input.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/radio.js": 
        /*!*********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/radio.js ***!
          \*********************************************************/
        /*! exports provided: MatRadioModule, MAT_RADIO_DEFAULT_OPTIONS_FACTORY, MAT_RADIO_DEFAULT_OPTIONS, MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR, MatRadioChange, MatRadioGroup, MatRadioButton */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatRadioModule", function () { return MatRadioModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_RADIO_DEFAULT_OPTIONS_FACTORY", function () { return MAT_RADIO_DEFAULT_OPTIONS_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_RADIO_DEFAULT_OPTIONS", function () { return MAT_RADIO_DEFAULT_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR", function () { return MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatRadioChange", function () { return MatRadioChange; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatRadioGroup", function () { return MatRadioGroup; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatRadioButton", function () { return MatRadioButton; });
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/collections */ "./node_modules/@angular/cdk/esm2015/collections.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var MAT_RADIO_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["InjectionToken"]('mat-radio-default-options', {
                providedIn: 'root',
                factory: MAT_RADIO_DEFAULT_OPTIONS_FACTORY
            });
            /**
             * @return {?}
             */
            function MAT_RADIO_DEFAULT_OPTIONS_FACTORY() {
                return {
                    color: 'accent'
                };
            }
            // Increasing integer for generating unique ids for radio components.
            /** @type {?} */
            var nextUniqueId = 0;
            /**
             * Provider Expression that allows mat-radio-group to register as a ControlValueAccessor. This
             * allows it to support [(ngModel)] and ngControl.
             * \@docs-private
             * @type {?}
             */
            var MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_4__["NG_VALUE_ACCESSOR"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatRadioGroup; })),
                multi: true
            };
            /**
             * Change event object emitted by MatRadio and MatRadioGroup.
             */
            var MatRadioChange = /** @class */ (function () {
                /**
                 * @param {?} source
                 * @param {?} value
                 */
                function MatRadioChange(source, value) {
                    this.source = source;
                    this.value = value;
                }
                return MatRadioChange;
            }());
            /**
             * A group of radio buttons. May contain one or more `<mat-radio-button>` elements.
             */
            var MatRadioGroup = /** @class */ (function () {
                /**
                 * @param {?} _changeDetector
                 */
                function MatRadioGroup(_changeDetector) {
                    this._changeDetector = _changeDetector;
                    /**
                     * Selected value for the radio group.
                     */
                    this._value = null;
                    /**
                     * The HTML name attribute applied to radio buttons in this group.
                     */
                    this._name = "mat-radio-group-" + nextUniqueId++;
                    /**
                     * The currently selected radio button. Should match value.
                     */
                    this._selected = null;
                    /**
                     * Whether the `value` has been set to its initial value.
                     */
                    this._isInitialized = false;
                    /**
                     * Whether the labels should appear after or before the radio-buttons. Defaults to 'after'
                     */
                    this._labelPosition = 'after';
                    /**
                     * Whether the radio group is disabled.
                     */
                    this._disabled = false;
                    /**
                     * Whether the radio group is required.
                     */
                    this._required = false;
                    /**
                     * The method to be called in order to update ngModel
                     */
                    this._controlValueAccessorChangeFn = ( /**
                     * @return {?}
                     */function () { });
                    /**
                     * onTouch function registered via registerOnTouch (ControlValueAccessor).
                     * \@docs-private
                     */
                    this.onTouched = ( /**
                     * @return {?}
                     */function () { });
                    /**
                     * Event emitted when the group value changes.
                     * Change events are only emitted when the value changes due to user interaction with
                     * a radio button (the same behavior as `<input type-"radio">`).
                     */
                    this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                }
                Object.defineProperty(MatRadioGroup.prototype, "name", {
                    /**
                     * Name of the radio button group. All radio buttons inside this group will use this name.
                     * @return {?}
                     */
                    get: function () { return this._name; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._name = value;
                        this._updateRadioButtonNames();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatRadioGroup.prototype, "labelPosition", {
                    /**
                     * Whether the labels should appear after or before the radio-buttons. Defaults to 'after'
                     * @return {?}
                     */
                    get: function () {
                        return this._labelPosition;
                    },
                    /**
                     * @param {?} v
                     * @return {?}
                     */
                    set: function (v) {
                        this._labelPosition = v === 'before' ? 'before' : 'after';
                        this._markRadiosForCheck();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatRadioGroup.prototype, "value", {
                    /**
                     * Value for the radio-group. Should equal the value of the selected radio button if there is
                     * a corresponding radio button with a matching value. If there is not such a corresponding
                     * radio button, this value persists to be applied in case a new radio button is added with a
                     * matching value.
                     * @return {?}
                     */
                    get: function () { return this._value; },
                    /**
                     * @param {?} newValue
                     * @return {?}
                     */
                    set: function (newValue) {
                        if (this._value !== newValue) {
                            // Set this before proceeding to ensure no circular loop occurs with selection.
                            this._value = newValue;
                            this._updateSelectedRadioFromValue();
                            this._checkSelectedRadioButton();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatRadioGroup.prototype._checkSelectedRadioButton = function () {
                    if (this._selected && !this._selected.checked) {
                        this._selected.checked = true;
                    }
                };
                Object.defineProperty(MatRadioGroup.prototype, "selected", {
                    /**
                     * The currently selected radio button. If set to a new radio button, the radio group value
                     * will be updated to match the new selected button.
                     * @return {?}
                     */
                    get: function () { return this._selected; },
                    /**
                     * @param {?} selected
                     * @return {?}
                     */
                    set: function (selected) {
                        this._selected = selected;
                        this.value = selected ? selected.value : null;
                        this._checkSelectedRadioButton();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatRadioGroup.prototype, "disabled", {
                    /**
                     * Whether the radio group is disabled
                     * @return {?}
                     */
                    get: function () { return this._disabled; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                        this._markRadiosForCheck();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatRadioGroup.prototype, "required", {
                    /**
                     * Whether the radio group is required
                     * @return {?}
                     */
                    get: function () { return this._required; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._required = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                        this._markRadiosForCheck();
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Initialize properties once content children are available.
                 * This allows us to propagate relevant attributes to associated buttons.
                 * @return {?}
                 */
                MatRadioGroup.prototype.ngAfterContentInit = function () {
                    // Mark this component as initialized in AfterContentInit because the initial value can
                    // possibly be set by NgModel on MatRadioGroup, and it is possible that the OnInit of the
                    // NgModel occurs *after* the OnInit of the MatRadioGroup.
                    this._isInitialized = true;
                };
                /**
                 * Mark this group as being "touched" (for ngModel). Meant to be called by the contained
                 * radio buttons upon their blur.
                 * @return {?}
                 */
                MatRadioGroup.prototype._touch = function () {
                    if (this.onTouched) {
                        this.onTouched();
                    }
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatRadioGroup.prototype._updateRadioButtonNames = function () {
                    var _this_1 = this;
                    if (this._radios) {
                        this._radios.forEach(( /**
                         * @param {?} radio
                         * @return {?}
                         */function (/**
                         * @param {?} radio
                         * @return {?}
                         */ radio) {
                            radio.name = _this_1.name;
                            radio._markForCheck();
                        }));
                    }
                };
                /**
                 * Updates the `selected` radio button from the internal _value state.
                 * @private
                 * @return {?}
                 */
                MatRadioGroup.prototype._updateSelectedRadioFromValue = function () {
                    var _this_1 = this;
                    // If the value already matches the selected radio, do nothing.
                    /** @type {?} */
                    var isAlreadySelected = this._selected !== null && this._selected.value === this._value;
                    if (this._radios && !isAlreadySelected) {
                        this._selected = null;
                        this._radios.forEach(( /**
                         * @param {?} radio
                         * @return {?}
                         */function (/**
                         * @param {?} radio
                         * @return {?}
                         */ radio) {
                            radio.checked = _this_1.value === radio.value;
                            if (radio.checked) {
                                _this_1._selected = radio;
                            }
                        }));
                    }
                };
                /**
                 * Dispatch change event with current selection and group value.
                 * @return {?}
                 */
                MatRadioGroup.prototype._emitChangeEvent = function () {
                    if (this._isInitialized) {
                        this.change.emit(new MatRadioChange(( /** @type {?} */(this._selected)), this._value));
                    }
                };
                /**
                 * @return {?}
                 */
                MatRadioGroup.prototype._markRadiosForCheck = function () {
                    if (this._radios) {
                        this._radios.forEach(( /**
                         * @param {?} radio
                         * @return {?}
                         */function (/**
                         * @param {?} radio
                         * @return {?}
                         */ radio) { return radio._markForCheck(); }));
                    }
                };
                /**
                 * Sets the model value. Implemented as part of ControlValueAccessor.
                 * @param {?} value
                 * @return {?}
                 */
                MatRadioGroup.prototype.writeValue = function (value) {
                    this.value = value;
                    this._changeDetector.markForCheck();
                };
                /**
                 * Registers a callback to be triggered when the model value changes.
                 * Implemented as part of ControlValueAccessor.
                 * @param {?} fn Callback to be registered.
                 * @return {?}
                 */
                MatRadioGroup.prototype.registerOnChange = function (fn) {
                    this._controlValueAccessorChangeFn = fn;
                };
                /**
                 * Registers a callback to be triggered when the control is touched.
                 * Implemented as part of ControlValueAccessor.
                 * @param {?} fn Callback to be registered.
                 * @return {?}
                 */
                MatRadioGroup.prototype.registerOnTouched = function (fn) {
                    this.onTouched = fn;
                };
                /**
                 * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.
                 * @param {?} isDisabled Whether the control should be disabled.
                 * @return {?}
                 */
                MatRadioGroup.prototype.setDisabledState = function (isDisabled) {
                    this.disabled = isDisabled;
                    this._changeDetector.markForCheck();
                };
                return MatRadioGroup;
            }());
            MatRadioGroup.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: 'mat-radio-group',
                            exportAs: 'matRadioGroup',
                            providers: [MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR],
                            host: {
                                'role': 'radiogroup',
                                'class': 'mat-radio-group',
                            },
                        },] },
            ];
            /** @nocollapse */
            MatRadioGroup.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectorRef"] }
            ]; };
            MatRadioGroup.propDecorators = {
                change: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                _radios: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChildren"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["forwardRef"])(( /**
                                         * @return {?}
                                         */function () { return MatRadioButton; })), { descendants: true },] }],
                color: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                labelPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                required: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }]
            };
            // Boilerplate for applying mixins to MatRadioButton.
            /**
             * \@docs-private
             */
            var MatRadioButtonBase = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 */
                function MatRadioButtonBase(_elementRef) {
                    this._elementRef = _elementRef;
                }
                return MatRadioButtonBase;
            }());
            // As per Material design specifications the selection control radio should use the accent color
            // palette by default. https://material.io/guidelines/components/selection-controls.html
            /** @type {?} */
            var _MatRadioButtonMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["mixinDisableRipple"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["mixinTabIndex"])(MatRadioButtonBase));
            /**
             * A Material design radio-button. Typically placed inside of `<mat-radio-group>` elements.
             */
            var MatRadioButton = /** @class */ (function (_super) {
                __extends(MatRadioButton, _super);
                /**
                 * @param {?} radioGroup
                 * @param {?} elementRef
                 * @param {?} _changeDetector
                 * @param {?} _focusMonitor
                 * @param {?} _radioDispatcher
                 * @param {?=} _animationMode
                 * @param {?=} _providerOverride
                 */
                function MatRadioButton(radioGroup, elementRef, _changeDetector, _focusMonitor, _radioDispatcher, _animationMode, _providerOverride) {
                    var _this_1 = _super.call(this, elementRef) || this;
                    _this_1._changeDetector = _changeDetector;
                    _this_1._focusMonitor = _focusMonitor;
                    _this_1._radioDispatcher = _radioDispatcher;
                    _this_1._animationMode = _animationMode;
                    _this_1._providerOverride = _providerOverride;
                    _this_1._uniqueId = "mat-radio-" + ++nextUniqueId;
                    /**
                     * The unique ID for the radio button.
                     */
                    _this_1.id = _this_1._uniqueId;
                    /**
                     * Event emitted when the checked state of this radio button changes.
                     * Change events are only emitted when the value changes due to user interaction with
                     * the radio button (the same behavior as `<input type-"radio">`).
                     */
                    _this_1.change = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /**
                     * Whether this radio is checked.
                     */
                    _this_1._checked = false;
                    /**
                     * Value assigned to this radio.
                     */
                    _this_1._value = null;
                    /**
                     * Unregister function for _radioDispatcher
                     */
                    _this_1._removeUniqueSelectionListener = ( /**
                     * @return {?}
                     */function () { });
                    // Assertions. Ideally these should be stripped out by the compiler.
                    // TODO(jelbourn): Assert that there's no name binding AND a parent radio group.
                    _this_1.radioGroup = radioGroup;
                    _this_1._removeUniqueSelectionListener =
                        _radioDispatcher.listen(( /**
                         * @param {?} id
                         * @param {?} name
                         * @return {?}
                         */function (id, name) {
                            if (id !== _this_1.id && name === _this_1.name) {
                                _this_1.checked = false;
                            }
                        }));
                    return _this_1;
                }
                Object.defineProperty(MatRadioButton.prototype, "checked", {
                    /**
                     * Whether this radio button is checked.
                     * @return {?}
                     */
                    get: function () { return this._checked; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var newCheckedState = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                        if (this._checked !== newCheckedState) {
                            this._checked = newCheckedState;
                            if (newCheckedState && this.radioGroup && this.radioGroup.value !== this.value) {
                                this.radioGroup.selected = this;
                            }
                            else if (!newCheckedState && this.radioGroup && this.radioGroup.value === this.value) {
                                // When unchecking the selected radio button, update the selected radio
                                // property on the group.
                                this.radioGroup.selected = null;
                            }
                            if (newCheckedState) {
                                // Notify all radio buttons with the same name to un-check.
                                this._radioDispatcher.notify(this.id, this.name);
                            }
                            this._changeDetector.markForCheck();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatRadioButton.prototype, "value", {
                    /**
                     * The value of this radio button.
                     * @return {?}
                     */
                    get: function () { return this._value; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (this._value !== value) {
                            this._value = value;
                            if (this.radioGroup !== null) {
                                if (!this.checked) {
                                    // Update checked when the value changed to match the radio group's value
                                    this.checked = this.radioGroup.value === value;
                                }
                                if (this.checked) {
                                    this.radioGroup.selected = this;
                                }
                            }
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatRadioButton.prototype, "labelPosition", {
                    /**
                     * Whether the label should appear after or before the radio button. Defaults to 'after'
                     * @return {?}
                     */
                    get: function () {
                        return this._labelPosition || (this.radioGroup && this.radioGroup.labelPosition) || 'after';
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._labelPosition = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatRadioButton.prototype, "disabled", {
                    /**
                     * Whether the radio button is disabled.
                     * @return {?}
                     */
                    get: function () {
                        return this._disabled || (this.radioGroup !== null && this.radioGroup.disabled);
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var newDisabledState = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                        if (this._disabled !== newDisabledState) {
                            this._disabled = newDisabledState;
                            this._changeDetector.markForCheck();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatRadioButton.prototype, "required", {
                    /**
                     * Whether the radio button is required.
                     * @return {?}
                     */
                    get: function () {
                        return this._required || (this.radioGroup && this.radioGroup.required);
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._required = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatRadioButton.prototype, "color", {
                    /**
                     * Theme color of the radio button.
                     * @return {?}
                     */
                    get: function () {
                        return this._color ||
                            (this.radioGroup && this.radioGroup.color) ||
                            this._providerOverride && this._providerOverride.color || 'accent';
                    },
                    /**
                     * @param {?} newValue
                     * @return {?}
                     */
                    set: function (newValue) { this._color = newValue; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatRadioButton.prototype, "inputId", {
                    /**
                     * ID of the native input element inside `<mat-radio-button>`
                     * @return {?}
                     */
                    get: function () { return (this.id || this._uniqueId) + "-input"; },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Focuses the radio button.
                 * @param {?=} options
                 * @return {?}
                 */
                MatRadioButton.prototype.focus = function (options) {
                    this._focusMonitor.focusVia(this._inputElement, 'keyboard', options);
                };
                /**
                 * Marks the radio button as needing checking for change detection.
                 * This method is exposed because the parent radio group will directly
                 * update bound properties of the radio button.
                 * @return {?}
                 */
                MatRadioButton.prototype._markForCheck = function () {
                    // When group value changes, the button will not be notified. Use `markForCheck` to explicit
                    // update radio button's status
                    this._changeDetector.markForCheck();
                };
                /**
                 * @return {?}
                 */
                MatRadioButton.prototype.ngOnInit = function () {
                    if (this.radioGroup) {
                        // If the radio is inside a radio group, determine if it should be checked
                        this.checked = this.radioGroup.value === this._value;
                        // Copy name from parent radio group
                        this.name = this.radioGroup.name;
                    }
                };
                /**
                 * @return {?}
                 */
                MatRadioButton.prototype.ngAfterViewInit = function () {
                    var _this_1 = this;
                    this._focusMonitor
                        .monitor(this._elementRef, true)
                        .subscribe(( /**
                 * @param {?} focusOrigin
                 * @return {?}
                 */function (/**
                 * @param {?} focusOrigin
                 * @return {?}
                 */ focusOrigin) {
                        if (!focusOrigin && _this_1.radioGroup) {
                            _this_1.radioGroup._touch();
                        }
                    }));
                };
                /**
                 * @return {?}
                 */
                MatRadioButton.prototype.ngOnDestroy = function () {
                    this._focusMonitor.stopMonitoring(this._elementRef);
                    this._removeUniqueSelectionListener();
                };
                /**
                 * Dispatch change event with current value.
                 * @private
                 * @return {?}
                 */
                MatRadioButton.prototype._emitChangeEvent = function () {
                    this.change.emit(new MatRadioChange(this, this._value));
                };
                /**
                 * @return {?}
                 */
                MatRadioButton.prototype._isRippleDisabled = function () {
                    return this.disableRipple || this.disabled;
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatRadioButton.prototype._onInputClick = function (event) {
                    // We have to stop propagation for click events on the visual hidden input element.
                    // By default, when a user clicks on a label element, a generated click event will be
                    // dispatched on the associated input element. Since we are using a label element as our
                    // root container, the click event on the `radio-button` will be executed twice.
                    // The real click event will bubble up, and the generated click event also tries to bubble up.
                    // This will lead to multiple click events.
                    // Preventing bubbling for the second event will solve that issue.
                    event.stopPropagation();
                };
                /**
                 * Triggered when the radio button received a click or the input recognized any change.
                 * Clicking on a label element, will trigger a change event on the associated input.
                 * @param {?} event
                 * @return {?}
                 */
                MatRadioButton.prototype._onInputChange = function (event) {
                    // We always have to stop propagation on the change event.
                    // Otherwise the change event, from the input element, will bubble up and
                    // emit its event object to the `change` output.
                    event.stopPropagation();
                    /** @type {?} */
                    var groupValueChanged = this.radioGroup && this.value !== this.radioGroup.value;
                    this.checked = true;
                    this._emitChangeEvent();
                    if (this.radioGroup) {
                        this.radioGroup._controlValueAccessorChangeFn(this.value);
                        if (groupValueChanged) {
                            this.radioGroup._emitChangeEvent();
                        }
                    }
                };
                return MatRadioButton;
            }(_MatRadioButtonMixinBase));
            MatRadioButton.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Component"], args: [{ selector: 'mat-radio-button',
                            template: "<label [attr.for]=\"inputId\" class=\"mat-radio-label\" #label><div class=\"mat-radio-container\"><div class=\"mat-radio-outer-circle\"></div><div class=\"mat-radio-inner-circle\"></div><div mat-ripple class=\"mat-radio-ripple\" [matRippleTrigger]=\"label\" [matRippleDisabled]=\"_isRippleDisabled()\" [matRippleCentered]=\"true\" [matRippleRadius]=\"20\" [matRippleAnimation]=\"{enterDuration: 150}\"><div class=\"mat-ripple-element mat-radio-persistent-ripple\"></div></div><input #input class=\"mat-radio-input cdk-visually-hidden\" type=\"radio\" [id]=\"inputId\" [checked]=\"checked\" [disabled]=\"disabled\" [tabIndex]=\"tabIndex\" [attr.name]=\"name\" [attr.value]=\"value\" [required]=\"required\" [attr.aria-label]=\"ariaLabel\" [attr.aria-labelledby]=\"ariaLabelledby\" [attr.aria-describedby]=\"ariaDescribedby\" (change)=\"_onInputChange($event)\" (click)=\"_onInputClick($event)\"></div><div class=\"mat-radio-label-content\" [class.mat-radio-label-before]=\"labelPosition == 'before'\"><span style=\"display:none\">&nbsp;</span><ng-content></ng-content></div></label>",
                            styles: [".mat-radio-button{display:inline-block;-webkit-tap-highlight-color:transparent;outline:0}.mat-radio-label{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;display:inline-flex;align-items:center;white-space:nowrap;vertical-align:middle;width:100%}.mat-radio-container{box-sizing:border-box;display:inline-block;position:relative;width:20px;height:20px;flex-shrink:0}.mat-radio-outer-circle{box-sizing:border-box;height:20px;left:0;position:absolute;top:0;transition:border-color ease 280ms;width:20px;border-width:2px;border-style:solid;border-radius:50%}._mat-animation-noopable .mat-radio-outer-circle{transition:none}.mat-radio-inner-circle{border-radius:50%;box-sizing:border-box;height:20px;left:0;position:absolute;top:0;transition:transform ease 280ms,background-color ease 280ms;width:20px;transform:scale(.001)}._mat-animation-noopable .mat-radio-inner-circle{transition:none}.mat-radio-checked .mat-radio-inner-circle{transform:scale(.5)}@media (-ms-high-contrast:active){.mat-radio-checked .mat-radio-inner-circle{border:solid 10px}}.mat-radio-label-content{-webkit-user-select:auto;-moz-user-select:auto;-ms-user-select:auto;user-select:auto;display:inline-block;order:0;line-height:inherit;padding-left:8px;padding-right:0}[dir=rtl] .mat-radio-label-content{padding-right:8px;padding-left:0}.mat-radio-label-content.mat-radio-label-before{order:-1;padding-left:0;padding-right:8px}[dir=rtl] .mat-radio-label-content.mat-radio-label-before{padding-right:0;padding-left:8px}.mat-radio-disabled,.mat-radio-disabled .mat-radio-label{cursor:default}.mat-radio-button .mat-radio-ripple{position:absolute;left:calc(50% - 20px);top:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}.mat-radio-button .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple){opacity:.16}.mat-radio-persistent-ripple{width:100%;height:100%;transform:none}.mat-radio-container:hover .mat-radio-persistent-ripple{opacity:.04}.mat-radio-button:not(.mat-radio-disabled).cdk-keyboard-focused .mat-radio-persistent-ripple,.mat-radio-button:not(.mat-radio-disabled).cdk-program-focused .mat-radio-persistent-ripple{opacity:.12}.mat-radio-disabled .mat-radio-container:hover .mat-radio-persistent-ripple,.mat-radio-persistent-ripple{opacity:0}@media (hover:none){.mat-radio-container:hover .mat-radio-persistent-ripple{display:none}}.mat-radio-input{bottom:0;left:50%}@media (-ms-high-contrast:active){.mat-radio-disabled{opacity:.5}}"],
                            inputs: ['disableRipple', 'tabIndex'],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewEncapsulation"].None,
                            exportAs: 'matRadioButton',
                            host: {
                                'class': 'mat-radio-button',
                                '[class.mat-radio-checked]': 'checked',
                                '[class.mat-radio-disabled]': 'disabled',
                                '[class._mat-animation-noopable]': '_animationMode === "NoopAnimations"',
                                '[class.mat-primary]': 'color === "primary"',
                                '[class.mat-accent]': 'color === "accent"',
                                '[class.mat-warn]': 'color === "warn"',
                                // Needs to be -1 so the `focus` event still fires.
                                '[attr.tabindex]': '-1',
                                '[attr.id]': 'id',
                                '[attr.aria-label]': 'null',
                                '[attr.aria-labelledby]': 'null',
                                '[attr.aria-describedby]': 'null',
                                // Note: under normal conditions focus shouldn't land on this element, however it may be
                                // programmatically set, for example inside of a focus trap, in this case we want to forward
                                // the focus to the native element.
                                '(focus)': '_inputElement.nativeElement.focus()',
                            },
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatRadioButton.ctorParameters = function () { return [
                { type: MatRadioGroup, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectorRef"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__["FocusMonitor"] },
                { type: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_2__["UniqueSelectionDispatcher"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_6__["ANIMATION_MODULE_TYPE"],] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [MAT_RADIO_DEFAULT_OPTIONS,] }] }
            ]; };
            MatRadioButton.propDecorators = {
                id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                ariaLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['aria-label',] }],
                ariaLabelledby: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['aria-labelledby',] }],
                ariaDescribedby: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['aria-describedby',] }],
                checked: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                labelPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                required: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                color: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                change: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                _inputElement: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewChild"], args: ['input', { static: false },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatRadioModule = /** @class */ (function () {
                function MatRadioModule() {
                }
                return MatRadioModule;
            }());
            MatRadioModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["NgModule"], args: [{
                            imports: [_angular_common__WEBPACK_IMPORTED_MODULE_7__["CommonModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_5__["MatRippleModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_5__["MatCommonModule"]],
                            exports: [MatRadioGroup, MatRadioButton, _angular_material_core__WEBPACK_IMPORTED_MODULE_5__["MatCommonModule"]],
                            declarations: [MatRadioGroup, MatRadioButton],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=radio.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/select.js": 
        /*!**********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/select.js ***!
          \**********************************************************/
        /*! exports provided: MatSelectModule, MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY, SELECT_PANEL_MAX_HEIGHT, SELECT_PANEL_PADDING_X, SELECT_PANEL_INDENT_PADDING_X, SELECT_ITEM_HEIGHT_EM, SELECT_MULTIPLE_PANEL_PADDING_X, SELECT_PANEL_VIEWPORT_PADDING, MAT_SELECT_SCROLL_STRATEGY, MAT_SELECT_SCROLL_STRATEGY_PROVIDER, MatSelectChange, MatSelectTrigger, MatSelect, matSelectAnimations, transformPanel, fadeInContent */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSelectModule", function () { return MatSelectModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY", function () { return MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SELECT_PANEL_MAX_HEIGHT", function () { return SELECT_PANEL_MAX_HEIGHT; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SELECT_PANEL_PADDING_X", function () { return SELECT_PANEL_PADDING_X; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SELECT_PANEL_INDENT_PADDING_X", function () { return SELECT_PANEL_INDENT_PADDING_X; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SELECT_ITEM_HEIGHT_EM", function () { return SELECT_ITEM_HEIGHT_EM; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SELECT_MULTIPLE_PANEL_PADDING_X", function () { return SELECT_MULTIPLE_PANEL_PADDING_X; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SELECT_PANEL_VIEWPORT_PADDING", function () { return SELECT_PANEL_VIEWPORT_PADDING; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_SELECT_SCROLL_STRATEGY", function () { return MAT_SELECT_SCROLL_STRATEGY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_SELECT_SCROLL_STRATEGY_PROVIDER", function () { return MAT_SELECT_SCROLL_STRATEGY_PROVIDER; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSelectChange", function () { return MatSelectChange; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSelectTrigger", function () { return MatSelectTrigger; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSelect", function () { return MatSelect; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matSelectAnimations", function () { return matSelectAnimations; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformPanel", function () { return transformPanel; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fadeInContent", function () { return fadeInContent; });
            /* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/animations */ "./node_modules/@angular/animations/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/collections */ "./node_modules/@angular/cdk/esm2015/collections.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /* harmony import */ var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/overlay */ "./node_modules/@angular/cdk/esm2015/overlay.js");
            /* harmony import */ var _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/cdk/scrolling */ "./node_modules/@angular/cdk/esm2015/scrolling.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_material_form_field__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/material/form-field */ "./node_modules/@angular/material/esm2015/form-field.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * The following are all the animations for the mat-select component, with each
             * const containing the metadata for one animation.
             *
             * The values below match the implementation of the AngularJS Material mat-select animation.
             * \@docs-private
             * @type {?}
             */
            var matSelectAnimations = {
                /**
                 * This animation ensures the select's overlay panel animation (transformPanel) is called when
                 * closing the select.
                 * This is needed due to https://github.com/angular/angular/issues/23302
                 */
                transformPanelWrap: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["trigger"])('transformPanelWrap', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('* => void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["query"])('@transformPanel', [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animateChild"])()], { optional: true }))
                ]),
                /**
                 * This animation transforms the select's overlay panel on and off the page.
                 *
                 * When the panel is attached to the DOM, it expands its width by the amount of padding, scales it
                 * up to 100% on the Y axis, fades in its border, and translates slightly up and to the
                 * side to ensure the option text correctly overlaps the trigger text.
                 *
                 * When the panel is removed from the DOM, it simply fades out linearly.
                 */
                transformPanel: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["trigger"])('transformPanel', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["state"])('void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
                        transform: 'scaleY(0.8)',
                        minWidth: '100%',
                        opacity: 0
                    })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["state"])('showing', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
                        opacity: 1,
                        minWidth: 'calc(100% + 32px)',
                        // 32px = 2 * 16px padding
                        transform: 'scaleY(1)'
                    })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["state"])('showing-multiple', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
                        opacity: 1,
                        minWidth: 'calc(100% + 64px)',
                        // 64px = 48px padding on the left + 16px padding on the right
                        transform: 'scaleY(1)'
                    })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('void => *', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])('120ms cubic-bezier(0, 0, 0.2, 1)')),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('* => void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])('100ms 25ms linear', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ opacity: 0 })))
                ]),
                /**
                 * This animation fades in the background color and text content of the
                 * select's options. It is time delayed to occur 100ms after the overlay
                 * panel has transformed in.
                 * @deprecated Not used anymore. To be removed.
                 * \@breaking-change 8.0.0
                 */
                fadeInContent: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["trigger"])('fadeInContent', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["state"])('showing', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ opacity: 1 })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('void => showing', [
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ opacity: 0 }),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])('150ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)')
                    ])
                ])
            };
            /**
             * @deprecated
             * \@breaking-change 8.0.0
             * \@docs-private
             * @type {?}
             */
            var transformPanel = matSelectAnimations.transformPanel;
            /**
             * @deprecated
             * \@breaking-change 8.0.0
             * \@docs-private
             * @type {?}
             */
            var fadeInContent = matSelectAnimations.fadeInContent;
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Returns an exception to be thrown when attempting to change a select's `multiple` option
             * after initialization.
             * \@docs-private
             * @return {?}
             */
            function getMatSelectDynamicMultipleError() {
                return Error('Cannot change `multiple` mode of select after initialization.');
            }
            /**
             * Returns an exception to be thrown when attempting to assign a non-array value to a select
             * in `multiple` mode. Note that `undefined` and `null` are still valid values to allow for
             * resetting the value.
             * \@docs-private
             * @return {?}
             */
            function getMatSelectNonArrayValueError() {
                return Error('Value must be an array in multiple-selection mode.');
            }
            /**
             * Returns an exception to be thrown when assigning a non-function value to the comparator
             * used to determine if a value corresponds to an option. Note that whether the function
             * actually takes two values and returns a boolean is not checked.
             * @return {?}
             */
            function getMatSelectNonFunctionValueError() {
                return Error('`compareWith` must be a function.');
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var nextUniqueId = 0;
            /**
             * The max height of the select's overlay panel
             * @type {?}
             */
            var SELECT_PANEL_MAX_HEIGHT = 256;
            /**
             * The panel's padding on the x-axis
             * @type {?}
             */
            var SELECT_PANEL_PADDING_X = 16;
            /**
             * The panel's x axis padding if it is indented (e.g. there is an option group).
             * @type {?}
             */
            var SELECT_PANEL_INDENT_PADDING_X = SELECT_PANEL_PADDING_X * 2;
            /**
             * The height of the select items in `em` units.
             * @type {?}
             */
            var SELECT_ITEM_HEIGHT_EM = 3;
            // TODO(josephperrott): Revert to a constant after 2018 spec updates are fully merged.
            /**
             * Distance between the panel edge and the option text in
             * multi-selection mode.
             *
             * Calculated as:
             * (SELECT_PANEL_PADDING_X * 1.5) + 16 = 40
             * The padding is multiplied by 1.5 because the checkbox's margin is half the padding.
             * The checkbox width is 16px.
             * @type {?}
             */
            var SELECT_MULTIPLE_PANEL_PADDING_X = SELECT_PANEL_PADDING_X * 1.5 + 16;
            /**
             * The select panel will only "fit" inside the viewport if it is positioned at
             * this value or more away from the viewport boundary.
             * @type {?}
             */
            var SELECT_PANEL_VIEWPORT_PADDING = 8;
            /**
             * Injection token that determines the scroll handling while a select is open.
             * @type {?}
             */
            var MAT_SELECT_SCROLL_STRATEGY = new _angular_core__WEBPACK_IMPORTED_MODULE_8__["InjectionToken"]('mat-select-scroll-strategy');
            /**
             * \@docs-private
             * @param {?} overlay
             * @return {?}
             */
            function MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {
                return ( /**
                 * @return {?}
                 */function () { return overlay.scrollStrategies.reposition(); });
            }
            /**
             * \@docs-private
             * @type {?}
             */
            var MAT_SELECT_SCROLL_STRATEGY_PROVIDER = {
                provide: MAT_SELECT_SCROLL_STRATEGY,
                deps: [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["Overlay"]],
                useFactory: MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY,
            };
            /**
             * Change event object that is emitted when the select value has changed.
             */
            var MatSelectChange = /** @class */ (function () {
                /**
                 * @param {?} source
                 * @param {?} value
                 */
                function MatSelectChange(source, value) {
                    this.source = source;
                    this.value = value;
                }
                return MatSelectChange;
            }());
            // Boilerplate for applying mixins to MatSelect.
            /**
             * \@docs-private
             */
            var MatSelectBase = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 * @param {?} _defaultErrorStateMatcher
                 * @param {?} _parentForm
                 * @param {?} _parentFormGroup
                 * @param {?} ngControl
                 */
                function MatSelectBase(_elementRef, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {
                    this._elementRef = _elementRef;
                    this._defaultErrorStateMatcher = _defaultErrorStateMatcher;
                    this._parentForm = _parentForm;
                    this._parentFormGroup = _parentFormGroup;
                    this.ngControl = ngControl;
                }
                return MatSelectBase;
            }());
            /** @type {?} */
            var _MatSelectMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_10__["mixinDisableRipple"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_10__["mixinTabIndex"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_10__["mixinDisabled"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_10__["mixinErrorState"])(MatSelectBase))));
            /**
             * Allows the user to customize the trigger that is displayed when the select has a value.
             */
            var MatSelectTrigger = /** @class */ (function () {
                function MatSelectTrigger() {
                }
                return MatSelectTrigger;
            }());
            MatSelectTrigger.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Directive"], args: [{
                            selector: 'mat-select-trigger'
                        },] },
            ];
            var MatSelect = /** @class */ (function (_super) {
                __extends(MatSelect, _super);
                /**
                 * @param {?} _viewportRuler
                 * @param {?} _changeDetectorRef
                 * @param {?} _ngZone
                 * @param {?} _defaultErrorStateMatcher
                 * @param {?} elementRef
                 * @param {?} _dir
                 * @param {?} _parentForm
                 * @param {?} _parentFormGroup
                 * @param {?} _parentFormField
                 * @param {?} ngControl
                 * @param {?} tabIndex
                 * @param {?} scrollStrategyFactory
                 * @param {?=} _liveAnnouncer
                 */
                function MatSelect(_viewportRuler, _changeDetectorRef, _ngZone, _defaultErrorStateMatcher, elementRef, _dir, _parentForm, _parentFormGroup, _parentFormField, ngControl, tabIndex, scrollStrategyFactory, _liveAnnouncer) {
                    var _this_1 = _super.call(this, elementRef, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) || this;
                    _this_1._viewportRuler = _viewportRuler;
                    _this_1._changeDetectorRef = _changeDetectorRef;
                    _this_1._ngZone = _ngZone;
                    _this_1._dir = _dir;
                    _this_1._parentFormField = _parentFormField;
                    _this_1.ngControl = ngControl;
                    _this_1._liveAnnouncer = _liveAnnouncer;
                    /**
                     * Whether or not the overlay panel is open.
                     */
                    _this_1._panelOpen = false;
                    /**
                     * Whether filling out the select is required in the form.
                     */
                    _this_1._required = false;
                    /**
                     * The scroll position of the overlay panel, calculated to center the selected option.
                     */
                    _this_1._scrollTop = 0;
                    /**
                     * Whether the component is in multiple selection mode.
                     */
                    _this_1._multiple = false;
                    /**
                     * Comparison function to specify which option is displayed. Defaults to object equality.
                     */
                    _this_1._compareWith = ( /**
                     * @param {?} o1
                     * @param {?} o2
                     * @return {?}
                     */function (o1, o2) { return o1 === o2; });
                    /**
                     * Unique id for this input.
                     */
                    _this_1._uid = "mat-select-" + nextUniqueId++;
                    /**
                     * Emits whenever the component is destroyed.
                     */
                    _this_1._destroy = new rxjs__WEBPACK_IMPORTED_MODULE_12__["Subject"]();
                    /**
                     * The cached font-size of the trigger element.
                     */
                    _this_1._triggerFontSize = 0;
                    /**
                     * `View -> model callback called when value changes`
                     */
                    _this_1._onChange = ( /**
                     * @return {?}
                     */function () { });
                    /**
                     * `View -> model callback called when select has been touched`
                     */
                    _this_1._onTouched = ( /**
                     * @return {?}
                     */function () { });
                    /**
                     * The IDs of child options to be passed to the aria-owns attribute.
                     */
                    _this_1._optionIds = '';
                    /**
                     * The value of the select panel's transform-origin property.
                     */
                    _this_1._transformOrigin = 'top';
                    /**
                     * Emits when the panel element is finished transforming in.
                     */
                    _this_1._panelDoneAnimatingStream = new rxjs__WEBPACK_IMPORTED_MODULE_12__["Subject"]();
                    /**
                     * The y-offset of the overlay panel in relation to the trigger's top start corner.
                     * This must be adjusted to align the selected option text over the trigger text.
                     * when the panel opens. Will change based on the y-position of the selected option.
                     */
                    _this_1._offsetY = 0;
                    /**
                     * This position config ensures that the top "start" corner of the overlay
                     * is aligned with with the top "start" of the origin by default (overlapping
                     * the trigger completely). If the panel cannot fit below the trigger, it
                     * will fall back to a position above the trigger.
                     */
                    _this_1._positions = [
                        {
                            originX: 'start',
                            originY: 'top',
                            overlayX: 'start',
                            overlayY: 'top',
                        },
                        {
                            originX: 'start',
                            originY: 'bottom',
                            overlayX: 'start',
                            overlayY: 'bottom',
                        },
                    ];
                    /**
                     * Whether the component is disabling centering of the active option over the trigger.
                     */
                    _this_1._disableOptionCentering = false;
                    _this_1._focused = false;
                    /**
                     * A name for this control that can be used by `mat-form-field`.
                     */
                    _this_1.controlType = 'mat-select';
                    /**
                     * Aria label of the select. If not specified, the placeholder will be used as label.
                     */
                    _this_1.ariaLabel = '';
                    /**
                     * Combined stream of all of the child options' change events.
                     */
                    _this_1.optionSelectionChanges = ( /** @type {?} */(Object(rxjs__WEBPACK_IMPORTED_MODULE_12__["defer"])(( /**
                     * @return {?}
                     */function () {
                        /** @type {?} */
                        var options = _this_1.options;
                        if (options) {
                            return options.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["startWith"])(options), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["switchMap"])(( /**
                             * @return {?}
                             */function () { return Object(rxjs__WEBPACK_IMPORTED_MODULE_12__["merge"]).apply(void 0, options.map(( /**
                             * @param {?} option
                             * @return {?}
                             */function (/**
                             * @param {?} option
                             * @return {?}
                             */ option) { return option.onSelectionChange; }))); })));
                        }
                        return _this_1._ngZone.onStable
                            .asObservable()
                            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["take"])(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["switchMap"])(( /**
                     * @return {?}
                     */function () { return _this_1.optionSelectionChanges; })));
                    }))));
                    /**
                     * Event emitted when the select panel has been toggled.
                     */
                    _this_1.openedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_8__["EventEmitter"]();
                    /**
                     * Event emitted when the select has been opened.
                     */
                    _this_1._openedStream = _this_1.openedChange.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["filter"])(( /**
                     * @param {?} o
                     * @return {?}
                     */function (/**
                     * @param {?} o
                     * @return {?}
                     */ o) { return o; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["map"])(( /**
                     * @return {?}
                     */function () { })));
                    /**
                     * Event emitted when the select has been closed.
                     */
                    _this_1._closedStream = _this_1.openedChange.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["filter"])(( /**
                     * @param {?} o
                     * @return {?}
                     */function (/**
                     * @param {?} o
                     * @return {?}
                     */ o) { return !o; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["map"])(( /**
                     * @return {?}
                     */function () { })));
                    /**
                     * Event emitted when the selected value has been changed by the user.
                     */
                    _this_1.selectionChange = new _angular_core__WEBPACK_IMPORTED_MODULE_8__["EventEmitter"]();
                    /**
                     * Event that emits whenever the raw value of the select changes. This is here primarily
                     * to facilitate the two-way binding for the `value` input.
                     * \@docs-private
                     */
                    _this_1.valueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_8__["EventEmitter"]();
                    if (_this_1.ngControl) {
                        // Note: we provide the value accessor through here, instead of
                        // the `providers` to avoid running into a circular import.
                        _this_1.ngControl.valueAccessor = _this_1;
                    }
                    _this_1._scrollStrategyFactory = scrollStrategyFactory;
                    _this_1._scrollStrategy = _this_1._scrollStrategyFactory();
                    _this_1.tabIndex = parseInt(tabIndex) || 0;
                    // Force setter to be called in case id was not specified.
                    _this_1.id = _this_1.id;
                    return _this_1;
                }
                Object.defineProperty(MatSelect.prototype, "focused", {
                    /**
                     * Whether the select is focused.
                     * @return {?}
                     */
                    get: function () {
                        return this._focused || this._panelOpen;
                    },
                    /**
                     * @deprecated Setter to be removed as this property is intended to be readonly.
                     * \@breaking-change 8.0.0
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._focused = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSelect.prototype, "placeholder", {
                    /**
                     * Placeholder to be shown if no value has been selected.
                     * @return {?}
                     */
                    get: function () { return this._placeholder; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._placeholder = value;
                        this.stateChanges.next();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSelect.prototype, "required", {
                    /**
                     * Whether the component is required.
                     * @return {?}
                     */
                    get: function () { return this._required; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._required = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);
                        this.stateChanges.next();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSelect.prototype, "multiple", {
                    /**
                     * Whether the user should be allowed to select multiple options.
                     * @return {?}
                     */
                    get: function () { return this._multiple; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (this._selectionModel) {
                            throw getMatSelectDynamicMultipleError();
                        }
                        this._multiple = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSelect.prototype, "disableOptionCentering", {
                    /**
                     * Whether to center the active option over the trigger.
                     * @return {?}
                     */
                    get: function () { return this._disableOptionCentering; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._disableOptionCentering = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSelect.prototype, "compareWith", {
                    /**
                     * Function to compare the option values with the selected values. The first argument
                     * is a value from an option. The second is a value from the selection. A boolean
                     * should be returned.
                     * @return {?}
                     */
                    get: function () { return this._compareWith; },
                    /**
                     * @param {?} fn
                     * @return {?}
                     */
                    set: function (fn) {
                        if (typeof fn !== 'function') {
                            throw getMatSelectNonFunctionValueError();
                        }
                        this._compareWith = fn;
                        if (this._selectionModel) {
                            // A different comparator means the selection could change.
                            this._initializeSelection();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSelect.prototype, "value", {
                    /**
                     * Value of the select control.
                     * @return {?}
                     */
                    get: function () { return this._value; },
                    /**
                     * @param {?} newValue
                     * @return {?}
                     */
                    set: function (newValue) {
                        if (newValue !== this._value) {
                            this.writeValue(newValue);
                            this._value = newValue;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSelect.prototype, "id", {
                    /**
                     * Unique id of the element.
                     * @return {?}
                     */
                    get: function () { return this._id; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._id = value || this._uid;
                        this.stateChanges.next();
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatSelect.prototype.ngOnInit = function () {
                    var _this_1 = this;
                    this._selectionModel = new _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_4__["SelectionModel"](this.multiple);
                    this.stateChanges.next();
                    // We need `distinctUntilChanged` here, because some browsers will
                    // fire the animation end event twice for the same animation. See:
                    // https://github.com/angular/angular/issues/24084
                    this._panelDoneAnimatingStream
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["distinctUntilChanged"])(), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["takeUntil"])(this._destroy))
                        .subscribe(( /**
                 * @return {?}
                 */function () {
                        if (_this_1.panelOpen) {
                            _this_1._scrollTop = 0;
                            _this_1.openedChange.emit(true);
                        }
                        else {
                            _this_1.openedChange.emit(false);
                            _this_1.overlayDir.offsetX = 0;
                            _this_1._changeDetectorRef.markForCheck();
                        }
                    }));
                    this._viewportRuler.change()
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["takeUntil"])(this._destroy))
                        .subscribe(( /**
                 * @return {?}
                 */function () {
                        if (_this_1._panelOpen) {
                            _this_1._triggerRect = _this_1.trigger.nativeElement.getBoundingClientRect();
                            _this_1._changeDetectorRef.markForCheck();
                        }
                    }));
                };
                /**
                 * @return {?}
                 */
                MatSelect.prototype.ngAfterContentInit = function () {
                    var _this_1 = this;
                    this._initKeyManager();
                    this._selectionModel.onChange.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["takeUntil"])(this._destroy)).subscribe(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) {
                        event.added.forEach(( /**
                         * @param {?} option
                         * @return {?}
                         */function (/**
                         * @param {?} option
                         * @return {?}
                         */ option) { return option.select(); }));
                        event.removed.forEach(( /**
                         * @param {?} option
                         * @return {?}
                         */function (/**
                         * @param {?} option
                         * @return {?}
                         */ option) { return option.deselect(); }));
                    }));
                    this.options.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["startWith"])(null), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["takeUntil"])(this._destroy)).subscribe(( /**
                     * @return {?}
                     */function () {
                        _this_1._resetOptions();
                        _this_1._initializeSelection();
                    }));
                };
                /**
                 * @return {?}
                 */
                MatSelect.prototype.ngDoCheck = function () {
                    if (this.ngControl) {
                        this.updateErrorState();
                    }
                };
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                MatSelect.prototype.ngOnChanges = function (changes) {
                    // Updating the disabled state is handled by `mixinDisabled`, but we need to additionally let
                    // the parent form field know to run change detection when the disabled state changes.
                    if (changes['disabled']) {
                        this.stateChanges.next();
                    }
                    if (changes['typeaheadDebounceInterval'] && this._keyManager) {
                        this._keyManager.withTypeAhead(this.typeaheadDebounceInterval);
                    }
                };
                /**
                 * @return {?}
                 */
                MatSelect.prototype.ngOnDestroy = function () {
                    this._destroy.next();
                    this._destroy.complete();
                    this.stateChanges.complete();
                };
                /**
                 * Toggles the overlay panel open or closed.
                 * @return {?}
                 */
                MatSelect.prototype.toggle = function () {
                    this.panelOpen ? this.close() : this.open();
                };
                /**
                 * Opens the overlay panel.
                 * @return {?}
                 */
                MatSelect.prototype.open = function () {
                    var _this_1 = this;
                    if (this.disabled || !this.options || !this.options.length || this._panelOpen) {
                        return;
                    }
                    this._triggerRect = this.trigger.nativeElement.getBoundingClientRect();
                    // Note: The computed font-size will be a string pixel value (e.g. "16px").
                    // `parseInt` ignores the trailing 'px' and converts this to a number.
                    this._triggerFontSize = parseInt(getComputedStyle(this.trigger.nativeElement).fontSize || '0');
                    this._panelOpen = true;
                    this._keyManager.withHorizontalOrientation(null);
                    this._calculateOverlayPosition();
                    this._highlightCorrectOption();
                    this._changeDetectorRef.markForCheck();
                    // Set the font size on the panel element once it exists.
                    this._ngZone.onStable.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["take"])(1)).subscribe(( /**
                     * @return {?}
                     */function () {
                        if (_this_1._triggerFontSize && _this_1.overlayDir.overlayRef &&
                            _this_1.overlayDir.overlayRef.overlayElement) {
                            _this_1.overlayDir.overlayRef.overlayElement.style.fontSize = _this_1._triggerFontSize + "px";
                        }
                    }));
                };
                /**
                 * Closes the overlay panel and focuses the host element.
                 * @return {?}
                 */
                MatSelect.prototype.close = function () {
                    if (this._panelOpen) {
                        this._panelOpen = false;
                        this._keyManager.withHorizontalOrientation(this._isRtl() ? 'rtl' : 'ltr');
                        this._changeDetectorRef.markForCheck();
                        this._onTouched();
                    }
                };
                /**
                 * Sets the select's value. Part of the ControlValueAccessor interface
                 * required to integrate with Angular's core forms API.
                 *
                 * @param {?} value New value to be written to the model.
                 * @return {?}
                 */
                MatSelect.prototype.writeValue = function (value) {
                    if (this.options) {
                        this._setSelectionByValue(value);
                    }
                };
                /**
                 * Saves a callback function to be invoked when the select's value
                 * changes from user input. Part of the ControlValueAccessor interface
                 * required to integrate with Angular's core forms API.
                 *
                 * @param {?} fn Callback to be triggered when the value changes.
                 * @return {?}
                 */
                MatSelect.prototype.registerOnChange = function (fn) {
                    this._onChange = fn;
                };
                /**
                 * Saves a callback function to be invoked when the select is blurred
                 * by the user. Part of the ControlValueAccessor interface required
                 * to integrate with Angular's core forms API.
                 *
                 * @param {?} fn Callback to be triggered when the component has been touched.
                 * @return {?}
                 */
                MatSelect.prototype.registerOnTouched = function (fn) {
                    this._onTouched = fn;
                };
                /**
                 * Disables the select. Part of the ControlValueAccessor interface required
                 * to integrate with Angular's core forms API.
                 *
                 * @param {?} isDisabled Sets whether the component is disabled.
                 * @return {?}
                 */
                MatSelect.prototype.setDisabledState = function (isDisabled) {
                    this.disabled = isDisabled;
                    this._changeDetectorRef.markForCheck();
                    this.stateChanges.next();
                };
                Object.defineProperty(MatSelect.prototype, "panelOpen", {
                    /**
                     * Whether or not the overlay panel is open.
                     * @return {?}
                     */
                    get: function () {
                        return this._panelOpen;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSelect.prototype, "selected", {
                    /**
                     * The currently selected option.
                     * @return {?}
                     */
                    get: function () {
                        return this.multiple ? this._selectionModel.selected : this._selectionModel.selected[0];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSelect.prototype, "triggerValue", {
                    /**
                     * The value displayed in the trigger.
                     * @return {?}
                     */
                    get: function () {
                        if (this.empty) {
                            return '';
                        }
                        if (this._multiple) {
                            /** @type {?} */
                            var selectedOptions = this._selectionModel.selected.map(( /**
                             * @param {?} option
                             * @return {?}
                             */function (/**
                             * @param {?} option
                             * @return {?}
                             */ option) { return option.viewValue; }));
                            if (this._isRtl()) {
                                selectedOptions.reverse();
                            }
                            // TODO(crisbeto): delimiter should be configurable for proper localization.
                            return selectedOptions.join(', ');
                        }
                        return this._selectionModel.selected[0].viewValue;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Whether the element is in RTL mode.
                 * @return {?}
                 */
                MatSelect.prototype._isRtl = function () {
                    return this._dir ? this._dir.value === 'rtl' : false;
                };
                /**
                 * Handles all keydown events on the select.
                 * @param {?} event
                 * @return {?}
                 */
                MatSelect.prototype._handleKeydown = function (event) {
                    if (!this.disabled) {
                        this.panelOpen ? this._handleOpenKeydown(event) : this._handleClosedKeydown(event);
                    }
                };
                /**
                 * Handles keyboard events while the select is closed.
                 * @private
                 * @param {?} event
                 * @return {?}
                 */
                MatSelect.prototype._handleClosedKeydown = function (event) {
                    /** @type {?} */
                    var keyCode = event.keyCode;
                    /** @type {?} */
                    var isArrowKey = keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["DOWN_ARROW"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["UP_ARROW"] ||
                        keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["LEFT_ARROW"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["RIGHT_ARROW"];
                    /** @type {?} */
                    var isOpenKey = keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["ENTER"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["SPACE"];
                    /** @type {?} */
                    var manager = this._keyManager;
                    // Open the select on ALT + arrow key to match the native <select>
                    if ((isOpenKey && !Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["hasModifierKey"])(event)) || ((this.multiple || event.altKey) && isArrowKey)) {
                        event.preventDefault(); // prevents the page from scrolling down when pressing space
                        this.open();
                    }
                    else if (!this.multiple) {
                        /** @type {?} */
                        var previouslySelectedOption = this.selected;
                        if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["HOME"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["END"]) {
                            keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["HOME"] ? manager.setFirstItemActive() : manager.setLastItemActive();
                            event.preventDefault();
                        }
                        else {
                            manager.onKeydown(event);
                        }
                        /** @type {?} */
                        var selectedOption = this.selected;
                        // Since the value has changed, we need to announce it ourselves.
                        // @breaking-change 8.0.0 remove null check for _liveAnnouncer.
                        if (this._liveAnnouncer && selectedOption && previouslySelectedOption !== selectedOption) {
                            // We set a duration on the live announcement, because we want the live element to be
                            // cleared after a while so that users can't navigate to it using the arrow keys.
                            this._liveAnnouncer.announce((( /** @type {?} */(selectedOption))).viewValue, 10000);
                        }
                    }
                };
                /**
                 * Handles keyboard events when the selected is open.
                 * @private
                 * @param {?} event
                 * @return {?}
                 */
                MatSelect.prototype._handleOpenKeydown = function (event) {
                    /** @type {?} */
                    var keyCode = event.keyCode;
                    /** @type {?} */
                    var isArrowKey = keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["DOWN_ARROW"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["UP_ARROW"];
                    /** @type {?} */
                    var manager = this._keyManager;
                    if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["HOME"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["END"]) {
                        event.preventDefault();
                        keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["HOME"] ? manager.setFirstItemActive() : manager.setLastItemActive();
                    }
                    else if (isArrowKey && event.altKey) {
                        // Close the select on ALT + arrow key to match the native <select>
                        event.preventDefault();
                        this.close();
                    }
                    else if ((keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["ENTER"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["SPACE"]) && manager.activeItem &&
                        !Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["hasModifierKey"])(event)) {
                        event.preventDefault();
                        manager.activeItem._selectViaInteraction();
                    }
                    else if (this._multiple && keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["A"] && event.ctrlKey) {
                        event.preventDefault();
                        /** @type {?} */
                        var hasDeselectedOptions_1 = this.options.some(( /**
                         * @param {?} opt
                         * @return {?}
                         */function (/**
                         * @param {?} opt
                         * @return {?}
                         */ opt) { return !opt.disabled && !opt.selected; }));
                        this.options.forEach(( /**
                         * @param {?} option
                         * @return {?}
                         */function (/**
                         * @param {?} option
                         * @return {?}
                         */ option) {
                            if (!option.disabled) {
                                hasDeselectedOptions_1 ? option.select() : option.deselect();
                            }
                        }));
                    }
                    else {
                        /** @type {?} */
                        var previouslyFocusedIndex = manager.activeItemIndex;
                        manager.onKeydown(event);
                        if (this._multiple && isArrowKey && event.shiftKey && manager.activeItem &&
                            manager.activeItemIndex !== previouslyFocusedIndex) {
                            manager.activeItem._selectViaInteraction();
                        }
                    }
                };
                /**
                 * @return {?}
                 */
                MatSelect.prototype._onFocus = function () {
                    if (!this.disabled) {
                        this._focused = true;
                        this.stateChanges.next();
                    }
                };
                /**
                 * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
                 * "blur" to the panel when it opens, causing a false positive.
                 * @return {?}
                 */
                MatSelect.prototype._onBlur = function () {
                    this._focused = false;
                    if (!this.disabled && !this.panelOpen) {
                        this._onTouched();
                        this._changeDetectorRef.markForCheck();
                        this.stateChanges.next();
                    }
                };
                /**
                 * Callback that is invoked when the overlay panel has been attached.
                 * @return {?}
                 */
                MatSelect.prototype._onAttached = function () {
                    var _this_1 = this;
                    this.overlayDir.positionChange.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["take"])(1)).subscribe(( /**
                     * @return {?}
                     */function () {
                        _this_1._changeDetectorRef.detectChanges();
                        _this_1._calculateOverlayOffsetX();
                        _this_1.panel.nativeElement.scrollTop = _this_1._scrollTop;
                    }));
                };
                /**
                 * Returns the theme to be used on the panel.
                 * @return {?}
                 */
                MatSelect.prototype._getPanelTheme = function () {
                    return this._parentFormField ? "mat-" + this._parentFormField.color : '';
                };
                Object.defineProperty(MatSelect.prototype, "empty", {
                    /**
                     * Whether the select has a value.
                     * @return {?}
                     */
                    get: function () {
                        return !this._selectionModel || this._selectionModel.isEmpty();
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @private
                 * @return {?}
                 */
                MatSelect.prototype._initializeSelection = function () {
                    var _this_1 = this;
                    // Defer setting the value in order to avoid the "Expression
                    // has changed after it was checked" errors from Angular.
                    Promise.resolve().then(( /**
                     * @return {?}
                     */function () {
                        _this_1._setSelectionByValue(_this_1.ngControl ? _this_1.ngControl.value : _this_1._value);
                        _this_1.stateChanges.next();
                    }));
                };
                /**
                 * Sets the selected option based on a value. If no option can be
                 * found with the designated value, the select trigger is cleared.
                 * @private
                 * @param {?} value
                 * @return {?}
                 */
                MatSelect.prototype._setSelectionByValue = function (value) {
                    var _this_1 = this;
                    if (this.multiple && value) {
                        if (!Array.isArray(value)) {
                            throw getMatSelectNonArrayValueError();
                        }
                        this._selectionModel.clear();
                        value.forEach(( /**
                         * @param {?} currentValue
                         * @return {?}
                         */function (currentValue) { return _this_1._selectValue(currentValue); }));
                        this._sortValues();
                    }
                    else {
                        this._selectionModel.clear();
                        /** @type {?} */
                        var correspondingOption = this._selectValue(value);
                        // Shift focus to the active item. Note that we shouldn't do this in multiple
                        // mode, because we don't know what option the user interacted with last.
                        if (correspondingOption) {
                            this._keyManager.setActiveItem(correspondingOption);
                        }
                        else if (!this.panelOpen) {
                            // Otherwise reset the highlighted option. Note that we only want to do this while
                            // closed, because doing it while open can shift the user's focus unnecessarily.
                            this._keyManager.setActiveItem(-1);
                        }
                    }
                    this._changeDetectorRef.markForCheck();
                };
                /**
                 * Finds and selects and option based on its value.
                 * @private
                 * @param {?} value
                 * @return {?} Option that has the corresponding value.
                 */
                MatSelect.prototype._selectValue = function (value) {
                    var _this_1 = this;
                    /** @type {?} */
                    var correspondingOption = this.options.find(( /**
                     * @param {?} option
                     * @return {?}
                     */function (option) {
                        try {
                            // Treat null as a special reset value.
                            return option.value != null && _this_1._compareWith(option.value, value);
                        }
                        catch (error) {
                            if (Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["isDevMode"])()) {
                                // Notify developers of errors in their comparator.
                                console.warn(error);
                            }
                            return false;
                        }
                    }));
                    if (correspondingOption) {
                        this._selectionModel.select(correspondingOption);
                    }
                    return correspondingOption;
                };
                /**
                 * Sets up a key manager to listen to keyboard events on the overlay panel.
                 * @private
                 * @return {?}
                 */
                MatSelect.prototype._initKeyManager = function () {
                    var _this_1 = this;
                    this._keyManager = new _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__["ActiveDescendantKeyManager"](this.options)
                        .withTypeAhead(this.typeaheadDebounceInterval)
                        .withVerticalOrientation()
                        .withHorizontalOrientation(this._isRtl() ? 'rtl' : 'ltr')
                        .withAllowedModifierKeys(['shiftKey']);
                    this._keyManager.tabOut.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["takeUntil"])(this._destroy)).subscribe(( /**
                     * @return {?}
                     */function () {
                        // Restore focus to the trigger before closing. Ensures that the focus
                        // position won't be lost if the user got focus into the overlay.
                        _this_1.focus();
                        _this_1.close();
                    }));
                    this._keyManager.change.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["takeUntil"])(this._destroy)).subscribe(( /**
                     * @return {?}
                     */function () {
                        if (_this_1._panelOpen && _this_1.panel) {
                            _this_1._scrollActiveOptionIntoView();
                        }
                        else if (!_this_1._panelOpen && !_this_1.multiple && _this_1._keyManager.activeItem) {
                            _this_1._keyManager.activeItem._selectViaInteraction();
                        }
                    }));
                };
                /**
                 * Drops current option subscriptions and IDs and resets from scratch.
                 * @private
                 * @return {?}
                 */
                MatSelect.prototype._resetOptions = function () {
                    var _this_1 = this;
                    /** @type {?} */
                    var changedOrDestroyed = Object(rxjs__WEBPACK_IMPORTED_MODULE_12__["merge"])(this.options.changes, this._destroy);
                    this.optionSelectionChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["takeUntil"])(changedOrDestroyed)).subscribe(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) {
                        _this_1._onSelect(event.source, event.isUserInput);
                        if (event.isUserInput && !_this_1.multiple && _this_1._panelOpen) {
                            _this_1.close();
                            _this_1.focus();
                        }
                    }));
                    // Listen to changes in the internal state of the options and react accordingly.
                    // Handles cases like the labels of the selected options changing.
                    Object(rxjs__WEBPACK_IMPORTED_MODULE_12__["merge"]).apply(void 0, this.options.map(( /**
                     * @param {?} option
                     * @return {?}
                     */function (/**
                     * @param {?} option
                     * @return {?}
                     */ option) { return option._stateChanges; }))).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["takeUntil"])(changedOrDestroyed))
                        .subscribe(( /**
                 * @return {?}
                 */function () {
                        _this_1._changeDetectorRef.markForCheck();
                        _this_1.stateChanges.next();
                    }));
                    this._setOptionIds();
                };
                /**
                 * Invoked when an option is clicked.
                 * @private
                 * @param {?} option
                 * @param {?} isUserInput
                 * @return {?}
                 */
                MatSelect.prototype._onSelect = function (option, isUserInput) {
                    /** @type {?} */
                    var wasSelected = this._selectionModel.isSelected(option);
                    if (option.value == null && !this._multiple) {
                        option.deselect();
                        this._selectionModel.clear();
                        this._propagateChanges(option.value);
                    }
                    else {
                        if (wasSelected !== option.selected) {
                            option.selected ? this._selectionModel.select(option) :
                                this._selectionModel.deselect(option);
                        }
                        if (isUserInput) {
                            this._keyManager.setActiveItem(option);
                        }
                        if (this.multiple) {
                            this._sortValues();
                            if (isUserInput) {
                                // In case the user selected the option with their mouse, we
                                // want to restore focus back to the trigger, in order to
                                // prevent the select keyboard controls from clashing with
                                // the ones from `mat-option`.
                                this.focus();
                            }
                        }
                    }
                    if (wasSelected !== this._selectionModel.isSelected(option)) {
                        this._propagateChanges();
                    }
                    this.stateChanges.next();
                };
                /**
                 * Sorts the selected values in the selected based on their order in the panel.
                 * @private
                 * @return {?}
                 */
                MatSelect.prototype._sortValues = function () {
                    var _this_1 = this;
                    if (this.multiple) {
                        /** @type {?} */
                        var options_1 = this.options.toArray();
                        this._selectionModel.sort(( /**
                         * @param {?} a
                         * @param {?} b
                         * @return {?}
                         */function (a, b) {
                            return _this_1.sortComparator ? _this_1.sortComparator(a, b, options_1) :
                                options_1.indexOf(a) - options_1.indexOf(b);
                        }));
                        this.stateChanges.next();
                    }
                };
                /**
                 * Emits change event to set the model value.
                 * @private
                 * @param {?=} fallbackValue
                 * @return {?}
                 */
                MatSelect.prototype._propagateChanges = function (fallbackValue) {
                    /** @type {?} */
                    var valueToEmit = null;
                    if (this.multiple) {
                        valueToEmit = (( /** @type {?} */(this.selected))).map(( /**
                         * @param {?} option
                         * @return {?}
                         */function (/**
                         * @param {?} option
                         * @return {?}
                         */ option) { return option.value; }));
                    }
                    else {
                        valueToEmit = this.selected ? (( /** @type {?} */(this.selected))).value : fallbackValue;
                    }
                    this._value = valueToEmit;
                    this.valueChange.emit(valueToEmit);
                    this._onChange(valueToEmit);
                    this.selectionChange.emit(new MatSelectChange(this, valueToEmit));
                    this._changeDetectorRef.markForCheck();
                };
                /**
                 * Records option IDs to pass to the aria-owns property.
                 * @private
                 * @return {?}
                 */
                MatSelect.prototype._setOptionIds = function () {
                    this._optionIds = this.options.map(( /**
                     * @param {?} option
                     * @return {?}
                     */function (/**
                     * @param {?} option
                     * @return {?}
                     */ option) { return option.id; })).join(' ');
                };
                /**
                 * Highlights the selected item. If no option is selected, it will highlight
                 * the first item instead.
                 * @private
                 * @return {?}
                 */
                MatSelect.prototype._highlightCorrectOption = function () {
                    if (this._keyManager) {
                        if (this.empty) {
                            this._keyManager.setFirstItemActive();
                        }
                        else {
                            this._keyManager.setActiveItem(this._selectionModel.selected[0]);
                        }
                    }
                };
                /**
                 * Scrolls the active option into view.
                 * @private
                 * @return {?}
                 */
                MatSelect.prototype._scrollActiveOptionIntoView = function () {
                    /** @type {?} */
                    var activeOptionIndex = this._keyManager.activeItemIndex || 0;
                    /** @type {?} */
                    var labelCount = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_10__["_countGroupLabelsBeforeOption"])(activeOptionIndex, this.options, this.optionGroups);
                    this.panel.nativeElement.scrollTop = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_10__["_getOptionScrollPosition"])(activeOptionIndex + labelCount, this._getItemHeight(), this.panel.nativeElement.scrollTop, SELECT_PANEL_MAX_HEIGHT);
                };
                /**
                 * Focuses the select element.
                 * @param {?=} options
                 * @return {?}
                 */
                MatSelect.prototype.focus = function (options) {
                    this._elementRef.nativeElement.focus(options);
                };
                /**
                 * Gets the index of the provided option in the option list.
                 * @private
                 * @param {?} option
                 * @return {?}
                 */
                MatSelect.prototype._getOptionIndex = function (option) {
                    return this.options.reduce(( /**
                     * @param {?} result
                     * @param {?} current
                     * @param {?} index
                     * @return {?}
                     */function (result, current, index) {
                        return result === undefined ? (option === current ? index : undefined) : result;
                    }), undefined);
                };
                /**
                 * Calculates the scroll position and x- and y-offsets of the overlay panel.
                 * @private
                 * @return {?}
                 */
                MatSelect.prototype._calculateOverlayPosition = function () {
                    /** @type {?} */
                    var itemHeight = this._getItemHeight();
                    /** @type {?} */
                    var items = this._getItemCount();
                    /** @type {?} */
                    var panelHeight = Math.min(items * itemHeight, SELECT_PANEL_MAX_HEIGHT);
                    /** @type {?} */
                    var scrollContainerHeight = items * itemHeight;
                    // The farthest the panel can be scrolled before it hits the bottom
                    /** @type {?} */
                    var maxScroll = scrollContainerHeight - panelHeight;
                    // If no value is selected we open the popup to the first item.
                    /** @type {?} */
                    var selectedOptionOffset = this.empty ? 0 : ( /** @type {?} */(this._getOptionIndex(this._selectionModel.selected[0])));
                    selectedOptionOffset += Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_10__["_countGroupLabelsBeforeOption"])(selectedOptionOffset, this.options, this.optionGroups);
                    // We must maintain a scroll buffer so the selected option will be scrolled to the
                    // center of the overlay panel rather than the top.
                    /** @type {?} */
                    var scrollBuffer = panelHeight / 2;
                    this._scrollTop = this._calculateOverlayScroll(selectedOptionOffset, scrollBuffer, maxScroll);
                    this._offsetY = this._calculateOverlayOffsetY(selectedOptionOffset, scrollBuffer, maxScroll);
                    this._checkOverlayWithinViewport(maxScroll);
                };
                /**
                 * Calculates the scroll position of the select's overlay panel.
                 *
                 * Attempts to center the selected option in the panel. If the option is
                 * too high or too low in the panel to be scrolled to the center, it clamps the
                 * scroll position to the min or max scroll positions respectively.
                 * @param {?} selectedIndex
                 * @param {?} scrollBuffer
                 * @param {?} maxScroll
                 * @return {?}
                 */
                MatSelect.prototype._calculateOverlayScroll = function (selectedIndex, scrollBuffer, maxScroll) {
                    /** @type {?} */
                    var itemHeight = this._getItemHeight();
                    /** @type {?} */
                    var optionOffsetFromScrollTop = itemHeight * selectedIndex;
                    /** @type {?} */
                    var halfOptionHeight = itemHeight / 2;
                    // Starts at the optionOffsetFromScrollTop, which scrolls the option to the top of the
                    // scroll container, then subtracts the scroll buffer to scroll the option down to
                    // the center of the overlay panel. Half the option height must be re-added to the
                    // scrollTop so the option is centered based on its middle, not its top edge.
                    /** @type {?} */
                    var optimalScrollPosition = optionOffsetFromScrollTop - scrollBuffer + halfOptionHeight;
                    return Math.min(Math.max(0, optimalScrollPosition), maxScroll);
                };
                /**
                 * Returns the aria-label of the select component.
                 * @return {?}
                 */
                MatSelect.prototype._getAriaLabel = function () {
                    // If an ariaLabelledby value has been set by the consumer, the select should not overwrite the
                    // `aria-labelledby` value by setting the ariaLabel to the placeholder.
                    return this.ariaLabelledby ? null : this.ariaLabel || this.placeholder;
                };
                /**
                 * Returns the aria-labelledby of the select component.
                 * @return {?}
                 */
                MatSelect.prototype._getAriaLabelledby = function () {
                    if (this.ariaLabelledby) {
                        return this.ariaLabelledby;
                    }
                    // Note: we use `_getAriaLabel` here, because we want to check whether there's a
                    // computed label. `this.ariaLabel` is only the user-specified label.
                    if (!this._parentFormField || !this._parentFormField._hasFloatingLabel() ||
                        this._getAriaLabel()) {
                        return null;
                    }
                    return this._parentFormField._labelId || null;
                };
                /**
                 * Determines the `aria-activedescendant` to be set on the host.
                 * @return {?}
                 */
                MatSelect.prototype._getAriaActiveDescendant = function () {
                    if (this.panelOpen && this._keyManager && this._keyManager.activeItem) {
                        return this._keyManager.activeItem.id;
                    }
                    return null;
                };
                /**
                 * Sets the x-offset of the overlay panel in relation to the trigger's top start corner.
                 * This must be adjusted to align the selected option text over the trigger text when
                 * the panel opens. Will change based on LTR or RTL text direction. Note that the offset
                 * can't be calculated until the panel has been attached, because we need to know the
                 * content width in order to constrain the panel within the viewport.
                 * @private
                 * @return {?}
                 */
                MatSelect.prototype._calculateOverlayOffsetX = function () {
                    /** @type {?} */
                    var overlayRect = this.overlayDir.overlayRef.overlayElement.getBoundingClientRect();
                    /** @type {?} */
                    var viewportSize = this._viewportRuler.getViewportSize();
                    /** @type {?} */
                    var isRtl = this._isRtl();
                    /** @type {?} */
                    var paddingWidth = this.multiple ? SELECT_MULTIPLE_PANEL_PADDING_X + SELECT_PANEL_PADDING_X :
                        SELECT_PANEL_PADDING_X * 2;
                    /** @type {?} */
                    var offsetX;
                    // Adjust the offset, depending on the option padding.
                    if (this.multiple) {
                        offsetX = SELECT_MULTIPLE_PANEL_PADDING_X;
                    }
                    else {
                        /** @type {?} */
                        var selected = this._selectionModel.selected[0] || this.options.first;
                        offsetX = selected && selected.group ? SELECT_PANEL_INDENT_PADDING_X : SELECT_PANEL_PADDING_X;
                    }
                    // Invert the offset in LTR.
                    if (!isRtl) {
                        offsetX *= -1;
                    }
                    // Determine how much the select overflows on each side.
                    /** @type {?} */
                    var leftOverflow = 0 - (overlayRect.left + offsetX - (isRtl ? paddingWidth : 0));
                    /** @type {?} */
                    var rightOverflow = overlayRect.right + offsetX - viewportSize.width
                        + (isRtl ? 0 : paddingWidth);
                    // If the element overflows on either side, reduce the offset to allow it to fit.
                    if (leftOverflow > 0) {
                        offsetX += leftOverflow + SELECT_PANEL_VIEWPORT_PADDING;
                    }
                    else if (rightOverflow > 0) {
                        offsetX -= rightOverflow + SELECT_PANEL_VIEWPORT_PADDING;
                    }
                    // Set the offset directly in order to avoid having to go through change detection and
                    // potentially triggering "changed after it was checked" errors. Round the value to avoid
                    // blurry content in some browsers.
                    this.overlayDir.offsetX = Math.round(offsetX);
                    this.overlayDir.overlayRef.updatePosition();
                };
                /**
                 * Calculates the y-offset of the select's overlay panel in relation to the
                 * top start corner of the trigger. It has to be adjusted in order for the
                 * selected option to be aligned over the trigger when the panel opens.
                 * @private
                 * @param {?} selectedIndex
                 * @param {?} scrollBuffer
                 * @param {?} maxScroll
                 * @return {?}
                 */
                MatSelect.prototype._calculateOverlayOffsetY = function (selectedIndex, scrollBuffer, maxScroll) {
                    /** @type {?} */
                    var itemHeight = this._getItemHeight();
                    /** @type {?} */
                    var optionHeightAdjustment = (itemHeight - this._triggerRect.height) / 2;
                    /** @type {?} */
                    var maxOptionsDisplayed = Math.floor(SELECT_PANEL_MAX_HEIGHT / itemHeight);
                    /** @type {?} */
                    var optionOffsetFromPanelTop;
                    // Disable offset if requested by user by returning 0 as value to offset
                    if (this._disableOptionCentering) {
                        return 0;
                    }
                    if (this._scrollTop === 0) {
                        optionOffsetFromPanelTop = selectedIndex * itemHeight;
                    }
                    else if (this._scrollTop === maxScroll) {
                        /** @type {?} */
                        var firstDisplayedIndex = this._getItemCount() - maxOptionsDisplayed;
                        /** @type {?} */
                        var selectedDisplayIndex = selectedIndex - firstDisplayedIndex;
                        // The first item is partially out of the viewport. Therefore we need to calculate what
                        // portion of it is shown in the viewport and account for it in our offset.
                        /** @type {?} */
                        var partialItemHeight = itemHeight - (this._getItemCount() * itemHeight - SELECT_PANEL_MAX_HEIGHT) % itemHeight;
                        // Because the panel height is longer than the height of the options alone,
                        // there is always extra padding at the top or bottom of the panel. When
                        // scrolled to the very bottom, this padding is at the top of the panel and
                        // must be added to the offset.
                        optionOffsetFromPanelTop = selectedDisplayIndex * itemHeight + partialItemHeight;
                    }
                    else {
                        // If the option was scrolled to the middle of the panel using a scroll buffer,
                        // its offset will be the scroll buffer minus the half height that was added to
                        // center it.
                        optionOffsetFromPanelTop = scrollBuffer - itemHeight / 2;
                    }
                    // The final offset is the option's offset from the top, adjusted for the height difference,
                    // multiplied by -1 to ensure that the overlay moves in the correct direction up the page.
                    // The value is rounded to prevent some browsers from blurring the content.
                    return Math.round(optionOffsetFromPanelTop * -1 - optionHeightAdjustment);
                };
                /**
                 * Checks that the attempted overlay position will fit within the viewport.
                 * If it will not fit, tries to adjust the scroll position and the associated
                 * y-offset so the panel can open fully on-screen. If it still won't fit,
                 * sets the offset back to 0 to allow the fallback position to take over.
                 * @private
                 * @param {?} maxScroll
                 * @return {?}
                 */
                MatSelect.prototype._checkOverlayWithinViewport = function (maxScroll) {
                    /** @type {?} */
                    var itemHeight = this._getItemHeight();
                    /** @type {?} */
                    var viewportSize = this._viewportRuler.getViewportSize();
                    /** @type {?} */
                    var topSpaceAvailable = this._triggerRect.top - SELECT_PANEL_VIEWPORT_PADDING;
                    /** @type {?} */
                    var bottomSpaceAvailable = viewportSize.height - this._triggerRect.bottom - SELECT_PANEL_VIEWPORT_PADDING;
                    /** @type {?} */
                    var panelHeightTop = Math.abs(this._offsetY);
                    /** @type {?} */
                    var totalPanelHeight = Math.min(this._getItemCount() * itemHeight, SELECT_PANEL_MAX_HEIGHT);
                    /** @type {?} */
                    var panelHeightBottom = totalPanelHeight - panelHeightTop - this._triggerRect.height;
                    if (panelHeightBottom > bottomSpaceAvailable) {
                        this._adjustPanelUp(panelHeightBottom, bottomSpaceAvailable);
                    }
                    else if (panelHeightTop > topSpaceAvailable) {
                        this._adjustPanelDown(panelHeightTop, topSpaceAvailable, maxScroll);
                    }
                    else {
                        this._transformOrigin = this._getOriginBasedOnOption();
                    }
                };
                /**
                 * Adjusts the overlay panel up to fit in the viewport.
                 * @private
                 * @param {?} panelHeightBottom
                 * @param {?} bottomSpaceAvailable
                 * @return {?}
                 */
                MatSelect.prototype._adjustPanelUp = function (panelHeightBottom, bottomSpaceAvailable) {
                    // Browsers ignore fractional scroll offsets, so we need to round.
                    /** @type {?} */
                    var distanceBelowViewport = Math.round(panelHeightBottom - bottomSpaceAvailable);
                    // Scrolls the panel up by the distance it was extending past the boundary, then
                    // adjusts the offset by that amount to move the panel up into the viewport.
                    this._scrollTop -= distanceBelowViewport;
                    this._offsetY -= distanceBelowViewport;
                    this._transformOrigin = this._getOriginBasedOnOption();
                    // If the panel is scrolled to the very top, it won't be able to fit the panel
                    // by scrolling, so set the offset to 0 to allow the fallback position to take
                    // effect.
                    if (this._scrollTop <= 0) {
                        this._scrollTop = 0;
                        this._offsetY = 0;
                        this._transformOrigin = "50% bottom 0px";
                    }
                };
                /**
                 * Adjusts the overlay panel down to fit in the viewport.
                 * @private
                 * @param {?} panelHeightTop
                 * @param {?} topSpaceAvailable
                 * @param {?} maxScroll
                 * @return {?}
                 */
                MatSelect.prototype._adjustPanelDown = function (panelHeightTop, topSpaceAvailable, maxScroll) {
                    // Browsers ignore fractional scroll offsets, so we need to round.
                    /** @type {?} */
                    var distanceAboveViewport = Math.round(panelHeightTop - topSpaceAvailable);
                    // Scrolls the panel down by the distance it was extending past the boundary, then
                    // adjusts the offset by that amount to move the panel down into the viewport.
                    this._scrollTop += distanceAboveViewport;
                    this._offsetY += distanceAboveViewport;
                    this._transformOrigin = this._getOriginBasedOnOption();
                    // If the panel is scrolled to the very bottom, it won't be able to fit the
                    // panel by scrolling, so set the offset to 0 to allow the fallback position
                    // to take effect.
                    if (this._scrollTop >= maxScroll) {
                        this._scrollTop = maxScroll;
                        this._offsetY = 0;
                        this._transformOrigin = "50% top 0px";
                        return;
                    }
                };
                /**
                 * Sets the transform origin point based on the selected option.
                 * @private
                 * @return {?}
                 */
                MatSelect.prototype._getOriginBasedOnOption = function () {
                    /** @type {?} */
                    var itemHeight = this._getItemHeight();
                    /** @type {?} */
                    var optionHeightAdjustment = (itemHeight - this._triggerRect.height) / 2;
                    /** @type {?} */
                    var originY = Math.abs(this._offsetY) - optionHeightAdjustment + itemHeight / 2;
                    return "50% " + originY + "px 0px";
                };
                /**
                 * Calculates the amount of items in the select. This includes options and group labels.
                 * @private
                 * @return {?}
                 */
                MatSelect.prototype._getItemCount = function () {
                    return this.options.length + this.optionGroups.length;
                };
                /**
                 * Calculates the height of the select's options.
                 * @private
                 * @return {?}
                 */
                MatSelect.prototype._getItemHeight = function () {
                    return this._triggerFontSize * SELECT_ITEM_HEIGHT_EM;
                };
                /**
                 * Implemented as part of MatFormFieldControl.
                 * \@docs-private
                 * @param {?} ids
                 * @return {?}
                 */
                MatSelect.prototype.setDescribedByIds = function (ids) {
                    this._ariaDescribedby = ids.join(' ');
                };
                /**
                 * Implemented as part of MatFormFieldControl.
                 * \@docs-private
                 * @return {?}
                 */
                MatSelect.prototype.onContainerClick = function () {
                    this.focus();
                    this.open();
                };
                Object.defineProperty(MatSelect.prototype, "shouldLabelFloat", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () {
                        return this._panelOpen || !this.empty;
                    },
                    enumerable: true,
                    configurable: true
                });
                return MatSelect;
            }(_MatSelectMixinBase));
            MatSelect.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"], args: [{ selector: 'mat-select',
                            exportAs: 'matSelect',
                            template: "<div cdk-overlay-origin class=\"mat-select-trigger\" aria-hidden=\"true\" (click)=\"toggle()\" #origin=\"cdkOverlayOrigin\" #trigger><div class=\"mat-select-value\" [ngSwitch]=\"empty\"><span class=\"mat-select-placeholder\" *ngSwitchCase=\"true\">{{placeholder || '\u00A0'}}</span> <span class=\"mat-select-value-text\" *ngSwitchCase=\"false\" [ngSwitch]=\"!!customTrigger\"><span *ngSwitchDefault>{{triggerValue || '\u00A0'}}</span><ng-content select=\"mat-select-trigger\" *ngSwitchCase=\"true\"></ng-content></span></div><div class=\"mat-select-arrow-wrapper\"><div class=\"mat-select-arrow\"></div></div></div><ng-template cdk-connected-overlay cdkConnectedOverlayLockPosition cdkConnectedOverlayHasBackdrop cdkConnectedOverlayBackdropClass=\"cdk-overlay-transparent-backdrop\" [cdkConnectedOverlayScrollStrategy]=\"_scrollStrategy\" [cdkConnectedOverlayOrigin]=\"origin\" [cdkConnectedOverlayOpen]=\"panelOpen\" [cdkConnectedOverlayPositions]=\"_positions\" [cdkConnectedOverlayMinWidth]=\"_triggerRect?.width\" [cdkConnectedOverlayOffsetY]=\"_offsetY\" (backdropClick)=\"close()\" (attach)=\"_onAttached()\" (detach)=\"close()\"><div class=\"mat-select-panel-wrap\" [@transformPanelWrap]><div #panel class=\"mat-select-panel {{ _getPanelTheme() }}\" [ngClass]=\"panelClass\" [@transformPanel]=\"multiple ? 'showing-multiple' : 'showing'\" (@transformPanel.done)=\"_panelDoneAnimatingStream.next($event.toState)\" [style.transformOrigin]=\"_transformOrigin\" [style.font-size.px]=\"_triggerFontSize\" (keydown)=\"_handleKeydown($event)\"><ng-content></ng-content></div></div></ng-template>",
                            styles: [".mat-select{display:inline-block;width:100%;outline:0}.mat-select-trigger{display:inline-table;cursor:pointer;position:relative;box-sizing:border-box}.mat-select-disabled .mat-select-trigger{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.mat-select-value{display:table-cell;max-width:0;width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.mat-select-value-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-select-arrow-wrapper{display:table-cell;vertical-align:middle}.mat-form-field-appearance-fill .mat-select-arrow-wrapper{transform:translateY(-50%)}.mat-form-field-appearance-outline .mat-select-arrow-wrapper{transform:translateY(-25%)}.mat-form-field-appearance-standard.mat-form-field-has-label .mat-select:not(.mat-select-empty) .mat-select-arrow-wrapper{transform:translateY(-50%)}.mat-form-field-appearance-standard .mat-select.mat-select-empty .mat-select-arrow-wrapper{transition:transform .4s cubic-bezier(.25,.8,.25,1)}._mat-animation-noopable.mat-form-field-appearance-standard .mat-select.mat-select-empty .mat-select-arrow-wrapper{transition:none}.mat-select-arrow{width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;margin:0 4px}.mat-select-panel-wrap{flex-basis:100%}.mat-select-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;padding-top:0;padding-bottom:0;max-height:256px;min-width:100%;border-radius:4px}@media (-ms-high-contrast:active){.mat-select-panel{outline:solid 1px}}.mat-select-panel .mat-optgroup-label,.mat-select-panel .mat-option{font-size:inherit;line-height:3em;height:3em}.mat-form-field-type-mat-select:not(.mat-form-field-disabled) .mat-form-field-flex{cursor:pointer}.mat-form-field-type-mat-select .mat-form-field-label{width:calc(100% - 18px)}.mat-select-placeholder{transition:color .4s .133s cubic-bezier(.25,.8,.25,1)}._mat-animation-noopable .mat-select-placeholder{transition:none}.mat-form-field-hide-placeholder .mat-select-placeholder{color:transparent;-webkit-text-fill-color:transparent;transition:none;display:block}"],
                            inputs: ['disabled', 'disableRipple', 'tabIndex'],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ChangeDetectionStrategy"].OnPush,
                            host: {
                                'role': 'listbox',
                                '[attr.id]': 'id',
                                '[attr.tabindex]': 'tabIndex',
                                '[attr.aria-label]': '_getAriaLabel()',
                                '[attr.aria-labelledby]': '_getAriaLabelledby()',
                                '[attr.aria-required]': 'required.toString()',
                                '[attr.aria-disabled]': 'disabled.toString()',
                                '[attr.aria-invalid]': 'errorState',
                                '[attr.aria-owns]': 'panelOpen ? _optionIds : null',
                                '[attr.aria-multiselectable]': 'multiple',
                                '[attr.aria-describedby]': '_ariaDescribedby || null',
                                '[attr.aria-activedescendant]': '_getAriaActiveDescendant()',
                                '[class.mat-select-disabled]': 'disabled',
                                '[class.mat-select-invalid]': 'errorState',
                                '[class.mat-select-required]': 'required',
                                '[class.mat-select-empty]': 'empty',
                                'class': 'mat-select',
                                '(keydown)': '_handleKeydown($event)',
                                '(focus)': '_onFocus()',
                                '(blur)': '_onBlur()',
                            },
                            animations: [
                                matSelectAnimations.transformPanelWrap,
                                matSelectAnimations.transformPanel
                            ],
                            providers: [
                                { provide: _angular_material_form_field__WEBPACK_IMPORTED_MODULE_11__["MatFormFieldControl"], useExisting: MatSelect },
                                { provide: _angular_material_core__WEBPACK_IMPORTED_MODULE_10__["MAT_OPTION_PARENT_COMPONENT"], useExisting: MatSelect }
                            ],
                        },] },
            ];
            /** @nocollapse */
            MatSelect.ctorParameters = function () { return [
                { type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_7__["ViewportRuler"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ChangeDetectorRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["NgZone"] },
                { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_10__["ErrorStateMatcher"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ElementRef"] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Optional"] }] },
                { type: _angular_forms__WEBPACK_IMPORTED_MODULE_9__["NgForm"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Optional"] }] },
                { type: _angular_forms__WEBPACK_IMPORTED_MODULE_9__["FormGroupDirective"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Optional"] }] },
                { type: _angular_material_form_field__WEBPACK_IMPORTED_MODULE_11__["MatFormField"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Optional"] }] },
                { type: _angular_forms__WEBPACK_IMPORTED_MODULE_9__["NgControl"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Self"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Optional"] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Attribute"], args: ['tabindex',] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Inject"], args: [MAT_SELECT_SCROLL_STRATEGY,] }] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__["LiveAnnouncer"] }
            ]; };
            MatSelect.propDecorators = {
                trigger: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ViewChild"], args: ['trigger', { static: false },] }],
                panel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ViewChild"], args: ['panel', { static: false },] }],
                overlayDir: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ViewChild"], args: [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["CdkConnectedOverlay"], { static: false },] }],
                options: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ContentChildren"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_10__["MatOption"], { descendants: true },] }],
                optionGroups: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ContentChildren"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_10__["MatOptgroup"],] }],
                panelClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"] }],
                customTrigger: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ContentChild"], args: [MatSelectTrigger, { static: false },] }],
                placeholder: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"] }],
                required: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"] }],
                multiple: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"] }],
                disableOptionCentering: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"] }],
                compareWith: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"] }],
                ariaLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"], args: ['aria-label',] }],
                ariaLabelledby: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"], args: ['aria-labelledby',] }],
                errorStateMatcher: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"] }],
                typeaheadDebounceInterval: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"] }],
                sortComparator: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"] }],
                id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"] }],
                openedChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Output"] }],
                _openedStream: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Output"], args: ['opened',] }],
                _closedStream: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Output"], args: ['closed',] }],
                selectionChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Output"] }],
                valueChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Output"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatSelectModule = /** @class */ (function () {
                function MatSelectModule() {
                }
                return MatSelectModule;
            }());
            MatSelectModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["NgModule"], args: [{
                            imports: [
                                _angular_common__WEBPACK_IMPORTED_MODULE_14__["CommonModule"],
                                _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["OverlayModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_10__["MatOptionModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_10__["MatCommonModule"],
                            ],
                            exports: [_angular_material_form_field__WEBPACK_IMPORTED_MODULE_11__["MatFormFieldModule"], MatSelect, MatSelectTrigger, _angular_material_core__WEBPACK_IMPORTED_MODULE_10__["MatOptionModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_10__["MatCommonModule"]],
                            declarations: [MatSelect, MatSelectTrigger],
                            providers: [MAT_SELECT_SCROLL_STRATEGY_PROVIDER]
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=select.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/slide-toggle.js": 
        /*!****************************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/slide-toggle.js ***!
          \****************************************************************/
        /*! exports provided: _MatSlideToggleRequiredValidatorModule, MatSlideToggleModule, MAT_SLIDE_TOGGLE_VALUE_ACCESSOR, MatSlideToggleChange, MatSlideToggle, MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS, MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR, MatSlideToggleRequiredValidator */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_MatSlideToggleRequiredValidatorModule", function () { return _MatSlideToggleRequiredValidatorModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSlideToggleModule", function () { return MatSlideToggleModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_SLIDE_TOGGLE_VALUE_ACCESSOR", function () { return MAT_SLIDE_TOGGLE_VALUE_ACCESSOR; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSlideToggleChange", function () { return MatSlideToggleChange; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSlideToggle", function () { return MatSlideToggle; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS", function () { return MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR", function () { return MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSlideToggleRequiredValidator", function () { return MatSlideToggleRequiredValidator; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/cdk/observers */ "./node_modules/@angular/cdk/esm2015/observers.js");
            /* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/platform-browser */ "./node_modules/@angular/platform-browser/fesm2015/platform-browser.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token to be used to override the default options for `mat-slide-toggle`.
             * @type {?}
             */
            var MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('mat-slide-toggle-default-options', {
                providedIn: 'root',
                factory: ( /**
                 * @return {?}
                 */function () { return ({ disableToggleValue: false, disableDragValue: false }); })
            });
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // Increasing integer for generating unique ids for slide-toggle components.
            /** @type {?} */
            var nextUniqueId = 0;
            /**
             * \@docs-private
             * @type {?}
             */
            var MAT_SLIDE_TOGGLE_VALUE_ACCESSOR = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_4__["NG_VALUE_ACCESSOR"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatSlideToggle; })),
                multi: true
            };
            /**
             * Change event object emitted by a MatSlideToggle.
             */
            var MatSlideToggleChange = /** @class */ (function () {
                /**
                 * @param {?} source
                 * @param {?} checked
                 */
                function MatSlideToggleChange(source, checked) {
                    this.source = source;
                    this.checked = checked;
                }
                return MatSlideToggleChange;
            }());
            // Boilerplate for applying mixins to MatSlideToggle.
            /**
             * \@docs-private
             */
            var MatSlideToggleBase = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 */
                function MatSlideToggleBase(_elementRef) {
                    this._elementRef = _elementRef;
                }
                return MatSlideToggleBase;
            }());
            /** @type {?} */
            var _MatSlideToggleMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["mixinTabIndex"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["mixinColor"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["mixinDisableRipple"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["mixinDisabled"])(MatSlideToggleBase)), 'accent'));
            /**
             * Represents a slidable "switch" toggle that can be moved between on and off.
             */
            var MatSlideToggle = /** @class */ (function (_super) {
                __extends(MatSlideToggle, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} _focusMonitor
                 * @param {?} _changeDetectorRef
                 * @param {?} tabIndex
                 * @param {?} _ngZone
                 * @param {?} defaults
                 * @param {?=} _animationMode
                 * @param {?=} _dir
                 */
                function MatSlideToggle(elementRef, _focusMonitor, _changeDetectorRef, tabIndex, _ngZone, defaults, _animationMode, _dir) {
                    var _this_1 = _super.call(this, elementRef) || this;
                    _this_1._focusMonitor = _focusMonitor;
                    _this_1._changeDetectorRef = _changeDetectorRef;
                    _this_1._ngZone = _ngZone;
                    _this_1.defaults = defaults;
                    _this_1._animationMode = _animationMode;
                    _this_1._dir = _dir;
                    _this_1._onChange = ( /**
                     * @param {?} _
                     * @return {?}
                     */function (_) { });
                    _this_1._onTouched = ( /**
                     * @return {?}
                     */function () { });
                    _this_1._uniqueId = "mat-slide-toggle-" + ++nextUniqueId;
                    _this_1._required = false;
                    _this_1._checked = false;
                    /**
                     * Whether the thumb is currently being dragged.
                     */
                    _this_1._dragging = false;
                    /**
                     * Name value will be applied to the input element if present.
                     */
                    _this_1.name = null;
                    /**
                     * A unique id for the slide-toggle input. If none is supplied, it will be auto-generated.
                     */
                    _this_1.id = _this_1._uniqueId;
                    /**
                     * Whether the label should appear after or before the slide-toggle. Defaults to 'after'.
                     */
                    _this_1.labelPosition = 'after';
                    /**
                     * Used to set the aria-label attribute on the underlying input element.
                     */
                    _this_1.ariaLabel = null;
                    /**
                     * Used to set the aria-labelledby attribute on the underlying input element.
                     */
                    _this_1.ariaLabelledby = null;
                    /**
                     * An event will be dispatched each time the slide-toggle changes its value.
                     */
                    _this_1.change = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * An event will be dispatched each time the slide-toggle input is toggled.
                     * This event is always emitted when the user toggles the slide toggle, but this does not mean
                     * the slide toggle's value has changed. The event does not fire when the user drags to change
                     * the slide toggle value.
                     */
                    _this_1.toggleChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * An event will be dispatched each time the slide-toggle is dragged.
                     * This event is always emitted when the user drags the slide toggle to make a change greater
                     * than 50%. It does not mean the slide toggle's value is changed. The event is not emitted when
                     * the user toggles the slide toggle to change its value.
                     */
                    _this_1.dragChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    _this_1.tabIndex = parseInt(tabIndex) || 0;
                    return _this_1;
                }
                Object.defineProperty(MatSlideToggle.prototype, "required", {
                    /**
                     * Whether the slide-toggle is required.
                     * @return {?}
                     */
                    get: function () { return this._required; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._required = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlideToggle.prototype, "checked", {
                    /**
                     * Whether the slide-toggle element is checked or not.
                     * @return {?}
                     */
                    get: function () { return this._checked; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._checked = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);
                        this._changeDetectorRef.markForCheck();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlideToggle.prototype, "inputId", {
                    /**
                     * Returns the unique id for the visual hidden input.
                     * @return {?}
                     */
                    get: function () { return (this.id || this._uniqueId) + "-input"; },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatSlideToggle.prototype.ngAfterContentInit = function () {
                    var _this_1 = this;
                    this._focusMonitor
                        .monitor(this._elementRef, true)
                        .subscribe(( /**
                 * @param {?} focusOrigin
                 * @return {?}
                 */function (/**
                 * @param {?} focusOrigin
                 * @return {?}
                 */ focusOrigin) {
                        if (!focusOrigin) {
                            // When a focused element becomes disabled, the browser *immediately* fires a blur event.
                            // Angular does not expect events to be raised during change detection, so any state
                            // change (such as a form control's 'ng-touched') will cause a changed-after-checked
                            // error. See https://github.com/angular/angular/issues/17793. To work around this,
                            // we defer telling the form control it has been touched until the next tick.
                            Promise.resolve().then(( /**
                             * @return {?}
                             */function () { return _this_1._onTouched(); }));
                        }
                    }));
                };
                /**
                 * @return {?}
                 */
                MatSlideToggle.prototype.ngOnDestroy = function () {
                    this._focusMonitor.stopMonitoring(this._elementRef);
                };
                /**
                 * Method being called whenever the underlying input emits a change event.
                 * @param {?} event
                 * @return {?}
                 */
                MatSlideToggle.prototype._onChangeEvent = function (event) {
                    // We always have to stop propagation on the change event.
                    // Otherwise the change event, from the input element, will bubble up and
                    // emit its event object to the component's `change` output.
                    event.stopPropagation();
                    if (!this._dragging) {
                        this.toggleChange.emit();
                    }
                    // Releasing the pointer over the `<label>` element while dragging triggers another
                    // click event on the `<label>` element. This means that the checked state of the underlying
                    // input changed unintentionally and needs to be changed back. Or when the slide toggle's config
                    // disabled toggle change event by setting `disableToggleValue: true`, the slide toggle's value
                    // does not change, and the checked state of the underlying input needs to be changed back.
                    if (this._dragging || this.defaults.disableToggleValue) {
                        this._inputElement.nativeElement.checked = this.checked;
                        return;
                    }
                    // Sync the value from the underlying input element with the component instance.
                    this.checked = this._inputElement.nativeElement.checked;
                    // Emit our custom change event only if the underlying input emitted one. This ensures that
                    // there is no change event, when the checked state changes programmatically.
                    this._emitChangeEvent();
                };
                /**
                 * Method being called whenever the slide-toggle has been clicked.
                 * @param {?} event
                 * @return {?}
                 */
                MatSlideToggle.prototype._onInputClick = function (event) {
                    // We have to stop propagation for click events on the visual hidden input element.
                    // By default, when a user clicks on a label element, a generated click event will be
                    // dispatched on the associated input element. Since we are using a label element as our
                    // root container, the click event on the `slide-toggle` will be executed twice.
                    // The real click event will bubble up, and the generated click event also tries to bubble up.
                    // This will lead to multiple click events.
                    // Preventing bubbling for the second event will solve that issue.
                    event.stopPropagation();
                };
                /**
                 * Implemented as part of ControlValueAccessor.
                 * @param {?} value
                 * @return {?}
                 */
                MatSlideToggle.prototype.writeValue = function (value) {
                    this.checked = !!value;
                };
                /**
                 * Implemented as part of ControlValueAccessor.
                 * @param {?} fn
                 * @return {?}
                 */
                MatSlideToggle.prototype.registerOnChange = function (fn) {
                    this._onChange = fn;
                };
                /**
                 * Implemented as part of ControlValueAccessor.
                 * @param {?} fn
                 * @return {?}
                 */
                MatSlideToggle.prototype.registerOnTouched = function (fn) {
                    this._onTouched = fn;
                };
                /**
                 * Implemented as a part of ControlValueAccessor.
                 * @param {?} isDisabled
                 * @return {?}
                 */
                MatSlideToggle.prototype.setDisabledState = function (isDisabled) {
                    this.disabled = isDisabled;
                    this._changeDetectorRef.markForCheck();
                };
                /**
                 * Focuses the slide-toggle.
                 * @param {?=} options
                 * @return {?}
                 */
                MatSlideToggle.prototype.focus = function (options) {
                    this._focusMonitor.focusVia(this._inputElement, 'keyboard', options);
                };
                /**
                 * Toggles the checked state of the slide-toggle.
                 * @return {?}
                 */
                MatSlideToggle.prototype.toggle = function () {
                    this.checked = !this.checked;
                    this._onChange(this.checked);
                };
                /**
                 * Emits a change event on the `change` output. Also notifies the FormControl about the change.
                 * @private
                 * @return {?}
                 */
                MatSlideToggle.prototype._emitChangeEvent = function () {
                    this._onChange(this.checked);
                    this.change.emit(new MatSlideToggleChange(this, this.checked));
                };
                /**
                 * Retrieves the percentage of thumb from the moved distance. Percentage as fraction of 100.
                 * @private
                 * @param {?} distance
                 * @return {?}
                 */
                MatSlideToggle.prototype._getDragPercentage = function (distance) {
                    /** @type {?} */
                    var percentage = (distance / this._thumbBarWidth) * 100;
                    // When the toggle was initially checked, then we have to start the drag at the end.
                    if (this._previousChecked) {
                        percentage += 100;
                    }
                    return Math.max(0, Math.min(percentage, 100));
                };
                /**
                 * @return {?}
                 */
                MatSlideToggle.prototype._onDragStart = function () {
                    if (!this.disabled && !this._dragging) {
                        /** @type {?} */
                        var thumbEl = this._thumbEl.nativeElement;
                        this._thumbBarWidth = this._thumbBarEl.nativeElement.clientWidth - thumbEl.clientWidth;
                        thumbEl.classList.add('mat-dragging');
                        this._previousChecked = this.checked;
                        this._dragging = true;
                    }
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatSlideToggle.prototype._onDrag = function (event) {
                    if (this._dragging) {
                        /** @type {?} */
                        var direction = this._dir && this._dir.value === 'rtl' ? -1 : 1;
                        this._dragPercentage = this._getDragPercentage(event.deltaX * direction);
                        // Calculate the moved distance based on the thumb bar width.
                        /** @type {?} */
                        var dragX = (this._dragPercentage / 100) * this._thumbBarWidth * direction;
                        this._thumbEl.nativeElement.style.transform = "translate3d(" + dragX + "px, 0, 0)";
                    }
                };
                /**
                 * @return {?}
                 */
                MatSlideToggle.prototype._onDragEnd = function () {
                    var _this_1 = this;
                    if (this._dragging) {
                        /** @type {?} */
                        var newCheckedValue = this._dragPercentage > 50;
                        if (newCheckedValue !== this.checked) {
                            this.dragChange.emit();
                            if (!this.defaults.disableDragValue) {
                                this.checked = newCheckedValue;
                                this._emitChangeEvent();
                            }
                        }
                        // The drag should be stopped outside of the current event handler, otherwise the
                        // click event will be fired before it and will revert the drag change.
                        this._ngZone.runOutsideAngular(( /**
                         * @return {?}
                         */function () { return setTimeout(( /**
                         * @return {?}
                         */function () {
                            if (_this_1._dragging) {
                                _this_1._dragging = false;
                                _this_1._thumbEl.nativeElement.classList.remove('mat-dragging');
                                // Reset the transform because the component will take care
                                // of the thumb position after drag.
                                _this_1._thumbEl.nativeElement.style.transform = '';
                            }
                        })); }));
                    }
                };
                /**
                 * Method being called whenever the label text changes.
                 * @return {?}
                 */
                MatSlideToggle.prototype._onLabelTextChange = function () {
                    // Since the event of the `cdkObserveContent` directive runs outside of the zone, the
                    // slide-toggle component will be only marked for check, but no actual change detection runs
                    // automatically. Instead of going back into the zone in order to trigger a change detection
                    // which causes *all* components to be checked (if explicitly marked or not using OnPush),
                    // we only trigger an explicit change detection for the slide-toggle view and its children.
                    this._changeDetectorRef.detectChanges();
                };
                return MatSlideToggle;
            }(_MatSlideToggleMixinBase));
            MatSlideToggle.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-slide-toggle',
                            exportAs: 'matSlideToggle',
                            host: {
                                'class': 'mat-slide-toggle',
                                '[id]': 'id',
                                // Needs to be `-1` so it can still receive programmatic focus.
                                '[attr.tabindex]': 'disabled ? null : -1',
                                '[attr.aria-label]': 'null',
                                '[attr.aria-labelledby]': 'null',
                                '[class.mat-checked]': 'checked',
                                '[class.mat-disabled]': 'disabled',
                                '[class.mat-slide-toggle-label-before]': 'labelPosition == "before"',
                                '[class._mat-animation-noopable]': '_animationMode === "NoopAnimations"',
                                '(focus)': '_inputElement.nativeElement.focus()',
                            },
                            template: "<label [attr.for]=\"inputId\" class=\"mat-slide-toggle-label\" #label><div #toggleBar class=\"mat-slide-toggle-bar\" [class.mat-slide-toggle-bar-no-side-margin]=\"!labelContent.textContent || !labelContent.textContent.trim()\"><input #input class=\"mat-slide-toggle-input cdk-visually-hidden\" type=\"checkbox\" role=\"switch\" [id]=\"inputId\" [required]=\"required\" [tabIndex]=\"tabIndex\" [checked]=\"checked\" [disabled]=\"disabled\" [attr.name]=\"name\" [attr.aria-checked]=\"checked.toString()\" [attr.aria-label]=\"ariaLabel\" [attr.aria-labelledby]=\"ariaLabelledby\" (change)=\"_onChangeEvent($event)\" (click)=\"_onInputClick($event)\"><div class=\"mat-slide-toggle-thumb-container\" #thumbContainer (slidestart)=\"_onDragStart()\" (slide)=\"_onDrag($event)\" (slideend)=\"_onDragEnd()\"><div class=\"mat-slide-toggle-thumb\"></div><div class=\"mat-slide-toggle-ripple\" mat-ripple [matRippleTrigger]=\"label\" [matRippleDisabled]=\"disableRipple || disabled\" [matRippleCentered]=\"true\" [matRippleRadius]=\"20\" [matRippleAnimation]=\"{enterDuration: 150}\"><div class=\"mat-ripple-element mat-slide-toggle-persistent-ripple\"></div></div></div></div><span class=\"mat-slide-toggle-content\" #labelContent (cdkObserveContent)=\"_onLabelTextChange()\"><span style=\"display:none\">&nbsp;</span><ng-content></ng-content></span></label>",
                            styles: [".mat-slide-toggle{display:inline-block;height:24px;max-width:100%;line-height:24px;white-space:nowrap;outline:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent}.mat-slide-toggle.mat-checked .mat-slide-toggle-thumb-container{transform:translate3d(16px,0,0)}[dir=rtl] .mat-slide-toggle.mat-checked .mat-slide-toggle-thumb-container{transform:translate3d(-16px,0,0)}.mat-slide-toggle.mat-disabled{opacity:.38}.mat-slide-toggle.mat-disabled .mat-slide-toggle-label,.mat-slide-toggle.mat-disabled .mat-slide-toggle-thumb-container{cursor:default}.mat-slide-toggle-label{display:flex;flex:1;flex-direction:row;align-items:center;height:inherit;cursor:pointer}.mat-slide-toggle-content{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-slide-toggle-label-before .mat-slide-toggle-label{order:1}.mat-slide-toggle-label-before .mat-slide-toggle-bar{order:2}.mat-slide-toggle-bar,[dir=rtl] .mat-slide-toggle-label-before .mat-slide-toggle-bar{margin-right:8px;margin-left:0}.mat-slide-toggle-label-before .mat-slide-toggle-bar,[dir=rtl] .mat-slide-toggle-bar{margin-left:8px;margin-right:0}.mat-slide-toggle-bar-no-side-margin{margin-left:0;margin-right:0}.mat-slide-toggle-thumb-container{position:absolute;z-index:1;width:20px;height:20px;top:-3px;left:0;transform:translate3d(0,0,0);transition:all 80ms linear;transition-property:transform;cursor:-webkit-grab;cursor:grab}.mat-slide-toggle-thumb-container.mat-dragging{transition-duration:0s}.mat-slide-toggle-thumb-container:active{cursor:-webkit-grabbing;cursor:grabbing}._mat-animation-noopable .mat-slide-toggle-thumb-container{transition:none}[dir=rtl] .mat-slide-toggle-thumb-container{left:auto;right:0}.mat-slide-toggle-thumb{height:20px;width:20px;border-radius:50%}.mat-slide-toggle-bar{position:relative;width:36px;height:14px;flex-shrink:0;border-radius:8px}.mat-slide-toggle-input{bottom:0;left:10px}[dir=rtl] .mat-slide-toggle-input{left:auto;right:10px}.mat-slide-toggle-bar,.mat-slide-toggle-thumb{transition:all 80ms linear;transition-property:background-color;transition-delay:50ms}._mat-animation-noopable .mat-slide-toggle-bar,._mat-animation-noopable .mat-slide-toggle-thumb{transition:none}.mat-slide-toggle .mat-slide-toggle-ripple{position:absolute;top:calc(50% - 20px);left:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}.mat-slide-toggle .mat-slide-toggle-ripple .mat-ripple-element:not(.mat-slide-toggle-persistent-ripple){opacity:.12}.mat-slide-toggle-persistent-ripple{width:100%;height:100%;transform:none}.mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{opacity:.04}.mat-slide-toggle:not(.mat-disabled).cdk-keyboard-focused .mat-slide-toggle-persistent-ripple{opacity:.12}.mat-slide-toggle-persistent-ripple,.mat-slide-toggle.mat-disabled .mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{opacity:0}@media (hover:none){.mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{display:none}}@media (-ms-high-contrast:active){.mat-slide-toggle-thumb{background:#fff;border:1px solid #000}.mat-slide-toggle.mat-checked .mat-slide-toggle-thumb{background:#000;border:1px solid #fff}.mat-slide-toggle-bar{background:#fff}.mat-slide-toggle.cdk-keyboard-focused .mat-slide-toggle-bar{outline:1px dotted;outline-offset:5px}}@media (-ms-high-contrast:black-on-white){.mat-slide-toggle-bar{border:1px solid #000}}"],
                            providers: [MAT_SLIDE_TOGGLE_VALUE_ACCESSOR],
                            inputs: ['disabled', 'disableRipple', 'color', 'tabIndex'],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatSlideToggle.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__["FocusMonitor"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Attribute"], args: ['tabindex',] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS,] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_6__["ANIMATION_MODULE_TYPE"],] }] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] }
            ]; };
            MatSlideToggle.propDecorators = {
                _thumbEl: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['thumbContainer', { static: false },] }],
                _thumbBarEl: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['toggleBar', { static: false },] }],
                name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                labelPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                ariaLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['aria-label',] }],
                ariaLabelledby: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['aria-labelledby',] }],
                required: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                checked: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                change: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                toggleChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                dragChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                _inputElement: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['input', { static: false },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_4__["NG_VALIDATORS"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatSlideToggleRequiredValidator; })),
                multi: true
            };
            /**
             * Validator for Material slide-toggle components with the required attribute in a
             * template-driven form. The default validator for required form controls asserts
             * that the control value is not undefined but that is not appropriate for a slide-toggle
             * where the value is always defined.
             *
             * Required slide-toggle form controls are valid when checked.
             */
            var MatSlideToggleRequiredValidator = /** @class */ (function (_super) {
                __extends(MatSlideToggleRequiredValidator, _super);
                function MatSlideToggleRequiredValidator() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatSlideToggleRequiredValidator;
            }(_angular_forms__WEBPACK_IMPORTED_MODULE_4__["CheckboxRequiredValidator"]));
            MatSlideToggleRequiredValidator.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: "mat-slide-toggle[required][formControlName],\n             mat-slide-toggle[required][formControl], mat-slide-toggle[required][ngModel]",
                            providers: [MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * This module is used by both original and MDC-based slide-toggle implementations.
             */
            // tslint:disable-next-line:class-name
            var _MatSlideToggleRequiredValidatorModule = /** @class */ (function () {
                function _MatSlideToggleRequiredValidatorModule() {
                }
                return _MatSlideToggleRequiredValidatorModule;
            }());
            _MatSlideToggleRequiredValidatorModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            exports: [MatSlideToggleRequiredValidator],
                            declarations: [MatSlideToggleRequiredValidator],
                        },] },
            ];
            var MatSlideToggleModule = /** @class */ (function () {
                function MatSlideToggleModule() {
                }
                return MatSlideToggleModule;
            }());
            MatSlideToggleModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [
                                _MatSlideToggleRequiredValidatorModule,
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_5__["MatRippleModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_5__["MatCommonModule"],
                                _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_7__["ObserversModule"],
                            ],
                            exports: [
                                _MatSlideToggleRequiredValidatorModule,
                                MatSlideToggle,
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_5__["MatCommonModule"]
                            ],
                            declarations: [MatSlideToggle],
                            providers: [
                                { provide: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_8__["HAMMER_GESTURE_CONFIG"], useClass: _angular_material_core__WEBPACK_IMPORTED_MODULE_5__["GestureConfig"] }
                            ],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=slide-toggle.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/slider.js": 
        /*!**********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/slider.js ***!
          \**********************************************************/
        /*! exports provided: MatSliderModule, MAT_SLIDER_VALUE_ACCESSOR, MatSliderChange, MatSlider */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSliderModule", function () { return MatSliderModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_SLIDER_VALUE_ACCESSOR", function () { return MAT_SLIDER_VALUE_ACCESSOR; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSliderChange", function () { return MatSliderChange; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSlider", function () { return MatSlider; });
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/platform-browser */ "./node_modules/@angular/platform-browser/fesm2015/platform-browser.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Visually, a 30px separation between tick marks looks best. This is very subjective but it is
             * the default separation we chose.
             * @type {?}
             */
            var MIN_AUTO_TICK_SEPARATION = 30;
            /**
             * The thumb gap size for a disabled slider.
             * @type {?}
             */
            var DISABLED_THUMB_GAP = 7;
            /**
             * The thumb gap size for a non-active slider at its minimum value.
             * @type {?}
             */
            var MIN_VALUE_NONACTIVE_THUMB_GAP = 7;
            /**
             * The thumb gap size for an active slider at its minimum value.
             * @type {?}
             */
            var MIN_VALUE_ACTIVE_THUMB_GAP = 10;
            /**
             * Provider Expression that allows mat-slider to register as a ControlValueAccessor.
             * This allows it to support [(ngModel)] and [formControl].
             * \@docs-private
             * @type {?}
             */
            var MAT_SLIDER_VALUE_ACCESSOR = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_5__["NG_VALUE_ACCESSOR"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_4__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatSlider; })),
                multi: true
            };
            /**
             * A simple change event emitted by the MatSlider component.
             */
            var MatSliderChange = /** @class */ (function () {
                function MatSliderChange() {
                }
                return MatSliderChange;
            }());
            // Boilerplate for applying mixins to MatSlider.
            /**
             * \@docs-private
             */
            var MatSliderBase = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 */
                function MatSliderBase(_elementRef) {
                    this._elementRef = _elementRef;
                }
                return MatSliderBase;
            }());
            /** @type {?} */
            var _MatSliderMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_6__["mixinTabIndex"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_6__["mixinColor"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_6__["mixinDisabled"])(MatSliderBase), 'accent'));
            /**
             * Allows users to select from a range of values by moving the slider thumb. It is similar in
             * behavior to the native `<input type="range">` element.
             */
            var MatSlider = /** @class */ (function (_super) {
                __extends(MatSlider, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} _focusMonitor
                 * @param {?} _changeDetectorRef
                 * @param {?} _dir
                 * @param {?} tabIndex
                 * @param {?=} _animationMode
                 */
                function MatSlider(elementRef, _focusMonitor, _changeDetectorRef, _dir, tabIndex, _animationMode) {
                    var _this_1 = _super.call(this, elementRef) || this;
                    _this_1._focusMonitor = _focusMonitor;
                    _this_1._changeDetectorRef = _changeDetectorRef;
                    _this_1._dir = _dir;
                    _this_1._animationMode = _animationMode;
                    _this_1._invert = false;
                    _this_1._max = 100;
                    _this_1._min = 0;
                    _this_1._step = 1;
                    _this_1._thumbLabel = false;
                    _this_1._tickInterval = 0;
                    _this_1._value = null;
                    _this_1._vertical = false;
                    /**
                     * Event emitted when the slider value has changed.
                     */
                    _this_1.change = new _angular_core__WEBPACK_IMPORTED_MODULE_4__["EventEmitter"]();
                    /**
                     * Event emitted when the slider thumb moves.
                     */
                    _this_1.input = new _angular_core__WEBPACK_IMPORTED_MODULE_4__["EventEmitter"]();
                    /**
                     * Emits when the raw value of the slider changes. This is here primarily
                     * to facilitate the two-way binding for the `value` input.
                     * \@docs-private
                     */
                    _this_1.valueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_4__["EventEmitter"]();
                    /**
                     * onTouch function registered via registerOnTouch (ControlValueAccessor).
                     */
                    _this_1.onTouched = ( /**
                     * @return {?}
                     */function () { });
                    _this_1._percent = 0;
                    /**
                     * Whether or not the thumb is sliding.
                     * Used to determine if there should be a transition for the thumb and fill track.
                     */
                    _this_1._isSliding = false;
                    /**
                     * Whether or not the slider is active (clicked or sliding).
                     * Used to shrink and grow the thumb as according to the Material Design spec.
                     */
                    _this_1._isActive = false;
                    /**
                     * The size of a tick interval as a percentage of the size of the track.
                     */
                    _this_1._tickIntervalPercent = 0;
                    /**
                     * The dimensions of the slider.
                     */
                    _this_1._sliderDimensions = null;
                    _this_1._controlValueAccessorChangeFn = ( /**
                     * @return {?}
                     */function () { });
                    /**
                     * Subscription to the Directionality change EventEmitter.
                     */
                    _this_1._dirChangeSubscription = rxjs__WEBPACK_IMPORTED_MODULE_8__["Subscription"].EMPTY;
                    _this_1.tabIndex = parseInt(tabIndex) || 0;
                    return _this_1;
                }
                Object.defineProperty(MatSlider.prototype, "invert", {
                    /**
                     * Whether the slider is inverted.
                     * @return {?}
                     */
                    get: function () { return this._invert; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._invert = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "max", {
                    /**
                     * The maximum value that the slider can have.
                     * @return {?}
                     */
                    get: function () { return this._max; },
                    /**
                     * @param {?} v
                     * @return {?}
                     */
                    set: function (v) {
                        this._max = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceNumberProperty"])(v, this._max);
                        this._percent = this._calculatePercentage(this._value);
                        // Since this also modifies the percentage, we need to let the change detection know.
                        this._changeDetectorRef.markForCheck();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "min", {
                    /**
                     * The minimum value that the slider can have.
                     * @return {?}
                     */
                    get: function () { return this._min; },
                    /**
                     * @param {?} v
                     * @return {?}
                     */
                    set: function (v) {
                        this._min = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceNumberProperty"])(v, this._min);
                        // If the value wasn't explicitly set by the user, set it to the min.
                        if (this._value === null) {
                            this.value = this._min;
                        }
                        this._percent = this._calculatePercentage(this._value);
                        // Since this also modifies the percentage, we need to let the change detection know.
                        this._changeDetectorRef.markForCheck();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "step", {
                    /**
                     * The values at which the thumb will snap.
                     * @return {?}
                     */
                    get: function () { return this._step; },
                    /**
                     * @param {?} v
                     * @return {?}
                     */
                    set: function (v) {
                        this._step = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceNumberProperty"])(v, this._step);
                        if (this._step % 1 !== 0) {
                            this._roundToDecimal = ( /** @type {?} */(this._step.toString().split('.').pop())).length;
                        }
                        // Since this could modify the label, we need to notify the change detection.
                        this._changeDetectorRef.markForCheck();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "thumbLabel", {
                    /**
                     * Whether or not to show the thumb label.
                     * @return {?}
                     */
                    get: function () { return this._thumbLabel; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._thumbLabel = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "tickInterval", {
                    /**
                     * How often to show ticks. Relative to the step so that a tick always appears on a step.
                     * Ex: Tick interval of 4 with a step of 3 will draw a tick every 4 steps (every 12 values).
                     * @return {?}
                     */
                    get: function () { return this._tickInterval; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (value === 'auto') {
                            this._tickInterval = 'auto';
                        }
                        else if (typeof value === 'number' || typeof value === 'string') {
                            this._tickInterval = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceNumberProperty"])(value, ( /** @type {?} */(this._tickInterval)));
                        }
                        else {
                            this._tickInterval = 0;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "value", {
                    /**
                     * Value of the slider.
                     * @return {?}
                     */
                    get: function () {
                        // If the value needs to be read and it is still uninitialized, initialize it to the min.
                        if (this._value === null) {
                            this.value = this._min;
                        }
                        return this._value;
                    },
                    /**
                     * @param {?} v
                     * @return {?}
                     */
                    set: function (v) {
                        if (v !== this._value) {
                            /** @type {?} */
                            var value = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceNumberProperty"])(v);
                            // While incrementing by a decimal we can end up with values like 33.300000000000004.
                            // Truncate it to ensure that it matches the label and to make it easier to work with.
                            if (this._roundToDecimal) {
                                value = parseFloat(value.toFixed(this._roundToDecimal));
                            }
                            this._value = value;
                            this._percent = this._calculatePercentage(this._value);
                            // Since this also modifies the percentage, we need to let the change detection know.
                            this._changeDetectorRef.markForCheck();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "vertical", {
                    /**
                     * Whether the slider is vertical.
                     * @return {?}
                     */
                    get: function () { return this._vertical; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._vertical = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "displayValue", {
                    /**
                     * The value to be used for display purposes.
                     * @return {?}
                     */
                    get: function () {
                        if (this.displayWith) {
                            // Value is never null but since setters and getters cannot have
                            // different types, the value getter is also typed to return null.
                            return this.displayWith(( /** @type {?} */(this.value)));
                        }
                        // Note that this could be improved further by rounding something like 0.999 to 1 or
                        // 0.899 to 0.9, however it is very performance sensitive, because it gets called on
                        // every change detection cycle.
                        if (this._roundToDecimal && this.value && this.value % 1 !== 0) {
                            return this.value.toFixed(this._roundToDecimal);
                        }
                        return this.value || 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * set focus to the host element
                 * @param {?=} options
                 * @return {?}
                 */
                MatSlider.prototype.focus = function (options) {
                    this._focusHostElement(options);
                };
                /**
                 * blur the host element
                 * @return {?}
                 */
                MatSlider.prototype.blur = function () {
                    this._blurHostElement();
                };
                Object.defineProperty(MatSlider.prototype, "percent", {
                    /**
                     * The percentage of the slider that coincides with the value.
                     * @return {?}
                     */
                    get: function () { return this._clamp(this._percent); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "_invertAxis", {
                    /**
                     * Whether the axis of the slider is inverted.
                     * (i.e. whether moving the thumb in the positive x or y direction decreases the slider's value).
                     * @return {?}
                     */
                    get: function () {
                        // Standard non-inverted mode for a vertical slider should be dragging the thumb from bottom to
                        // top. However from a y-axis standpoint this is inverted.
                        return this.vertical ? !this.invert : this.invert;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "_isMinValue", {
                    /**
                     * Whether the slider is at its minimum value.
                     * @return {?}
                     */
                    get: function () {
                        return this.percent === 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "_thumbGap", {
                    /**
                     * The amount of space to leave between the slider thumb and the track fill & track background
                     * elements.
                     * @return {?}
                     */
                    get: function () {
                        if (this.disabled) {
                            return DISABLED_THUMB_GAP;
                        }
                        if (this._isMinValue && !this.thumbLabel) {
                            return this._isActive ? MIN_VALUE_ACTIVE_THUMB_GAP : MIN_VALUE_NONACTIVE_THUMB_GAP;
                        }
                        return 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "_trackBackgroundStyles", {
                    /**
                     * CSS styles for the track background element.
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var axis = this.vertical ? 'Y' : 'X';
                        /** @type {?} */
                        var scale = this.vertical ? "1, " + (1 - this.percent) + ", 1" : 1 - this.percent + ", 1, 1";
                        /** @type {?} */
                        var sign = this._shouldInvertMouseCoords() ? '-' : '';
                        return {
                            // scale3d avoids some rendering issues in Chrome. See #12071.
                            transform: "translate" + axis + "(" + sign + this._thumbGap + "px) scale3d(" + scale + ")"
                        };
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "_trackFillStyles", {
                    /**
                     * CSS styles for the track fill element.
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var axis = this.vertical ? 'Y' : 'X';
                        /** @type {?} */
                        var scale = this.vertical ? "1, " + this.percent + ", 1" : this.percent + ", 1, 1";
                        /** @type {?} */
                        var sign = this._shouldInvertMouseCoords() ? '' : '-';
                        return {
                            // scale3d avoids some rendering issues in Chrome. See #12071.
                            transform: "translate" + axis + "(" + sign + this._thumbGap + "px) scale3d(" + scale + ")"
                        };
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "_ticksContainerStyles", {
                    /**
                     * CSS styles for the ticks container element.
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var axis = this.vertical ? 'Y' : 'X';
                        // For a horizontal slider in RTL languages we push the ticks container off the left edge
                        // instead of the right edge to avoid causing a horizontal scrollbar to appear.
                        /** @type {?} */
                        var sign = !this.vertical && this._getDirection() == 'rtl' ? '' : '-';
                        /** @type {?} */
                        var offset = this._tickIntervalPercent / 2 * 100;
                        return {
                            'transform': "translate" + axis + "(" + sign + offset + "%)"
                        };
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "_ticksStyles", {
                    /**
                     * CSS styles for the ticks element.
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var tickSize = this._tickIntervalPercent * 100;
                        /** @type {?} */
                        var backgroundSize = this.vertical ? "2px " + tickSize + "%" : tickSize + "% 2px";
                        /** @type {?} */
                        var axis = this.vertical ? 'Y' : 'X';
                        // Depending on the direction we pushed the ticks container, push the ticks the opposite
                        // direction to re-center them but clip off the end edge. In RTL languages we need to flip the
                        // ticks 180 degrees so we're really cutting off the end edge abd not the start.
                        /** @type {?} */
                        var sign = !this.vertical && this._getDirection() == 'rtl' ? '-' : '';
                        /** @type {?} */
                        var rotate = !this.vertical && this._getDirection() == 'rtl' ? ' rotate(180deg)' : '';
                        /** @type {?} */
                        var styles = {
                            'backgroundSize': backgroundSize,
                            // Without translateZ ticks sometimes jitter as the slider moves on Chrome & Firefox.
                            'transform': "translateZ(0) translate" + axis + "(" + sign + tickSize / 2 + "%)" + rotate
                        };
                        if (this._isMinValue && this._thumbGap) {
                            /** @type {?} */
                            var side = this.vertical ?
                                (this._invertAxis ? 'Bottom' : 'Top') :
                                (this._invertAxis ? 'Right' : 'Left');
                            styles["padding" + side] = this._thumbGap + "px";
                        }
                        return styles;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "_thumbContainerStyles", {
                    /**
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var axis = this.vertical ? 'Y' : 'X';
                        // For a horizontal slider in RTL languages we push the thumb container off the left edge
                        // instead of the right edge to avoid causing a horizontal scrollbar to appear.
                        /** @type {?} */
                        var invertOffset = (this._getDirection() == 'rtl' && !this.vertical) ? !this._invertAxis : this._invertAxis;
                        /** @type {?} */
                        var offset = (invertOffset ? this.percent : 1 - this.percent) * 100;
                        return {
                            'transform': "translate" + axis + "(-" + offset + "%)"
                        };
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Whether mouse events should be converted to a slider position by calculating their distance
                 * from the right or bottom edge of the slider as opposed to the top or left.
                 * @return {?}
                 */
                MatSlider.prototype._shouldInvertMouseCoords = function () {
                    return (this._getDirection() == 'rtl' && !this.vertical) ? !this._invertAxis : this._invertAxis;
                };
                /**
                 * The language direction for this slider element.
                 * @private
                 * @return {?}
                 */
                MatSlider.prototype._getDirection = function () {
                    return (this._dir && this._dir.value == 'rtl') ? 'rtl' : 'ltr';
                };
                /**
                 * @return {?}
                 */
                MatSlider.prototype.ngOnInit = function () {
                    var _this_1 = this;
                    this._focusMonitor
                        .monitor(this._elementRef, true)
                        .subscribe(( /**
                 * @param {?} origin
                 * @return {?}
                 */function (origin) {
                        _this_1._isActive = !!origin && origin !== 'keyboard';
                        _this_1._changeDetectorRef.detectChanges();
                    }));
                    if (this._dir) {
                        this._dirChangeSubscription = this._dir.change.subscribe(( /**
                         * @return {?}
                         */function () {
                            _this_1._changeDetectorRef.markForCheck();
                        }));
                    }
                };
                /**
                 * @return {?}
                 */
                MatSlider.prototype.ngOnDestroy = function () {
                    this._focusMonitor.stopMonitoring(this._elementRef);
                    this._dirChangeSubscription.unsubscribe();
                };
                /**
                 * @return {?}
                 */
                MatSlider.prototype._onMouseenter = function () {
                    if (this.disabled) {
                        return;
                    }
                    // We save the dimensions of the slider here so we can use them to update the spacing of the
                    // ticks and determine where on the slider click and slide events happen.
                    this._sliderDimensions = this._getSliderDimensions();
                    this._updateTickIntervalPercent();
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatSlider.prototype._onMousedown = function (event) {
                    // Don't do anything if the slider is disabled or the
                    // user is using anything other than the main mouse button.
                    if (this.disabled || event.button !== 0) {
                        return;
                    }
                    /** @type {?} */
                    var oldValue = this.value;
                    this._isSliding = false;
                    this._focusHostElement();
                    this._updateValueFromPosition({ x: event.clientX, y: event.clientY });
                    // Emit a change and input event if the value changed.
                    if (oldValue != this.value) {
                        this._emitInputEvent();
                        this._emitChangeEvent();
                    }
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatSlider.prototype._onSlide = function (event) {
                    if (this.disabled) {
                        return;
                    }
                    // The slide start event sometimes fails to fire on iOS, so if we're not already in the sliding
                    // state, call the slide start handler manually.
                    if (!this._isSliding) {
                        this._onSlideStart(null);
                    }
                    // Prevent the slide from selecting anything else.
                    event.preventDefault();
                    /** @type {?} */
                    var oldValue = this.value;
                    this._updateValueFromPosition({ x: event.center.x, y: event.center.y });
                    // Native range elements always emit `input` events when the value changed while sliding.
                    if (oldValue != this.value) {
                        this._emitInputEvent();
                    }
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatSlider.prototype._onSlideStart = function (event) {
                    if (this.disabled || this._isSliding) {
                        return;
                    }
                    // Simulate mouseenter in case this is a mobile device.
                    this._onMouseenter();
                    this._isSliding = true;
                    this._focusHostElement();
                    this._valueOnSlideStart = this.value;
                    if (event) {
                        this._updateValueFromPosition({ x: event.center.x, y: event.center.y });
                        event.preventDefault();
                    }
                };
                /**
                 * @return {?}
                 */
                MatSlider.prototype._onSlideEnd = function () {
                    this._isSliding = false;
                    if (this._valueOnSlideStart != this.value && !this.disabled) {
                        this._emitChangeEvent();
                    }
                    this._valueOnSlideStart = null;
                };
                /**
                 * @return {?}
                 */
                MatSlider.prototype._onFocus = function () {
                    // We save the dimensions of the slider here so we can use them to update the spacing of the
                    // ticks and determine where on the slider click and slide events happen.
                    this._sliderDimensions = this._getSliderDimensions();
                    this._updateTickIntervalPercent();
                };
                /**
                 * @return {?}
                 */
                MatSlider.prototype._onBlur = function () {
                    this.onTouched();
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatSlider.prototype._onKeydown = function (event) {
                    if (this.disabled || Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["hasModifierKey"])(event)) {
                        return;
                    }
                    /** @type {?} */
                    var oldValue = this.value;
                    switch (event.keyCode) {
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["PAGE_UP"]:
                            this._increment(10);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["PAGE_DOWN"]:
                            this._increment(-10);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["END"]:
                            this.value = this.max;
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["HOME"]:
                            this.value = this.min;
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["LEFT_ARROW"]:
                            // NOTE: For a sighted user it would make more sense that when they press an arrow key on an
                            // inverted slider the thumb moves in that direction. However for a blind user, nothing
                            // about the slider indicates that it is inverted. They will expect left to be decrement,
                            // regardless of how it appears on the screen. For speakers ofRTL languages, they probably
                            // expect left to mean increment. Therefore we flip the meaning of the side arrow keys for
                            // RTL. For inverted sliders we prefer a good a11y experience to having it "look right" for
                            // sighted users, therefore we do not swap the meaning.
                            this._increment(this._getDirection() == 'rtl' ? 1 : -1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["UP_ARROW"]:
                            this._increment(1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["RIGHT_ARROW"]:
                            // See comment on LEFT_ARROW about the conditions under which we flip the meaning.
                            this._increment(this._getDirection() == 'rtl' ? -1 : 1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["DOWN_ARROW"]:
                            this._increment(-1);
                            break;
                        default:
                            // Return if the key is not one that we explicitly handle to avoid calling preventDefault on
                            // it.
                            return;
                    }
                    if (oldValue != this.value) {
                        this._emitInputEvent();
                        this._emitChangeEvent();
                    }
                    this._isSliding = true;
                    event.preventDefault();
                };
                /**
                 * @return {?}
                 */
                MatSlider.prototype._onKeyup = function () {
                    this._isSliding = false;
                };
                /**
                 * Increments the slider by the given number of steps (negative number decrements).
                 * @private
                 * @param {?} numSteps
                 * @return {?}
                 */
                MatSlider.prototype._increment = function (numSteps) {
                    this.value = this._clamp((this.value || 0) + this.step * numSteps, this.min, this.max);
                };
                /**
                 * Calculate the new value from the new physical location. The value will always be snapped.
                 * @private
                 * @param {?} pos
                 * @return {?}
                 */
                MatSlider.prototype._updateValueFromPosition = function (pos) {
                    if (!this._sliderDimensions) {
                        return;
                    }
                    /** @type {?} */
                    var offset = this.vertical ? this._sliderDimensions.top : this._sliderDimensions.left;
                    /** @type {?} */
                    var size = this.vertical ? this._sliderDimensions.height : this._sliderDimensions.width;
                    /** @type {?} */
                    var posComponent = this.vertical ? pos.y : pos.x;
                    // The exact value is calculated from the event and used to find the closest snap value.
                    /** @type {?} */
                    var percent = this._clamp((posComponent - offset) / size);
                    if (this._shouldInvertMouseCoords()) {
                        percent = 1 - percent;
                    }
                    // Since the steps may not divide cleanly into the max value, if the user
                    // slid to 0 or 100 percent, we jump to the min/max value. This approach
                    // is slightly more intuitive than using `Math.ceil` below, because it
                    // follows the user's pointer closer.
                    if (percent === 0) {
                        this.value = this.min;
                    }
                    else if (percent === 1) {
                        this.value = this.max;
                    }
                    else {
                        /** @type {?} */
                        var exactValue = this._calculateValue(percent);
                        // This calculation finds the closest step by finding the closest
                        // whole number divisible by the step relative to the min.
                        /** @type {?} */
                        var closestValue = Math.round((exactValue - this.min) / this.step) * this.step + this.min;
                        // The value needs to snap to the min and max.
                        this.value = this._clamp(closestValue, this.min, this.max);
                    }
                };
                /**
                 * Emits a change event if the current value is different from the last emitted value.
                 * @private
                 * @return {?}
                 */
                MatSlider.prototype._emitChangeEvent = function () {
                    this._controlValueAccessorChangeFn(this.value);
                    this.valueChange.emit(this.value);
                    this.change.emit(this._createChangeEvent());
                };
                /**
                 * Emits an input event when the current value is different from the last emitted value.
                 * @private
                 * @return {?}
                 */
                MatSlider.prototype._emitInputEvent = function () {
                    this.input.emit(this._createChangeEvent());
                };
                /**
                 * Updates the amount of space between ticks as a percentage of the width of the slider.
                 * @private
                 * @return {?}
                 */
                MatSlider.prototype._updateTickIntervalPercent = function () {
                    if (!this.tickInterval || !this._sliderDimensions) {
                        return;
                    }
                    if (this.tickInterval == 'auto') {
                        /** @type {?} */
                        var trackSize = this.vertical ? this._sliderDimensions.height : this._sliderDimensions.width;
                        /** @type {?} */
                        var pixelsPerStep = trackSize * this.step / (this.max - this.min);
                        /** @type {?} */
                        var stepsPerTick = Math.ceil(MIN_AUTO_TICK_SEPARATION / pixelsPerStep);
                        /** @type {?} */
                        var pixelsPerTick = stepsPerTick * this.step;
                        this._tickIntervalPercent = pixelsPerTick / trackSize;
                    }
                    else {
                        this._tickIntervalPercent = this.tickInterval * this.step / (this.max - this.min);
                    }
                };
                /**
                 * Creates a slider change object from the specified value.
                 * @private
                 * @param {?=} value
                 * @return {?}
                 */
                MatSlider.prototype._createChangeEvent = function (value) {
                    if (value === void 0) { value = this.value; }
                    /** @type {?} */
                    var event = new MatSliderChange();
                    event.source = this;
                    event.value = value;
                    return event;
                };
                /**
                 * Calculates the percentage of the slider that a value is.
                 * @private
                 * @param {?} value
                 * @return {?}
                 */
                MatSlider.prototype._calculatePercentage = function (value) {
                    return ((value || 0) - this.min) / (this.max - this.min);
                };
                /**
                 * Calculates the value a percentage of the slider corresponds to.
                 * @private
                 * @param {?} percentage
                 * @return {?}
                 */
                MatSlider.prototype._calculateValue = function (percentage) {
                    return this.min + percentage * (this.max - this.min);
                };
                /**
                 * Return a number between two numbers.
                 * @private
                 * @param {?} value
                 * @param {?=} min
                 * @param {?=} max
                 * @return {?}
                 */
                MatSlider.prototype._clamp = function (value, min, max) {
                    if (min === void 0) { min = 0; }
                    if (max === void 0) { max = 1; }
                    return Math.max(min, Math.min(value, max));
                };
                /**
                 * Get the bounding client rect of the slider track element.
                 * The track is used rather than the native element to ignore the extra space that the thumb can
                 * take up.
                 * @private
                 * @return {?}
                 */
                MatSlider.prototype._getSliderDimensions = function () {
                    return this._sliderWrapper ? this._sliderWrapper.nativeElement.getBoundingClientRect() : null;
                };
                /**
                 * Focuses the native element.
                 * Currently only used to allow a blur event to fire but will be used with keyboard input later.
                 * @private
                 * @param {?=} options
                 * @return {?}
                 */
                MatSlider.prototype._focusHostElement = function (options) {
                    this._elementRef.nativeElement.focus(options);
                };
                /**
                 * Blurs the native element.
                 * @private
                 * @return {?}
                 */
                MatSlider.prototype._blurHostElement = function () {
                    this._elementRef.nativeElement.blur();
                };
                /**
                 * Sets the model value. Implemented as part of ControlValueAccessor.
                 * @param {?} value
                 * @return {?}
                 */
                MatSlider.prototype.writeValue = function (value) {
                    this.value = value;
                };
                /**
                 * Registers a callback to be triggered when the value has changed.
                 * Implemented as part of ControlValueAccessor.
                 * @param {?} fn Callback to be registered.
                 * @return {?}
                 */
                MatSlider.prototype.registerOnChange = function (fn) {
                    this._controlValueAccessorChangeFn = fn;
                };
                /**
                 * Registers a callback to be triggered when the component is touched.
                 * Implemented as part of ControlValueAccessor.
                 * @param {?} fn Callback to be registered.
                 * @return {?}
                 */
                MatSlider.prototype.registerOnTouched = function (fn) {
                    this.onTouched = fn;
                };
                /**
                 * Sets whether the component should be disabled.
                 * Implemented as part of ControlValueAccessor.
                 * @param {?} isDisabled
                 * @return {?}
                 */
                MatSlider.prototype.setDisabledState = function (isDisabled) {
                    this.disabled = isDisabled;
                };
                return MatSlider;
            }(_MatSliderMixinBase));
            MatSlider.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Component"], args: [{ selector: 'mat-slider',
                            exportAs: 'matSlider',
                            providers: [MAT_SLIDER_VALUE_ACCESSOR],
                            host: {
                                '(focus)': '_onFocus()',
                                '(blur)': '_onBlur()',
                                '(mousedown)': '_onMousedown($event)',
                                '(keydown)': '_onKeydown($event)',
                                '(keyup)': '_onKeyup()',
                                '(mouseenter)': '_onMouseenter()',
                                '(slide)': '_onSlide($event)',
                                '(slideend)': '_onSlideEnd()',
                                '(slidestart)': '_onSlideStart($event)',
                                // On Safari starting to slide temporarily triggers text selection mode which
                                // show the wrong cursor. We prevent it by stopping the `selectstart` event.
                                '(selectstart)': '$event.preventDefault()',
                                'class': 'mat-slider',
                                'role': 'slider',
                                '[tabIndex]': 'tabIndex',
                                '[attr.aria-disabled]': 'disabled',
                                '[attr.aria-valuemax]': 'max',
                                '[attr.aria-valuemin]': 'min',
                                '[attr.aria-valuenow]': 'value',
                                '[attr.aria-orientation]': 'vertical ? "vertical" : "horizontal"',
                                '[class.mat-slider-disabled]': 'disabled',
                                '[class.mat-slider-has-ticks]': 'tickInterval',
                                '[class.mat-slider-horizontal]': '!vertical',
                                '[class.mat-slider-axis-inverted]': '_invertAxis',
                                // Class binding which is only used by the test harness as there is no other
                                // way for the harness to detect if mouse coordinates need to be inverted.
                                '[class.mat-slider-invert-mouse-coords]': '_shouldInvertMouseCoords()',
                                '[class.mat-slider-sliding]': '_isSliding',
                                '[class.mat-slider-thumb-label-showing]': 'thumbLabel',
                                '[class.mat-slider-vertical]': 'vertical',
                                '[class.mat-slider-min-value]': '_isMinValue',
                                '[class.mat-slider-hide-last-tick]': 'disabled || _isMinValue && _thumbGap && _invertAxis',
                                '[class._mat-animation-noopable]': '_animationMode === "NoopAnimations"',
                            },
                            template: "<div class=\"mat-slider-wrapper\" #sliderWrapper><div class=\"mat-slider-track-wrapper\"><div class=\"mat-slider-track-background\" [ngStyle]=\"_trackBackgroundStyles\"></div><div class=\"mat-slider-track-fill\" [ngStyle]=\"_trackFillStyles\"></div></div><div class=\"mat-slider-ticks-container\" [ngStyle]=\"_ticksContainerStyles\"><div class=\"mat-slider-ticks\" [ngStyle]=\"_ticksStyles\"></div></div><div class=\"mat-slider-thumb-container\" [ngStyle]=\"_thumbContainerStyles\"><div class=\"mat-slider-focus-ring\"></div><div class=\"mat-slider-thumb\"></div><div class=\"mat-slider-thumb-label\"><span class=\"mat-slider-thumb-label-text\">{{displayValue}}</span></div></div></div>",
                            styles: [".mat-slider{display:inline-block;position:relative;box-sizing:border-box;padding:8px;outline:0;vertical-align:middle}.mat-slider.mat-slider-sliding:not(.mat-slider-disabled),.mat-slider:not(.mat-slider-disabled):active{cursor:-webkit-grabbing;cursor:grabbing}.mat-slider-wrapper{position:absolute}.mat-slider-track-wrapper{position:absolute;top:0;left:0;overflow:hidden}.mat-slider-track-fill{position:absolute;transform-origin:0 0;transition:transform .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-track-background{position:absolute;transform-origin:100% 100%;transition:transform .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-ticks-container{position:absolute;left:0;top:0;overflow:hidden}.mat-slider-ticks{background-repeat:repeat;background-clip:content-box;box-sizing:border-box;opacity:0;transition:opacity .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-thumb-container{position:absolute;z-index:1;transition:transform .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-focus-ring{position:absolute;width:30px;height:30px;border-radius:50%;transform:scale(0);opacity:0;transition:transform .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1),opacity .4s cubic-bezier(.25,.8,.25,1)}.mat-slider.cdk-keyboard-focused .mat-slider-focus-ring,.mat-slider.cdk-program-focused .mat-slider-focus-ring{transform:scale(1);opacity:1}.mat-slider:not(.mat-slider-disabled):not(.mat-slider-sliding) .mat-slider-thumb,.mat-slider:not(.mat-slider-disabled):not(.mat-slider-sliding) .mat-slider-thumb-label{cursor:-webkit-grab;cursor:grab}.mat-slider-thumb{position:absolute;right:-10px;bottom:-10px;box-sizing:border-box;width:20px;height:20px;border:3px solid transparent;border-radius:50%;transform:scale(.7);transition:transform .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1),border-color .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-thumb-label{display:none;align-items:center;justify-content:center;position:absolute;width:28px;height:28px;border-radius:50%;transition:transform .4s cubic-bezier(.25,.8,.25,1),border-radius .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1)}@media (-ms-high-contrast:active){.mat-slider-thumb-label{outline:solid 1px}}.mat-slider-thumb-label-text{z-index:1;opacity:0;transition:opacity .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-sliding .mat-slider-thumb-container,.mat-slider-sliding .mat-slider-track-background,.mat-slider-sliding .mat-slider-track-fill{transition-duration:0s}.mat-slider-has-ticks .mat-slider-wrapper::after{content:'';position:absolute;border-width:0;border-style:solid;opacity:0;transition:opacity .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-has-ticks.cdk-focused:not(.mat-slider-hide-last-tick) .mat-slider-wrapper::after,.mat-slider-has-ticks:hover:not(.mat-slider-hide-last-tick) .mat-slider-wrapper::after{opacity:1}.mat-slider-has-ticks.cdk-focused:not(.mat-slider-disabled) .mat-slider-ticks,.mat-slider-has-ticks:hover:not(.mat-slider-disabled) .mat-slider-ticks{opacity:1}.mat-slider-thumb-label-showing .mat-slider-focus-ring{display:none}.mat-slider-thumb-label-showing .mat-slider-thumb-label{display:flex}.mat-slider-axis-inverted .mat-slider-track-fill{transform-origin:100% 100%}.mat-slider-axis-inverted .mat-slider-track-background{transform-origin:0 0}.mat-slider:not(.mat-slider-disabled).cdk-focused.mat-slider-thumb-label-showing .mat-slider-thumb{transform:scale(0)}.mat-slider:not(.mat-slider-disabled).cdk-focused .mat-slider-thumb-label{border-radius:50% 50% 0}.mat-slider:not(.mat-slider-disabled).cdk-focused .mat-slider-thumb-label-text{opacity:1}.mat-slider:not(.mat-slider-disabled).cdk-mouse-focused .mat-slider-thumb,.mat-slider:not(.mat-slider-disabled).cdk-program-focused .mat-slider-thumb,.mat-slider:not(.mat-slider-disabled).cdk-touch-focused .mat-slider-thumb{border-width:2px;transform:scale(1)}.mat-slider-disabled .mat-slider-focus-ring{transform:scale(0);opacity:0}.mat-slider-disabled .mat-slider-thumb{border-width:4px;transform:scale(.5)}.mat-slider-disabled .mat-slider-thumb-label{display:none}.mat-slider-horizontal{height:48px;min-width:128px}.mat-slider-horizontal .mat-slider-wrapper{height:2px;top:23px;left:8px;right:8px}.mat-slider-horizontal .mat-slider-wrapper::after{height:2px;border-left-width:2px;right:0;top:0}.mat-slider-horizontal .mat-slider-track-wrapper{height:2px;width:100%}.mat-slider-horizontal .mat-slider-track-fill{height:2px;width:100%;transform:scaleX(0)}.mat-slider-horizontal .mat-slider-track-background{height:2px;width:100%;transform:scaleX(1)}.mat-slider-horizontal .mat-slider-ticks-container{height:2px;width:100%}@media (-ms-high-contrast:active){.mat-slider-horizontal .mat-slider-ticks-container{height:0;outline:solid 2px;top:1px}}.mat-slider-horizontal .mat-slider-ticks{height:2px;width:100%}.mat-slider-horizontal .mat-slider-thumb-container{width:100%;height:0;top:50%}.mat-slider-horizontal .mat-slider-focus-ring{top:-15px;right:-15px}.mat-slider-horizontal .mat-slider-thumb-label{right:-14px;top:-40px;transform:translateY(26px) scale(.01) rotate(45deg)}.mat-slider-horizontal .mat-slider-thumb-label-text{transform:rotate(-45deg)}.mat-slider-horizontal.cdk-focused .mat-slider-thumb-label{transform:rotate(45deg)}@media (-ms-high-contrast:active){.mat-slider-horizontal.cdk-focused .mat-slider-thumb-label,.mat-slider-horizontal.cdk-focused .mat-slider-thumb-label-text{transform:none}}.mat-slider-vertical{width:48px;min-height:128px}.mat-slider-vertical .mat-slider-wrapper{width:2px;top:8px;bottom:8px;left:23px}.mat-slider-vertical .mat-slider-wrapper::after{width:2px;border-top-width:2px;bottom:0;left:0}.mat-slider-vertical .mat-slider-track-wrapper{height:100%;width:2px}.mat-slider-vertical .mat-slider-track-fill{height:100%;width:2px;transform:scaleY(0)}.mat-slider-vertical .mat-slider-track-background{height:100%;width:2px;transform:scaleY(1)}.mat-slider-vertical .mat-slider-ticks-container{width:2px;height:100%}@media (-ms-high-contrast:active){.mat-slider-vertical .mat-slider-ticks-container{width:0;outline:solid 2px;left:1px}}.mat-slider-vertical .mat-slider-focus-ring{bottom:-15px;left:-15px}.mat-slider-vertical .mat-slider-ticks{width:2px;height:100%}.mat-slider-vertical .mat-slider-thumb-container{height:100%;width:0;left:50%}.mat-slider-vertical .mat-slider-thumb{-webkit-backface-visibility:hidden;backface-visibility:hidden}.mat-slider-vertical .mat-slider-thumb-label{bottom:-14px;left:-40px;transform:translateX(26px) scale(.01) rotate(-45deg)}.mat-slider-vertical .mat-slider-thumb-label-text{transform:rotate(45deg)}.mat-slider-vertical.cdk-focused .mat-slider-thumb-label{transform:rotate(-45deg)}[dir=rtl] .mat-slider-wrapper::after{left:0;right:auto}[dir=rtl] .mat-slider-horizontal .mat-slider-track-fill{transform-origin:100% 100%}[dir=rtl] .mat-slider-horizontal .mat-slider-track-background{transform-origin:0 0}[dir=rtl] .mat-slider-horizontal.mat-slider-axis-inverted .mat-slider-track-fill{transform-origin:0 0}[dir=rtl] .mat-slider-horizontal.mat-slider-axis-inverted .mat-slider-track-background{transform-origin:100% 100%}.mat-slider._mat-animation-noopable .mat-slider-focus-ring,.mat-slider._mat-animation-noopable .mat-slider-has-ticks .mat-slider-wrapper::after,.mat-slider._mat-animation-noopable .mat-slider-thumb,.mat-slider._mat-animation-noopable .mat-slider-thumb-container,.mat-slider._mat-animation-noopable .mat-slider-thumb-label,.mat-slider._mat-animation-noopable .mat-slider-thumb-label-text,.mat-slider._mat-animation-noopable .mat-slider-ticks,.mat-slider._mat-animation-noopable .mat-slider-track-background,.mat-slider._mat-animation-noopable .mat-slider-track-fill{transition:none}"],
                            inputs: ['disabled', 'color', 'tabIndex'],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_4__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_4__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatSlider.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["ElementRef"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__["FocusMonitor"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["ChangeDetectorRef"] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_1__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Optional"] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Attribute"], args: ['tabindex',] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_7__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            MatSlider.propDecorators = {
                invert: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Input"] }],
                max: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Input"] }],
                min: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Input"] }],
                step: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Input"] }],
                thumbLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Input"] }],
                tickInterval: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Input"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Input"] }],
                displayWith: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Input"] }],
                vertical: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Input"] }],
                change: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Output"] }],
                input: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Output"] }],
                valueChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Output"] }],
                _sliderWrapper: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["ViewChild"], args: ['sliderWrapper', { static: false },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatSliderModule = /** @class */ (function () {
                function MatSliderModule() {
                }
                return MatSliderModule;
            }());
            MatSliderModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["NgModule"], args: [{
                            imports: [_angular_common__WEBPACK_IMPORTED_MODULE_9__["CommonModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_6__["MatCommonModule"]],
                            exports: [MatSlider, _angular_material_core__WEBPACK_IMPORTED_MODULE_6__["MatCommonModule"]],
                            declarations: [MatSlider],
                            providers: [{ provide: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_10__["HAMMER_GESTURE_CONFIG"], useClass: _angular_material_core__WEBPACK_IMPORTED_MODULE_6__["GestureConfig"] }]
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=slider.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/stepper.js": 
        /*!***********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/stepper.js ***!
          \***********************************************************/
        /*! exports provided: MatStepperModule, MatStepLabel, MatStep, MatStepper, MatHorizontalStepper, MatVerticalStepper, MatStepperNext, MatStepperPrevious, MatStepHeader, MAT_STEPPER_INTL_PROVIDER_FACTORY, MatStepperIntl, MAT_STEPPER_INTL_PROVIDER, matStepperAnimations, MatStepperIcon */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatStepperModule", function () { return MatStepperModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatStepLabel", function () { return MatStepLabel; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatStep", function () { return MatStep; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatStepper", function () { return MatStepper; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatHorizontalStepper", function () { return MatHorizontalStepper; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatVerticalStepper", function () { return MatVerticalStepper; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatStepperNext", function () { return MatStepperNext; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatStepperPrevious", function () { return MatStepperPrevious; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatStepHeader", function () { return MatStepHeader; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_STEPPER_INTL_PROVIDER_FACTORY", function () { return MAT_STEPPER_INTL_PROVIDER_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatStepperIntl", function () { return MatStepperIntl; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_STEPPER_INTL_PROVIDER", function () { return MAT_STEPPER_INTL_PROVIDER; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matStepperAnimations", function () { return matStepperAnimations; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatStepperIcon", function () { return MatStepperIcon; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/stepper */ "./node_modules/@angular/cdk/esm2015/stepper.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/animations */ "./node_modules/@angular/animations/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/cdk/portal */ "./node_modules/@angular/cdk/esm2015/portal.js");
            /* harmony import */ var _angular_material_button__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/material/button */ "./node_modules/@angular/material/esm2015/button.js");
            /* harmony import */ var _angular_material_icon__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/material/icon */ "./node_modules/@angular/material/esm2015/icon.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatStepLabel = /** @class */ (function (_super) {
                __extends(MatStepLabel, _super);
                function MatStepLabel() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatStepLabel;
            }(_angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["CdkStepLabel"]));
            MatStepLabel.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[matStepLabel]',
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Stepper data that is required for internationalization.
             */
            var MatStepperIntl = /** @class */ (function () {
                function MatStepperIntl() {
                    /**
                     * Stream that emits whenever the labels here are changed. Use this to notify
                     * components if the labels have changed after initialization.
                     */
                    this.changes = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
                    /**
                     * Label that is rendered below optional steps.
                     */
                    this.optionalLabel = 'Optional';
                }
                return MatStepperIntl;
            }());
            MatStepperIntl.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */ MatStepperIntl.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function MatStepperIntl_Factory() { return new MatStepperIntl(); }, token: MatStepperIntl, providedIn: "root" });
            /**
             * \@docs-private
             * @param {?} parentIntl
             * @return {?}
             */
            function MAT_STEPPER_INTL_PROVIDER_FACTORY(parentIntl) {
                return parentIntl || new MatStepperIntl();
            }
            /**
             * \@docs-private
             * @type {?}
             */
            var MAT_STEPPER_INTL_PROVIDER = {
                provide: MatStepperIntl,
                deps: [[new _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"](), new _angular_core__WEBPACK_IMPORTED_MODULE_0__["SkipSelf"](), MatStepperIntl]],
                useFactory: MAT_STEPPER_INTL_PROVIDER_FACTORY
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatStepHeader = /** @class */ (function (_super) {
                __extends(MatStepHeader, _super);
                /**
                 * @param {?} _intl
                 * @param {?} _focusMonitor
                 * @param {?} _elementRef
                 * @param {?} changeDetectorRef
                 */
                function MatStepHeader(_intl, _focusMonitor, _elementRef, changeDetectorRef) {
                    var _this_1 = _super.call(this, _elementRef) || this;
                    _this_1._intl = _intl;
                    _this_1._focusMonitor = _focusMonitor;
                    _focusMonitor.monitor(_elementRef, true);
                    _this_1._intlSubscription = _intl.changes.subscribe(( /**
                     * @return {?}
                     */function () { return changeDetectorRef.markForCheck(); }));
                    return _this_1;
                }
                /**
                 * @return {?}
                 */
                MatStepHeader.prototype.ngOnDestroy = function () {
                    this._intlSubscription.unsubscribe();
                    this._focusMonitor.stopMonitoring(this._elementRef);
                };
                /**
                 * Focuses the step header.
                 * @return {?}
                 */
                MatStepHeader.prototype.focus = function () {
                    this._focusMonitor.focusVia(this._elementRef, 'program');
                };
                /**
                 * Returns string label of given step if it is a text label.
                 * @return {?}
                 */
                MatStepHeader.prototype._stringLabel = function () {
                    return this.label instanceof MatStepLabel ? null : this.label;
                };
                /**
                 * Returns MatStepLabel if the label of given step is a template label.
                 * @return {?}
                 */
                MatStepHeader.prototype._templateLabel = function () {
                    return this.label instanceof MatStepLabel ? this.label : null;
                };
                /**
                 * Returns the host HTML element.
                 * @return {?}
                 */
                MatStepHeader.prototype._getHostElement = function () {
                    return this._elementRef.nativeElement;
                };
                /**
                 * Template context variables that are exposed to the `matStepperIcon` instances.
                 * @return {?}
                 */
                MatStepHeader.prototype._getIconContext = function () {
                    return {
                        index: this.index,
                        active: this.active,
                        optional: this.optional
                    };
                };
                /**
                 * @param {?} state
                 * @return {?}
                 */
                MatStepHeader.prototype._getDefaultTextForState = function (state$$1) {
                    if (state$$1 == 'number') {
                        return "" + (this.index + 1);
                    }
                    if (state$$1 == 'edit') {
                        return 'create';
                    }
                    if (state$$1 == 'error') {
                        return 'warning';
                    }
                    return state$$1;
                };
                return MatStepHeader;
            }(_angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["CdkStepHeader"]));
            MatStepHeader.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-step-header',
                            template: "<div class=\"mat-step-header-ripple\" matRipple [matRippleTrigger]=\"_getHostElement()\" [matRippleDisabled]=\"disableRipple\"></div><div class=\"mat-step-icon-state-{{state}} mat-step-icon\" [class.mat-step-icon-selected]=\"selected\"><div class=\"mat-step-icon-content\" [ngSwitch]=\"!!(iconOverrides && iconOverrides[state])\"><ng-container *ngSwitchCase=\"true\" [ngTemplateOutlet]=\"iconOverrides[state]\" [ngTemplateOutletContext]=\"_getIconContext()\"></ng-container><ng-container *ngSwitchDefault [ngSwitch]=\"state\"><span *ngSwitchCase=\"'number'\">{{_getDefaultTextForState(state)}}</span><mat-icon *ngSwitchDefault>{{_getDefaultTextForState(state)}}</mat-icon></ng-container></div></div><div class=\"mat-step-label\" [class.mat-step-label-active]=\"active\" [class.mat-step-label-selected]=\"selected\" [class.mat-step-label-error]=\"state == 'error'\"><ng-container *ngIf=\"_templateLabel()\" [ngTemplateOutlet]=\"_templateLabel()!.template\"></ng-container><div class=\"mat-step-text-label\" *ngIf=\"_stringLabel()\">{{label}}</div><div class=\"mat-step-optional\" *ngIf=\"optional && state != 'error'\">{{_intl.optionalLabel}}</div><div class=\"mat-step-sub-label-error\" *ngIf=\"state == 'error'\">{{errorMessage}}</div></div>",
                            styles: [".mat-step-header{overflow:hidden;outline:0;cursor:pointer;position:relative;box-sizing:content-box;-webkit-tap-highlight-color:transparent}.mat-step-optional,.mat-step-sub-label-error{font-size:12px}.mat-step-icon{border-radius:50%;height:24px;width:24px;flex-shrink:0;position:relative}.mat-step-icon .mat-icon,.mat-step-icon-content{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)}.mat-step-icon .mat-icon{font-size:16px;height:16px;width:16px}.mat-step-icon-state-error .mat-icon{font-size:24px;height:24px;width:24px}.mat-step-label{display:inline-block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;min-width:50px;vertical-align:middle}.mat-step-text-label{text-overflow:ellipsis;overflow:hidden}.mat-step-header .mat-step-header-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}"],
                            host: {
                                'class': 'mat-step-header',
                                'role': 'tab',
                            },
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatStepHeader.ctorParameters = function () { return [
                { type: MatStepperIntl },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_3__["FocusMonitor"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] }
            ]; };
            MatStepHeader.propDecorators = {
                state: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                label: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                errorMessage: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                iconOverrides: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                index: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                active: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                optional: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                disableRipple: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Animations used by the Material steppers.
             * \@docs-private
             * @type {?}
             */
            var matStepperAnimations = {
                /**
                 * Animation that transitions the step along the X axis in a horizontal stepper.
                 */
                horizontalStepTransition: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["trigger"])('stepTransition', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('previous', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translate3d(-100%, 0, 0)', visibility: 'hidden' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('current', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'none', visibility: 'visible' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('next', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translate3d(100%, 0, 0)', visibility: 'hidden' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["transition"])('* => *', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["animate"])('500ms cubic-bezier(0.35, 0, 0.25, 1)'))
                ]),
                /**
                 * Animation that transitions the step along the Y axis in a vertical stepper.
                 */
                verticalStepTransition: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["trigger"])('stepTransition', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('previous', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ height: '0px', visibility: 'hidden' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('next', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ height: '0px', visibility: 'hidden' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('current', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ height: '*', visibility: 'visible' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["transition"])('* <=> current', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["animate"])('225ms cubic-bezier(0.4, 0.0, 0.2, 1)'))
                ])
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Template to be used to override the icons inside the step header.
             */
            var MatStepperIcon = /** @class */ (function () {
                /**
                 * @param {?} templateRef
                 */
                function MatStepperIcon(templateRef) {
                    this.templateRef = templateRef;
                }
                return MatStepperIcon;
            }());
            MatStepperIcon.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'ng-template[matStepperIcon]',
                        },] },
            ];
            /** @nocollapse */
            MatStepperIcon.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"] }
            ]; };
            MatStepperIcon.propDecorators = {
                name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['matStepperIcon',] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatStep = /** @class */ (function (_super) {
                __extends(MatStep, _super);
                /**
                 * \@breaking-change 8.0.0 remove the `?` after `stepperOptions`
                 * @param {?} stepper
                 * @param {?} _errorStateMatcher
                 * @param {?=} stepperOptions
                 */
                function MatStep(stepper, _errorStateMatcher, stepperOptions) {
                    var _this_1 = _super.call(this, stepper, stepperOptions) || this;
                    _this_1._errorStateMatcher = _errorStateMatcher;
                    return _this_1;
                }
                /**
                 * Custom error state matcher that additionally checks for validity of interacted form.
                 * @param {?} control
                 * @param {?} form
                 * @return {?}
                 */
                MatStep.prototype.isErrorState = function (control, form) {
                    /** @type {?} */
                    var originalErrorState = this._errorStateMatcher.isErrorState(control, form);
                    // Custom error state checks for the validity of form that is not submitted or touched
                    // since user can trigger a form change by calling for another step without directly
                    // interacting with the current form.
                    /** @type {?} */
                    var customErrorState = !!(control && control.invalid && this.interacted);
                    return originalErrorState || customErrorState;
                };
                return MatStep;
            }(_angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["CdkStep"]));
            MatStep.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-step',
                            template: "<ng-template><ng-content></ng-content></ng-template>",
                            providers: [{ provide: _angular_material_core__WEBPACK_IMPORTED_MODULE_7__["ErrorStateMatcher"], useExisting: MatStep }],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            exportAs: 'matStep',
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatStep.ctorParameters = function () { return [
                { type: MatStepper, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                                                 * @return {?}
                                                 */function () { return MatStepper; })),] }] },
                { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_7__["ErrorStateMatcher"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["SkipSelf"] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["STEPPER_GLOBAL_OPTIONS"],] }] }
            ]; };
            MatStep.propDecorators = {
                stepLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChild"], args: [MatStepLabel, { static: false },] }]
            };
            var MatStepper = /** @class */ (function (_super) {
                __extends(MatStepper, _super);
                function MatStepper() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    /**
                     * Event emitted when the current step is done transitioning in.
                     */
                    _this_1.animationDone = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Consumer-specified template-refs to be used to override the header icons.
                     */
                    _this_1._iconOverrides = {};
                    /**
                     * Stream of animation `done` events when the body expands/collapses.
                     */
                    _this_1._animationDone = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
                    return _this_1;
                }
                /**
                 * @return {?}
                 */
                MatStepper.prototype.ngAfterContentInit = function () {
                    var _this_1 = this;
                    this._icons.forEach(( /**
                     * @param {?} __0
                     * @return {?}
                     */function (_a) {
                        var name = _a.name, templateRef = _a.templateRef;
                        return _this_1._iconOverrides[name] = templateRef;
                    }));
                    // Mark the component for change detection whenever the content children query changes
                    this._steps.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__["takeUntil"])(this._destroyed)).subscribe(( /**
                     * @return {?}
                     */function () { return _this_1._stateChanged(); }));
                    this._animationDone.pipe(
                    // This needs a `distinctUntilChanged` in order to avoid emitting the same event twice due
                    // to a bug in animations where the `.done` callback gets invoked twice on some browsers.
                    // See https://github.com/angular/angular/issues/24084
                    Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__["distinctUntilChanged"])(( /**
                     * @param {?} x
                     * @param {?} y
                     * @return {?}
                     */function (x, y) { return x.fromState === y.fromState && x.toState === y.toState; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__["takeUntil"])(this._destroyed)).subscribe(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) {
                        if ((( /** @type {?} */(event.toState))) === 'current') {
                            _this_1.animationDone.emit();
                        }
                    }));
                };
                return MatStepper;
            }(_angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["CdkStepper"]));
            MatStepper.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: '[matStepper]', providers: [{ provide: _angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["CdkStepper"], useExisting: MatStepper }] },] },
            ];
            MatStepper.propDecorators = {
                _stepHeader: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChildren"], args: [MatStepHeader,] }],
                _steps: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChildren"], args: [MatStep,] }],
                _icons: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChildren"], args: [MatStepperIcon,] }],
                animationDone: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                disableRipple: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            var MatHorizontalStepper = /** @class */ (function (_super) {
                __extends(MatHorizontalStepper, _super);
                function MatHorizontalStepper() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    /**
                     * Whether the label should display in bottom or end position.
                     */
                    _this_1.labelPosition = 'end';
                    return _this_1;
                }
                return MatHorizontalStepper;
            }(MatStepper));
            MatHorizontalStepper.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-horizontal-stepper',
                            exportAs: 'matHorizontalStepper',
                            template: "<div class=\"mat-horizontal-stepper-header-container\"><ng-container *ngFor=\"let step of steps; let i = index; let isLast = last\"><mat-step-header class=\"mat-horizontal-stepper-header\" (click)=\"step.select()\" (keydown)=\"_onKeydown($event)\" [tabIndex]=\"_getFocusIndex() === i ? 0 : -1\" [id]=\"_getStepLabelId(i)\" [attr.aria-posinset]=\"i + 1\" [attr.aria-setsize]=\"steps.length\" [attr.aria-controls]=\"_getStepContentId(i)\" [attr.aria-selected]=\"selectedIndex == i\" [attr.aria-label]=\"step.ariaLabel || null\" [attr.aria-labelledby]=\"(!step.ariaLabel && step.ariaLabelledby) ? step.ariaLabelledby : null\" [index]=\"i\" [state]=\"_getIndicatorType(i, step.state)\" [label]=\"step.stepLabel || step.label\" [selected]=\"selectedIndex === i\" [active]=\"step.completed || selectedIndex === i || !linear\" [optional]=\"step.optional\" [errorMessage]=\"step.errorMessage\" [iconOverrides]=\"_iconOverrides\" [disableRipple]=\"disableRipple\"></mat-step-header><div *ngIf=\"!isLast\" class=\"mat-stepper-horizontal-line\"></div></ng-container></div><div class=\"mat-horizontal-content-container\"><div *ngFor=\"let step of steps; let i = index\" [attr.tabindex]=\"selectedIndex === i ? 0 : null\" class=\"mat-horizontal-stepper-content\" role=\"tabpanel\" [@stepTransition]=\"_getAnimationDirection(i)\" (@stepTransition.done)=\"_animationDone.next($event)\" [id]=\"_getStepContentId(i)\" [attr.aria-labelledby]=\"_getStepLabelId(i)\" [attr.aria-expanded]=\"selectedIndex === i\"><ng-container [ngTemplateOutlet]=\"step.content\"></ng-container></div></div>",
                            styles: [".mat-stepper-horizontal,.mat-stepper-vertical{display:block}.mat-horizontal-stepper-header-container{white-space:nowrap;display:flex;align-items:center}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header-container{align-items:flex-start}.mat-stepper-horizontal-line{border-top-width:1px;border-top-style:solid;flex:auto;height:0;margin:0 -16px;min-width:32px}.mat-stepper-label-position-bottom .mat-stepper-horizontal-line{margin:0;min-width:0;position:relative;top:36px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::before,.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::before{border-top-width:1px;border-top-style:solid;content:'';display:inline-block;height:0;position:absolute;top:36px;width:calc(50% - 20px)}.mat-horizontal-stepper-header{display:flex;height:72px;overflow:hidden;align-items:center;padding:0 24px}.mat-horizontal-stepper-header .mat-step-icon{margin-right:8px;flex:none}[dir=rtl] .mat-horizontal-stepper-header .mat-step-icon{margin-right:0;margin-left:8px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header{box-sizing:border-box;flex-direction:column;height:auto;padding:24px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::after{right:0}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::before,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::before{left:0}[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:first-child::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:last-child::before{display:none}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header .mat-step-icon{margin-right:0;margin-left:0}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header .mat-step-label{padding:16px 0 0 0;text-align:center;width:100%}.mat-vertical-stepper-header{display:flex;align-items:center;padding:24px;height:24px}.mat-vertical-stepper-header .mat-step-icon{margin-right:12px}[dir=rtl] .mat-vertical-stepper-header .mat-step-icon{margin-right:0;margin-left:12px}.mat-horizontal-stepper-content{outline:0}.mat-horizontal-stepper-content[aria-expanded=false]{height:0;overflow:hidden}.mat-horizontal-content-container{overflow:hidden;padding:0 24px 24px 24px}.mat-vertical-content-container{margin-left:36px;border:0;position:relative}[dir=rtl] .mat-vertical-content-container{margin-left:0;margin-right:36px}.mat-stepper-vertical-line::before{content:'';position:absolute;top:-16px;bottom:-16px;left:0;border-left-width:1px;border-left-style:solid}[dir=rtl] .mat-stepper-vertical-line::before{left:auto;right:0}.mat-vertical-stepper-content{overflow:hidden;outline:0}.mat-vertical-content{padding:0 24px 24px 24px}.mat-step:last-child .mat-vertical-content-container{border:none}"],
                            inputs: ['selectedIndex'],
                            host: {
                                'class': 'mat-stepper-horizontal',
                                '[class.mat-stepper-label-position-end]': 'labelPosition == "end"',
                                '[class.mat-stepper-label-position-bottom]': 'labelPosition == "bottom"',
                                'aria-orientation': 'horizontal',
                                'role': 'tablist',
                            },
                            animations: [matStepperAnimations.horizontalStepTransition],
                            providers: [
                                { provide: MatStepper, useExisting: MatHorizontalStepper },
                                { provide: _angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["CdkStepper"], useExisting: MatHorizontalStepper }
                            ],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            MatHorizontalStepper.propDecorators = {
                labelPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            var MatVerticalStepper = /** @class */ (function (_super) {
                __extends(MatVerticalStepper, _super);
                /**
                 * @param {?} dir
                 * @param {?} changeDetectorRef
                 * @param {?=} elementRef
                 * @param {?=} _document
                 */
                function MatVerticalStepper(dir, changeDetectorRef, 
                // @breaking-change 8.0.0 `elementRef` and `_document` parameters to become required.
                elementRef, _document) {
                    var _this_1 = _super.call(this, dir, changeDetectorRef, elementRef, _document) || this;
                    _this_1._orientation = 'vertical';
                    return _this_1;
                }
                return MatVerticalStepper;
            }(MatStepper));
            MatVerticalStepper.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-vertical-stepper',
                            exportAs: 'matVerticalStepper',
                            template: "<div class=\"mat-step\" *ngFor=\"let step of steps; let i = index; let isLast = last\"><mat-step-header class=\"mat-vertical-stepper-header\" (click)=\"step.select()\" (keydown)=\"_onKeydown($event)\" [tabIndex]=\"_getFocusIndex() == i ? 0 : -1\" [id]=\"_getStepLabelId(i)\" [attr.aria-posinset]=\"i + 1\" [attr.aria-setsize]=\"steps.length\" [attr.aria-controls]=\"_getStepContentId(i)\" [attr.aria-selected]=\"selectedIndex === i\" [attr.aria-label]=\"step.ariaLabel || null\" [attr.aria-labelledby]=\"(!step.ariaLabel && step.ariaLabelledby) ? step.ariaLabelledby : null\" [index]=\"i\" [state]=\"_getIndicatorType(i, step.state)\" [label]=\"step.stepLabel || step.label\" [selected]=\"selectedIndex === i\" [active]=\"step.completed || selectedIndex === i || !linear\" [optional]=\"step.optional\" [errorMessage]=\"step.errorMessage\" [iconOverrides]=\"_iconOverrides\" [disableRipple]=\"disableRipple\"></mat-step-header><div class=\"mat-vertical-content-container\" [class.mat-stepper-vertical-line]=\"!isLast\"><div class=\"mat-vertical-stepper-content\" role=\"tabpanel\" [attr.tabindex]=\"selectedIndex === i ? 0 : null\" [@stepTransition]=\"_getAnimationDirection(i)\" (@stepTransition.done)=\"_animationDone.next($event)\" [id]=\"_getStepContentId(i)\" [attr.aria-labelledby]=\"_getStepLabelId(i)\" [attr.aria-expanded]=\"selectedIndex === i\"><div class=\"mat-vertical-content\"><ng-container [ngTemplateOutlet]=\"step.content\"></ng-container></div></div></div></div>",
                            styles: [".mat-stepper-horizontal,.mat-stepper-vertical{display:block}.mat-horizontal-stepper-header-container{white-space:nowrap;display:flex;align-items:center}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header-container{align-items:flex-start}.mat-stepper-horizontal-line{border-top-width:1px;border-top-style:solid;flex:auto;height:0;margin:0 -16px;min-width:32px}.mat-stepper-label-position-bottom .mat-stepper-horizontal-line{margin:0;min-width:0;position:relative;top:36px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::before,.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::before{border-top-width:1px;border-top-style:solid;content:'';display:inline-block;height:0;position:absolute;top:36px;width:calc(50% - 20px)}.mat-horizontal-stepper-header{display:flex;height:72px;overflow:hidden;align-items:center;padding:0 24px}.mat-horizontal-stepper-header .mat-step-icon{margin-right:8px;flex:none}[dir=rtl] .mat-horizontal-stepper-header .mat-step-icon{margin-right:0;margin-left:8px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header{box-sizing:border-box;flex-direction:column;height:auto;padding:24px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::after{right:0}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::before,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::before{left:0}[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:first-child::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:last-child::before{display:none}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header .mat-step-icon{margin-right:0;margin-left:0}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header .mat-step-label{padding:16px 0 0 0;text-align:center;width:100%}.mat-vertical-stepper-header{display:flex;align-items:center;padding:24px;height:24px}.mat-vertical-stepper-header .mat-step-icon{margin-right:12px}[dir=rtl] .mat-vertical-stepper-header .mat-step-icon{margin-right:0;margin-left:12px}.mat-horizontal-stepper-content{outline:0}.mat-horizontal-stepper-content[aria-expanded=false]{height:0;overflow:hidden}.mat-horizontal-content-container{overflow:hidden;padding:0 24px 24px 24px}.mat-vertical-content-container{margin-left:36px;border:0;position:relative}[dir=rtl] .mat-vertical-content-container{margin-left:0;margin-right:36px}.mat-stepper-vertical-line::before{content:'';position:absolute;top:-16px;bottom:-16px;left:0;border-left-width:1px;border-left-style:solid}[dir=rtl] .mat-stepper-vertical-line::before{left:auto;right:0}.mat-vertical-stepper-content{overflow:hidden;outline:0}.mat-vertical-content{padding:0 24px 24px 24px}.mat-step:last-child .mat-vertical-content-container{border:none}"],
                            inputs: ['selectedIndex'],
                            host: {
                                'class': 'mat-stepper-vertical',
                                'aria-orientation': 'vertical',
                                'role': 'tablist',
                            },
                            animations: [matStepperAnimations.verticalStepTransition],
                            providers: [
                                { provide: MatStepper, useExisting: MatVerticalStepper },
                                { provide: _angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["CdkStepper"], useExisting: MatVerticalStepper }
                            ],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatVerticalStepper.ctorParameters = function () { return [
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_6__["DOCUMENT"],] }] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Button that moves to the next step in a stepper workflow.
             */
            var MatStepperNext = /** @class */ (function (_super) {
                __extends(MatStepperNext, _super);
                function MatStepperNext() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatStepperNext;
            }(_angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["CdkStepperNext"]));
            MatStepperNext.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'button[matStepperNext]',
                            host: {
                                '[type]': 'type',
                            },
                            inputs: ['type']
                        },] },
            ];
            /**
             * Button that moves to the previous step in a stepper workflow.
             */
            var MatStepperPrevious = /** @class */ (function (_super) {
                __extends(MatStepperPrevious, _super);
                function MatStepperPrevious() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatStepperPrevious;
            }(_angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["CdkStepperPrevious"]));
            MatStepperPrevious.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'button[matStepperPrevious]',
                            host: {
                                '[type]': 'type',
                            },
                            inputs: ['type']
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatStepperModule = /** @class */ (function () {
                function MatStepperModule() {
                }
                return MatStepperModule;
            }());
            MatStepperModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_7__["MatCommonModule"],
                                _angular_common__WEBPACK_IMPORTED_MODULE_6__["CommonModule"],
                                _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_9__["PortalModule"],
                                _angular_material_button__WEBPACK_IMPORTED_MODULE_10__["MatButtonModule"],
                                _angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["CdkStepperModule"],
                                _angular_material_icon__WEBPACK_IMPORTED_MODULE_11__["MatIconModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_7__["MatRippleModule"],
                            ],
                            exports: [
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_7__["MatCommonModule"],
                                MatHorizontalStepper,
                                MatVerticalStepper,
                                MatStep,
                                MatStepLabel,
                                MatStepper,
                                MatStepperNext,
                                MatStepperPrevious,
                                MatStepHeader,
                                MatStepperIcon,
                            ],
                            declarations: [
                                MatHorizontalStepper,
                                MatVerticalStepper,
                                MatStep,
                                MatStepLabel,
                                MatStepper,
                                MatStepperNext,
                                MatStepperPrevious,
                                MatStepHeader,
                                MatStepperIcon,
                            ],
                            providers: [MAT_STEPPER_INTL_PROVIDER, _angular_material_core__WEBPACK_IMPORTED_MODULE_7__["ErrorStateMatcher"]],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=stepper.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/tabs.js": 
        /*!********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/tabs.js ***!
          \********************************************************/
        /*! exports provided: MatTabsModule, MatInkBar, _MAT_INK_BAR_POSITIONER, MatTabBody, _MatTabBodyBase, MatTabBodyPortal, MatTabHeader, _MatTabHeaderBase, MatTabLabelWrapper, MatTab, MatTabLabel, MatTabNav, MatTabLink, _MatTabNavBase, _MatTabLinkBase, MatTabContent, MatTabChangeEvent, MAT_TABS_CONFIG, _MatTabGroupBase, MatTabGroup, matTabsAnimations, ɵa24, ɵb24 */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTabsModule", function () { return MatTabsModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatInkBar", function () { return MatInkBar; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_MAT_INK_BAR_POSITIONER", function () { return _MAT_INK_BAR_POSITIONER; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTabBody", function () { return MatTabBody; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_MatTabBodyBase", function () { return _MatTabBodyBase; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTabBodyPortal", function () { return MatTabBodyPortal; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTabHeader", function () { return MatTabHeader; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_MatTabHeaderBase", function () { return _MatTabHeaderBase; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTabLabelWrapper", function () { return MatTabLabelWrapper; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTab", function () { return MatTab; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTabLabel", function () { return MatTabLabel; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTabNav", function () { return MatTabNav; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTabLink", function () { return MatTabLink; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_MatTabNavBase", function () { return _MatTabNavBase; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_MatTabLinkBase", function () { return _MatTabLinkBase; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTabContent", function () { return MatTabContent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTabChangeEvent", function () { return MatTabChangeEvent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_TABS_CONFIG", function () { return MAT_TABS_CONFIG; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_MatTabGroupBase", function () { return _MatTabGroupBase; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTabGroup", function () { return MatTabGroup; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matTabsAnimations", function () { return matTabsAnimations; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵa24", function () { return _MAT_INK_BAR_POSITIONER_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵb24", function () { return MatPaginatedTabHeader; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/portal */ "./node_modules/@angular/cdk/esm2015/portal.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/animations */ "./node_modules/@angular/animations/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/cdk/scrolling */ "./node_modules/@angular/cdk/esm2015/scrolling.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @angular/cdk/platform */ "./node_modules/@angular/cdk/esm2015/platform.js");
            /* harmony import */ var _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @angular/cdk/observers */ "./node_modules/@angular/cdk/esm2015/observers.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token for the MatInkBar's Positioner.
             * @type {?}
             */
            var _MAT_INK_BAR_POSITIONER = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('MatInkBarPositioner', {
                providedIn: 'root',
                factory: _MAT_INK_BAR_POSITIONER_FACTORY
            });
            /**
             * The default positioner function for the MatInkBar.
             * \@docs-private
             * @return {?}
             */
            function _MAT_INK_BAR_POSITIONER_FACTORY() {
                /** @type {?} */
                var method = ( /**
                 * @param {?} element
                 * @return {?}
                 */function (element) { return ({
                    left: element ? (element.offsetLeft || 0) + 'px' : '0',
                    width: element ? (element.offsetWidth || 0) + 'px' : '0',
                }); });
                return method;
            }
            /**
             * The ink-bar is used to display and animate the line underneath the current active tab label.
             * \@docs-private
             */
            var MatInkBar = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 * @param {?} _ngZone
                 * @param {?} _inkBarPositioner
                 * @param {?=} _animationMode
                 */
                function MatInkBar(_elementRef, _ngZone, _inkBarPositioner, _animationMode) {
                    this._elementRef = _elementRef;
                    this._ngZone = _ngZone;
                    this._inkBarPositioner = _inkBarPositioner;
                    this._animationMode = _animationMode;
                }
                /**
                 * Calculates the styles from the provided element in order to align the ink-bar to that element.
                 * Shows the ink bar if previously set as hidden.
                 * @param {?} element
                 * @return {?}
                 */
                MatInkBar.prototype.alignToElement = function (element) {
                    var _this_1 = this;
                    this.show();
                    if (typeof requestAnimationFrame !== 'undefined') {
                        this._ngZone.runOutsideAngular(( /**
                         * @return {?}
                         */function () {
                            requestAnimationFrame(( /**
                             * @return {?}
                             */function () { return _this_1._setStyles(element); }));
                        }));
                    }
                    else {
                        this._setStyles(element);
                    }
                };
                /**
                 * Shows the ink bar.
                 * @return {?}
                 */
                MatInkBar.prototype.show = function () {
                    this._elementRef.nativeElement.style.visibility = 'visible';
                };
                /**
                 * Hides the ink bar.
                 * @return {?}
                 */
                MatInkBar.prototype.hide = function () {
                    this._elementRef.nativeElement.style.visibility = 'hidden';
                };
                /**
                 * Sets the proper styles to the ink bar element.
                 * @private
                 * @param {?} element
                 * @return {?}
                 */
                MatInkBar.prototype._setStyles = function (element) {
                    /** @type {?} */
                    var positions = this._inkBarPositioner(element);
                    /** @type {?} */
                    var inkBar = this._elementRef.nativeElement;
                    inkBar.style.left = positions.left;
                    inkBar.style.width = positions.width;
                };
                return MatInkBar;
            }());
            MatInkBar.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'mat-ink-bar',
                            host: {
                                'class': 'mat-ink-bar',
                                '[class._mat-animation-noopable]': "_animationMode === 'NoopAnimations'",
                            },
                        },] },
            ];
            /** @nocollapse */
            MatInkBar.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_MAT_INK_BAR_POSITIONER,] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_1__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Decorates the `ng-template` tags and reads out the template from it.
             */
            var MatTabContent = /** @class */ (function () {
                /**
                 * @param {?} template
                 */
                function MatTabContent(template) {
                    this.template = template;
                }
                return MatTabContent;
            }());
            MatTabContent.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: '[matTabContent]' },] },
            ];
            /** @nocollapse */
            MatTabContent.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Used to flag tab labels for use with the portal directive
             */
            var MatTabLabel = /** @class */ (function (_super) {
                __extends(MatTabLabel, _super);
                function MatTabLabel() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatTabLabel;
            }(_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_2__["CdkPortal"]));
            MatTabLabel.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[mat-tab-label], [matTabLabel]',
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // Boilerplate for applying mixins to MatTab.
            /**
             * \@docs-private
             */
            var MatTabBase = /** @class */ (function () {
                function MatTabBase() {
                }
                return MatTabBase;
            }());
            /** @type {?} */
            var _MatTabMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["mixinDisabled"])(MatTabBase);
            var MatTab = /** @class */ (function (_super) {
                __extends(MatTab, _super);
                /**
                 * @param {?} _viewContainerRef
                 */
                function MatTab(_viewContainerRef) {
                    var _this_1 = _super.call(this) || this;
                    _this_1._viewContainerRef = _viewContainerRef;
                    /**
                     * Plain text label for the tab, used when there is no template label.
                     */
                    _this_1.textLabel = '';
                    /**
                     * Portal that will be the hosted content of the tab
                     */
                    _this_1._contentPortal = null;
                    /**
                     * Emits whenever the internal state of the tab changes.
                     */
                    _this_1._stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
                    /**
                     * The relatively indexed position where 0 represents the center, negative is left, and positive
                     * represents the right.
                     */
                    _this_1.position = null;
                    /**
                     * The initial relatively index origin of the tab if it was created and selected after there
                     * was already a selected tab. Provides context of what position the tab should originate from.
                     */
                    _this_1.origin = null;
                    /**
                     * Whether the tab is currently active.
                     */
                    _this_1.isActive = false;
                    return _this_1;
                }
                Object.defineProperty(MatTab.prototype, "content", {
                    /**
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () {
                        return this._contentPortal;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                MatTab.prototype.ngOnChanges = function (changes) {
                    if (changes.hasOwnProperty('textLabel') || changes.hasOwnProperty('disabled')) {
                        this._stateChanges.next();
                    }
                };
                /**
                 * @return {?}
                 */
                MatTab.prototype.ngOnDestroy = function () {
                    this._stateChanges.complete();
                };
                /**
                 * @return {?}
                 */
                MatTab.prototype.ngOnInit = function () {
                    this._contentPortal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_2__["TemplatePortal"](this._explicitContent || this._implicitContent, this._viewContainerRef);
                };
                return MatTab;
            }(_MatTabMixinBase));
            MatTab.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-tab',
                            template: "<ng-template><ng-content></ng-content></ng-template>",
                            inputs: ['disabled'],
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            exportAs: 'matTab',
                        },] },
            ];
            /** @nocollapse */
            MatTab.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"] }
            ]; };
            MatTab.propDecorators = {
                templateLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChild"], args: [MatTabLabel, { static: false },] }],
                _explicitContent: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChild"], args: [MatTabContent, { read: _angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"], static: true },] }],
                _implicitContent: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"], { static: true },] }],
                textLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['label',] }],
                ariaLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['aria-label',] }],
                ariaLabelledby: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['aria-labelledby',] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Animations used by the Material tabs.
             * \@docs-private
             * @type {?}
             */
            var matTabsAnimations = {
                /**
                 * Animation translates a tab along the X axis.
                 */
                translateTab: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["trigger"])('translateTab', [
                    // Note: transitions to `none` instead of 0, because some browsers might blur the content.
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["state"])('center, void, left-origin-center, right-origin-center', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["style"])({ transform: 'none' })),
                    // If the tab is either on the left or right, we additionally add a `min-height` of 1px
                    // in order to ensure that the element has a height before its state changes. This is
                    // necessary because Chrome does seem to skip the transition in RTL mode if the element does
                    // not have a static height and is not rendered. See related issue: #9465
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["state"])('left', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["style"])({ transform: 'translate3d(-100%, 0, 0)', minHeight: '1px' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["state"])('right', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["style"])({ transform: 'translate3d(100%, 0, 0)', minHeight: '1px' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["transition"])('* => left, * => right, left => center, right => center', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["animate"])('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)')),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["transition"])('void => left-origin-center', [
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["style"])({ transform: 'translate3d(-100%, 0, 0)' }),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["animate"])('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)')
                    ]),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["transition"])('void => right-origin-center', [
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["style"])({ transform: 'translate3d(100%, 0, 0)' }),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["animate"])('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)')
                    ])
                ])
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * The portal host directive for the contents of the tab.
             * \@docs-private
             */
            var MatTabBodyPortal = /** @class */ (function (_super) {
                __extends(MatTabBodyPortal, _super);
                /**
                 * @param {?} componentFactoryResolver
                 * @param {?} viewContainerRef
                 * @param {?} _host
                 */
                function MatTabBodyPortal(componentFactoryResolver, viewContainerRef, _host) {
                    var _this_1 = _super.call(this, componentFactoryResolver, viewContainerRef) || this;
                    _this_1._host = _host;
                    /**
                     * Subscription to events for when the tab body begins centering.
                     */
                    _this_1._centeringSub = rxjs__WEBPACK_IMPORTED_MODULE_4__["Subscription"].EMPTY;
                    /**
                     * Subscription to events for when the tab body finishes leaving from center position.
                     */
                    _this_1._leavingSub = rxjs__WEBPACK_IMPORTED_MODULE_4__["Subscription"].EMPTY;
                    return _this_1;
                }
                /**
                 * Set initial visibility or set up subscription for changing visibility.
                 * @return {?}
                 */
                MatTabBodyPortal.prototype.ngOnInit = function () {
                    var _this_1 = this;
                    _super.prototype.ngOnInit.call(this);
                    this._centeringSub = this._host._beforeCentering
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["startWith"])(this._host._isCenterPosition(this._host._position)))
                        .subscribe(( /**
                 * @param {?} isCentering
                 * @return {?}
                 */function (isCentering) {
                        if (isCentering && !_this_1.hasAttached()) {
                            _this_1.attach(_this_1._host._content);
                        }
                    }));
                    this._leavingSub = this._host._afterLeavingCenter.subscribe(( /**
                     * @return {?}
                     */function () {
                        _this_1.detach();
                    }));
                };
                /**
                 * Clean up centering subscription.
                 * @return {?}
                 */
                MatTabBodyPortal.prototype.ngOnDestroy = function () {
                    _super.prototype.ngOnDestroy.call(this);
                    this._centeringSub.unsubscribe();
                    this._leavingSub.unsubscribe();
                };
                return MatTabBodyPortal;
            }(_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_2__["CdkPortalOutlet"]));
            MatTabBodyPortal.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[matTabBodyHost]'
                        },] },
            ];
            /** @nocollapse */
            MatTabBodyPortal.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"] },
                { type: MatTabBody, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                                                 * @return {?}
                                                 */function () { return MatTabBody; })),] }] }
            ]; };
            /**
             * Base class with all of the `MatTabBody` functionality.
             * \@docs-private
             * @abstract
             */
            // tslint:disable-next-line:class-name
            var _MatTabBodyBase = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 * @param {?} _dir
                 * @param {?} changeDetectorRef
                 */
                function _MatTabBodyBase(_elementRef, _dir, changeDetectorRef) {
                    var _this_1 = this;
                    this._elementRef = _elementRef;
                    this._dir = _dir;
                    /**
                     * Subscription to the directionality change observable.
                     */
                    this._dirChangeSubscription = rxjs__WEBPACK_IMPORTED_MODULE_4__["Subscription"].EMPTY;
                    /**
                     * Emits when an animation on the tab is complete.
                     */
                    this._translateTabComplete = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
                    /**
                     * Event emitted when the tab begins to animate towards the center as the active tab.
                     */
                    this._onCentering = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Event emitted before the centering of the tab begins.
                     */
                    this._beforeCentering = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Event emitted before the centering of the tab begins.
                     */
                    this._afterLeavingCenter = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Event emitted when the tab completes its animation towards the center.
                     */
                    this._onCentered = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"](true);
                    // Note that the default value will always be overwritten by `MatTabBody`, but we need one
                    // anyway to prevent the animations module from throwing an error if the body is used on its own.
                    /**
                     * Duration for the tab's animation.
                     */
                    this.animationDuration = '500ms';
                    if (_dir) {
                        this._dirChangeSubscription = _dir.change.subscribe(( /**
                         * @param {?} dir
                         * @return {?}
                         */function (dir) {
                            _this_1._computePositionAnimationState(dir);
                            changeDetectorRef.markForCheck();
                        }));
                    }
                    // Ensure that we get unique animation events, because the `.done` callback can get
                    // invoked twice in some browsers. See https://github.com/angular/angular/issues/24084.
                    this._translateTabComplete.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["distinctUntilChanged"])(( /**
                     * @param {?} x
                     * @param {?} y
                     * @return {?}
                     */function (x, y) {
                        return x.fromState === y.fromState && x.toState === y.toState;
                    }))).subscribe(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) {
                        // If the transition to the center is complete, emit an event.
                        if (_this_1._isCenterPosition(event.toState) && _this_1._isCenterPosition(_this_1._position)) {
                            _this_1._onCentered.emit();
                        }
                        if (_this_1._isCenterPosition(event.fromState) && !_this_1._isCenterPosition(_this_1._position)) {
                            _this_1._afterLeavingCenter.emit();
                        }
                    }));
                }
                Object.defineProperty(_MatTabBodyBase.prototype, "position", {
                    /**
                     * The shifted index position of the tab body, where zero represents the active center tab.
                     * @param {?} position
                     * @return {?}
                     */
                    set: function (position) {
                        this._positionIndex = position;
                        this._computePositionAnimationState();
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * After initialized, check if the content is centered and has an origin. If so, set the
                 * special position states that transition the tab from the left or right before centering.
                 * @return {?}
                 */
                _MatTabBodyBase.prototype.ngOnInit = function () {
                    if (this._position == 'center' && this.origin != null) {
                        this._position = this._computePositionFromOrigin();
                    }
                };
                /**
                 * @return {?}
                 */
                _MatTabBodyBase.prototype.ngOnDestroy = function () {
                    this._dirChangeSubscription.unsubscribe();
                    this._translateTabComplete.complete();
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                _MatTabBodyBase.prototype._onTranslateTabStarted = function (event) {
                    /** @type {?} */
                    var isCentering = this._isCenterPosition(event.toState);
                    this._beforeCentering.emit(isCentering);
                    if (isCentering) {
                        this._onCentering.emit(this._elementRef.nativeElement.clientHeight);
                    }
                };
                /**
                 * The text direction of the containing app.
                 * @return {?}
                 */
                _MatTabBodyBase.prototype._getLayoutDirection = function () {
                    return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
                };
                /**
                 * Whether the provided position state is considered center, regardless of origin.
                 * @param {?} position
                 * @return {?}
                 */
                _MatTabBodyBase.prototype._isCenterPosition = function (position) {
                    return position == 'center' ||
                        position == 'left-origin-center' ||
                        position == 'right-origin-center';
                };
                /**
                 * Computes the position state that will be used for the tab-body animation trigger.
                 * @private
                 * @param {?=} dir
                 * @return {?}
                 */
                _MatTabBodyBase.prototype._computePositionAnimationState = function (dir) {
                    if (dir === void 0) { dir = this._getLayoutDirection(); }
                    if (this._positionIndex < 0) {
                        this._position = dir == 'ltr' ? 'left' : 'right';
                    }
                    else if (this._positionIndex > 0) {
                        this._position = dir == 'ltr' ? 'right' : 'left';
                    }
                    else {
                        this._position = 'center';
                    }
                };
                /**
                 * Computes the position state based on the specified origin position. This is used if the
                 * tab is becoming visible immediately after creation.
                 * @private
                 * @return {?}
                 */
                _MatTabBodyBase.prototype._computePositionFromOrigin = function () {
                    /** @type {?} */
                    var dir = this._getLayoutDirection();
                    if ((dir == 'ltr' && this.origin <= 0) || (dir == 'rtl' && this.origin > 0)) {
                        return 'left-origin-center';
                    }
                    return 'right-origin-center';
                };
                return _MatTabBodyBase;
            }());
            _MatTabBodyBase.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            // TODO(crisbeto): this selector can be removed when we update to Angular 9.0.
                            selector: 'do-not-use-abstract-mat-tab-body-base'
                        },] },
            ];
            /** @nocollapse */
            _MatTabBodyBase.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] }
            ]; };
            _MatTabBodyBase.propDecorators = {
                _onCentering: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                _beforeCentering: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                _afterLeavingCenter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                _onCentered: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                _content: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['content',] }],
                origin: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                animationDuration: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                position: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * Wrapper for the contents of a tab.
             * \@docs-private
             */
            var MatTabBody = /** @class */ (function (_super) {
                __extends(MatTabBody, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} dir
                 * @param {?} changeDetectorRef
                 */
                function MatTabBody(elementRef, dir, changeDetectorRef) {
                    return _super.call(this, elementRef, dir, changeDetectorRef) || this;
                }
                return MatTabBody;
            }(_MatTabBodyBase));
            MatTabBody.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-tab-body',
                            template: "<div class=\"mat-tab-body-content\" #content [@translateTab]=\"{ value: _position, params: {animationDuration: animationDuration} }\" (@translateTab.start)=\"_onTranslateTabStarted($event)\" (@translateTab.done)=\"_translateTabComplete.next($event)\"><ng-template matTabBodyHost></ng-template></div>",
                            styles: [".mat-tab-body-content{height:100%;overflow:auto}.mat-tab-group-dynamic-height .mat-tab-body-content{overflow:hidden}"],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            animations: [matTabsAnimations.translateTab],
                            host: {
                                'class': 'mat-tab-body',
                            }
                        },] },
            ];
            /** @nocollapse */
            MatTabBody.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] }
            ]; };
            MatTabBody.propDecorators = {
                _portalHost: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_2__["PortalHostDirective"], { static: false },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Used to generate unique ID's for each tab component
             * @type {?}
             */
            var nextId = 0;
            /**
             * A simple change event emitted on focus or selection changes.
             */
            var MatTabChangeEvent = /** @class */ (function () {
                function MatTabChangeEvent() {
                }
                return MatTabChangeEvent;
            }());
            /**
             * Injection token that can be used to provide the default options the tabs module.
             * @type {?}
             */
            var MAT_TABS_CONFIG = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('MAT_TABS_CONFIG');
            // Boilerplate for applying mixins to MatTabGroup.
            /**
             * \@docs-private
             */
            var MatTabGroupMixinBase = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 */
                function MatTabGroupMixinBase(_elementRef) {
                    this._elementRef = _elementRef;
                }
                return MatTabGroupMixinBase;
            }());
            /** @type {?} */
            var _MatTabGroupMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["mixinColor"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["mixinDisableRipple"])(MatTabGroupMixinBase), 'primary');
            /**
             * Base class with all of the `MatTabGroupBase` functionality.
             * \@docs-private
             * @abstract
             */
            // tslint:disable-next-line:class-name
            var _MatTabGroupBase = /** @class */ (function (_super) {
                __extends(_MatTabGroupBase, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} _changeDetectorRef
                 * @param {?=} defaultConfig
                 * @param {?=} _animationMode
                 */
                function _MatTabGroupBase(elementRef, _changeDetectorRef, defaultConfig, _animationMode) {
                    var _this_1 = _super.call(this, elementRef) || this;
                    _this_1._changeDetectorRef = _changeDetectorRef;
                    _this_1._animationMode = _animationMode;
                    /**
                     * The tab index that should be selected after the content has been checked.
                     */
                    _this_1._indexToSelect = 0;
                    /**
                     * Snapshot of the height of the tab body wrapper before another tab is activated.
                     */
                    _this_1._tabBodyWrapperHeight = 0;
                    /**
                     * Subscription to tabs being added/removed.
                     */
                    _this_1._tabsSubscription = rxjs__WEBPACK_IMPORTED_MODULE_4__["Subscription"].EMPTY;
                    /**
                     * Subscription to changes in the tab labels.
                     */
                    _this_1._tabLabelSubscription = rxjs__WEBPACK_IMPORTED_MODULE_4__["Subscription"].EMPTY;
                    _this_1._dynamicHeight = false;
                    _this_1._selectedIndex = null;
                    /**
                     * Position of the tab header.
                     */
                    _this_1.headerPosition = 'above';
                    /**
                     * Output to enable support for two-way binding on `[(selectedIndex)]`
                     */
                    _this_1.selectedIndexChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Event emitted when focus has changed within a tab group.
                     */
                    _this_1.focusChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Event emitted when the body animation has completed
                     */
                    _this_1.animationDone = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Event emitted when the tab selection has changed.
                     */
                    _this_1.selectedTabChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"](true);
                    _this_1._groupId = nextId++;
                    _this_1.animationDuration = defaultConfig && defaultConfig.animationDuration ?
                        defaultConfig.animationDuration : '500ms';
                    return _this_1;
                }
                Object.defineProperty(_MatTabGroupBase.prototype, "dynamicHeight", {
                    /**
                     * Whether the tab group should grow to the size of the active tab.
                     * @return {?}
                     */
                    get: function () { return this._dynamicHeight; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._dynamicHeight = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(_MatTabGroupBase.prototype, "selectedIndex", {
                    /**
                     * The index of the active tab.
                     * @return {?}
                     */
                    get: function () { return this._selectedIndex; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._indexToSelect = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__["coerceNumberProperty"])(value, null);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(_MatTabGroupBase.prototype, "animationDuration", {
                    /**
                     * Duration for the tab animation. Will be normalized to milliseconds if no units are set.
                     * @return {?}
                     */
                    get: function () { return this._animationDuration; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._animationDuration = /^\d+$/.test(value) ? value + 'ms' : value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(_MatTabGroupBase.prototype, "backgroundColor", {
                    /**
                     * Background color of the tab group.
                     * @return {?}
                     */
                    get: function () { return this._backgroundColor; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var nativeElement = this._elementRef.nativeElement;
                        nativeElement.classList.remove("mat-background-" + this.backgroundColor);
                        if (value) {
                            nativeElement.classList.add("mat-background-" + value);
                        }
                        this._backgroundColor = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * After the content is checked, this component knows what tabs have been defined
                 * and what the selected index should be. This is where we can know exactly what position
                 * each tab should be in according to the new selected index, and additionally we know how
                 * a new selected tab should transition in (from the left or right).
                 * @return {?}
                 */
                _MatTabGroupBase.prototype.ngAfterContentChecked = function () {
                    var _this_1 = this;
                    // Don't clamp the `indexToSelect` immediately in the setter because it can happen that
                    // the amount of tabs changes before the actual change detection runs.
                    /** @type {?} */
                    var indexToSelect = this._indexToSelect = this._clampTabIndex(this._indexToSelect);
                    // If there is a change in selected index, emit a change event. Should not trigger if
                    // the selected index has not yet been initialized.
                    if (this._selectedIndex != indexToSelect) {
                        /** @type {?} */
                        var isFirstRun_1 = this._selectedIndex == null;
                        if (!isFirstRun_1) {
                            this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));
                        }
                        // Changing these values after change detection has run
                        // since the checked content may contain references to them.
                        Promise.resolve().then(( /**
                         * @return {?}
                         */function () {
                            _this_1._tabs.forEach(( /**
                             * @param {?} tab
                             * @param {?} index
                             * @return {?}
                             */function (tab, index) { return tab.isActive = index === indexToSelect; }));
                            if (!isFirstRun_1) {
                                _this_1.selectedIndexChange.emit(indexToSelect);
                            }
                        }));
                    }
                    // Setup the position for each tab and optionally setup an origin on the next selected tab.
                    this._tabs.forEach(( /**
                     * @param {?} tab
                     * @param {?} index
                     * @return {?}
                     */function (tab, index) {
                        tab.position = index - indexToSelect;
                        // If there is already a selected tab, then set up an origin for the next selected tab
                        // if it doesn't have one already.
                        if (_this_1._selectedIndex != null && tab.position == 0 && !tab.origin) {
                            tab.origin = indexToSelect - _this_1._selectedIndex;
                        }
                    }));
                    if (this._selectedIndex !== indexToSelect) {
                        this._selectedIndex = indexToSelect;
                        this._changeDetectorRef.markForCheck();
                    }
                };
                /**
                 * @return {?}
                 */
                _MatTabGroupBase.prototype.ngAfterContentInit = function () {
                    var _this_1 = this;
                    this._subscribeToTabLabels();
                    // Subscribe to changes in the amount of tabs, in order to be
                    // able to re-render the content as new tabs are added or removed.
                    this._tabsSubscription = this._tabs.changes.subscribe(( /**
                     * @return {?}
                     */function () {
                        /** @type {?} */
                        var indexToSelect = _this_1._clampTabIndex(_this_1._indexToSelect);
                        // Maintain the previously-selected tab if a new tab is added or removed and there is no
                        // explicit change that selects a different tab.
                        if (indexToSelect === _this_1._selectedIndex) {
                            /** @type {?} */
                            var tabs = _this_1._tabs.toArray();
                            for (var i = 0; i < tabs.length; i++) {
                                if (tabs[i].isActive) {
                                    // Assign both to the `_indexToSelect` and `_selectedIndex` so we don't fire a changed
                                    // event, otherwise the consumer may end up in an infinite loop in some edge cases like
                                    // adding a tab within the `selectedIndexChange` event.
                                    _this_1._indexToSelect = _this_1._selectedIndex = i;
                                    break;
                                }
                            }
                        }
                        _this_1._subscribeToTabLabels();
                        _this_1._changeDetectorRef.markForCheck();
                    }));
                };
                /**
                 * @return {?}
                 */
                _MatTabGroupBase.prototype.ngOnDestroy = function () {
                    this._tabsSubscription.unsubscribe();
                    this._tabLabelSubscription.unsubscribe();
                };
                /**
                 * Re-aligns the ink bar to the selected tab element.
                 * @return {?}
                 */
                _MatTabGroupBase.prototype.realignInkBar = function () {
                    if (this._tabHeader) {
                        this._tabHeader._alignInkBarToSelectedTab();
                    }
                };
                /**
                 * @param {?} index
                 * @return {?}
                 */
                _MatTabGroupBase.prototype._focusChanged = function (index) {
                    this.focusChange.emit(this._createChangeEvent(index));
                };
                /**
                 * @private
                 * @param {?} index
                 * @return {?}
                 */
                _MatTabGroupBase.prototype._createChangeEvent = function (index) {
                    /** @type {?} */
                    var event = new MatTabChangeEvent;
                    event.index = index;
                    if (this._tabs && this._tabs.length) {
                        event.tab = this._tabs.toArray()[index];
                    }
                    return event;
                };
                /**
                 * Subscribes to changes in the tab labels. This is needed, because the \@Input for the label is
                 * on the MatTab component, whereas the data binding is inside the MatTabGroup. In order for the
                 * binding to be updated, we need to subscribe to changes in it and trigger change detection
                 * manually.
                 * @private
                 * @return {?}
                 */
                _MatTabGroupBase.prototype._subscribeToTabLabels = function () {
                    var _this_1 = this;
                    if (this._tabLabelSubscription) {
                        this._tabLabelSubscription.unsubscribe();
                    }
                    this._tabLabelSubscription = Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["merge"]).apply(void 0, this._tabs.map(( /**
                     * @param {?} tab
                     * @return {?}
                     */function (/**
                     * @param {?} tab
                     * @return {?}
                     */ tab) { return tab._stateChanges; }))).subscribe(( /**
                 * @return {?}
                 */function () { return _this_1._changeDetectorRef.markForCheck(); }));
                };
                /**
                 * Clamps the given index to the bounds of 0 and the tabs length.
                 * @private
                 * @param {?} index
                 * @return {?}
                 */
                _MatTabGroupBase.prototype._clampTabIndex = function (index) {
                    // Note the `|| 0`, which ensures that values like NaN can't get through
                    // and which would otherwise throw the component into an infinite loop
                    // (since Math.max(NaN, 0) === NaN).
                    return Math.min(this._tabs.length - 1, Math.max(index || 0, 0));
                };
                /**
                 * Returns a unique id for each tab label element
                 * @param {?} i
                 * @return {?}
                 */
                _MatTabGroupBase.prototype._getTabLabelId = function (i) {
                    return "mat-tab-label-" + this._groupId + "-" + i;
                };
                /**
                 * Returns a unique id for each tab content element
                 * @param {?} i
                 * @return {?}
                 */
                _MatTabGroupBase.prototype._getTabContentId = function (i) {
                    return "mat-tab-content-" + this._groupId + "-" + i;
                };
                /**
                 * Sets the height of the body wrapper to the height of the activating tab if dynamic
                 * height property is true.
                 * @param {?} tabHeight
                 * @return {?}
                 */
                _MatTabGroupBase.prototype._setTabBodyWrapperHeight = function (tabHeight) {
                    if (!this._dynamicHeight || !this._tabBodyWrapperHeight) {
                        return;
                    }
                    /** @type {?} */
                    var wrapper = this._tabBodyWrapper.nativeElement;
                    wrapper.style.height = this._tabBodyWrapperHeight + 'px';
                    // This conditional forces the browser to paint the height so that
                    // the animation to the new height can have an origin.
                    if (this._tabBodyWrapper.nativeElement.offsetHeight) {
                        wrapper.style.height = tabHeight + 'px';
                    }
                };
                /**
                 * Removes the height of the tab body wrapper.
                 * @return {?}
                 */
                _MatTabGroupBase.prototype._removeTabBodyWrapperHeight = function () {
                    /** @type {?} */
                    var wrapper = this._tabBodyWrapper.nativeElement;
                    this._tabBodyWrapperHeight = wrapper.clientHeight;
                    wrapper.style.height = '';
                    this.animationDone.emit();
                };
                /**
                 * Handle click events, setting new selected index if appropriate.
                 * @param {?} tab
                 * @param {?} tabHeader
                 * @param {?} index
                 * @return {?}
                 */
                _MatTabGroupBase.prototype._handleClick = function (tab, tabHeader, index) {
                    if (!tab.disabled) {
                        this.selectedIndex = tabHeader.focusIndex = index;
                    }
                };
                /**
                 * Retrieves the tabindex for the tab.
                 * @param {?} tab
                 * @param {?} idx
                 * @return {?}
                 */
                _MatTabGroupBase.prototype._getTabIndex = function (tab, idx) {
                    if (tab.disabled) {
                        return null;
                    }
                    return this.selectedIndex === idx ? 0 : -1;
                };
                return _MatTabGroupBase;
            }(_MatTabGroupMixinBase));
            _MatTabGroupBase.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            // TODO(crisbeto): this selector can be removed when we update to Angular 9.0.
                            selector: 'do-not-use-abstract-mat-tab-group-base'
                        },] },
            ];
            /** @nocollapse */
            _MatTabGroupBase.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [MAT_TABS_CONFIG,] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_1__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            _MatTabGroupBase.propDecorators = {
                dynamicHeight: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selectedIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                headerPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                animationDuration: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                backgroundColor: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selectedIndexChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                focusChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                animationDone: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                selectedTabChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }]
            };
            /**
             * Material design tab-group component. Supports basic tab pairs (label + content) and includes
             * animated ink-bar, keyboard navigation, and screen reader.
             * See: https://material.io/design/components/tabs.html
             */
            var MatTabGroup = /** @class */ (function (_super) {
                __extends(MatTabGroup, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} changeDetectorRef
                 * @param {?=} defaultConfig
                 * @param {?=} animationMode
                 */
                function MatTabGroup(elementRef, changeDetectorRef, defaultConfig, animationMode) {
                    return _super.call(this, elementRef, changeDetectorRef, defaultConfig, animationMode) || this;
                }
                return MatTabGroup;
            }(_MatTabGroupBase));
            MatTabGroup.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-tab-group',
                            exportAs: 'matTabGroup',
                            template: "<mat-tab-header #tabHeader [selectedIndex]=\"selectedIndex\" [disableRipple]=\"disableRipple\" (indexFocused)=\"_focusChanged($event)\" (selectFocusedIndex)=\"selectedIndex = $event\"><div class=\"mat-tab-label\" role=\"tab\" matTabLabelWrapper mat-ripple cdkMonitorElementFocus *ngFor=\"let tab of _tabs; let i = index\" [id]=\"_getTabLabelId(i)\" [attr.tabIndex]=\"_getTabIndex(tab, i)\" [attr.aria-posinset]=\"i + 1\" [attr.aria-setsize]=\"_tabs.length\" [attr.aria-controls]=\"_getTabContentId(i)\" [attr.aria-selected]=\"selectedIndex == i\" [attr.aria-label]=\"tab.ariaLabel || null\" [attr.aria-labelledby]=\"(!tab.ariaLabel && tab.ariaLabelledby) ? tab.ariaLabelledby : null\" [class.mat-tab-label-active]=\"selectedIndex == i\" [disabled]=\"tab.disabled\" [matRippleDisabled]=\"tab.disabled || disableRipple\" (click)=\"_handleClick(tab, tabHeader, i)\"><div class=\"mat-tab-label-content\"><ng-template [ngIf]=\"tab.templateLabel\"><ng-template [cdkPortalOutlet]=\"tab.templateLabel\"></ng-template></ng-template><ng-template [ngIf]=\"!tab.templateLabel\">{{tab.textLabel}}</ng-template></div></div></mat-tab-header><div class=\"mat-tab-body-wrapper\" [class._mat-animation-noopable]=\"_animationMode === 'NoopAnimations'\" #tabBodyWrapper><mat-tab-body role=\"tabpanel\" *ngFor=\"let tab of _tabs; let i = index\" [id]=\"_getTabContentId(i)\" [attr.aria-labelledby]=\"_getTabLabelId(i)\" [class.mat-tab-body-active]=\"selectedIndex == i\" [content]=\"tab.content\" [position]=\"tab.position\" [origin]=\"tab.origin\" [animationDuration]=\"animationDuration\" (_onCentered)=\"_removeTabBodyWrapperHeight()\" (_onCentering)=\"_setTabBodyWrapperHeight($event)\"></mat-tab-body></div>",
                            styles: [".mat-tab-group{display:flex;flex-direction:column}.mat-tab-group.mat-tab-group-inverted-header{flex-direction:column-reverse}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:0}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}@media (-ms-high-contrast:active){.mat-tab-label:focus{outline:dotted 2px}}.mat-tab-label.mat-tab-disabled{cursor:default}@media (-ms-high-contrast:active){.mat-tab-label.mat-tab-disabled{opacity:.5}}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media (-ms-high-contrast:active){.mat-tab-label{opacity:1}}@media (max-width:599px){.mat-tab-label{padding:0 12px}}@media (max-width:959px){.mat-tab-label{padding:0 12px}}.mat-tab-group[mat-stretch-tabs]>.mat-tab-header .mat-tab-label{flex-basis:0;flex-grow:1}.mat-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height .5s cubic-bezier(.35,0,.25,1)}._mat-animation-noopable.mat-tab-body-wrapper{transition:none;animation:none}.mat-tab-body{top:0;left:0;right:0;bottom:0;position:absolute;display:block;overflow:hidden;flex-basis:100%}.mat-tab-body.mat-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}.mat-tab-group.mat-tab-group-dynamic-height .mat-tab-body.mat-tab-body-active{overflow-y:hidden}"],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            inputs: ['color', 'disableRipple'],
                            host: {
                                'class': 'mat-tab-group',
                                '[class.mat-tab-group-dynamic-height]': 'dynamicHeight',
                                '[class.mat-tab-group-inverted-header]': 'headerPosition === "below"',
                            },
                        },] },
            ];
            /** @nocollapse */
            MatTabGroup.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [MAT_TABS_CONFIG,] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_1__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            MatTabGroup.propDecorators = {
                _tabs: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChildren"], args: [MatTab,] }],
                _tabBodyWrapper: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['tabBodyWrapper', { static: false },] }],
                _tabHeader: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['tabHeader', { static: false },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // Boilerplate for applying mixins to MatTabLabelWrapper.
            /**
             * \@docs-private
             */
            var MatTabLabelWrapperBase = /** @class */ (function () {
                function MatTabLabelWrapperBase() {
                }
                return MatTabLabelWrapperBase;
            }());
            /** @type {?} */
            var _MatTabLabelWrapperMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["mixinDisabled"])(MatTabLabelWrapperBase);
            /**
             * Used in the `mat-tab-group` view to display tab labels.
             * \@docs-private
             */
            var MatTabLabelWrapper = /** @class */ (function (_super) {
                __extends(MatTabLabelWrapper, _super);
                /**
                 * @param {?} elementRef
                 */
                function MatTabLabelWrapper(elementRef) {
                    var _this_1 = _super.call(this) || this;
                    _this_1.elementRef = elementRef;
                    return _this_1;
                }
                /**
                 * Sets focus on the wrapper element
                 * @return {?}
                 */
                MatTabLabelWrapper.prototype.focus = function () {
                    this.elementRef.nativeElement.focus();
                };
                /**
                 * @return {?}
                 */
                MatTabLabelWrapper.prototype.getOffsetLeft = function () {
                    return this.elementRef.nativeElement.offsetLeft;
                };
                /**
                 * @return {?}
                 */
                MatTabLabelWrapper.prototype.getOffsetWidth = function () {
                    return this.elementRef.nativeElement.offsetWidth;
                };
                return MatTabLabelWrapper;
            }(_MatTabLabelWrapperMixinBase));
            MatTabLabelWrapper.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[matTabLabelWrapper]',
                            inputs: ['disabled'],
                            host: {
                                '[class.mat-tab-disabled]': 'disabled',
                                '[attr.aria-disabled]': '!!disabled',
                            }
                        },] },
            ];
            /** @nocollapse */
            MatTabLabelWrapper.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Config used to bind passive event listeners
             * @type {?}
             */
            var passiveEventListenerOptions = ( /** @type {?} */(Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_12__["normalizePassiveListenerOptions"])({ passive: true })));
            /**
             * The distance in pixels that will be overshot when scrolling a tab label into view. This helps
             * provide a small affordance to the label next to it.
             * @type {?}
             */
            var EXAGGERATED_OVERSCROLL = 60;
            /**
             * Amount of milliseconds to wait before starting to scroll the header automatically.
             * Set a little conservatively in order to handle fake events dispatched on touch devices.
             * @type {?}
             */
            var HEADER_SCROLL_DELAY = 650;
            /**
             * Interval in milliseconds at which to scroll the header
             * while the user is holding their pointer.
             * @type {?}
             */
            var HEADER_SCROLL_INTERVAL = 100;
            /**
             * Base class for a tab header that supported pagination.
             * \@docs-private
             * @abstract
             */
            var MatPaginatedTabHeader = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 * @param {?} _changeDetectorRef
                 * @param {?} _viewportRuler
                 * @param {?} _dir
                 * @param {?} _ngZone
                 * @param {?=} _platform
                 * @param {?=} _animationMode
                 */
                function MatPaginatedTabHeader(_elementRef, _changeDetectorRef, _viewportRuler, _dir, _ngZone, _platform, _animationMode) {
                    var _this_1 = this;
                    this._elementRef = _elementRef;
                    this._changeDetectorRef = _changeDetectorRef;
                    this._viewportRuler = _viewportRuler;
                    this._dir = _dir;
                    this._ngZone = _ngZone;
                    this._platform = _platform;
                    this._animationMode = _animationMode;
                    /**
                     * The distance in pixels that the tab labels should be translated to the left.
                     */
                    this._scrollDistance = 0;
                    /**
                     * Whether the header should scroll to the selected index after the view has been checked.
                     */
                    this._selectedIndexChanged = false;
                    /**
                     * Emits when the component is destroyed.
                     */
                    this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
                    /**
                     * Whether the controls for pagination should be displayed
                     */
                    this._showPaginationControls = false;
                    /**
                     * Whether the tab list can be scrolled more towards the end of the tab label list.
                     */
                    this._disableScrollAfter = true;
                    /**
                     * Whether the tab list can be scrolled more towards the beginning of the tab label list.
                     */
                    this._disableScrollBefore = true;
                    /**
                     * Stream that will stop the automated scrolling.
                     */
                    this._stopScrolling = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
                    this._selectedIndex = 0;
                    /**
                     * Event emitted when the option is selected.
                     */
                    this.selectFocusedIndex = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Event emitted when a label is focused.
                     */
                    this.indexFocused = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    // Bind the `mouseleave` event on the outside since it doesn't change anything in the view.
                    _ngZone.runOutsideAngular(( /**
                     * @return {?}
                     */function () {
                        Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(_elementRef.nativeElement, 'mouseleave')
                            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["takeUntil"])(_this_1._destroyed))
                            .subscribe(( /**
                     * @return {?}
                     */function () {
                            _this_1._stopInterval();
                        }));
                    }));
                }
                Object.defineProperty(MatPaginatedTabHeader.prototype, "selectedIndex", {
                    /**
                     * The index of the active tab.
                     * @return {?}
                     */
                    get: function () { return this._selectedIndex; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        value = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__["coerceNumberProperty"])(value);
                        if (this._selectedIndex != value) {
                            this._selectedIndexChanged = true;
                            this._selectedIndex = value;
                            if (this._keyManager) {
                                this._keyManager.updateActiveItemIndex(value);
                            }
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype.ngAfterViewInit = function () {
                    var _this_1 = this;
                    // We need to handle these events manually, because we want to bind passive event listeners.
                    Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(this._previousPaginator.nativeElement, 'touchstart', passiveEventListenerOptions)
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["takeUntil"])(this._destroyed))
                        .subscribe(( /**
                 * @return {?}
                 */function () {
                        _this_1._handlePaginatorPress('before');
                    }));
                    Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(this._nextPaginator.nativeElement, 'touchstart', passiveEventListenerOptions)
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["takeUntil"])(this._destroyed))
                        .subscribe(( /**
                 * @return {?}
                 */function () {
                        _this_1._handlePaginatorPress('after');
                    }));
                };
                /**
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype.ngAfterContentInit = function () {
                    var _this_1 = this;
                    /** @type {?} */
                    var dirChange = this._dir ? this._dir.change : Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["of"])(null);
                    /** @type {?} */
                    var resize = this._viewportRuler.change(150);
                    /** @type {?} */
                    var realign = ( /**
                     * @return {?}
                     */function () {
                        _this_1.updatePagination();
                        _this_1._alignInkBarToSelectedTab();
                    });
                    this._keyManager = new _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_10__["FocusKeyManager"](this._items)
                        .withHorizontalOrientation(this._getLayoutDirection())
                        .withWrap();
                    this._keyManager.updateActiveItem(0);
                    // Defer the first call in order to allow for slower browsers to lay out the elements.
                    // This helps in cases where the user lands directly on a page with paginated tabs.
                    typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame(realign) : realign();
                    // On dir change or window resize, realign the ink bar and update the orientation of
                    // the key manager if the direction has changed.
                    Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["merge"])(dirChange, resize, this._items.changes).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["takeUntil"])(this._destroyed)).subscribe(( /**
                     * @return {?}
                     */function () {
                        realign();
                        _this_1._keyManager.withHorizontalOrientation(_this_1._getLayoutDirection());
                    }));
                    // If there is a change in the focus key manager we need to emit the `indexFocused`
                    // event in order to provide a public event that notifies about focus changes. Also we realign
                    // the tabs container by scrolling the new focused tab into the visible section.
                    this._keyManager.change.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["takeUntil"])(this._destroyed)).subscribe(( /**
                     * @param {?} newFocusIndex
                     * @return {?}
                     */function (/**
                     * @param {?} newFocusIndex
                     * @return {?}
                     */ newFocusIndex) {
                        _this_1.indexFocused.emit(newFocusIndex);
                        _this_1._setTabFocus(newFocusIndex);
                    }));
                };
                /**
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype.ngAfterContentChecked = function () {
                    // If the number of tab labels have changed, check if scrolling should be enabled
                    if (this._tabLabelCount != this._items.length) {
                        this.updatePagination();
                        this._tabLabelCount = this._items.length;
                        this._changeDetectorRef.markForCheck();
                    }
                    // If the selected index has changed, scroll to the label and check if the scrolling controls
                    // should be disabled.
                    if (this._selectedIndexChanged) {
                        this._scrollToLabel(this._selectedIndex);
                        this._checkScrollingControls();
                        this._alignInkBarToSelectedTab();
                        this._selectedIndexChanged = false;
                        this._changeDetectorRef.markForCheck();
                    }
                    // If the scroll distance has been changed (tab selected, focused, scroll controls activated),
                    // then translate the header to reflect this.
                    if (this._scrollDistanceChanged) {
                        this._updateTabScrollPosition();
                        this._scrollDistanceChanged = false;
                        this._changeDetectorRef.markForCheck();
                    }
                };
                /**
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype.ngOnDestroy = function () {
                    this._destroyed.next();
                    this._destroyed.complete();
                    this._stopScrolling.complete();
                };
                /**
                 * Handles keyboard events on the header.
                 * @param {?} event
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype._handleKeydown = function (event) {
                    // We don't handle any key bindings with a modifier key.
                    if (Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["hasModifierKey"])(event)) {
                        return;
                    }
                    switch (event.keyCode) {
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["HOME"]:
                            this._keyManager.setFirstItemActive();
                            event.preventDefault();
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["END"]:
                            this._keyManager.setLastItemActive();
                            event.preventDefault();
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["ENTER"]:
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["SPACE"]:
                            this.selectFocusedIndex.emit(this.focusIndex);
                            this._itemSelected(event);
                            break;
                        default:
                            this._keyManager.onKeydown(event);
                    }
                };
                /**
                 * Callback for when the MutationObserver detects that the content has changed.
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype._onContentChanges = function () {
                    var _this_1 = this;
                    /** @type {?} */
                    var textContent = this._elementRef.nativeElement.textContent;
                    // We need to diff the text content of the header, because the MutationObserver callback
                    // will fire even if the text content didn't change which is inefficient and is prone
                    // to infinite loops if a poorly constructed expression is passed in (see #14249).
                    if (textContent !== this._currentTextContent) {
                        this._currentTextContent = textContent || '';
                        // The content observer runs outside the `NgZone` by default, which
                        // means that we need to bring the callback back in ourselves.
                        this._ngZone.run(( /**
                         * @return {?}
                         */function () {
                            _this_1.updatePagination();
                            _this_1._alignInkBarToSelectedTab();
                            _this_1._changeDetectorRef.markForCheck();
                        }));
                    }
                };
                /**
                 * Updates the view whether pagination should be enabled or not.
                 *
                 * WARNING: Calling this method can be very costly in terms of performance. It should be called
                 * as infrequently as possible from outside of the Tabs component as it causes a reflow of the
                 * page.
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype.updatePagination = function () {
                    this._checkPaginationEnabled();
                    this._checkScrollingControls();
                    this._updateTabScrollPosition();
                };
                Object.defineProperty(MatPaginatedTabHeader.prototype, "focusIndex", {
                    /**
                     * Tracks which element has focus; used for keyboard navigation
                     * @return {?}
                     */
                    get: function () {
                        return this._keyManager ? ( /** @type {?} */(this._keyManager.activeItemIndex)) : 0;
                    },
                    /**
                     * When the focus index is set, we must manually send focus to the correct label
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (!this._isValidIndex(value) || this.focusIndex === value || !this._keyManager) {
                            return;
                        }
                        this._keyManager.setActiveItem(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is
                 * providing a valid index and return true.
                 * @param {?} index
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype._isValidIndex = function (index) {
                    if (!this._items) {
                        return true;
                    }
                    /** @type {?} */
                    var tab = this._items ? this._items.toArray()[index] : null;
                    return !!tab && !tab.disabled;
                };
                /**
                 * Sets focus on the HTML element for the label wrapper and scrolls it into the view if
                 * scrolling is enabled.
                 * @param {?} tabIndex
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype._setTabFocus = function (tabIndex) {
                    if (this._showPaginationControls) {
                        this._scrollToLabel(tabIndex);
                    }
                    if (this._items && this._items.length) {
                        this._items.toArray()[tabIndex].focus();
                        // Do not let the browser manage scrolling to focus the element, this will be handled
                        // by using translation. In LTR, the scroll left should be 0. In RTL, the scroll width
                        // should be the full width minus the offset width.
                        /** @type {?} */
                        var containerEl = this._tabListContainer.nativeElement;
                        /** @type {?} */
                        var dir = this._getLayoutDirection();
                        if (dir == 'ltr') {
                            containerEl.scrollLeft = 0;
                        }
                        else {
                            containerEl.scrollLeft = containerEl.scrollWidth - containerEl.offsetWidth;
                        }
                    }
                };
                /**
                 * The layout direction of the containing app.
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype._getLayoutDirection = function () {
                    return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
                };
                /**
                 * Performs the CSS transformation on the tab list that will cause the list to scroll.
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype._updateTabScrollPosition = function () {
                    /** @type {?} */
                    var scrollDistance = this.scrollDistance;
                    /** @type {?} */
                    var platform = this._platform;
                    /** @type {?} */
                    var translateX = this._getLayoutDirection() === 'ltr' ? -scrollDistance : scrollDistance;
                    // Don't use `translate3d` here because we don't want to create a new layer. A new layer
                    // seems to cause flickering and overflow in Internet Explorer. For example, the ink bar
                    // and ripples will exceed the boundaries of the visible tab bar.
                    // See: https://github.com/angular/components/issues/10276
                    // We round the `transform` here, because transforms with sub-pixel precision cause some
                    // browsers to blur the content of the element.
                    this._tabList.nativeElement.style.transform = "translateX(" + Math.round(translateX) + "px)";
                    // Setting the `transform` on IE will change the scroll offset of the parent, causing the
                    // position to be thrown off in some cases. We have to reset it ourselves to ensure that
                    // it doesn't get thrown off. Note that we scope it only to IE and Edge, because messing
                    // with the scroll position throws off Chrome 71+ in RTL mode (see #14689).
                    // @breaking-change 9.0.0 Remove null check for `platform` after it can no longer be undefined.
                    if (platform && (platform.TRIDENT || platform.EDGE)) {
                        this._tabListContainer.nativeElement.scrollLeft = 0;
                    }
                };
                Object.defineProperty(MatPaginatedTabHeader.prototype, "scrollDistance", {
                    /**
                     * Sets the distance in pixels that the tab header should be transformed in the X-axis.
                     * @return {?}
                     */
                    get: function () { return this._scrollDistance; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._scrollTo(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or
                 * the end of the list, respectively). The distance to scroll is computed to be a third of the
                 * length of the tab list view window.
                 *
                 * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
                 * should be called sparingly.
                 * @param {?} direction
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype._scrollHeader = function (direction) {
                    /** @type {?} */
                    var viewLength = this._tabListContainer.nativeElement.offsetWidth;
                    // Move the scroll distance one-third the length of the tab list's viewport.
                    /** @type {?} */
                    var scrollAmount = (direction == 'before' ? -1 : 1) * viewLength / 3;
                    return this._scrollTo(this._scrollDistance + scrollAmount);
                };
                /**
                 * Handles click events on the pagination arrows.
                 * @param {?} direction
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype._handlePaginatorClick = function (direction) {
                    this._stopInterval();
                    this._scrollHeader(direction);
                };
                /**
                 * Moves the tab list such that the desired tab label (marked by index) is moved into view.
                 *
                 * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
                 * should be called sparingly.
                 * @param {?} labelIndex
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype._scrollToLabel = function (labelIndex) {
                    /** @type {?} */
                    var selectedLabel = this._items ? this._items.toArray()[labelIndex] : null;
                    if (!selectedLabel) {
                        return;
                    }
                    // The view length is the visible width of the tab labels.
                    /** @type {?} */
                    var viewLength = this._tabListContainer.nativeElement.offsetWidth;
                    var _a = selectedLabel.elementRef.nativeElement, offsetLeft = _a.offsetLeft, offsetWidth = _a.offsetWidth;
                    /** @type {?} */
                    var labelBeforePos;
                    /** @type {?} */
                    var labelAfterPos;
                    if (this._getLayoutDirection() == 'ltr') {
                        labelBeforePos = offsetLeft;
                        labelAfterPos = labelBeforePos + offsetWidth;
                    }
                    else {
                        labelAfterPos = this._tabList.nativeElement.offsetWidth - offsetLeft;
                        labelBeforePos = labelAfterPos - offsetWidth;
                    }
                    /** @type {?} */
                    var beforeVisiblePos = this.scrollDistance;
                    /** @type {?} */
                    var afterVisiblePos = this.scrollDistance + viewLength;
                    if (labelBeforePos < beforeVisiblePos) {
                        // Scroll header to move label to the before direction
                        this.scrollDistance -= beforeVisiblePos - labelBeforePos + EXAGGERATED_OVERSCROLL;
                    }
                    else if (labelAfterPos > afterVisiblePos) {
                        // Scroll header to move label to the after direction
                        this.scrollDistance += labelAfterPos - afterVisiblePos + EXAGGERATED_OVERSCROLL;
                    }
                };
                /**
                 * Evaluate whether the pagination controls should be displayed. If the scroll width of the
                 * tab list is wider than the size of the header container, then the pagination controls should
                 * be shown.
                 *
                 * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
                 * should be called sparingly.
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype._checkPaginationEnabled = function () {
                    /** @type {?} */
                    var isEnabled = this._tabList.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth;
                    if (!isEnabled) {
                        this.scrollDistance = 0;
                    }
                    if (isEnabled !== this._showPaginationControls) {
                        this._changeDetectorRef.markForCheck();
                    }
                    this._showPaginationControls = isEnabled;
                };
                /**
                 * Evaluate whether the before and after controls should be enabled or disabled.
                 * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the
                 * before button. If the header is at the end of the list (scroll distance is equal to the
                 * maximum distance we can scroll), then disable the after button.
                 *
                 * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
                 * should be called sparingly.
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype._checkScrollingControls = function () {
                    // Check if the pagination arrows should be activated.
                    this._disableScrollBefore = this.scrollDistance == 0;
                    this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance();
                    this._changeDetectorRef.markForCheck();
                };
                /**
                 * Determines what is the maximum length in pixels that can be set for the scroll distance. This
                 * is equal to the difference in width between the tab list container and tab header container.
                 *
                 * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
                 * should be called sparingly.
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype._getMaxScrollDistance = function () {
                    /** @type {?} */
                    var lengthOfTabList = this._tabList.nativeElement.scrollWidth;
                    /** @type {?} */
                    var viewLength = this._tabListContainer.nativeElement.offsetWidth;
                    return (lengthOfTabList - viewLength) || 0;
                };
                /**
                 * Tells the ink-bar to align itself to the current label wrapper
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype._alignInkBarToSelectedTab = function () {
                    /** @type {?} */
                    var selectedItem = this._items && this._items.length ?
                        this._items.toArray()[this.selectedIndex] : null;
                    /** @type {?} */
                    var selectedLabelWrapper = selectedItem ? selectedItem.elementRef.nativeElement : null;
                    if (selectedLabelWrapper) {
                        this._inkBar.alignToElement(selectedLabelWrapper);
                    }
                    else {
                        this._inkBar.hide();
                    }
                };
                /**
                 * Stops the currently-running paginator interval.
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype._stopInterval = function () {
                    this._stopScrolling.next();
                };
                /**
                 * Handles the user pressing down on one of the paginators.
                 * Starts scrolling the header after a certain amount of time.
                 * @param {?} direction In which direction the paginator should be scrolled.
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype._handlePaginatorPress = function (direction) {
                    var _this_1 = this;
                    // Avoid overlapping timers.
                    this._stopInterval();
                    // Start a timer after the delay and keep firing based on the interval.
                    Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["timer"])(HEADER_SCROLL_DELAY, HEADER_SCROLL_INTERVAL)
                        // Keep the timer going until something tells it to stop or the component is destroyed.
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["takeUntil"])(Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["merge"])(this._stopScrolling, this._destroyed)))
                        .subscribe(( /**
                 * @return {?}
                 */function () {
                        var _a = _this_1._scrollHeader(direction), maxScrollDistance = _a.maxScrollDistance, distance = _a.distance;
                        // Stop the timer if we've reached the start or the end.
                        if (distance === 0 || distance >= maxScrollDistance) {
                            _this_1._stopInterval();
                        }
                    }));
                };
                /**
                 * Scrolls the header to a given position.
                 * @private
                 * @param {?} position Position to which to scroll.
                 * @return {?} Information on the current scroll distance and the maximum.
                 */
                MatPaginatedTabHeader.prototype._scrollTo = function (position) {
                    /** @type {?} */
                    var maxScrollDistance = this._getMaxScrollDistance();
                    this._scrollDistance = Math.max(0, Math.min(maxScrollDistance, position));
                    // Mark that the scroll distance has changed so that after the view is checked, the CSS
                    // transformation can move the header.
                    this._scrollDistanceChanged = true;
                    this._checkScrollingControls();
                    return { maxScrollDistance: maxScrollDistance, distance: this._scrollDistance };
                };
                return MatPaginatedTabHeader;
            }());
            MatPaginatedTabHeader.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            // TODO(crisbeto): this selector can be removed when we update to Angular 9.0.
                            selector: 'do-not-use-abstract-mat-paginated-tab-header'
                        },] },
            ];
            /** @nocollapse */
            MatPaginatedTabHeader.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_9__["ViewportRuler"] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] },
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_12__["Platform"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_1__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Base class with all of the `MatTabHeader` functionality.
             * \@docs-private
             * @abstract
             */
            // tslint:disable-next-line:class-name
            var _MatTabHeaderBase = /** @class */ (function (_super) {
                __extends(_MatTabHeaderBase, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} changeDetectorRef
                 * @param {?} viewportRuler
                 * @param {?} dir
                 * @param {?} ngZone
                 * @param {?} platform
                 * @param {?=} animationMode
                 */
                function _MatTabHeaderBase(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, 
                // @breaking-change 9.0.0 `_animationMode` parameter to be made required.
                animationMode) {
                    var _this_1 = _super.call(this, elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode) || this;
                    _this_1._disableRipple = false;
                    return _this_1;
                }
                Object.defineProperty(_MatTabHeaderBase.prototype, "disableRipple", {
                    /**
                     * Whether the ripple effect is disabled or not.
                     * @return {?}
                     */
                    get: function () { return this._disableRipple; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._disableRipple = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @protected
                 * @param {?} event
                 * @return {?}
                 */
                _MatTabHeaderBase.prototype._itemSelected = function (event) {
                    event.preventDefault();
                };
                return _MatTabHeaderBase;
            }(MatPaginatedTabHeader));
            _MatTabHeaderBase.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            // TODO(crisbeto): this selector can be removed when we update to Angular 9.0.
                            selector: 'do-not-use-abstract-mat-tab-header-base'
                        },] },
            ];
            /** @nocollapse */
            _MatTabHeaderBase.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_9__["ViewportRuler"] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] },
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_12__["Platform"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_1__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            _MatTabHeaderBase.propDecorators = {
                disableRipple: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * The header of the tab group which displays a list of all the tabs in the tab group. Includes
             * an ink bar that follows the currently selected tab. When the tabs list's width exceeds the
             * width of the header container, then arrows will be displayed to allow the user to scroll
             * left and right across the header.
             * \@docs-private
             */
            var MatTabHeader = /** @class */ (function (_super) {
                __extends(MatTabHeader, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} changeDetectorRef
                 * @param {?} viewportRuler
                 * @param {?} dir
                 * @param {?} ngZone
                 * @param {?} platform
                 * @param {?=} animationMode
                 */
                function MatTabHeader(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, 
                // @breaking-change 9.0.0 `_animationMode` parameter to be made required.
                animationMode) {
                    return _super.call(this, elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode) || this;
                }
                return MatTabHeader;
            }(_MatTabHeaderBase));
            MatTabHeader.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-tab-header',
                            template: "<div class=\"mat-tab-header-pagination mat-tab-header-pagination-before mat-elevation-z4\" #previousPaginator aria-hidden=\"true\" mat-ripple [matRippleDisabled]=\"_disableScrollBefore || disableRipple\" [class.mat-tab-header-pagination-disabled]=\"_disableScrollBefore\" (click)=\"_handlePaginatorClick('before')\" (mousedown)=\"_handlePaginatorPress('before')\" (touchend)=\"_stopInterval()\"><div class=\"mat-tab-header-pagination-chevron\"></div></div><div class=\"mat-tab-label-container\" #tabListContainer (keydown)=\"_handleKeydown($event)\"><div #tabList class=\"mat-tab-list\" [class._mat-animation-noopable]=\"_animationMode === 'NoopAnimations'\" role=\"tablist\" (cdkObserveContent)=\"_onContentChanges()\"><div class=\"mat-tab-labels\"><ng-content></ng-content></div><mat-ink-bar></mat-ink-bar></div></div><div class=\"mat-tab-header-pagination mat-tab-header-pagination-after mat-elevation-z4\" #nextPaginator aria-hidden=\"true\" mat-ripple [matRippleDisabled]=\"_disableScrollAfter || disableRipple\" [class.mat-tab-header-pagination-disabled]=\"_disableScrollAfter\" (mousedown)=\"_handlePaginatorPress('after')\" (click)=\"_handlePaginatorClick('after')\" (touchend)=\"_stopInterval()\"><div class=\"mat-tab-header-pagination-chevron\"></div></div>",
                            styles: [".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-header-pagination{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-pagination-after,.mat-tab-header-rtl .mat-tab-header-pagination-before{padding-right:4px}.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:'';height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-list{flex-grow:1;position:relative;transition:transform .5s cubic-bezier(.35,0,.25,1)}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:.5s cubic-bezier(.35,0,.25,1)}._mat-animation-noopable.mat-ink-bar{transition:none;animation:none}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}@media (-ms-high-contrast:active){.mat-ink-bar{outline:solid 2px;height:0}}.mat-tab-labels{display:flex}[mat-align-tabs=center] .mat-tab-labels{justify-content:center}[mat-align-tabs=end] .mat-tab-labels{justify-content:flex-end}.mat-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}._mat-animation-noopable.mat-tab-list{transition:none;animation:none}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:0}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}@media (-ms-high-contrast:active){.mat-tab-label:focus{outline:dotted 2px}}.mat-tab-label.mat-tab-disabled{cursor:default}@media (-ms-high-contrast:active){.mat-tab-label.mat-tab-disabled{opacity:.5}}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media (-ms-high-contrast:active){.mat-tab-label{opacity:1}}@media (max-width:599px){.mat-tab-label{min-width:72px}}"],
                            inputs: ['selectedIndex'],
                            outputs: ['selectFocusedIndex', 'indexFocused'],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            host: {
                                'class': 'mat-tab-header',
                                '[class.mat-tab-header-pagination-controls-enabled]': '_showPaginationControls',
                                '[class.mat-tab-header-rtl]': "_getLayoutDirection() == 'rtl'",
                            },
                        },] },
            ];
            /** @nocollapse */
            MatTabHeader.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_9__["ViewportRuler"] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] },
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_12__["Platform"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_1__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            MatTabHeader.propDecorators = {
                _items: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChildren"], args: [MatTabLabelWrapper,] }],
                _inkBar: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [MatInkBar, { static: true },] }],
                _tabListContainer: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['tabListContainer', { static: true },] }],
                _tabList: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['tabList', { static: true },] }],
                _nextPaginator: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['nextPaginator', { static: false },] }],
                _previousPaginator: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['previousPaginator', { static: false },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Base class with all of the `MatTabNav` functionality.
             * \@docs-private
             * @abstract
             */
            // tslint:disable-next-line:class-name
            var _MatTabNavBase = /** @class */ (function (_super) {
                __extends(_MatTabNavBase, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} dir
                 * @param {?} ngZone
                 * @param {?} changeDetectorRef
                 * @param {?} viewportRuler
                 * @param {?=} platform
                 * @param {?=} animationMode
                 */
                function _MatTabNavBase(elementRef, dir, ngZone, changeDetectorRef, viewportRuler, 
                /**
                 * @deprecated @breaking-change 9.0.0 `platform` parameter to become required.
                 */
                platform, animationMode) {
                    var _this_1 = _super.call(this, elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode) || this;
                    _this_1._disableRipple = false;
                    /**
                     * Theme color of the nav bar.
                     */
                    _this_1.color = 'primary';
                    return _this_1;
                }
                Object.defineProperty(_MatTabNavBase.prototype, "backgroundColor", {
                    /**
                     * Background color of the tab nav.
                     * @return {?}
                     */
                    get: function () { return this._backgroundColor; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var classList = this._elementRef.nativeElement.classList;
                        classList.remove("mat-background-" + this.backgroundColor);
                        if (value) {
                            classList.add("mat-background-" + value);
                        }
                        this._backgroundColor = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(_MatTabNavBase.prototype, "disableRipple", {
                    /**
                     * Whether the ripple effect is disabled or not.
                     * @return {?}
                     */
                    get: function () { return this._disableRipple; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._disableRipple = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @protected
                 * @return {?}
                 */
                _MatTabNavBase.prototype._itemSelected = function () {
                    // noop
                };
                /**
                 * @return {?}
                 */
                _MatTabNavBase.prototype.ngAfterContentInit = function () {
                    var _this_1 = this;
                    // We need this to run before the `changes` subscription in parent to ensure that the
                    // selectedIndex is up-to-date by the time the super class starts looking for it.
                    this._items.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["startWith"])(null), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["takeUntil"])(this._destroyed)).subscribe(( /**
                     * @return {?}
                     */function () {
                        _this_1.updateActiveLink();
                    }));
                    _super.prototype.ngAfterContentInit.call(this);
                };
                /**
                 * Notifies the component that the active link has been changed.
                 * \@breaking-change 8.0.0 `element` parameter to be removed.
                 * @param {?=} _element
                 * @return {?}
                 */
                _MatTabNavBase.prototype.updateActiveLink = function (_element) {
                    if (!this._items) {
                        return;
                    }
                    /** @type {?} */
                    var items = this._items.toArray();
                    for (var i = 0; i < items.length; i++) {
                        if (items[i].active) {
                            this.selectedIndex = i;
                            this._changeDetectorRef.markForCheck();
                            return;
                        }
                    }
                    // The ink bar should hide itself if no items are active.
                    this.selectedIndex = -1;
                    this._inkBar.hide();
                };
                return _MatTabNavBase;
            }(MatPaginatedTabHeader));
            _MatTabNavBase.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            // TODO(crisbeto): this selector can be removed when we update to Angular 9.0.
                            selector: 'do-not-use-abstract-mat-tab-nav-base'
                        },] },
            ];
            /** @nocollapse */
            _MatTabNavBase.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_9__["ViewportRuler"] },
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_12__["Platform"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_1__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            _MatTabNavBase.propDecorators = {
                backgroundColor: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                disableRipple: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                color: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * Navigation component matching the styles of the tab group header.
             * Provides anchored navigation with animated ink bar.
             */
            var MatTabNav = /** @class */ (function (_super) {
                __extends(MatTabNav, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} dir
                 * @param {?} ngZone
                 * @param {?} changeDetectorRef
                 * @param {?} viewportRuler
                 * @param {?=} platform
                 * @param {?=} animationMode
                 */
                function MatTabNav(elementRef, dir, ngZone, changeDetectorRef, viewportRuler, 
                /**
                 * @deprecated @breaking-change 9.0.0 `platform` parameter to become required.
                 */
                platform, animationMode) {
                    return _super.call(this, elementRef, dir, ngZone, changeDetectorRef, viewportRuler, platform, animationMode) || this;
                }
                return MatTabNav;
            }(_MatTabNavBase));
            MatTabNav.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: '[mat-tab-nav-bar]',
                            exportAs: 'matTabNavBar, matTabNav',
                            inputs: ['color'],
                            template: "<div class=\"mat-tab-header-pagination mat-tab-header-pagination-before mat-elevation-z4\" #previousPaginator aria-hidden=\"true\" mat-ripple [matRippleDisabled]=\"_disableScrollBefore || disableRipple\" [class.mat-tab-header-pagination-disabled]=\"_disableScrollBefore\" (click)=\"_handlePaginatorClick('before')\" (mousedown)=\"_handlePaginatorPress('before')\" (touchend)=\"_stopInterval()\"><div class=\"mat-tab-header-pagination-chevron\"></div></div><div class=\"mat-tab-link-container\" #tabListContainer (keydown)=\"_handleKeydown($event)\"><div class=\"mat-tab-list\" #tabList (cdkObserveContent)=\"_onContentChanges()\"><div class=\"mat-tab-links\"><ng-content></ng-content></div><mat-ink-bar></mat-ink-bar></div></div><div class=\"mat-tab-header-pagination mat-tab-header-pagination-after mat-elevation-z4\" #nextPaginator aria-hidden=\"true\" mat-ripple [matRippleDisabled]=\"_disableScrollAfter || disableRipple\" [class.mat-tab-header-pagination-disabled]=\"_disableScrollAfter\" (mousedown)=\"_handlePaginatorPress('after')\" (click)=\"_handlePaginatorClick('after')\" (touchend)=\"_stopInterval()\"><div class=\"mat-tab-header-pagination-chevron\"></div></div>",
                            styles: [".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-header-pagination{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-pagination-after,.mat-tab-header-rtl .mat-tab-header-pagination-before{padding-right:4px}.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:'';height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-list{flex-grow:1;position:relative;transition:transform .5s cubic-bezier(.35,0,.25,1)}.mat-tab-links{display:flex}[mat-align-tabs=center] .mat-tab-links{justify-content:center}[mat-align-tabs=end] .mat-tab-links{justify-content:flex-end}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:.5s cubic-bezier(.35,0,.25,1)}._mat-animation-noopable.mat-ink-bar{transition:none;animation:none}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}@media (-ms-high-contrast:active){.mat-ink-bar{outline:solid 2px;height:0}}.mat-tab-link-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}.mat-tab-link{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;vertical-align:top;text-decoration:none;position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent}.mat-tab-link:focus{outline:0}.mat-tab-link:focus:not(.mat-tab-disabled){opacity:1}@media (-ms-high-contrast:active){.mat-tab-link:focus{outline:dotted 2px}}.mat-tab-link.mat-tab-disabled{cursor:default}@media (-ms-high-contrast:active){.mat-tab-link.mat-tab-disabled{opacity:.5}}.mat-tab-link .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media (-ms-high-contrast:active){.mat-tab-link{opacity:1}}[mat-stretch-tabs] .mat-tab-link{flex-basis:0;flex-grow:1}.mat-tab-link.mat-tab-disabled{pointer-events:none}@media (max-width:599px){.mat-tab-link{min-width:72px}}"],
                            host: {
                                'class': 'mat-tab-nav-bar mat-tab-header',
                                '[class.mat-tab-header-pagination-controls-enabled]': '_showPaginationControls',
                                '[class.mat-tab-header-rtl]': "_getLayoutDirection() == 'rtl'",
                                '[class.mat-primary]': 'color !== "warn" && color !== "accent"',
                                '[class.mat-accent]': 'color === "accent"',
                                '[class.mat-warn]': 'color === "warn"',
                            },
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatTabNav.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_9__["ViewportRuler"] },
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_12__["Platform"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_1__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            MatTabNav.propDecorators = {
                _items: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChildren"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                                         * @return {?}
                                         */function () { return MatTabLink; })), { descendants: true },] }],
                _inkBar: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [MatInkBar, { static: true },] }],
                _tabListContainer: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['tabListContainer', { static: true },] }],
                _tabList: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['tabList', { static: true },] }],
                _nextPaginator: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['nextPaginator', { static: false },] }],
                _previousPaginator: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['previousPaginator', { static: false },] }]
            };
            // Boilerplate for applying mixins to MatTabLink.
            var MatTabLinkMixinBase = /** @class */ (function () {
                function MatTabLinkMixinBase() {
                }
                return MatTabLinkMixinBase;
            }());
            /** @type {?} */
            var _MatTabLinkMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["mixinTabIndex"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["mixinDisableRipple"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["mixinDisabled"])(MatTabLinkMixinBase)));
            /**
             * Base class with all of the `MatTabLink` functionality.
             */
            // tslint:disable-next-line:class-name
            var _MatTabLinkBase = /** @class */ (function (_super) {
                __extends(_MatTabLinkBase, _super);
                /**
                 * @param {?} _tabNavBar
                 * @param {?} elementRef
                 * @param {?} globalRippleOptions
                 * @param {?} tabIndex
                 * @param {?} _focusMonitor
                 * @param {?=} animationMode
                 */
                function _MatTabLinkBase(_tabNavBar, elementRef, globalRippleOptions, tabIndex, _focusMonitor, animationMode) {
                    var _this_1 = _super.call(this) || this;
                    _this_1._tabNavBar = _tabNavBar;
                    _this_1.elementRef = elementRef;
                    _this_1._focusMonitor = _focusMonitor;
                    /**
                     * Whether the tab link is active or not.
                     */
                    _this_1._isActive = false;
                    _this_1.rippleConfig = globalRippleOptions || {};
                    _this_1.tabIndex = parseInt(tabIndex) || 0;
                    if (animationMode === 'NoopAnimations') {
                        _this_1.rippleConfig.animation = { enterDuration: 0, exitDuration: 0 };
                    }
                    _focusMonitor.monitor(elementRef);
                    return _this_1;
                }
                Object.defineProperty(_MatTabLinkBase.prototype, "active", {
                    /**
                     * Whether the link is active.
                     * @return {?}
                     */
                    get: function () { return this._isActive; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (value !== this._isActive) {
                            this._isActive = value;
                            this._tabNavBar.updateActiveLink(this.elementRef);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(_MatTabLinkBase.prototype, "rippleDisabled", {
                    /**
                     * Whether ripples are disabled on interaction.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () {
                        return this.disabled || this.disableRipple || this._tabNavBar.disableRipple ||
                            !!this.rippleConfig.disabled;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                _MatTabLinkBase.prototype.focus = function () {
                    this.elementRef.nativeElement.focus();
                };
                /**
                 * @return {?}
                 */
                _MatTabLinkBase.prototype.ngOnDestroy = function () {
                    this._focusMonitor.stopMonitoring(this.elementRef);
                };
                return _MatTabLinkBase;
            }(_MatTabLinkMixinBase));
            _MatTabLinkBase.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            // TODO(crisbeto): this selector can be removed when we update to Angular 9.0.
                            selector: 'do-not-use-abstract-mat-tab-link-base'
                        },] },
            ];
            /** @nocollapse */
            _MatTabLinkBase.ctorParameters = function () { return [
                { type: _MatTabNavBase },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MAT_RIPPLE_GLOBAL_OPTIONS"],] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Attribute"], args: ['tabindex',] }] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_10__["FocusMonitor"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_1__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            _MatTabLinkBase.propDecorators = {
                active: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * Link inside of a `mat-tab-nav-bar`.
             */
            var MatTabLink = /** @class */ (function (_super) {
                __extends(MatTabLink, _super);
                /**
                 * @param {?} tabNavBar
                 * @param {?} elementRef
                 * @param {?} ngZone
                 * @param {?} platform
                 * @param {?} globalRippleOptions
                 * @param {?} tabIndex
                 * @param {?} focusMonitor
                 * @param {?=} animationMode
                 */
                function MatTabLink(tabNavBar, elementRef, ngZone, platform, globalRippleOptions, tabIndex, focusMonitor, animationMode) {
                    var _this_1 = _super.call(this, tabNavBar, elementRef, globalRippleOptions, tabIndex, focusMonitor, animationMode) || this;
                    _this_1._tabLinkRipple = new _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["RippleRenderer"](_this_1, ngZone, elementRef, platform);
                    _this_1._tabLinkRipple.setupTriggerEvents(elementRef.nativeElement);
                    return _this_1;
                }
                /**
                 * @return {?}
                 */
                MatTabLink.prototype.ngOnDestroy = function () {
                    _super.prototype.ngOnDestroy.call(this);
                    this._tabLinkRipple._removeTriggerEvents();
                };
                return MatTabLink;
            }(_MatTabLinkBase));
            MatTabLink.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[mat-tab-link], [matTabLink]',
                            exportAs: 'matTabLink',
                            inputs: ['disabled', 'disableRipple', 'tabIndex'],
                            host: {
                                'class': 'mat-tab-link',
                                '[attr.aria-current]': 'active ? "page" : null',
                                '[attr.aria-disabled]': 'disabled',
                                '[attr.tabIndex]': 'tabIndex',
                                '[class.mat-tab-disabled]': 'disabled',
                                '[class.mat-tab-label-active]': 'active',
                            }
                        },] },
            ];
            /** @nocollapse */
            MatTabLink.ctorParameters = function () { return [
                { type: MatTabNav },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] },
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_12__["Platform"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MAT_RIPPLE_GLOBAL_OPTIONS"],] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Attribute"], args: ['tabindex',] }] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_10__["FocusMonitor"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_1__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatTabsModule = /** @class */ (function () {
                function MatTabsModule() {
                }
                return MatTabsModule;
            }());
            MatTabsModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [
                                _angular_common__WEBPACK_IMPORTED_MODULE_14__["CommonModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatCommonModule"],
                                _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_2__["PortalModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatRippleModule"],
                                _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_13__["ObserversModule"],
                                _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_10__["A11yModule"],
                            ],
                            // Don't export all components because some are only to be used internally.
                            exports: [
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatCommonModule"],
                                MatTabGroup,
                                MatTabLabel,
                                MatTab,
                                MatTabNav,
                                MatTabLink,
                                MatTabContent,
                            ],
                            declarations: [
                                MatTabGroup,
                                MatTabLabel,
                                MatTab,
                                MatInkBar,
                                MatTabLabelWrapper,
                                MatTabNav,
                                MatTabLink,
                                MatTabBody,
                                MatTabBodyPortal,
                                MatTabHeader,
                                MatTabContent,
                                ( /** @type {?} */(
                                // TODO(crisbeto): these can be removed once they're turned into selector-less directives.
                                MatPaginatedTabHeader)),
                                ( /** @type {?} */(_MatTabGroupBase)),
                                ( /** @type {?} */(_MatTabNavBase)),
                                ( /** @type {?} */(_MatTabBodyBase)),
                                ( /** @type {?} */(_MatTabHeaderBase)),
                                ( /** @type {?} */(_MatTabLinkBase)),
                            ],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=tabs.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/tooltip.js": 
        /*!***********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/tooltip.js ***!
          \***********************************************************/
        /*! exports provided: MatTooltipModule, getMatTooltipInvalidPositionError, MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY, MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY, SCROLL_THROTTLE_MS, TOOLTIP_PANEL_CLASS, MAT_TOOLTIP_SCROLL_STRATEGY, MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER, MAT_TOOLTIP_DEFAULT_OPTIONS, MatTooltip, TooltipComponent, matTooltipAnimations */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTooltipModule", function () { return MatTooltipModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMatTooltipInvalidPositionError", function () { return getMatTooltipInvalidPositionError; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY", function () { return MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY", function () { return MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SCROLL_THROTTLE_MS", function () { return SCROLL_THROTTLE_MS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOOLTIP_PANEL_CLASS", function () { return TOOLTIP_PANEL_CLASS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_TOOLTIP_SCROLL_STRATEGY", function () { return MAT_TOOLTIP_SCROLL_STRATEGY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER", function () { return MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_TOOLTIP_DEFAULT_OPTIONS", function () { return MAT_TOOLTIP_DEFAULT_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTooltip", function () { return MatTooltip; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TooltipComponent", function () { return TooltipComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matTooltipAnimations", function () { return matTooltipAnimations; });
            /* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/animations */ "./node_modules/@angular/animations/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /* harmony import */ var _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/layout */ "./node_modules/@angular/cdk/esm2015/layout.js");
            /* harmony import */ var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/overlay */ "./node_modules/@angular/cdk/esm2015/overlay.js");
            /* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/cdk/platform */ "./node_modules/@angular/cdk/esm2015/platform.js");
            /* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/cdk/portal */ "./node_modules/@angular/cdk/esm2015/portal.js");
            /* harmony import */ var _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/cdk/scrolling */ "./node_modules/@angular/cdk/esm2015/scrolling.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/platform-browser */ "./node_modules/@angular/platform-browser/fesm2015/platform-browser.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Animations used by MatTooltip.
             * \@docs-private
             * @type {?}
             */
            var matTooltipAnimations = {
                /**
                 * Animation that transitions a tooltip in and out.
                 */
                tooltipState: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["trigger"])('state', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["state"])('initial, void, hidden', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ opacity: 0, transform: 'scale(0)' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["state"])('visible', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ transform: 'scale(1)' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('* => visible', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])('200ms cubic-bezier(0, 0, 0.2, 1)', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["keyframes"])([
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ opacity: 0, transform: 'scale(0)', offset: 0 }),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ opacity: 0.5, transform: 'scale(0.99)', offset: 0.5 }),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ opacity: 1, transform: 'scale(1)', offset: 1 })
                    ]))),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('* => hidden', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])('100ms cubic-bezier(0, 0, 0.2, 1)', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ opacity: 0 }))),
                ])
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Time in ms to throttle repositioning after scroll events.
             * @type {?}
             */
            var SCROLL_THROTTLE_MS = 20;
            /**
             * CSS class that will be attached to the overlay panel.
             * @type {?}
             */
            var TOOLTIP_PANEL_CLASS = 'mat-tooltip-panel';
            /**
             * Creates an error to be thrown if the user supplied an invalid tooltip position.
             * \@docs-private
             * @param {?} position
             * @return {?}
             */
            function getMatTooltipInvalidPositionError(position) {
                return Error("Tooltip position \"" + position + "\" is invalid.");
            }
            /**
             * Injection token that determines the scroll handling while a tooltip is visible.
             * @type {?}
             */
            var MAT_TOOLTIP_SCROLL_STRATEGY = new _angular_core__WEBPACK_IMPORTED_MODULE_10__["InjectionToken"]('mat-tooltip-scroll-strategy');
            /**
             * \@docs-private
             * @param {?} overlay
             * @return {?}
             */
            function MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY(overlay) {
                return ( /**
                 * @return {?}
                 */function () { return overlay.scrollStrategies.reposition({ scrollThrottle: SCROLL_THROTTLE_MS }); });
            }
            /**
             * \@docs-private
             * @type {?}
             */
            var MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER = {
                provide: MAT_TOOLTIP_SCROLL_STRATEGY,
                deps: [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["Overlay"]],
                useFactory: MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY,
            };
            /**
             * Injection token to be used to override the default options for `matTooltip`.
             * @type {?}
             */
            var MAT_TOOLTIP_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_10__["InjectionToken"]('mat-tooltip-default-options', {
                providedIn: 'root',
                factory: MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY
            });
            /**
             * \@docs-private
             * @return {?}
             */
            function MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY() {
                return {
                    showDelay: 0,
                    hideDelay: 0,
                    touchendHideDelay: 1500,
                };
            }
            /**
             * Directive that attaches a material design tooltip to the host element. Animates the showing and
             * hiding of a tooltip provided position (defaults to below the element).
             *
             * https://material.io/design/components/tooltips.html
             */
            var MatTooltip = /** @class */ (function () {
                /**
                 * @param {?} _overlay
                 * @param {?} _elementRef
                 * @param {?} _scrollDispatcher
                 * @param {?} _viewContainerRef
                 * @param {?} _ngZone
                 * @param {?} platform
                 * @param {?} _ariaDescriber
                 * @param {?} _focusMonitor
                 * @param {?} scrollStrategy
                 * @param {?} _dir
                 * @param {?} _defaultOptions
                 * @param {?=} hammerLoader
                 */
                function MatTooltip(_overlay, _elementRef, _scrollDispatcher, _viewContainerRef, _ngZone, platform, _ariaDescriber, _focusMonitor, scrollStrategy, _dir, _defaultOptions, hammerLoader) {
                    var _this_1 = this;
                    this._overlay = _overlay;
                    this._elementRef = _elementRef;
                    this._scrollDispatcher = _scrollDispatcher;
                    this._viewContainerRef = _viewContainerRef;
                    this._ngZone = _ngZone;
                    this._ariaDescriber = _ariaDescriber;
                    this._focusMonitor = _focusMonitor;
                    this._dir = _dir;
                    this._defaultOptions = _defaultOptions;
                    this._position = 'below';
                    this._disabled = false;
                    /**
                     * The default delay in ms before showing the tooltip after show is called
                     */
                    this.showDelay = this._defaultOptions.showDelay;
                    /**
                     * The default delay in ms before hiding the tooltip after hide is called
                     */
                    this.hideDelay = this._defaultOptions.hideDelay;
                    this._message = '';
                    this._manualListeners = new Map();
                    /**
                     * Emits when the component is destroyed.
                     */
                    this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_12__["Subject"]();
                    this._scrollStrategy = scrollStrategy;
                    /** @type {?} */
                    var element = _elementRef.nativeElement;
                    /** @type {?} */
                    var hasGestures = typeof window === 'undefined' || (( /** @type {?} */(window))).Hammer || hammerLoader;
                    // The mouse events shouldn't be bound on mobile devices, because they can prevent the
                    // first tap from firing its click event or can cause the tooltip to open for clicks.
                    if (!platform.IOS && !platform.ANDROID) {
                        this._manualListeners
                            .set('mouseenter', ( /**
                     * @return {?}
                     */function () { return _this_1.show(); }))
                            .set('mouseleave', ( /**
                     * @return {?}
                     */function () { return _this_1.hide(); }));
                    }
                    else if (!hasGestures) {
                        // If Hammerjs isn't loaded, fall back to showing on `touchstart`, otherwise
                        // there's no way for the user to trigger the tooltip on a touch device.
                        this._manualListeners.set('touchstart', ( /**
                         * @return {?}
                         */function () { return _this_1.show(); }));
                    }
                    this._manualListeners.forEach(( /**
                     * @param {?} listener
                     * @param {?} event
                     * @return {?}
                     */function (listener, event) { return element.addEventListener(event, listener); }));
                    _focusMonitor.monitor(_elementRef).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["takeUntil"])(this._destroyed)).subscribe(( /**
                     * @param {?} origin
                     * @return {?}
                     */function (/**
                     * @param {?} origin
                     * @return {?}
                     */ origin) {
                        // Note that the focus monitor runs outside the Angular zone.
                        if (!origin) {
                            _ngZone.run(( /**
                             * @return {?}
                             */function () { return _this_1.hide(0); }));
                        }
                        else if (origin === 'keyboard') {
                            _ngZone.run(( /**
                             * @return {?}
                             */function () { return _this_1.show(); }));
                        }
                    }));
                    if (_defaultOptions && _defaultOptions.position) {
                        this.position = _defaultOptions.position;
                    }
                }
                Object.defineProperty(MatTooltip.prototype, "position", {
                    /**
                     * Allows the user to define the position of the tooltip relative to the parent element
                     * @return {?}
                     */
                    get: function () { return this._position; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (value !== this._position) {
                            this._position = value;
                            if (this._overlayRef) {
                                this._updatePosition();
                                if (this._tooltipInstance) {
                                    ( /** @type {?} */(this._tooltipInstance)).show(0);
                                }
                                this._overlayRef.updatePosition();
                            }
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatTooltip.prototype, "disabled", {
                    /**
                     * Disables the display of the tooltip.
                     * @return {?}
                     */
                    get: function () { return this._disabled; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);
                        // If tooltip is disabled, hide immediately.
                        if (this._disabled) {
                            this.hide(0);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatTooltip.prototype, "message", {
                    /**
                     * The message to be displayed in the tooltip
                     * @return {?}
                     */
                    get: function () { return this._message; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        var _this_1 = this;
                        this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this._message);
                        // If the message is not a string (e.g. number), convert it to a string and trim it.
                        this._message = value != null ? ("" + value).trim() : '';
                        if (!this._message && this._isTooltipVisible()) {
                            this.hide(0);
                        }
                        else {
                            this._updateTooltipMessage();
                            this._ngZone.runOutsideAngular(( /**
                             * @return {?}
                             */function () {
                                // The `AriaDescriber` has some functionality that avoids adding a description if it's the
                                // same as the `aria-label` of an element, however we can't know whether the tooltip trigger
                                // has a data-bound `aria-label` or when it'll be set for the first time. We can avoid the
                                // issue by deferring the description by a tick so Angular has time to set the `aria-label`.
                                Promise.resolve().then(( /**
                                 * @return {?}
                                 */function () {
                                    _this_1._ariaDescriber.describe(_this_1._elementRef.nativeElement, _this_1.message);
                                }));
                            }));
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatTooltip.prototype, "tooltipClass", {
                    /**
                     * Classes to be passed to the tooltip. Supports the same syntax as `ngClass`.
                     * @return {?}
                     */
                    get: function () { return this._tooltipClass; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._tooltipClass = value;
                        if (this._tooltipInstance) {
                            this._setTooltipClass(this._tooltipClass);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Setup styling-specific things
                 * @return {?}
                 */
                MatTooltip.prototype.ngOnInit = function () {
                    /** @type {?} */
                    var element = this._elementRef.nativeElement;
                    /** @type {?} */
                    var elementStyle = ( /** @type {?} */(element.style));
                    if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {
                        // When we bind a gesture event on an element (in this case `longpress`), HammerJS
                        // will add some inline styles by default, including `user-select: none`. This is
                        // problematic on iOS and in Safari, because it will prevent users from typing in inputs.
                        // Since `user-select: none` is not needed for the `longpress` event and can cause unexpected
                        // behavior for text fields, we always clear the `user-select` to avoid such issues.
                        elementStyle.webkitUserSelect = elementStyle.userSelect = elementStyle.msUserSelect = '';
                    }
                    // Hammer applies `-webkit-user-drag: none` on all elements by default,
                    // which breaks the native drag&drop. If the consumer explicitly made
                    // the element draggable, clear the `-webkit-user-drag`.
                    if (element.draggable && elementStyle.webkitUserDrag === 'none') {
                        elementStyle.webkitUserDrag = '';
                    }
                };
                /**
                 * Dispose the tooltip when destroyed.
                 * @return {?}
                 */
                MatTooltip.prototype.ngOnDestroy = function () {
                    var _this_1 = this;
                    if (this._overlayRef) {
                        this._overlayRef.dispose();
                        this._tooltipInstance = null;
                    }
                    // Clean up the event listeners set in the constructor
                    this._manualListeners.forEach(( /**
                     * @param {?} listener
                     * @param {?} event
                     * @return {?}
                     */function (listener, event) {
                        _this_1._elementRef.nativeElement.removeEventListener(event, listener);
                    }));
                    this._manualListeners.clear();
                    this._destroyed.next();
                    this._destroyed.complete();
                    this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this.message);
                    this._focusMonitor.stopMonitoring(this._elementRef);
                };
                /**
                 * Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input
                 * @param {?=} delay
                 * @return {?}
                 */
                MatTooltip.prototype.show = function (delay) {
                    var _this_1 = this;
                    if (delay === void 0) { delay = this.showDelay; }
                    if (this.disabled || !this.message || (this._isTooltipVisible() &&
                        !( /** @type {?} */(this._tooltipInstance))._showTimeoutId && !( /** @type {?} */(this._tooltipInstance))._hideTimeoutId)) {
                        return;
                    }
                    /** @type {?} */
                    var overlayRef = this._createOverlay();
                    this._detach();
                    this._portal = this._portal || new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_8__["ComponentPortal"](TooltipComponent, this._viewContainerRef);
                    this._tooltipInstance = overlayRef.attach(this._portal).instance;
                    this._tooltipInstance.afterHidden()
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["takeUntil"])(this._destroyed))
                        .subscribe(( /**
                 * @return {?}
                 */function () { return _this_1._detach(); }));
                    this._setTooltipClass(this._tooltipClass);
                    this._updateTooltipMessage();
                    ( /** @type {?} */(this._tooltipInstance)).show(delay);
                };
                /**
                 * Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input
                 * @param {?=} delay
                 * @return {?}
                 */
                MatTooltip.prototype.hide = function (delay) {
                    if (delay === void 0) { delay = this.hideDelay; }
                    if (this._tooltipInstance) {
                        this._tooltipInstance.hide(delay);
                    }
                };
                /**
                 * Shows/hides the tooltip
                 * @return {?}
                 */
                MatTooltip.prototype.toggle = function () {
                    this._isTooltipVisible() ? this.hide() : this.show();
                };
                /**
                 * Returns true if the tooltip is currently visible to the user
                 * @return {?}
                 */
                MatTooltip.prototype._isTooltipVisible = function () {
                    return !!this._tooltipInstance && this._tooltipInstance.isVisible();
                };
                /**
                 * Handles the keydown events on the host element.
                 * @param {?} e
                 * @return {?}
                 */
                MatTooltip.prototype._handleKeydown = function (e) {
                    if (this._isTooltipVisible() && e.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__["ESCAPE"] && !Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__["hasModifierKey"])(e)) {
                        e.preventDefault();
                        e.stopPropagation();
                        this.hide(0);
                    }
                };
                /**
                 * Handles the touchend events on the host element.
                 * @return {?}
                 */
                MatTooltip.prototype._handleTouchend = function () {
                    this.hide(this._defaultOptions.touchendHideDelay);
                };
                /**
                 * Create the overlay config and position strategy
                 * @private
                 * @return {?}
                 */
                MatTooltip.prototype._createOverlay = function () {
                    var _this_1 = this;
                    if (this._overlayRef) {
                        return this._overlayRef;
                    }
                    /** @type {?} */
                    var scrollableAncestors = this._scrollDispatcher.getAncestorScrollContainers(this._elementRef);
                    // Create connected position strategy that listens for scroll events to reposition.
                    /** @type {?} */
                    var strategy = this._overlay.position()
                        .flexibleConnectedTo(this._elementRef)
                        .withTransformOriginOn('.mat-tooltip')
                        .withFlexibleDimensions(false)
                        .withViewportMargin(8)
                        .withScrollableContainers(scrollableAncestors);
                    strategy.positionChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["takeUntil"])(this._destroyed)).subscribe(( /**
                     * @param {?} change
                     * @return {?}
                     */function (/**
                     * @param {?} change
                     * @return {?}
                     */ change) {
                        if (_this_1._tooltipInstance) {
                            if (change.scrollableViewProperties.isOverlayClipped && _this_1._tooltipInstance.isVisible()) {
                                // After position changes occur and the overlay is clipped by
                                // a parent scrollable then close the tooltip.
                                _this_1._ngZone.run(( /**
                                 * @return {?}
                                 */function () { return _this_1.hide(0); }));
                            }
                        }
                    }));
                    this._overlayRef = this._overlay.create({
                        direction: this._dir,
                        positionStrategy: strategy,
                        panelClass: TOOLTIP_PANEL_CLASS,
                        scrollStrategy: this._scrollStrategy()
                    });
                    this._updatePosition();
                    this._overlayRef.detachments()
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["takeUntil"])(this._destroyed))
                        .subscribe(( /**
                 * @return {?}
                 */function () { return _this_1._detach(); }));
                    return this._overlayRef;
                };
                /**
                 * Detaches the currently-attached tooltip.
                 * @private
                 * @return {?}
                 */
                MatTooltip.prototype._detach = function () {
                    if (this._overlayRef && this._overlayRef.hasAttached()) {
                        this._overlayRef.detach();
                    }
                    this._tooltipInstance = null;
                };
                /**
                 * Updates the position of the current tooltip.
                 * @private
                 * @return {?}
                 */
                MatTooltip.prototype._updatePosition = function () {
                    /** @type {?} */
                    var position = ( /** @type {?} */(( /** @type {?} */(this._overlayRef)).getConfig().positionStrategy));
                    /** @type {?} */
                    var origin = this._getOrigin();
                    /** @type {?} */
                    var overlay = this._getOverlayPosition();
                    position.withPositions([
                        Object.assign({}, origin.main, overlay.main),
                        Object.assign({}, origin.fallback, overlay.fallback)
                    ]);
                };
                /**
                 * Returns the origin position and a fallback position based on the user's position preference.
                 * The fallback position is the inverse of the origin (e.g. `'below' -> 'above'`).
                 * @return {?}
                 */
                MatTooltip.prototype._getOrigin = function () {
                    /** @type {?} */
                    var isLtr = !this._dir || this._dir.value == 'ltr';
                    /** @type {?} */
                    var position = this.position;
                    /** @type {?} */
                    var originPosition;
                    if (position == 'above' || position == 'below') {
                        originPosition = { originX: 'center', originY: position == 'above' ? 'top' : 'bottom' };
                    }
                    else if (position == 'before' ||
                        (position == 'left' && isLtr) ||
                        (position == 'right' && !isLtr)) {
                        originPosition = { originX: 'start', originY: 'center' };
                    }
                    else if (position == 'after' ||
                        (position == 'right' && isLtr) ||
                        (position == 'left' && !isLtr)) {
                        originPosition = { originX: 'end', originY: 'center' };
                    }
                    else {
                        throw getMatTooltipInvalidPositionError(position);
                    }
                    var _a = this._invertPosition(originPosition.originX, originPosition.originY), x = _a.x, y = _a.y;
                    return {
                        main: originPosition,
                        fallback: { originX: x, originY: y }
                    };
                };
                /**
                 * Returns the overlay position and a fallback position based on the user's preference
                 * @return {?}
                 */
                MatTooltip.prototype._getOverlayPosition = function () {
                    /** @type {?} */
                    var isLtr = !this._dir || this._dir.value == 'ltr';
                    /** @type {?} */
                    var position = this.position;
                    /** @type {?} */
                    var overlayPosition;
                    if (position == 'above') {
                        overlayPosition = { overlayX: 'center', overlayY: 'bottom' };
                    }
                    else if (position == 'below') {
                        overlayPosition = { overlayX: 'center', overlayY: 'top' };
                    }
                    else if (position == 'before' ||
                        (position == 'left' && isLtr) ||
                        (position == 'right' && !isLtr)) {
                        overlayPosition = { overlayX: 'end', overlayY: 'center' };
                    }
                    else if (position == 'after' ||
                        (position == 'right' && isLtr) ||
                        (position == 'left' && !isLtr)) {
                        overlayPosition = { overlayX: 'start', overlayY: 'center' };
                    }
                    else {
                        throw getMatTooltipInvalidPositionError(position);
                    }
                    var _a = this._invertPosition(overlayPosition.overlayX, overlayPosition.overlayY), x = _a.x, y = _a.y;
                    return {
                        main: overlayPosition,
                        fallback: { overlayX: x, overlayY: y }
                    };
                };
                /**
                 * Updates the tooltip message and repositions the overlay according to the new message length
                 * @private
                 * @return {?}
                 */
                MatTooltip.prototype._updateTooltipMessage = function () {
                    var _this_1 = this;
                    // Must wait for the message to be painted to the tooltip so that the overlay can properly
                    // calculate the correct positioning based on the size of the text.
                    if (this._tooltipInstance) {
                        this._tooltipInstance.message = this.message;
                        this._tooltipInstance._markForCheck();
                        this._ngZone.onMicrotaskEmpty.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["take"])(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["takeUntil"])(this._destroyed)).subscribe(( /**
                         * @return {?}
                         */function () {
                            if (_this_1._tooltipInstance) {
                                ( /** @type {?} */(_this_1._overlayRef)).updatePosition();
                            }
                        }));
                    }
                };
                /**
                 * Updates the tooltip class
                 * @private
                 * @param {?} tooltipClass
                 * @return {?}
                 */
                MatTooltip.prototype._setTooltipClass = function (tooltipClass) {
                    if (this._tooltipInstance) {
                        this._tooltipInstance.tooltipClass = tooltipClass;
                        this._tooltipInstance._markForCheck();
                    }
                };
                /**
                 * Inverts an overlay position.
                 * @private
                 * @param {?} x
                 * @param {?} y
                 * @return {?}
                 */
                MatTooltip.prototype._invertPosition = function (x, y) {
                    if (this.position === 'above' || this.position === 'below') {
                        if (y === 'top') {
                            y = 'bottom';
                        }
                        else if (y === 'bottom') {
                            y = 'top';
                        }
                    }
                    else {
                        if (x === 'end') {
                            x = 'start';
                        }
                        else if (x === 'start') {
                            x = 'end';
                        }
                    }
                    return { x: x, y: y };
                };
                return MatTooltip;
            }());
            MatTooltip.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["Directive"], args: [{
                            selector: '[matTooltip]',
                            exportAs: 'matTooltip',
                            host: {
                                '(longpress)': 'show()',
                                '(keydown)': '_handleKeydown($event)',
                                '(touchend)': '_handleTouchend()',
                            },
                        },] },
            ];
            /** @nocollapse */
            MatTooltip.ctorParameters = function () { return [
                { type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["Overlay"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["ElementRef"] },
                { type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_9__["ScrollDispatcher"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["ViewContainerRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["NgZone"] },
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_7__["Platform"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__["AriaDescriber"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__["FocusMonitor"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["Inject"], args: [MAT_TOOLTIP_SCROLL_STRATEGY,] }] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["Optional"] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["Inject"], args: [MAT_TOOLTIP_DEFAULT_OPTIONS,] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["Inject"], args: [_angular_platform_browser__WEBPACK_IMPORTED_MODULE_11__["HAMMER_LOADER"],] }] }
            ]; };
            MatTooltip.propDecorators = {
                position: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["Input"], args: ['matTooltipPosition',] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["Input"], args: ['matTooltipDisabled',] }],
                showDelay: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["Input"], args: ['matTooltipShowDelay',] }],
                hideDelay: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["Input"], args: ['matTooltipHideDelay',] }],
                message: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["Input"], args: ['matTooltip',] }],
                tooltipClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["Input"], args: ['matTooltipClass',] }]
            };
            /**
             * Internal component that wraps the tooltip's content.
             * \@docs-private
             */
            var TooltipComponent = /** @class */ (function () {
                /**
                 * @param {?} _changeDetectorRef
                 * @param {?} _breakpointObserver
                 */
                function TooltipComponent(_changeDetectorRef, _breakpointObserver) {
                    this._changeDetectorRef = _changeDetectorRef;
                    this._breakpointObserver = _breakpointObserver;
                    /**
                     * Property watched by the animation framework to show or hide the tooltip
                     */
                    this._visibility = 'initial';
                    /**
                     * Whether interactions on the page should close the tooltip
                     */
                    this._closeOnInteraction = false;
                    /**
                     * Subject for notifying that the tooltip has been hidden from the view
                     */
                    this._onHide = new rxjs__WEBPACK_IMPORTED_MODULE_12__["Subject"]();
                    /**
                     * Stream that emits whether the user has a handset-sized display.
                     */
                    this._isHandset = this._breakpointObserver.observe(_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_5__["Breakpoints"].Handset);
                }
                /**
                 * Shows the tooltip with an animation originating from the provided origin
                 * @param {?} delay Amount of milliseconds to the delay showing the tooltip.
                 * @return {?}
                 */
                TooltipComponent.prototype.show = function (delay) {
                    var _this_1 = this;
                    // Cancel the delayed hide if it is scheduled
                    if (this._hideTimeoutId) {
                        clearTimeout(this._hideTimeoutId);
                        this._hideTimeoutId = null;
                    }
                    // Body interactions should cancel the tooltip if there is a delay in showing.
                    this._closeOnInteraction = true;
                    this._showTimeoutId = setTimeout(( /**
                     * @return {?}
                     */function () {
                        _this_1._visibility = 'visible';
                        _this_1._showTimeoutId = null;
                        // Mark for check so if any parent component has set the
                        // ChangeDetectionStrategy to OnPush it will be checked anyways
                        _this_1._markForCheck();
                    }), delay);
                };
                /**
                 * Begins the animation to hide the tooltip after the provided delay in ms.
                 * @param {?} delay Amount of milliseconds to delay showing the tooltip.
                 * @return {?}
                 */
                TooltipComponent.prototype.hide = function (delay) {
                    var _this_1 = this;
                    // Cancel the delayed show if it is scheduled
                    if (this._showTimeoutId) {
                        clearTimeout(this._showTimeoutId);
                        this._showTimeoutId = null;
                    }
                    this._hideTimeoutId = setTimeout(( /**
                     * @return {?}
                     */function () {
                        _this_1._visibility = 'hidden';
                        _this_1._hideTimeoutId = null;
                        // Mark for check so if any parent component has set the
                        // ChangeDetectionStrategy to OnPush it will be checked anyways
                        _this_1._markForCheck();
                    }), delay);
                };
                /**
                 * Returns an observable that notifies when the tooltip has been hidden from view.
                 * @return {?}
                 */
                TooltipComponent.prototype.afterHidden = function () {
                    return this._onHide.asObservable();
                };
                /**
                 * Whether the tooltip is being displayed.
                 * @return {?}
                 */
                TooltipComponent.prototype.isVisible = function () {
                    return this._visibility === 'visible';
                };
                /**
                 * @return {?}
                 */
                TooltipComponent.prototype.ngOnDestroy = function () {
                    this._onHide.complete();
                };
                /**
                 * @return {?}
                 */
                TooltipComponent.prototype._animationStart = function () {
                    this._closeOnInteraction = false;
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                TooltipComponent.prototype._animationDone = function (event) {
                    /** @type {?} */
                    var toState = ( /** @type {?} */(event.toState));
                    if (toState === 'hidden' && !this.isVisible()) {
                        this._onHide.next();
                    }
                    if (toState === 'visible' || toState === 'hidden') {
                        this._closeOnInteraction = true;
                    }
                };
                /**
                 * Interactions on the HTML body should close the tooltip immediately as defined in the
                 * material design spec.
                 * https://material.io/design/components/tooltips.html#behavior
                 * @return {?}
                 */
                TooltipComponent.prototype._handleBodyInteraction = function () {
                    if (this._closeOnInteraction) {
                        this.hide(0);
                    }
                };
                /**
                 * Marks that the tooltip needs to be checked in the next change detection run.
                 * Mainly used for rendering the initial text before positioning a tooltip, which
                 * can be problematic in components with OnPush change detection.
                 * @return {?}
                 */
                TooltipComponent.prototype._markForCheck = function () {
                    this._changeDetectorRef.markForCheck();
                };
                return TooltipComponent;
            }());
            TooltipComponent.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["Component"], args: [{ selector: 'mat-tooltip-component',
                            template: "<div class=\"mat-tooltip\" [ngClass]=\"tooltipClass\" [class.mat-tooltip-handset]=\"(_isHandset | async)?.matches\" [@state]=\"_visibility\" (@state.start)=\"_animationStart()\" (@state.done)=\"_animationDone($event)\">{{message}}</div>",
                            styles: [".mat-tooltip-panel{pointer-events:none!important}.mat-tooltip{color:#fff;border-radius:4px;margin:14px;max-width:250px;padding-left:8px;padding-right:8px;overflow:hidden;text-overflow:ellipsis}@media (-ms-high-contrast:active){.mat-tooltip{outline:solid 1px}}.mat-tooltip-handset{margin:24px;padding-left:16px;padding-right:16px}"],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_10__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_10__["ChangeDetectionStrategy"].OnPush,
                            animations: [matTooltipAnimations.tooltipState],
                            host: {
                                // Forces the element to have a layout in IE and Edge. This fixes issues where the element
                                // won't be rendered if the animations are disabled or there is no web animations polyfill.
                                '[style.zoom]': '_visibility === "visible" ? 1 : null',
                                '(body:click)': 'this._handleBodyInteraction()',
                                'aria-hidden': 'true',
                            }
                        },] },
            ];
            /** @nocollapse */
            TooltipComponent.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["ChangeDetectorRef"] },
                { type: _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_5__["BreakpointObserver"] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatTooltipModule = /** @class */ (function () {
                function MatTooltipModule() {
                }
                return MatTooltipModule;
            }());
            MatTooltipModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["NgModule"], args: [{
                            imports: [
                                _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__["A11yModule"],
                                _angular_common__WEBPACK_IMPORTED_MODULE_14__["CommonModule"],
                                _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["OverlayModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_15__["MatCommonModule"],
                            ],
                            exports: [MatTooltip, TooltipComponent, _angular_material_core__WEBPACK_IMPORTED_MODULE_15__["MatCommonModule"]],
                            declarations: [MatTooltip, TooltipComponent],
                            entryComponents: [TooltipComponent],
                            providers: [
                                MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER,
                                { provide: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_11__["HAMMER_GESTURE_CONFIG"], useClass: _angular_material_core__WEBPACK_IMPORTED_MODULE_15__["GestureConfig"] },
                            ]
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=tooltip.js.map
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js": 
        /*!***************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
          \***************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports) {
            function _arrayWithHoles(arr) {
                if (Array.isArray(arr))
                    return arr;
            }
            module.exports = _arrayWithHoles;
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js": 
        /*!**********************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
          \**********************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports) {
            function _assertThisInitialized(self) {
                if (self === void 0) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return self;
            }
            module.exports = _assertThisInitialized;
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js": 
        /*!***************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
          \***************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports) {
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                }
            }
            module.exports = _classCallCheck;
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/construct.js": 
        /*!**********************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/construct.js ***!
          \**********************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");
            function isNativeReflectConstruct() {
                if (typeof Reflect === "undefined" || !Reflect.construct)
                    return false;
                if (Reflect.construct.sham)
                    return false;
                if (typeof Proxy === "function")
                    return true;
                try {
                    Date.prototype.toString.call(Reflect.construct(Date, [], function () { }));
                    return true;
                }
                catch (e) {
                    return false;
                }
            }
            function _construct(Parent, args, Class) {
                if (isNativeReflectConstruct()) {
                    module.exports = _construct = Reflect.construct;
                }
                else {
                    module.exports = _construct = function _construct(Parent, args, Class) {
                        var a = [null];
                        a.push.apply(a, args);
                        var Constructor = Function.bind.apply(Parent, a);
                        var instance = new Constructor();
                        if (Class)
                            setPrototypeOf(instance, Class.prototype);
                        return instance;
                    };
                }
                return _construct.apply(null, arguments);
            }
            module.exports = _construct;
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/createClass.js": 
        /*!************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
          \************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports) {
            function _defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            function _createClass(Constructor, protoProps, staticProps) {
                if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                    _defineProperties(Constructor, staticProps);
                return Constructor;
            }
            module.exports = _createClass;
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/defineProperty.js": 
        /*!***************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
          \***************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports) {
            function _defineProperty(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                }
                else {
                    obj[key] = value;
                }
                return obj;
            }
            module.exports = _defineProperty;
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/get.js": 
        /*!****************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/get.js ***!
          \****************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            var superPropBase = __webpack_require__(/*! ./superPropBase */ "./node_modules/@babel/runtime/helpers/superPropBase.js");
            function _get(target, property, receiver) {
                if (typeof Reflect !== "undefined" && Reflect.get) {
                    module.exports = _get = Reflect.get;
                }
                else {
                    module.exports = _get = function _get(target, property, receiver) {
                        var base = superPropBase(target, property);
                        if (!base)
                            return;
                        var desc = Object.getOwnPropertyDescriptor(base, property);
                        if (desc.get) {
                            return desc.get.call(receiver);
                        }
                        return desc.value;
                    };
                }
                return _get(target, property, receiver || target);
            }
            module.exports = _get;
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js": 
        /*!***************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
          \***************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports) {
            function _getPrototypeOf(o) {
                module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                    return o.__proto__ || Object.getPrototypeOf(o);
                };
                return _getPrototypeOf(o);
            }
            module.exports = _getPrototypeOf;
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/inherits.js": 
        /*!*********************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/inherits.js ***!
          \*********************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");
            function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function");
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        writable: true,
                        configurable: true
                    }
                });
                if (superClass)
                    setPrototypeOf(subClass, superClass);
            }
            module.exports = _inherits;
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js": 
        /*!**********************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
          \**********************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports) {
            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    "default": obj
                };
            }
            module.exports = _interopRequireDefault;
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js": 
        /*!***********************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/interopRequireWildcard.js ***!
          \***********************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            var _typeof = __webpack_require__(/*! ../helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");
            function _getRequireWildcardCache() {
                if (typeof WeakMap !== "function")
                    return null;
                var cache = new WeakMap();
                _getRequireWildcardCache = function _getRequireWildcardCache() {
                    return cache;
                };
                return cache;
            }
            function _interopRequireWildcard(obj) {
                if (obj && obj.__esModule) {
                    return obj;
                }
                if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
                    return {
                        "default": obj
                    };
                }
                var cache = _getRequireWildcardCache();
                if (cache && cache.has(obj)) {
                    return cache.get(obj);
                }
                var newObj = {};
                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key)) {
                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
                        if (desc && (desc.get || desc.set)) {
                            Object.defineProperty(newObj, key, desc);
                        }
                        else {
                            newObj[key] = obj[key];
                        }
                    }
                }
                newObj["default"] = obj;
                if (cache) {
                    cache.set(obj, newObj);
                }
                return newObj;
            }
            module.exports = _interopRequireWildcard;
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/isNativeFunction.js": 
        /*!*****************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/isNativeFunction.js ***!
          \*****************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports) {
            function _isNativeFunction(fn) {
                return Function.toString.call(fn).indexOf("[native code]") !== -1;
            }
            module.exports = _isNativeFunction;
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/iterableToArray.js": 
        /*!****************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/iterableToArray.js ***!
          \****************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports) {
            function _iterableToArray(iter) {
                if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]")
                    return Array.from(iter);
            }
            module.exports = _iterableToArray;
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js": 
        /*!*********************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
          \*********************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports) {
            function _iterableToArrayLimit(arr, i) {
                if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
                    return;
                }
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = undefined;
                try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                        _arr.push(_s.value);
                        if (i && _arr.length === i)
                            break;
                    }
                }
                catch (err) {
                    _d = true;
                    _e = err;
                }
                finally {
                    try {
                        if (!_n && _i["return"] != null)
                            _i["return"]();
                    }
                    finally {
                        if (_d)
                            throw _e;
                    }
                }
                return _arr;
            }
            module.exports = _iterableToArrayLimit;
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/nonIterableRest.js": 
        /*!****************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
          \****************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports) {
            function _nonIterableRest() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
            module.exports = _nonIterableRest;
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js": 
        /*!**************************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
          \**************************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            var _typeof = __webpack_require__(/*! ../helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");
            var assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js");
            function _possibleConstructorReturn(self, call) {
                if (call && (_typeof(call) === "object" || typeof call === "function")) {
                    return call;
                }
                return assertThisInitialized(self);
            }
            module.exports = _possibleConstructorReturn;
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js": 
        /*!***************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
          \***************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports) {
            function _setPrototypeOf(o, p) {
                module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                    o.__proto__ = p;
                    return o;
                };
                return _setPrototypeOf(o, p);
            }
            module.exports = _setPrototypeOf;
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/slicedToArray.js": 
        /*!**************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/slicedToArray.js ***!
          \**************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles */ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js");
            var iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit */ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js");
            var nonIterableRest = __webpack_require__(/*! ./nonIterableRest */ "./node_modules/@babel/runtime/helpers/nonIterableRest.js");
            function _slicedToArray(arr, i) {
                return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
            }
            module.exports = _slicedToArray;
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/superPropBase.js": 
        /*!**************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/superPropBase.js ***!
          \**************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            var getPrototypeOf = __webpack_require__(/*! ./getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
            function _superPropBase(object, property) {
                while (!Object.prototype.hasOwnProperty.call(object, property)) {
                    object = getPrototypeOf(object);
                    if (object === null)
                        break;
                }
                return object;
            }
            module.exports = _superPropBase;
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/toArray.js": 
        /*!********************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/toArray.js ***!
          \********************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles */ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js");
            var iterableToArray = __webpack_require__(/*! ./iterableToArray */ "./node_modules/@babel/runtime/helpers/iterableToArray.js");
            var nonIterableRest = __webpack_require__(/*! ./nonIterableRest */ "./node_modules/@babel/runtime/helpers/nonIterableRest.js");
            function _toArray(arr) {
                return arrayWithHoles(arr) || iterableToArray(arr) || nonIterableRest();
            }
            module.exports = _toArray;
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/typeof.js": 
        /*!*******************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
          \*******************************************************/
        /*! no static exports found */
        /***/ (function (module, exports) {
            function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof2 = function _typeof2(obj) { return typeof obj; };
            }
            else {
                _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
            } return _typeof2(obj); }
            function _typeof(obj) {
                if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
                    module.exports = _typeof = function _typeof(obj) {
                        return _typeof2(obj);
                    };
                }
                else {
                    module.exports = _typeof = function _typeof(obj) {
                        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
                    };
                }
                return _typeof(obj);
            }
            module.exports = _typeof;
            /***/ 
        }),
        /***/ "./node_modules/@babel/runtime/helpers/wrapNativeSuper.js": 
        /*!****************************************************************!*\
          !*** ./node_modules/@babel/runtime/helpers/wrapNativeSuper.js ***!
          \****************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            var getPrototypeOf = __webpack_require__(/*! ./getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
            var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");
            var isNativeFunction = __webpack_require__(/*! ./isNativeFunction */ "./node_modules/@babel/runtime/helpers/isNativeFunction.js");
            var construct = __webpack_require__(/*! ./construct */ "./node_modules/@babel/runtime/helpers/construct.js");
            function _wrapNativeSuper(Class) {
                var _cache = typeof Map === "function" ? new Map() : undefined;
                module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
                    if (Class === null || !isNativeFunction(Class))
                        return Class;
                    if (typeof Class !== "function") {
                        throw new TypeError("Super expression must either be null or a function");
                    }
                    if (typeof _cache !== "undefined") {
                        if (_cache.has(Class))
                            return _cache.get(Class);
                        _cache.set(Class, Wrapper);
                    }
                    function Wrapper() {
                        return construct(Class, arguments, getPrototypeOf(this).constructor);
                    }
                    Wrapper.prototype = Object.create(Class.prototype, {
                        constructor: {
                            value: Wrapper,
                            enumerable: false,
                            writable: true,
                            configurable: true
                        }
                    });
                    return setPrototypeOf(Wrapper, Class);
                };
                return _wrapNativeSuper(Class);
            }
            module.exports = _wrapNativeSuper;
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/ajv.js": 
        /*!*************************************!*\
          !*** ./node_modules/ajv/lib/ajv.js ***!
          \*************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var compileSchema = __webpack_require__(/*! ./compile */ "./node_modules/ajv/lib/compile/index.js"), resolve = __webpack_require__(/*! ./compile/resolve */ "./node_modules/ajv/lib/compile/resolve.js"), Cache = __webpack_require__(/*! ./cache */ "./node_modules/ajv/lib/cache.js"), SchemaObject = __webpack_require__(/*! ./compile/schema_obj */ "./node_modules/ajv/lib/compile/schema_obj.js"), stableStringify = __webpack_require__(/*! fast-json-stable-stringify */ "./node_modules/fast-json-stable-stringify/index.js"), formats = __webpack_require__(/*! ./compile/formats */ "./node_modules/ajv/lib/compile/formats.js"), rules = __webpack_require__(/*! ./compile/rules */ "./node_modules/ajv/lib/compile/rules.js"), $dataMetaSchema = __webpack_require__(/*! ./data */ "./node_modules/ajv/lib/data.js"), util = __webpack_require__(/*! ./compile/util */ "./node_modules/ajv/lib/compile/util.js");
            module.exports = Ajv;
            Ajv.prototype.validate = validate;
            Ajv.prototype.compile = compile;
            Ajv.prototype.addSchema = addSchema;
            Ajv.prototype.addMetaSchema = addMetaSchema;
            Ajv.prototype.validateSchema = validateSchema;
            Ajv.prototype.getSchema = getSchema;
            Ajv.prototype.removeSchema = removeSchema;
            Ajv.prototype.addFormat = addFormat;
            Ajv.prototype.errorsText = errorsText;
            Ajv.prototype._addSchema = _addSchema;
            Ajv.prototype._compile = _compile;
            Ajv.prototype.compileAsync = __webpack_require__(/*! ./compile/async */ "./node_modules/ajv/lib/compile/async.js");
            var customKeyword = __webpack_require__(/*! ./keyword */ "./node_modules/ajv/lib/keyword.js");
            Ajv.prototype.addKeyword = customKeyword.add;
            Ajv.prototype.getKeyword = customKeyword.get;
            Ajv.prototype.removeKeyword = customKeyword.remove;
            Ajv.prototype.validateKeyword = customKeyword.validate;
            var errorClasses = __webpack_require__(/*! ./compile/error_classes */ "./node_modules/ajv/lib/compile/error_classes.js");
            Ajv.ValidationError = errorClasses.Validation;
            Ajv.MissingRefError = errorClasses.MissingRef;
            Ajv.$dataMetaSchema = $dataMetaSchema;
            var META_SCHEMA_ID = 'http://json-schema.org/draft-07/schema';
            var META_IGNORE_OPTIONS = ['removeAdditional', 'useDefaults', 'coerceTypes', 'strictDefaults'];
            var META_SUPPORT_DATA = ['/properties'];
            /**
             * Creates validator instance.
             * Usage: `Ajv(opts)`
             * @param {Object} opts optional options
             * @return {Object} ajv instance
             */
            function Ajv(opts) {
                if (!(this instanceof Ajv))
                    return new Ajv(opts);
                opts = this._opts = util.copy(opts) || {};
                setLogger(this);
                this._schemas = {};
                this._refs = {};
                this._fragments = {};
                this._formats = formats(opts.format);
                this._cache = opts.cache || new Cache;
                this._loadingSchemas = {};
                this._compilations = [];
                this.RULES = rules();
                this._getId = chooseGetId(opts);
                opts.loopRequired = opts.loopRequired || Infinity;
                if (opts.errorDataPath == 'property')
                    opts._errorDataPathProperty = true;
                if (opts.serialize === undefined)
                    opts.serialize = stableStringify;
                this._metaOpts = getMetaSchemaOptions(this);
                if (opts.formats)
                    addInitialFormats(this);
                addDefaultMetaSchema(this);
                if (typeof opts.meta == 'object')
                    this.addMetaSchema(opts.meta);
                if (opts.nullable)
                    this.addKeyword('nullable', { metaSchema: { type: 'boolean' } });
                addInitialSchemas(this);
            }
            /**
             * Validate data using schema
             * Schema will be compiled and cached (using serialized JSON as key. [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize.
             * @this   Ajv
             * @param  {String|Object} schemaKeyRef key, ref or schema object
             * @param  {Any} data to be validated
             * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).
             */
            function validate(schemaKeyRef, data) {
                var v;
                if (typeof schemaKeyRef == 'string') {
                    v = this.getSchema(schemaKeyRef);
                    if (!v)
                        throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
                }
                else {
                    var schemaObj = this._addSchema(schemaKeyRef);
                    v = schemaObj.validate || this._compile(schemaObj);
                }
                var valid = v(data);
                if (v.$async !== true)
                    this.errors = v.errors;
                return valid;
            }
            /**
             * Create validating function for passed schema.
             * @this   Ajv
             * @param  {Object} schema schema object
             * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.
             * @return {Function} validating function
             */
            function compile(schema, _meta) {
                var schemaObj = this._addSchema(schema, undefined, _meta);
                return schemaObj.validate || this._compile(schemaObj);
            }
            /**
             * Adds schema to the instance.
             * @this   Ajv
             * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.
             * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
             * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
             * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
             * @return {Ajv} this for method chaining
             */
            function addSchema(schema, key, _skipValidation, _meta) {
                if (Array.isArray(schema)) {
                    for (var i = 0; i < schema.length; i++)
                        this.addSchema(schema[i], undefined, _skipValidation, _meta);
                    return this;
                }
                var id = this._getId(schema);
                if (id !== undefined && typeof id != 'string')
                    throw new Error('schema id must be string');
                key = resolve.normalizeId(key || id);
                checkUnique(this, key);
                this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
                return this;
            }
            /**
             * Add schema that will be used to validate other schemas
             * options in META_IGNORE_OPTIONS are alway set to false
             * @this   Ajv
             * @param {Object} schema schema object
             * @param {String} key optional schema key
             * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
             * @return {Ajv} this for method chaining
             */
            function addMetaSchema(schema, key, skipValidation) {
                this.addSchema(schema, key, skipValidation, true);
                return this;
            }
            /**
             * Validate schema
             * @this   Ajv
             * @param {Object} schema schema to validate
             * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid
             * @return {Boolean} true if schema is valid
             */
            function validateSchema(schema, throwOrLogError) {
                var $schema = schema.$schema;
                if ($schema !== undefined && typeof $schema != 'string')
                    throw new Error('$schema must be a string');
                $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
                if (!$schema) {
                    this.logger.warn('meta-schema not available');
                    this.errors = null;
                    return true;
                }
                var valid = this.validate($schema, schema);
                if (!valid && throwOrLogError) {
                    var message = 'schema is invalid: ' + this.errorsText();
                    if (this._opts.validateSchema == 'log')
                        this.logger.error(message);
                    else
                        throw new Error(message);
                }
                return valid;
            }
            function defaultMeta(self) {
                var meta = self._opts.meta;
                self._opts.defaultMeta = typeof meta == 'object'
                    ? self._getId(meta) || meta
                    : self.getSchema(META_SCHEMA_ID)
                        ? META_SCHEMA_ID
                        : undefined;
                return self._opts.defaultMeta;
            }
            /**
             * Get compiled schema from the instance by `key` or `ref`.
             * @this   Ajv
             * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).
             * @return {Function} schema validating function (with property `schema`).
             */
            function getSchema(keyRef) {
                var schemaObj = _getSchemaObj(this, keyRef);
                switch (typeof schemaObj) {
                    case 'object': return schemaObj.validate || this._compile(schemaObj);
                    case 'string': return this.getSchema(schemaObj);
                    case 'undefined': return _getSchemaFragment(this, keyRef);
                }
            }
            function _getSchemaFragment(self, ref) {
                var res = resolve.schema.call(self, { schema: {} }, ref);
                if (res) {
                    var schema = res.schema, root = res.root, baseId = res.baseId;
                    var v = compileSchema.call(self, schema, root, undefined, baseId);
                    self._fragments[ref] = new SchemaObject({
                        ref: ref,
                        fragment: true,
                        schema: schema,
                        root: root,
                        baseId: baseId,
                        validate: v
                    });
                    return v;
                }
            }
            function _getSchemaObj(self, keyRef) {
                keyRef = resolve.normalizeId(keyRef);
                return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
            }
            /**
             * Remove cached schema(s).
             * If no parameter is passed all schemas but meta-schemas are removed.
             * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
             * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
             * @this   Ajv
             * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object
             * @return {Ajv} this for method chaining
             */
            function removeSchema(schemaKeyRef) {
                if (schemaKeyRef instanceof RegExp) {
                    _removeAllSchemas(this, this._schemas, schemaKeyRef);
                    _removeAllSchemas(this, this._refs, schemaKeyRef);
                    return this;
                }
                switch (typeof schemaKeyRef) {
                    case 'undefined':
                        _removeAllSchemas(this, this._schemas);
                        _removeAllSchemas(this, this._refs);
                        this._cache.clear();
                        return this;
                    case 'string':
                        var schemaObj = _getSchemaObj(this, schemaKeyRef);
                        if (schemaObj)
                            this._cache.del(schemaObj.cacheKey);
                        delete this._schemas[schemaKeyRef];
                        delete this._refs[schemaKeyRef];
                        return this;
                    case 'object':
                        var serialize = this._opts.serialize;
                        var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
                        this._cache.del(cacheKey);
                        var id = this._getId(schemaKeyRef);
                        if (id) {
                            id = resolve.normalizeId(id);
                            delete this._schemas[id];
                            delete this._refs[id];
                        }
                }
                return this;
            }
            function _removeAllSchemas(self, schemas, regex) {
                for (var keyRef in schemas) {
                    var schemaObj = schemas[keyRef];
                    if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
                        self._cache.del(schemaObj.cacheKey);
                        delete schemas[keyRef];
                    }
                }
            }
            /* @this   Ajv */
            function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
                if (typeof schema != 'object' && typeof schema != 'boolean')
                    throw new Error('schema should be object or boolean');
                var serialize = this._opts.serialize;
                var cacheKey = serialize ? serialize(schema) : schema;
                var cached = this._cache.get(cacheKey);
                if (cached)
                    return cached;
                shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
                var id = resolve.normalizeId(this._getId(schema));
                if (id && shouldAddSchema)
                    checkUnique(this, id);
                var willValidate = this._opts.validateSchema !== false && !skipValidation;
                var recursiveMeta;
                if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
                    this.validateSchema(schema, true);
                var localRefs = resolve.ids.call(this, schema);
                var schemaObj = new SchemaObject({
                    id: id,
                    schema: schema,
                    localRefs: localRefs,
                    cacheKey: cacheKey,
                    meta: meta
                });
                if (id[0] != '#' && shouldAddSchema)
                    this._refs[id] = schemaObj;
                this._cache.put(cacheKey, schemaObj);
                if (willValidate && recursiveMeta)
                    this.validateSchema(schema, true);
                return schemaObj;
            }
            /* @this   Ajv */
            function _compile(schemaObj, root) {
                if (schemaObj.compiling) {
                    schemaObj.validate = callValidate;
                    callValidate.schema = schemaObj.schema;
                    callValidate.errors = null;
                    callValidate.root = root ? root : callValidate;
                    if (schemaObj.schema.$async === true)
                        callValidate.$async = true;
                    return callValidate;
                }
                schemaObj.compiling = true;
                var currentOpts;
                if (schemaObj.meta) {
                    currentOpts = this._opts;
                    this._opts = this._metaOpts;
                }
                var v;
                try {
                    v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs);
                }
                catch (e) {
                    delete schemaObj.validate;
                    throw e;
                }
                finally {
                    schemaObj.compiling = false;
                    if (schemaObj.meta)
                        this._opts = currentOpts;
                }
                schemaObj.validate = v;
                schemaObj.refs = v.refs;
                schemaObj.refVal = v.refVal;
                schemaObj.root = v.root;
                return v;
                /* @this   {*} - custom context, see passContext option */
                function callValidate() {
                    /* jshint validthis: true */
                    var _validate = schemaObj.validate;
                    var result = _validate.apply(this, arguments);
                    callValidate.errors = _validate.errors;
                    return result;
                }
            }
            function chooseGetId(opts) {
                switch (opts.schemaId) {
                    case 'auto': return _get$IdOrId;
                    case 'id': return _getId;
                    default: return _get$Id;
                }
            }
            /* @this   Ajv */
            function _getId(schema) {
                if (schema.$id)
                    this.logger.warn('schema $id ignored', schema.$id);
                return schema.id;
            }
            /* @this   Ajv */
            function _get$Id(schema) {
                if (schema.id)
                    this.logger.warn('schema id ignored', schema.id);
                return schema.$id;
            }
            function _get$IdOrId(schema) {
                if (schema.$id && schema.id && schema.$id != schema.id)
                    throw new Error('schema $id is different from id');
                return schema.$id || schema.id;
            }
            /**
             * Convert array of error message objects to string
             * @this   Ajv
             * @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.
             * @param  {Object} options optional options with properties `separator` and `dataVar`.
             * @return {String} human readable string with all errors descriptions
             */
            function errorsText(errors, options) {
                errors = errors || this.errors;
                if (!errors)
                    return 'No errors';
                options = options || {};
                var separator = options.separator === undefined ? ', ' : options.separator;
                var dataVar = options.dataVar === undefined ? 'data' : options.dataVar;
                var text = '';
                for (var i = 0; i < errors.length; i++) {
                    var e = errors[i];
                    if (e)
                        text += dataVar + e.dataPath + ' ' + e.message + separator;
                }
                return text.slice(0, -separator.length);
            }
            /**
             * Add custom format
             * @this   Ajv
             * @param {String} name format name
             * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
             * @return {Ajv} this for method chaining
             */
            function addFormat(name, format) {
                if (typeof format == 'string')
                    format = new RegExp(format);
                this._formats[name] = format;
                return this;
            }
            function addDefaultMetaSchema(self) {
                var $dataSchema;
                if (self._opts.$data) {
                    $dataSchema = __webpack_require__(/*! ./refs/data.json */ "./node_modules/ajv/lib/refs/data.json");
                    self.addMetaSchema($dataSchema, $dataSchema.$id, true);
                }
                if (self._opts.meta === false)
                    return;
                var metaSchema = __webpack_require__(/*! ./refs/json-schema-draft-07.json */ "./node_modules/ajv/lib/refs/json-schema-draft-07.json");
                if (self._opts.$data)
                    metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
                self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
                self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;
            }
            function addInitialSchemas(self) {
                var optsSchemas = self._opts.schemas;
                if (!optsSchemas)
                    return;
                if (Array.isArray(optsSchemas))
                    self.addSchema(optsSchemas);
                else
                    for (var key in optsSchemas)
                        self.addSchema(optsSchemas[key], key);
            }
            function addInitialFormats(self) {
                for (var name in self._opts.formats) {
                    var format = self._opts.formats[name];
                    self.addFormat(name, format);
                }
            }
            function checkUnique(self, id) {
                if (self._schemas[id] || self._refs[id])
                    throw new Error('schema with key or id "' + id + '" already exists');
            }
            function getMetaSchemaOptions(self) {
                var metaOpts = util.copy(self._opts);
                for (var i = 0; i < META_IGNORE_OPTIONS.length; i++)
                    delete metaOpts[META_IGNORE_OPTIONS[i]];
                return metaOpts;
            }
            function setLogger(self) {
                var logger = self._opts.logger;
                if (logger === false) {
                    self.logger = { log: noop, warn: noop, error: noop };
                }
                else {
                    if (logger === undefined)
                        logger = console;
                    if (!(typeof logger == 'object' && logger.log && logger.warn && logger.error))
                        throw new Error('logger must implement log, warn and error methods');
                    self.logger = logger;
                }
            }
            function noop() { }
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/cache.js": 
        /*!***************************************!*\
          !*** ./node_modules/ajv/lib/cache.js ***!
          \***************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var Cache = module.exports = function Cache() {
                this._cache = {};
            };
            Cache.prototype.put = function Cache_put(key, value) {
                this._cache[key] = value;
            };
            Cache.prototype.get = function Cache_get(key) {
                return this._cache[key];
            };
            Cache.prototype.del = function Cache_del(key) {
                delete this._cache[key];
            };
            Cache.prototype.clear = function Cache_clear() {
                this._cache = {};
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/compile/async.js": 
        /*!***********************************************!*\
          !*** ./node_modules/ajv/lib/compile/async.js ***!
          \***********************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var MissingRefError = __webpack_require__(/*! ./error_classes */ "./node_modules/ajv/lib/compile/error_classes.js").MissingRef;
            module.exports = compileAsync;
            /**
             * Creates validating function for passed schema with asynchronous loading of missing schemas.
             * `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.
             * @this  Ajv
             * @param {Object}   schema schema object
             * @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped
             * @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.
             * @return {Promise} promise that resolves with a validating function.
             */
            function compileAsync(schema, meta, callback) {
                /* eslint no-shadow: 0 */
                /* global Promise */
                /* jshint validthis: true */
                var self = this;
                if (typeof this._opts.loadSchema != 'function')
                    throw new Error('options.loadSchema should be a function');
                if (typeof meta == 'function') {
                    callback = meta;
                    meta = undefined;
                }
                var p = loadMetaSchemaOf(schema).then(function () {
                    var schemaObj = self._addSchema(schema, undefined, meta);
                    return schemaObj.validate || _compileAsync(schemaObj);
                });
                if (callback) {
                    p.then(function (v) { callback(null, v); }, callback);
                }
                return p;
                function loadMetaSchemaOf(sch) {
                    var $schema = sch.$schema;
                    return $schema && !self.getSchema($schema)
                        ? compileAsync.call(self, { $ref: $schema }, true)
                        : Promise.resolve();
                }
                function _compileAsync(schemaObj) {
                    try {
                        return self._compile(schemaObj);
                    }
                    catch (e) {
                        if (e instanceof MissingRefError)
                            return loadMissingSchema(e);
                        throw e;
                    }
                    function loadMissingSchema(e) {
                        var ref = e.missingSchema;
                        if (added(ref))
                            throw new Error('Schema ' + ref + ' is loaded but ' + e.missingRef + ' cannot be resolved');
                        var schemaPromise = self._loadingSchemas[ref];
                        if (!schemaPromise) {
                            schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);
                            schemaPromise.then(removePromise, removePromise);
                        }
                        return schemaPromise.then(function (sch) {
                            if (!added(ref)) {
                                return loadMetaSchemaOf(sch).then(function () {
                                    if (!added(ref))
                                        self.addSchema(sch, ref, undefined, meta);
                                });
                            }
                        }).then(function () {
                            return _compileAsync(schemaObj);
                        });
                        function removePromise() {
                            delete self._loadingSchemas[ref];
                        }
                        function added(ref) {
                            return self._refs[ref] || self._schemas[ref];
                        }
                    }
                }
            }
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/compile/error_classes.js": 
        /*!*******************************************************!*\
          !*** ./node_modules/ajv/lib/compile/error_classes.js ***!
          \*******************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var resolve = __webpack_require__(/*! ./resolve */ "./node_modules/ajv/lib/compile/resolve.js");
            module.exports = {
                Validation: errorSubclass(ValidationError),
                MissingRef: errorSubclass(MissingRefError)
            };
            function ValidationError(errors) {
                this.message = 'validation failed';
                this.errors = errors;
                this.ajv = this.validation = true;
            }
            MissingRefError.message = function (baseId, ref) {
                return 'can\'t resolve reference ' + ref + ' from id ' + baseId;
            };
            function MissingRefError(baseId, ref, message) {
                this.message = message || MissingRefError.message(baseId, ref);
                this.missingRef = resolve.url(baseId, ref);
                this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
            }
            function errorSubclass(Subclass) {
                Subclass.prototype = Object.create(Error.prototype);
                Subclass.prototype.constructor = Subclass;
                return Subclass;
            }
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/compile/formats.js": 
        /*!*************************************************!*\
          !*** ./node_modules/ajv/lib/compile/formats.js ***!
          \*************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var util = __webpack_require__(/*! ./util */ "./node_modules/ajv/lib/compile/util.js");
            var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
            var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d:\d\d)?$/i;
            var HOSTNAME = /^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*$/i;
            var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
            var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
            // uri-template: https://tools.ietf.org/html/rfc6570
            var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
            // For the source: https://gist.github.com/dperini/729294
            // For test cases: https://mathiasbynens.be/demo/url-regex
            // @todo Delete current URL in favour of the commented out URL rule when this issue is fixed https://github.com/eslint/eslint/issues/7983.
            // var URL = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu;
            var URL = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
            var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
            var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
            var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
            var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
            module.exports = formats;
            function formats(mode) {
                mode = mode == 'full' ? 'full' : 'fast';
                return util.copy(formats[mode]);
            }
            formats.fast = {
                // date: http://tools.ietf.org/html/rfc3339#section-5.6
                date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
                // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
                time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d:\d\d)?$/i,
                'date-time': /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d:\d\d)$/i,
                // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
                uri: /^(?:[a-z][a-z0-9+-.]*:)(?:\/?\/)?[^\s]*$/i,
                'uri-reference': /^(?:(?:[a-z][a-z0-9+-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
                'uri-template': URITEMPLATE,
                url: URL,
                // email (sources from jsen validator):
                // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
                // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
                email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
                hostname: HOSTNAME,
                // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
                ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
                // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
                ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
                regex: regex,
                // uuid: http://tools.ietf.org/html/rfc4122
                uuid: UUID,
                // JSON-pointer: https://tools.ietf.org/html/rfc6901
                // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
                'json-pointer': JSON_POINTER,
                'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
                // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
                'relative-json-pointer': RELATIVE_JSON_POINTER
            };
            formats.full = {
                date: date,
                time: time,
                'date-time': date_time,
                uri: uri,
                'uri-reference': URIREF,
                'uri-template': URITEMPLATE,
                url: URL,
                email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
                hostname: hostname,
                ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
                ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
                regex: regex,
                uuid: UUID,
                'json-pointer': JSON_POINTER,
                'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
                'relative-json-pointer': RELATIVE_JSON_POINTER
            };
            function isLeapYear(year) {
                // https://tools.ietf.org/html/rfc3339#appendix-C
                return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
            }
            function date(str) {
                // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
                var matches = str.match(DATE);
                if (!matches)
                    return false;
                var year = +matches[1];
                var month = +matches[2];
                var day = +matches[3];
                return month >= 1 && month <= 12 && day >= 1 &&
                    day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
            }
            function time(str, full) {
                var matches = str.match(TIME);
                if (!matches)
                    return false;
                var hour = matches[1];
                var minute = matches[2];
                var second = matches[3];
                var timeZone = matches[5];
                return ((hour <= 23 && minute <= 59 && second <= 59) ||
                    (hour == 23 && minute == 59 && second == 60)) &&
                    (!full || timeZone);
            }
            var DATE_TIME_SEPARATOR = /t|\s/i;
            function date_time(str) {
                // http://tools.ietf.org/html/rfc3339#section-5.6
                var dateTime = str.split(DATE_TIME_SEPARATOR);
                return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
            }
            function hostname(str) {
                // https://tools.ietf.org/html/rfc1034#section-3.5
                // https://tools.ietf.org/html/rfc1123#section-2
                return str.length <= 255 && HOSTNAME.test(str);
            }
            var NOT_URI_FRAGMENT = /\/|:/;
            function uri(str) {
                // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
                return NOT_URI_FRAGMENT.test(str) && URI.test(str);
            }
            var Z_ANCHOR = /[^\\]\\Z/;
            function regex(str) {
                if (Z_ANCHOR.test(str))
                    return false;
                try {
                    new RegExp(str);
                    return true;
                }
                catch (e) {
                    return false;
                }
            }
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/compile/index.js": 
        /*!***********************************************!*\
          !*** ./node_modules/ajv/lib/compile/index.js ***!
          \***********************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var resolve = __webpack_require__(/*! ./resolve */ "./node_modules/ajv/lib/compile/resolve.js"), util = __webpack_require__(/*! ./util */ "./node_modules/ajv/lib/compile/util.js"), errorClasses = __webpack_require__(/*! ./error_classes */ "./node_modules/ajv/lib/compile/error_classes.js"), stableStringify = __webpack_require__(/*! fast-json-stable-stringify */ "./node_modules/fast-json-stable-stringify/index.js");
            var validateGenerator = __webpack_require__(/*! ../dotjs/validate */ "./node_modules/ajv/lib/dotjs/validate.js");
            /**
             * Functions below are used inside compiled validations function
             */
            var ucs2length = util.ucs2length;
            var equal = __webpack_require__(/*! fast-deep-equal */ "./node_modules/fast-deep-equal/index.js");
            // this error is thrown by async schemas to return validation errors via exception
            var ValidationError = errorClasses.Validation;
            module.exports = compile;
            /**
             * Compiles schema to validation function
             * @this   Ajv
             * @param  {Object} schema schema object
             * @param  {Object} root object with information about the root schema for this schema
             * @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
             * @param  {String} baseId base ID for IDs in the schema
             * @return {Function} validation function
             */
            function compile(schema, root, localRefs, baseId) {
                /* jshint validthis: true, evil: true */
                /* eslint no-shadow: 0 */
                var self = this, opts = this._opts, refVal = [undefined], refs = {}, patterns = [], patternsHash = {}, defaults = [], defaultsHash = {}, customRules = [];
                root = root || { schema: schema, refVal: refVal, refs: refs };
                var c = checkCompiling.call(this, schema, root, baseId);
                var compilation = this._compilations[c.index];
                if (c.compiling)
                    return (compilation.callValidate = callValidate);
                var formats = this._formats;
                var RULES = this.RULES;
                try {
                    var v = localCompile(schema, root, localRefs, baseId);
                    compilation.validate = v;
                    var cv = compilation.callValidate;
                    if (cv) {
                        cv.schema = v.schema;
                        cv.errors = null;
                        cv.refs = v.refs;
                        cv.refVal = v.refVal;
                        cv.root = v.root;
                        cv.$async = v.$async;
                        if (opts.sourceCode)
                            cv.source = v.source;
                    }
                    return v;
                }
                finally {
                    endCompiling.call(this, schema, root, baseId);
                }
                /* @this   {*} - custom context, see passContext option */
                function callValidate() {
                    /* jshint validthis: true */
                    var validate = compilation.validate;
                    var result = validate.apply(this, arguments);
                    callValidate.errors = validate.errors;
                    return result;
                }
                function localCompile(_schema, _root, localRefs, baseId) {
                    var isRoot = !_root || (_root && _root.schema == _schema);
                    if (_root.schema != root.schema)
                        return compile.call(self, _schema, _root, localRefs, baseId);
                    var $async = _schema.$async === true;
                    var sourceCode = validateGenerator({
                        isTop: true,
                        schema: _schema,
                        isRoot: isRoot,
                        baseId: baseId,
                        root: _root,
                        schemaPath: '',
                        errSchemaPath: '#',
                        errorPath: '""',
                        MissingRefError: errorClasses.MissingRef,
                        RULES: RULES,
                        validate: validateGenerator,
                        util: util,
                        resolve: resolve,
                        resolveRef: resolveRef,
                        usePattern: usePattern,
                        useDefault: useDefault,
                        useCustomRule: useCustomRule,
                        opts: opts,
                        formats: formats,
                        logger: self.logger,
                        self: self
                    });
                    sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode)
                        + vars(defaults, defaultCode) + vars(customRules, customRuleCode)
                        + sourceCode;
                    if (opts.processCode)
                        sourceCode = opts.processCode(sourceCode);
                    // console.log('\n\n\n *** \n', JSON.stringify(sourceCode));
                    var validate;
                    try {
                        var makeValidate = new Function('self', 'RULES', 'formats', 'root', 'refVal', 'defaults', 'customRules', 'equal', 'ucs2length', 'ValidationError', sourceCode);
                        validate = makeValidate(self, RULES, formats, root, refVal, defaults, customRules, equal, ucs2length, ValidationError);
                        refVal[0] = validate;
                    }
                    catch (e) {
                        self.logger.error('Error compiling schema, function code:', sourceCode);
                        throw e;
                    }
                    validate.schema = _schema;
                    validate.errors = null;
                    validate.refs = refs;
                    validate.refVal = refVal;
                    validate.root = isRoot ? validate : _root;
                    if ($async)
                        validate.$async = true;
                    if (opts.sourceCode === true) {
                        validate.source = {
                            code: sourceCode,
                            patterns: patterns,
                            defaults: defaults
                        };
                    }
                    return validate;
                }
                function resolveRef(baseId, ref, isRoot) {
                    ref = resolve.url(baseId, ref);
                    var refIndex = refs[ref];
                    var _refVal, refCode;
                    if (refIndex !== undefined) {
                        _refVal = refVal[refIndex];
                        refCode = 'refVal[' + refIndex + ']';
                        return resolvedRef(_refVal, refCode);
                    }
                    if (!isRoot && root.refs) {
                        var rootRefId = root.refs[ref];
                        if (rootRefId !== undefined) {
                            _refVal = root.refVal[rootRefId];
                            refCode = addLocalRef(ref, _refVal);
                            return resolvedRef(_refVal, refCode);
                        }
                    }
                    refCode = addLocalRef(ref);
                    var v = resolve.call(self, localCompile, root, ref);
                    if (v === undefined) {
                        var localSchema = localRefs && localRefs[ref];
                        if (localSchema) {
                            v = resolve.inlineRef(localSchema, opts.inlineRefs)
                                ? localSchema
                                : compile.call(self, localSchema, root, localRefs, baseId);
                        }
                    }
                    if (v === undefined) {
                        removeLocalRef(ref);
                    }
                    else {
                        replaceLocalRef(ref, v);
                        return resolvedRef(v, refCode);
                    }
                }
                function addLocalRef(ref, v) {
                    var refId = refVal.length;
                    refVal[refId] = v;
                    refs[ref] = refId;
                    return 'refVal' + refId;
                }
                function removeLocalRef(ref) {
                    delete refs[ref];
                }
                function replaceLocalRef(ref, v) {
                    var refId = refs[ref];
                    refVal[refId] = v;
                }
                function resolvedRef(refVal, code) {
                    return typeof refVal == 'object' || typeof refVal == 'boolean'
                        ? { code: code, schema: refVal, inline: true }
                        : { code: code, $async: refVal && !!refVal.$async };
                }
                function usePattern(regexStr) {
                    var index = patternsHash[regexStr];
                    if (index === undefined) {
                        index = patternsHash[regexStr] = patterns.length;
                        patterns[index] = regexStr;
                    }
                    return 'pattern' + index;
                }
                function useDefault(value) {
                    switch (typeof value) {
                        case 'boolean':
                        case 'number':
                            return '' + value;
                        case 'string':
                            return util.toQuotedString(value);
                        case 'object':
                            if (value === null)
                                return 'null';
                            var valueStr = stableStringify(value);
                            var index = defaultsHash[valueStr];
                            if (index === undefined) {
                                index = defaultsHash[valueStr] = defaults.length;
                                defaults[index] = value;
                            }
                            return 'default' + index;
                    }
                }
                function useCustomRule(rule, schema, parentSchema, it) {
                    if (self._opts.validateSchema !== false) {
                        var deps = rule.definition.dependencies;
                        if (deps && !deps.every(function (keyword) {
                            return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
                        }))
                            throw new Error('parent schema must have all required keywords: ' + deps.join(','));
                        var validateSchema = rule.definition.validateSchema;
                        if (validateSchema) {
                            var valid = validateSchema(schema);
                            if (!valid) {
                                var message = 'keyword schema is invalid: ' + self.errorsText(validateSchema.errors);
                                if (self._opts.validateSchema == 'log')
                                    self.logger.error(message);
                                else
                                    throw new Error(message);
                            }
                        }
                    }
                    var compile = rule.definition.compile, inline = rule.definition.inline, macro = rule.definition.macro;
                    var validate;
                    if (compile) {
                        validate = compile.call(self, schema, parentSchema, it);
                    }
                    else if (macro) {
                        validate = macro.call(self, schema, parentSchema, it);
                        if (opts.validateSchema !== false)
                            self.validateSchema(validate, true);
                    }
                    else if (inline) {
                        validate = inline.call(self, it, rule.keyword, schema, parentSchema);
                    }
                    else {
                        validate = rule.definition.validate;
                        if (!validate)
                            return;
                    }
                    if (validate === undefined)
                        throw new Error('custom keyword "' + rule.keyword + '"failed to compile');
                    var index = customRules.length;
                    customRules[index] = validate;
                    return {
                        code: 'customRule' + index,
                        validate: validate
                    };
                }
            }
            /**
             * Checks if the schema is currently compiled
             * @this   Ajv
             * @param  {Object} schema schema to compile
             * @param  {Object} root root object
             * @param  {String} baseId base schema ID
             * @return {Object} object with properties "index" (compilation index) and "compiling" (boolean)
             */
            function checkCompiling(schema, root, baseId) {
                /* jshint validthis: true */
                var index = compIndex.call(this, schema, root, baseId);
                if (index >= 0)
                    return { index: index, compiling: true };
                index = this._compilations.length;
                this._compilations[index] = {
                    schema: schema,
                    root: root,
                    baseId: baseId
                };
                return { index: index, compiling: false };
            }
            /**
             * Removes the schema from the currently compiled list
             * @this   Ajv
             * @param  {Object} schema schema to compile
             * @param  {Object} root root object
             * @param  {String} baseId base schema ID
             */
            function endCompiling(schema, root, baseId) {
                /* jshint validthis: true */
                var i = compIndex.call(this, schema, root, baseId);
                if (i >= 0)
                    this._compilations.splice(i, 1);
            }
            /**
             * Index of schema compilation in the currently compiled list
             * @this   Ajv
             * @param  {Object} schema schema to compile
             * @param  {Object} root root object
             * @param  {String} baseId base schema ID
             * @return {Integer} compilation index
             */
            function compIndex(schema, root, baseId) {
                /* jshint validthis: true */
                for (var i = 0; i < this._compilations.length; i++) {
                    var c = this._compilations[i];
                    if (c.schema == schema && c.root == root && c.baseId == baseId)
                        return i;
                }
                return -1;
            }
            function patternCode(i, patterns) {
                return 'var pattern' + i + ' = new RegExp(' + util.toQuotedString(patterns[i]) + ');';
            }
            function defaultCode(i) {
                return 'var default' + i + ' = defaults[' + i + '];';
            }
            function refValCode(i, refVal) {
                return refVal[i] === undefined ? '' : 'var refVal' + i + ' = refVal[' + i + '];';
            }
            function customRuleCode(i) {
                return 'var customRule' + i + ' = customRules[' + i + '];';
            }
            function vars(arr, statement) {
                if (!arr.length)
                    return '';
                var code = '';
                for (var i = 0; i < arr.length; i++)
                    code += statement(i, arr);
                return code;
            }
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/compile/resolve.js": 
        /*!*************************************************!*\
          !*** ./node_modules/ajv/lib/compile/resolve.js ***!
          \*************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var URI = __webpack_require__(/*! uri-js */ "./node_modules/uri-js/dist/es5/uri.all.js"), equal = __webpack_require__(/*! fast-deep-equal */ "./node_modules/fast-deep-equal/index.js"), util = __webpack_require__(/*! ./util */ "./node_modules/ajv/lib/compile/util.js"), SchemaObject = __webpack_require__(/*! ./schema_obj */ "./node_modules/ajv/lib/compile/schema_obj.js"), traverse = __webpack_require__(/*! json-schema-traverse */ "./node_modules/json-schema-traverse/index.js");
            module.exports = resolve;
            resolve.normalizeId = normalizeId;
            resolve.fullPath = getFullPath;
            resolve.url = resolveUrl;
            resolve.ids = resolveIds;
            resolve.inlineRef = inlineRef;
            resolve.schema = resolveSchema;
            /**
             * [resolve and compile the references ($ref)]
             * @this   Ajv
             * @param  {Function} compile reference to schema compilation funciton (localCompile)
             * @param  {Object} root object with information about the root schema for the current schema
             * @param  {String} ref reference to resolve
             * @return {Object|Function} schema object (if the schema can be inlined) or validation function
             */
            function resolve(compile, root, ref) {
                /* jshint validthis: true */
                var refVal = this._refs[ref];
                if (typeof refVal == 'string') {
                    if (this._refs[refVal])
                        refVal = this._refs[refVal];
                    else
                        return resolve.call(this, compile, root, refVal);
                }
                refVal = refVal || this._schemas[ref];
                if (refVal instanceof SchemaObject) {
                    return inlineRef(refVal.schema, this._opts.inlineRefs)
                        ? refVal.schema
                        : refVal.validate || this._compile(refVal);
                }
                var res = resolveSchema.call(this, root, ref);
                var schema, v, baseId;
                if (res) {
                    schema = res.schema;
                    root = res.root;
                    baseId = res.baseId;
                }
                if (schema instanceof SchemaObject) {
                    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
                }
                else if (schema !== undefined) {
                    v = inlineRef(schema, this._opts.inlineRefs)
                        ? schema
                        : compile.call(this, schema, root, undefined, baseId);
                }
                return v;
            }
            /**
             * Resolve schema, its root and baseId
             * @this Ajv
             * @param  {Object} root root object with properties schema, refVal, refs
             * @param  {String} ref  reference to resolve
             * @return {Object} object with properties schema, root, baseId
             */
            function resolveSchema(root, ref) {
                /* jshint validthis: true */
                var p = URI.parse(ref), refPath = _getFullPath(p), baseId = getFullPath(this._getId(root.schema));
                if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
                    var id = normalizeId(refPath);
                    var refVal = this._refs[id];
                    if (typeof refVal == 'string') {
                        return resolveRecursive.call(this, root, refVal, p);
                    }
                    else if (refVal instanceof SchemaObject) {
                        if (!refVal.validate)
                            this._compile(refVal);
                        root = refVal;
                    }
                    else {
                        refVal = this._schemas[id];
                        if (refVal instanceof SchemaObject) {
                            if (!refVal.validate)
                                this._compile(refVal);
                            if (id == normalizeId(ref))
                                return { schema: refVal, root: root, baseId: baseId };
                            root = refVal;
                        }
                        else {
                            return;
                        }
                    }
                    if (!root.schema)
                        return;
                    baseId = getFullPath(this._getId(root.schema));
                }
                return getJsonPointer.call(this, p, baseId, root.schema, root);
            }
            /* @this Ajv */
            function resolveRecursive(root, ref, parsedRef) {
                /* jshint validthis: true */
                var res = resolveSchema.call(this, root, ref);
                if (res) {
                    var schema = res.schema;
                    var baseId = res.baseId;
                    root = res.root;
                    var id = this._getId(schema);
                    if (id)
                        baseId = resolveUrl(baseId, id);
                    return getJsonPointer.call(this, parsedRef, baseId, schema, root);
                }
            }
            var PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);
            /* @this Ajv */
            function getJsonPointer(parsedRef, baseId, schema, root) {
                /* jshint validthis: true */
                parsedRef.fragment = parsedRef.fragment || '';
                if (parsedRef.fragment.slice(0, 1) != '/')
                    return;
                var parts = parsedRef.fragment.split('/');
                for (var i = 1; i < parts.length; i++) {
                    var part = parts[i];
                    if (part) {
                        part = util.unescapeFragment(part);
                        schema = schema[part];
                        if (schema === undefined)
                            break;
                        var id;
                        if (!PREVENT_SCOPE_CHANGE[part]) {
                            id = this._getId(schema);
                            if (id)
                                baseId = resolveUrl(baseId, id);
                            if (schema.$ref) {
                                var $ref = resolveUrl(baseId, schema.$ref);
                                var res = resolveSchema.call(this, root, $ref);
                                if (res) {
                                    schema = res.schema;
                                    root = res.root;
                                    baseId = res.baseId;
                                }
                            }
                        }
                    }
                }
                if (schema !== undefined && schema !== root.schema)
                    return { schema: schema, root: root, baseId: baseId };
            }
            var SIMPLE_INLINED = util.toHash([
                'type', 'format', 'pattern',
                'maxLength', 'minLength',
                'maxProperties', 'minProperties',
                'maxItems', 'minItems',
                'maximum', 'minimum',
                'uniqueItems', 'multipleOf',
                'required', 'enum'
            ]);
            function inlineRef(schema, limit) {
                if (limit === false)
                    return false;
                if (limit === undefined || limit === true)
                    return checkNoRef(schema);
                else if (limit)
                    return countKeys(schema) <= limit;
            }
            function checkNoRef(schema) {
                var item;
                if (Array.isArray(schema)) {
                    for (var i = 0; i < schema.length; i++) {
                        item = schema[i];
                        if (typeof item == 'object' && !checkNoRef(item))
                            return false;
                    }
                }
                else {
                    for (var key in schema) {
                        if (key == '$ref')
                            return false;
                        item = schema[key];
                        if (typeof item == 'object' && !checkNoRef(item))
                            return false;
                    }
                }
                return true;
            }
            function countKeys(schema) {
                var count = 0, item;
                if (Array.isArray(schema)) {
                    for (var i = 0; i < schema.length; i++) {
                        item = schema[i];
                        if (typeof item == 'object')
                            count += countKeys(item);
                        if (count == Infinity)
                            return Infinity;
                    }
                }
                else {
                    for (var key in schema) {
                        if (key == '$ref')
                            return Infinity;
                        if (SIMPLE_INLINED[key]) {
                            count++;
                        }
                        else {
                            item = schema[key];
                            if (typeof item == 'object')
                                count += countKeys(item) + 1;
                            if (count == Infinity)
                                return Infinity;
                        }
                    }
                }
                return count;
            }
            function getFullPath(id, normalize) {
                if (normalize !== false)
                    id = normalizeId(id);
                var p = URI.parse(id);
                return _getFullPath(p);
            }
            function _getFullPath(p) {
                return URI.serialize(p).split('#')[0] + '#';
            }
            var TRAILING_SLASH_HASH = /#\/?$/;
            function normalizeId(id) {
                return id ? id.replace(TRAILING_SLASH_HASH, '') : '';
            }
            function resolveUrl(baseId, id) {
                id = normalizeId(id);
                return URI.resolve(baseId, id);
            }
            /* @this Ajv */
            function resolveIds(schema) {
                var schemaId = normalizeId(this._getId(schema));
                var baseIds = { '': schemaId };
                var fullPaths = { '': getFullPath(schemaId, false) };
                var localRefs = {};
                var self = this;
                traverse(schema, { allKeys: true }, function (sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
                    if (jsonPtr === '')
                        return;
                    var id = self._getId(sch);
                    var baseId = baseIds[parentJsonPtr];
                    var fullPath = fullPaths[parentJsonPtr] + '/' + parentKeyword;
                    if (keyIndex !== undefined)
                        fullPath += '/' + (typeof keyIndex == 'number' ? keyIndex : util.escapeFragment(keyIndex));
                    if (typeof id == 'string') {
                        id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);
                        var refVal = self._refs[id];
                        if (typeof refVal == 'string')
                            refVal = self._refs[refVal];
                        if (refVal && refVal.schema) {
                            if (!equal(sch, refVal.schema))
                                throw new Error('id "' + id + '" resolves to more than one schema');
                        }
                        else if (id != normalizeId(fullPath)) {
                            if (id[0] == '#') {
                                if (localRefs[id] && !equal(sch, localRefs[id]))
                                    throw new Error('id "' + id + '" resolves to more than one schema');
                                localRefs[id] = sch;
                            }
                            else {
                                self._refs[id] = fullPath;
                            }
                        }
                    }
                    baseIds[jsonPtr] = baseId;
                    fullPaths[jsonPtr] = fullPath;
                });
                return localRefs;
            }
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/compile/rules.js": 
        /*!***********************************************!*\
          !*** ./node_modules/ajv/lib/compile/rules.js ***!
          \***********************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var ruleModules = __webpack_require__(/*! ../dotjs */ "./node_modules/ajv/lib/dotjs/index.js"), toHash = __webpack_require__(/*! ./util */ "./node_modules/ajv/lib/compile/util.js").toHash;
            module.exports = function rules() {
                var RULES = [
                    { type: 'number',
                        rules: [{ 'maximum': ['exclusiveMaximum'] },
                            { 'minimum': ['exclusiveMinimum'] }, 'multipleOf', 'format'] },
                    { type: 'string',
                        rules: ['maxLength', 'minLength', 'pattern', 'format'] },
                    { type: 'array',
                        rules: ['maxItems', 'minItems', 'items', 'contains', 'uniqueItems'] },
                    { type: 'object',
                        rules: ['maxProperties', 'minProperties', 'required', 'dependencies', 'propertyNames',
                            { 'properties': ['additionalProperties', 'patternProperties'] }] },
                    { rules: ['$ref', 'const', 'enum', 'not', 'anyOf', 'oneOf', 'allOf', 'if'] }
                ];
                var ALL = ['type', '$comment'];
                var KEYWORDS = [
                    '$schema', '$id', 'id', '$data', '$async', 'title',
                    'description', 'default', 'definitions',
                    'examples', 'readOnly', 'writeOnly',
                    'contentMediaType', 'contentEncoding',
                    'additionalItems', 'then', 'else'
                ];
                var TYPES = ['number', 'integer', 'string', 'array', 'object', 'boolean', 'null'];
                RULES.all = toHash(ALL);
                RULES.types = toHash(TYPES);
                RULES.forEach(function (group) {
                    group.rules = group.rules.map(function (keyword) {
                        var implKeywords;
                        if (typeof keyword == 'object') {
                            var key = Object.keys(keyword)[0];
                            implKeywords = keyword[key];
                            keyword = key;
                            implKeywords.forEach(function (k) {
                                ALL.push(k);
                                RULES.all[k] = true;
                            });
                        }
                        ALL.push(keyword);
                        var rule = RULES.all[keyword] = {
                            keyword: keyword,
                            code: ruleModules[keyword],
                            implements: implKeywords
                        };
                        return rule;
                    });
                    RULES.all.$comment = {
                        keyword: '$comment',
                        code: ruleModules.$comment
                    };
                    if (group.type)
                        RULES.types[group.type] = group;
                });
                RULES.keywords = toHash(ALL.concat(KEYWORDS));
                RULES.custom = {};
                return RULES;
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/compile/schema_obj.js": 
        /*!****************************************************!*\
          !*** ./node_modules/ajv/lib/compile/schema_obj.js ***!
          \****************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var util = __webpack_require__(/*! ./util */ "./node_modules/ajv/lib/compile/util.js");
            module.exports = SchemaObject;
            function SchemaObject(obj) {
                util.copy(obj, this);
            }
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/compile/ucs2length.js": 
        /*!****************************************************!*\
          !*** ./node_modules/ajv/lib/compile/ucs2length.js ***!
          \****************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            // https://mathiasbynens.be/notes/javascript-encoding
            // https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
            module.exports = function ucs2length(str) {
                var length = 0, len = str.length, pos = 0, value;
                while (pos < len) {
                    length++;
                    value = str.charCodeAt(pos++);
                    if (value >= 0xD800 && value <= 0xDBFF && pos < len) {
                        // high surrogate, and there is a next character
                        value = str.charCodeAt(pos);
                        if ((value & 0xFC00) == 0xDC00)
                            pos++; // low surrogate
                    }
                }
                return length;
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/compile/util.js": 
        /*!**********************************************!*\
          !*** ./node_modules/ajv/lib/compile/util.js ***!
          \**********************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            module.exports = {
                copy: copy,
                checkDataType: checkDataType,
                checkDataTypes: checkDataTypes,
                coerceToTypes: coerceToTypes,
                toHash: toHash,
                getProperty: getProperty,
                escapeQuotes: escapeQuotes,
                equal: __webpack_require__(/*! fast-deep-equal */ "./node_modules/fast-deep-equal/index.js"),
                ucs2length: __webpack_require__(/*! ./ucs2length */ "./node_modules/ajv/lib/compile/ucs2length.js"),
                varOccurences: varOccurences,
                varReplace: varReplace,
                cleanUpCode: cleanUpCode,
                finalCleanUpCode: finalCleanUpCode,
                schemaHasRules: schemaHasRules,
                schemaHasRulesExcept: schemaHasRulesExcept,
                schemaUnknownRules: schemaUnknownRules,
                toQuotedString: toQuotedString,
                getPathExpr: getPathExpr,
                getPath: getPath,
                getData: getData,
                unescapeFragment: unescapeFragment,
                unescapeJsonPointer: unescapeJsonPointer,
                escapeFragment: escapeFragment,
                escapeJsonPointer: escapeJsonPointer
            };
            function copy(o, to) {
                to = to || {};
                for (var key in o)
                    to[key] = o[key];
                return to;
            }
            function checkDataType(dataType, data, negate) {
                var EQUAL = negate ? ' !== ' : ' === ', AND = negate ? ' || ' : ' && ', OK = negate ? '!' : '', NOT = negate ? '' : '!';
                switch (dataType) {
                    case 'null': return data + EQUAL + 'null';
                    case 'array': return OK + 'Array.isArray(' + data + ')';
                    case 'object': return '(' + OK + data + AND +
                        'typeof ' + data + EQUAL + '"object"' + AND +
                        NOT + 'Array.isArray(' + data + '))';
                    case 'integer': return '(typeof ' + data + EQUAL + '"number"' + AND +
                        NOT + '(' + data + ' % 1)' +
                        AND + data + EQUAL + data + ')';
                    default: return 'typeof ' + data + EQUAL + '"' + dataType + '"';
                }
            }
            function checkDataTypes(dataTypes, data) {
                switch (dataTypes.length) {
                    case 1: return checkDataType(dataTypes[0], data, true);
                    default:
                        var code = '';
                        var types = toHash(dataTypes);
                        if (types.array && types.object) {
                            code = types.null ? '(' : '(!' + data + ' || ';
                            code += 'typeof ' + data + ' !== "object")';
                            delete types.null;
                            delete types.array;
                            delete types.object;
                        }
                        if (types.number)
                            delete types.integer;
                        for (var t in types)
                            code += (code ? ' && ' : '') + checkDataType(t, data, true);
                        return code;
                }
            }
            var COERCE_TO_TYPES = toHash(['string', 'number', 'integer', 'boolean', 'null']);
            function coerceToTypes(optionCoerceTypes, dataTypes) {
                if (Array.isArray(dataTypes)) {
                    var types = [];
                    for (var i = 0; i < dataTypes.length; i++) {
                        var t = dataTypes[i];
                        if (COERCE_TO_TYPES[t])
                            types[types.length] = t;
                        else if (optionCoerceTypes === 'array' && t === 'array')
                            types[types.length] = t;
                    }
                    if (types.length)
                        return types;
                }
                else if (COERCE_TO_TYPES[dataTypes]) {
                    return [dataTypes];
                }
                else if (optionCoerceTypes === 'array' && dataTypes === 'array') {
                    return ['array'];
                }
            }
            function toHash(arr) {
                var hash = {};
                for (var i = 0; i < arr.length; i++)
                    hash[arr[i]] = true;
                return hash;
            }
            var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
            var SINGLE_QUOTE = /'|\\/g;
            function getProperty(key) {
                return typeof key == 'number'
                    ? '[' + key + ']'
                    : IDENTIFIER.test(key)
                        ? '.' + key
                        : "['" + escapeQuotes(key) + "']";
            }
            function escapeQuotes(str) {
                return str.replace(SINGLE_QUOTE, '\\$&')
                    .replace(/\n/g, '\\n')
                    .replace(/\r/g, '\\r')
                    .replace(/\f/g, '\\f')
                    .replace(/\t/g, '\\t');
            }
            function varOccurences(str, dataVar) {
                dataVar += '[^0-9]';
                var matches = str.match(new RegExp(dataVar, 'g'));
                return matches ? matches.length : 0;
            }
            function varReplace(str, dataVar, expr) {
                dataVar += '([^0-9])';
                expr = expr.replace(/\$/g, '$$$$');
                return str.replace(new RegExp(dataVar, 'g'), expr + '$1');
            }
            var EMPTY_ELSE = /else\s*{\s*}/g, EMPTY_IF_NO_ELSE = /if\s*\([^)]+\)\s*\{\s*\}(?!\s*else)/g, EMPTY_IF_WITH_ELSE = /if\s*\(([^)]+)\)\s*\{\s*\}\s*else(?!\s*if)/g;
            function cleanUpCode(out) {
                return out.replace(EMPTY_ELSE, '')
                    .replace(EMPTY_IF_NO_ELSE, '')
                    .replace(EMPTY_IF_WITH_ELSE, 'if (!($1))');
            }
            var ERRORS_REGEXP = /[^v.]errors/g, REMOVE_ERRORS = /var errors = 0;|var vErrors = null;|validate.errors = vErrors;/g, REMOVE_ERRORS_ASYNC = /var errors = 0;|var vErrors = null;/g, RETURN_VALID = 'return errors === 0;', RETURN_TRUE = 'validate.errors = null; return true;', RETURN_ASYNC = /if \(errors === 0\) return data;\s*else throw new ValidationError\(vErrors\);/, RETURN_DATA_ASYNC = 'return data;', ROOTDATA_REGEXP = /[^A-Za-z_$]rootData[^A-Za-z0-9_$]/g, REMOVE_ROOTDATA = /if \(rootData === undefined\) rootData = data;/;
            function finalCleanUpCode(out, async) {
                var matches = out.match(ERRORS_REGEXP);
                if (matches && matches.length == 2) {
                    out = async
                        ? out.replace(REMOVE_ERRORS_ASYNC, '')
                            .replace(RETURN_ASYNC, RETURN_DATA_ASYNC)
                        : out.replace(REMOVE_ERRORS, '')
                            .replace(RETURN_VALID, RETURN_TRUE);
                }
                matches = out.match(ROOTDATA_REGEXP);
                if (!matches || matches.length !== 3)
                    return out;
                return out.replace(REMOVE_ROOTDATA, '');
            }
            function schemaHasRules(schema, rules) {
                if (typeof schema == 'boolean')
                    return !schema;
                for (var key in schema)
                    if (rules[key])
                        return true;
            }
            function schemaHasRulesExcept(schema, rules, exceptKeyword) {
                if (typeof schema == 'boolean')
                    return !schema && exceptKeyword != 'not';
                for (var key in schema)
                    if (key != exceptKeyword && rules[key])
                        return true;
            }
            function schemaUnknownRules(schema, rules) {
                if (typeof schema == 'boolean')
                    return;
                for (var key in schema)
                    if (!rules[key])
                        return key;
            }
            function toQuotedString(str) {
                return '\'' + escapeQuotes(str) + '\'';
            }
            function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
                var path = jsonPointers // false by default
                    ? '\'/\' + ' + expr + (isNumber ? '' : '.replace(/~/g, \'~0\').replace(/\\//g, \'~1\')')
                    : (isNumber ? '\'[\' + ' + expr + ' + \']\'' : '\'[\\\'\' + ' + expr + ' + \'\\\']\'');
                return joinPaths(currentPath, path);
            }
            function getPath(currentPath, prop, jsonPointers) {
                var path = jsonPointers // false by default
                    ? toQuotedString('/' + escapeJsonPointer(prop))
                    : toQuotedString(getProperty(prop));
                return joinPaths(currentPath, path);
            }
            var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
            var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
            function getData($data, lvl, paths) {
                var up, jsonPointer, data, matches;
                if ($data === '')
                    return 'rootData';
                if ($data[0] == '/') {
                    if (!JSON_POINTER.test($data))
                        throw new Error('Invalid JSON-pointer: ' + $data);
                    jsonPointer = $data;
                    data = 'rootData';
                }
                else {
                    matches = $data.match(RELATIVE_JSON_POINTER);
                    if (!matches)
                        throw new Error('Invalid JSON-pointer: ' + $data);
                    up = +matches[1];
                    jsonPointer = matches[2];
                    if (jsonPointer == '#') {
                        if (up >= lvl)
                            throw new Error('Cannot access property/index ' + up + ' levels up, current level is ' + lvl);
                        return paths[lvl - up];
                    }
                    if (up > lvl)
                        throw new Error('Cannot access data ' + up + ' levels up, current level is ' + lvl);
                    data = 'data' + ((lvl - up) || '');
                    if (!jsonPointer)
                        return data;
                }
                var expr = data;
                var segments = jsonPointer.split('/');
                for (var i = 0; i < segments.length; i++) {
                    var segment = segments[i];
                    if (segment) {
                        data += getProperty(unescapeJsonPointer(segment));
                        expr += ' && ' + data;
                    }
                }
                return expr;
            }
            function joinPaths(a, b) {
                if (a == '""')
                    return b;
                return (a + ' + ' + b).replace(/' \+ '/g, '');
            }
            function unescapeFragment(str) {
                return unescapeJsonPointer(decodeURIComponent(str));
            }
            function escapeFragment(str) {
                return encodeURIComponent(escapeJsonPointer(str));
            }
            function escapeJsonPointer(str) {
                return str.replace(/~/g, '~0').replace(/\//g, '~1');
            }
            function unescapeJsonPointer(str) {
                return str.replace(/~1/g, '/').replace(/~0/g, '~');
            }
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/data.js": 
        /*!**************************************!*\
          !*** ./node_modules/ajv/lib/data.js ***!
          \**************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var KEYWORDS = [
                'multipleOf',
                'maximum',
                'exclusiveMaximum',
                'minimum',
                'exclusiveMinimum',
                'maxLength',
                'minLength',
                'pattern',
                'additionalItems',
                'maxItems',
                'minItems',
                'uniqueItems',
                'maxProperties',
                'minProperties',
                'required',
                'additionalProperties',
                'enum',
                'format',
                'const'
            ];
            module.exports = function (metaSchema, keywordsJsonPointers) {
                for (var i = 0; i < keywordsJsonPointers.length; i++) {
                    metaSchema = JSON.parse(JSON.stringify(metaSchema));
                    var segments = keywordsJsonPointers[i].split('/');
                    var keywords = metaSchema;
                    var j;
                    for (j = 1; j < segments.length; j++)
                        keywords = keywords[segments[j]];
                    for (j = 0; j < KEYWORDS.length; j++) {
                        var key = KEYWORDS[j];
                        var schema = keywords[key];
                        if (schema) {
                            keywords[key] = {
                                anyOf: [
                                    schema,
                                    { $ref: 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#' }
                                ]
                            };
                        }
                    }
                }
                return metaSchema;
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/definition_schema.js": 
        /*!***************************************************!*\
          !*** ./node_modules/ajv/lib/definition_schema.js ***!
          \***************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var metaSchema = __webpack_require__(/*! ./refs/json-schema-draft-07.json */ "./node_modules/ajv/lib/refs/json-schema-draft-07.json");
            module.exports = {
                $id: 'https://github.com/epoberezkin/ajv/blob/master/lib/definition_schema.js',
                definitions: {
                    simpleTypes: metaSchema.definitions.simpleTypes
                },
                type: 'object',
                dependencies: {
                    schema: ['validate'],
                    $data: ['validate'],
                    statements: ['inline'],
                    valid: { not: { required: ['macro'] } }
                },
                properties: {
                    type: metaSchema.properties.type,
                    schema: { type: 'boolean' },
                    statements: { type: 'boolean' },
                    dependencies: {
                        type: 'array',
                        items: { type: 'string' }
                    },
                    metaSchema: { type: 'object' },
                    modifying: { type: 'boolean' },
                    valid: { type: 'boolean' },
                    $data: { type: 'boolean' },
                    async: { type: 'boolean' },
                    errors: {
                        anyOf: [
                            { type: 'boolean' },
                            { const: 'full' }
                        ]
                    }
                }
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/dotjs/_limit.js": 
        /*!**********************************************!*\
          !*** ./node_modules/ajv/lib/dotjs/_limit.js ***!
          \**********************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            module.exports = function generate__limit(it, $keyword, $ruleType) {
                var out = ' ';
                var $lvl = it.level;
                var $dataLvl = it.dataLevel;
                var $schema = it.schema[$keyword];
                var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
                var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
                var $breakOnError = !it.opts.allErrors;
                var $errorKeyword;
                var $data = 'data' + ($dataLvl || '');
                var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
                if ($isData) {
                    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
                    $schemaValue = 'schema' + $lvl;
                }
                else {
                    $schemaValue = $schema;
                }
                var $isMax = $keyword == 'maximum', $exclusiveKeyword = $isMax ? 'exclusiveMaximum' : 'exclusiveMinimum', $schemaExcl = it.schema[$exclusiveKeyword], $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data, $op = $isMax ? '<' : '>', $notOp = $isMax ? '>' : '<', $errorKeyword = undefined;
                if ($isDataExcl) {
                    var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr), $exclusive = 'exclusive' + $lvl, $exclType = 'exclType' + $lvl, $exclIsNumber = 'exclIsNumber' + $lvl, $opExpr = 'op' + $lvl, $opStr = '\' + ' + $opExpr + ' + \'';
                    out += ' var schemaExcl' + ($lvl) + ' = ' + ($schemaValueExcl) + '; ';
                    $schemaValueExcl = 'schemaExcl' + $lvl;
                    out += ' var ' + ($exclusive) + '; var ' + ($exclType) + ' = typeof ' + ($schemaValueExcl) + '; if (' + ($exclType) + ' != \'boolean\' && ' + ($exclType) + ' != \'undefined\' && ' + ($exclType) + ' != \'number\') { ';
                    var $errorKeyword = $exclusiveKeyword;
                    var $$outStack = $$outStack || [];
                    $$outStack.push(out);
                    out = ''; /* istanbul ignore else */
                    if (it.createErrors !== false) {
                        out += ' { keyword: \'' + ($errorKeyword || '_exclusiveLimit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
                        if (it.opts.messages !== false) {
                            out += ' , message: \'' + ($exclusiveKeyword) + ' should be boolean\' ';
                        }
                        if (it.opts.verbose) {
                            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                        }
                        out += ' } ';
                    }
                    else {
                        out += ' {} ';
                    }
                    var __err = out;
                    out = $$outStack.pop();
                    if (!it.compositeRule && $breakOnError) {
                        /* istanbul ignore if */
                        if (it.async) {
                            out += ' throw new ValidationError([' + (__err) + ']); ';
                        }
                        else {
                            out += ' validate.errors = [' + (__err) + ']; return false; ';
                        }
                    }
                    else {
                        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                    }
                    out += ' } else if ( ';
                    if ($isData) {
                        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
                    }
                    out += ' ' + ($exclType) + ' == \'number\' ? ( (' + ($exclusive) + ' = ' + ($schemaValue) + ' === undefined || ' + ($schemaValueExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ') ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValueExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) : ( (' + ($exclusive) + ' = ' + ($schemaValueExcl) + ' === true) ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValue) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { var op' + ($lvl) + ' = ' + ($exclusive) + ' ? \'' + ($op) + '\' : \'' + ($op) + '=\'; ';
                    if ($schema === undefined) {
                        $errorKeyword = $exclusiveKeyword;
                        $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
                        $schemaValue = $schemaValueExcl;
                        $isData = $isDataExcl;
                    }
                }
                else {
                    var $exclIsNumber = typeof $schemaExcl == 'number', $opStr = $op;
                    if ($exclIsNumber && $isData) {
                        var $opExpr = '\'' + $opStr + '\'';
                        out += ' if ( ';
                        if ($isData) {
                            out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
                        }
                        out += ' ( ' + ($schemaValue) + ' === undefined || ' + ($schemaExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ' ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { ';
                    }
                    else {
                        if ($exclIsNumber && $schema === undefined) {
                            $exclusive = true;
                            $errorKeyword = $exclusiveKeyword;
                            $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
                            $schemaValue = $schemaExcl;
                            $notOp += '=';
                        }
                        else {
                            if ($exclIsNumber)
                                $schemaValue = Math[$isMax ? 'min' : 'max']($schemaExcl, $schema);
                            if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
                                $exclusive = true;
                                $errorKeyword = $exclusiveKeyword;
                                $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
                                $notOp += '=';
                            }
                            else {
                                $exclusive = false;
                                $opStr += '=';
                            }
                        }
                        var $opExpr = '\'' + $opStr + '\'';
                        out += ' if ( ';
                        if ($isData) {
                            out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
                        }
                        out += ' ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' || ' + ($data) + ' !== ' + ($data) + ') { ';
                    }
                }
                $errorKeyword = $errorKeyword || $keyword;
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = ''; /* istanbul ignore else */
                if (it.createErrors !== false) {
                    out += ' { keyword: \'' + ($errorKeyword || '_limit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { comparison: ' + ($opExpr) + ', limit: ' + ($schemaValue) + ', exclusive: ' + ($exclusive) + ' } ';
                    if (it.opts.messages !== false) {
                        out += ' , message: \'should be ' + ($opStr) + ' ';
                        if ($isData) {
                            out += '\' + ' + ($schemaValue);
                        }
                        else {
                            out += '' + ($schemaValue) + '\'';
                        }
                    }
                    if (it.opts.verbose) {
                        out += ' , schema:  ';
                        if ($isData) {
                            out += 'validate.schema' + ($schemaPath);
                        }
                        else {
                            out += '' + ($schema);
                        }
                        out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                    }
                    out += ' } ';
                }
                else {
                    out += ' {} ';
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */
                    if (it.async) {
                        out += ' throw new ValidationError([' + (__err) + ']); ';
                    }
                    else {
                        out += ' validate.errors = [' + (__err) + ']; return false; ';
                    }
                }
                else {
                    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                }
                out += ' } ';
                if ($breakOnError) {
                    out += ' else { ';
                }
                return out;
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/dotjs/_limitItems.js": 
        /*!***************************************************!*\
          !*** ./node_modules/ajv/lib/dotjs/_limitItems.js ***!
          \***************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            module.exports = function generate__limitItems(it, $keyword, $ruleType) {
                var out = ' ';
                var $lvl = it.level;
                var $dataLvl = it.dataLevel;
                var $schema = it.schema[$keyword];
                var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
                var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
                var $breakOnError = !it.opts.allErrors;
                var $errorKeyword;
                var $data = 'data' + ($dataLvl || '');
                var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
                if ($isData) {
                    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
                    $schemaValue = 'schema' + $lvl;
                }
                else {
                    $schemaValue = $schema;
                }
                var $op = $keyword == 'maxItems' ? '>' : '<';
                out += 'if ( ';
                if ($isData) {
                    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
                }
                out += ' ' + ($data) + '.length ' + ($op) + ' ' + ($schemaValue) + ') { ';
                var $errorKeyword = $keyword;
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = ''; /* istanbul ignore else */
                if (it.createErrors !== false) {
                    out += ' { keyword: \'' + ($errorKeyword || '_limitItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
                    if (it.opts.messages !== false) {
                        out += ' , message: \'should NOT have ';
                        if ($keyword == 'maxItems') {
                            out += 'more';
                        }
                        else {
                            out += 'fewer';
                        }
                        out += ' than ';
                        if ($isData) {
                            out += '\' + ' + ($schemaValue) + ' + \'';
                        }
                        else {
                            out += '' + ($schema);
                        }
                        out += ' items\' ';
                    }
                    if (it.opts.verbose) {
                        out += ' , schema:  ';
                        if ($isData) {
                            out += 'validate.schema' + ($schemaPath);
                        }
                        else {
                            out += '' + ($schema);
                        }
                        out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                    }
                    out += ' } ';
                }
                else {
                    out += ' {} ';
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */
                    if (it.async) {
                        out += ' throw new ValidationError([' + (__err) + ']); ';
                    }
                    else {
                        out += ' validate.errors = [' + (__err) + ']; return false; ';
                    }
                }
                else {
                    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                }
                out += '} ';
                if ($breakOnError) {
                    out += ' else { ';
                }
                return out;
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/dotjs/_limitLength.js": 
        /*!****************************************************!*\
          !*** ./node_modules/ajv/lib/dotjs/_limitLength.js ***!
          \****************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            module.exports = function generate__limitLength(it, $keyword, $ruleType) {
                var out = ' ';
                var $lvl = it.level;
                var $dataLvl = it.dataLevel;
                var $schema = it.schema[$keyword];
                var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
                var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
                var $breakOnError = !it.opts.allErrors;
                var $errorKeyword;
                var $data = 'data' + ($dataLvl || '');
                var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
                if ($isData) {
                    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
                    $schemaValue = 'schema' + $lvl;
                }
                else {
                    $schemaValue = $schema;
                }
                var $op = $keyword == 'maxLength' ? '>' : '<';
                out += 'if ( ';
                if ($isData) {
                    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
                }
                if (it.opts.unicode === false) {
                    out += ' ' + ($data) + '.length ';
                }
                else {
                    out += ' ucs2length(' + ($data) + ') ';
                }
                out += ' ' + ($op) + ' ' + ($schemaValue) + ') { ';
                var $errorKeyword = $keyword;
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = ''; /* istanbul ignore else */
                if (it.createErrors !== false) {
                    out += ' { keyword: \'' + ($errorKeyword || '_limitLength') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
                    if (it.opts.messages !== false) {
                        out += ' , message: \'should NOT be ';
                        if ($keyword == 'maxLength') {
                            out += 'longer';
                        }
                        else {
                            out += 'shorter';
                        }
                        out += ' than ';
                        if ($isData) {
                            out += '\' + ' + ($schemaValue) + ' + \'';
                        }
                        else {
                            out += '' + ($schema);
                        }
                        out += ' characters\' ';
                    }
                    if (it.opts.verbose) {
                        out += ' , schema:  ';
                        if ($isData) {
                            out += 'validate.schema' + ($schemaPath);
                        }
                        else {
                            out += '' + ($schema);
                        }
                        out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                    }
                    out += ' } ';
                }
                else {
                    out += ' {} ';
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */
                    if (it.async) {
                        out += ' throw new ValidationError([' + (__err) + ']); ';
                    }
                    else {
                        out += ' validate.errors = [' + (__err) + ']; return false; ';
                    }
                }
                else {
                    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                }
                out += '} ';
                if ($breakOnError) {
                    out += ' else { ';
                }
                return out;
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/dotjs/_limitProperties.js": 
        /*!********************************************************!*\
          !*** ./node_modules/ajv/lib/dotjs/_limitProperties.js ***!
          \********************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            module.exports = function generate__limitProperties(it, $keyword, $ruleType) {
                var out = ' ';
                var $lvl = it.level;
                var $dataLvl = it.dataLevel;
                var $schema = it.schema[$keyword];
                var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
                var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
                var $breakOnError = !it.opts.allErrors;
                var $errorKeyword;
                var $data = 'data' + ($dataLvl || '');
                var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
                if ($isData) {
                    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
                    $schemaValue = 'schema' + $lvl;
                }
                else {
                    $schemaValue = $schema;
                }
                var $op = $keyword == 'maxProperties' ? '>' : '<';
                out += 'if ( ';
                if ($isData) {
                    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
                }
                out += ' Object.keys(' + ($data) + ').length ' + ($op) + ' ' + ($schemaValue) + ') { ';
                var $errorKeyword = $keyword;
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = ''; /* istanbul ignore else */
                if (it.createErrors !== false) {
                    out += ' { keyword: \'' + ($errorKeyword || '_limitProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
                    if (it.opts.messages !== false) {
                        out += ' , message: \'should NOT have ';
                        if ($keyword == 'maxProperties') {
                            out += 'more';
                        }
                        else {
                            out += 'fewer';
                        }
                        out += ' than ';
                        if ($isData) {
                            out += '\' + ' + ($schemaValue) + ' + \'';
                        }
                        else {
                            out += '' + ($schema);
                        }
                        out += ' properties\' ';
                    }
                    if (it.opts.verbose) {
                        out += ' , schema:  ';
                        if ($isData) {
                            out += 'validate.schema' + ($schemaPath);
                        }
                        else {
                            out += '' + ($schema);
                        }
                        out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                    }
                    out += ' } ';
                }
                else {
                    out += ' {} ';
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */
                    if (it.async) {
                        out += ' throw new ValidationError([' + (__err) + ']); ';
                    }
                    else {
                        out += ' validate.errors = [' + (__err) + ']; return false; ';
                    }
                }
                else {
                    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                }
                out += '} ';
                if ($breakOnError) {
                    out += ' else { ';
                }
                return out;
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/dotjs/allOf.js": 
        /*!*********************************************!*\
          !*** ./node_modules/ajv/lib/dotjs/allOf.js ***!
          \*********************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            module.exports = function generate_allOf(it, $keyword, $ruleType) {
                var out = ' ';
                var $schema = it.schema[$keyword];
                var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
                var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
                var $breakOnError = !it.opts.allErrors;
                var $it = it.util.copy(it);
                var $closingBraces = '';
                $it.level++;
                var $nextValid = 'valid' + $it.level;
                var $currentBaseId = $it.baseId, $allSchemasEmpty = true;
                var arr1 = $schema;
                if (arr1) {
                    var $sch, $i = -1, l1 = arr1.length - 1;
                    while ($i < l1) {
                        $sch = arr1[$i += 1];
                        if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
                            $allSchemasEmpty = false;
                            $it.schema = $sch;
                            $it.schemaPath = $schemaPath + '[' + $i + ']';
                            $it.errSchemaPath = $errSchemaPath + '/' + $i;
                            out += '  ' + (it.validate($it)) + ' ';
                            $it.baseId = $currentBaseId;
                            if ($breakOnError) {
                                out += ' if (' + ($nextValid) + ') { ';
                                $closingBraces += '}';
                            }
                        }
                    }
                }
                if ($breakOnError) {
                    if ($allSchemasEmpty) {
                        out += ' if (true) { ';
                    }
                    else {
                        out += ' ' + ($closingBraces.slice(0, -1)) + ' ';
                    }
                }
                out = it.util.cleanUpCode(out);
                return out;
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/dotjs/anyOf.js": 
        /*!*********************************************!*\
          !*** ./node_modules/ajv/lib/dotjs/anyOf.js ***!
          \*********************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            module.exports = function generate_anyOf(it, $keyword, $ruleType) {
                var out = ' ';
                var $lvl = it.level;
                var $dataLvl = it.dataLevel;
                var $schema = it.schema[$keyword];
                var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
                var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
                var $breakOnError = !it.opts.allErrors;
                var $data = 'data' + ($dataLvl || '');
                var $valid = 'valid' + $lvl;
                var $errs = 'errs__' + $lvl;
                var $it = it.util.copy(it);
                var $closingBraces = '';
                $it.level++;
                var $nextValid = 'valid' + $it.level;
                var $noEmptySchema = $schema.every(function ($sch) {
                    return (it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all));
                });
                if ($noEmptySchema) {
                    var $currentBaseId = $it.baseId;
                    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = false;  ';
                    var $wasComposite = it.compositeRule;
                    it.compositeRule = $it.compositeRule = true;
                    var arr1 = $schema;
                    if (arr1) {
                        var $sch, $i = -1, l1 = arr1.length - 1;
                        while ($i < l1) {
                            $sch = arr1[$i += 1];
                            $it.schema = $sch;
                            $it.schemaPath = $schemaPath + '[' + $i + ']';
                            $it.errSchemaPath = $errSchemaPath + '/' + $i;
                            out += '  ' + (it.validate($it)) + ' ';
                            $it.baseId = $currentBaseId;
                            out += ' ' + ($valid) + ' = ' + ($valid) + ' || ' + ($nextValid) + '; if (!' + ($valid) + ') { ';
                            $closingBraces += '}';
                        }
                    }
                    it.compositeRule = $it.compositeRule = $wasComposite;
                    out += ' ' + ($closingBraces) + ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
                    if (it.createErrors !== false) {
                        out += ' { keyword: \'' + ('anyOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
                        if (it.opts.messages !== false) {
                            out += ' , message: \'should match some schema in anyOf\' ';
                        }
                        if (it.opts.verbose) {
                            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                        }
                        out += ' } ';
                    }
                    else {
                        out += ' {} ';
                    }
                    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                    if (!it.compositeRule && $breakOnError) {
                        /* istanbul ignore if */
                        if (it.async) {
                            out += ' throw new ValidationError(vErrors); ';
                        }
                        else {
                            out += ' validate.errors = vErrors; return false; ';
                        }
                    }
                    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
                    if (it.opts.allErrors) {
                        out += ' } ';
                    }
                    out = it.util.cleanUpCode(out);
                }
                else {
                    if ($breakOnError) {
                        out += ' if (true) { ';
                    }
                }
                return out;
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/dotjs/comment.js": 
        /*!***********************************************!*\
          !*** ./node_modules/ajv/lib/dotjs/comment.js ***!
          \***********************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            module.exports = function generate_comment(it, $keyword, $ruleType) {
                var out = ' ';
                var $schema = it.schema[$keyword];
                var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
                var $breakOnError = !it.opts.allErrors;
                var $comment = it.util.toQuotedString($schema);
                if (it.opts.$comment === true) {
                    out += ' console.log(' + ($comment) + ');';
                }
                else if (typeof it.opts.$comment == 'function') {
                    out += ' self._opts.$comment(' + ($comment) + ', ' + (it.util.toQuotedString($errSchemaPath)) + ', validate.root.schema);';
                }
                return out;
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/dotjs/const.js": 
        /*!*********************************************!*\
          !*** ./node_modules/ajv/lib/dotjs/const.js ***!
          \*********************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            module.exports = function generate_const(it, $keyword, $ruleType) {
                var out = ' ';
                var $lvl = it.level;
                var $dataLvl = it.dataLevel;
                var $schema = it.schema[$keyword];
                var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
                var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
                var $breakOnError = !it.opts.allErrors;
                var $data = 'data' + ($dataLvl || '');
                var $valid = 'valid' + $lvl;
                var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
                if ($isData) {
                    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
                    $schemaValue = 'schema' + $lvl;
                }
                else {
                    $schemaValue = $schema;
                }
                if (!$isData) {
                    out += ' var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + ';';
                }
                out += 'var ' + ($valid) + ' = equal(' + ($data) + ', schema' + ($lvl) + '); if (!' + ($valid) + ') {   ';
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = ''; /* istanbul ignore else */
                if (it.createErrors !== false) {
                    out += ' { keyword: \'' + ('const') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValue: schema' + ($lvl) + ' } ';
                    if (it.opts.messages !== false) {
                        out += ' , message: \'should be equal to constant\' ';
                    }
                    if (it.opts.verbose) {
                        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                    }
                    out += ' } ';
                }
                else {
                    out += ' {} ';
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */
                    if (it.async) {
                        out += ' throw new ValidationError([' + (__err) + ']); ';
                    }
                    else {
                        out += ' validate.errors = [' + (__err) + ']; return false; ';
                    }
                }
                else {
                    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                }
                out += ' }';
                if ($breakOnError) {
                    out += ' else { ';
                }
                return out;
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/dotjs/contains.js": 
        /*!************************************************!*\
          !*** ./node_modules/ajv/lib/dotjs/contains.js ***!
          \************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            module.exports = function generate_contains(it, $keyword, $ruleType) {
                var out = ' ';
                var $lvl = it.level;
                var $dataLvl = it.dataLevel;
                var $schema = it.schema[$keyword];
                var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
                var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
                var $breakOnError = !it.opts.allErrors;
                var $data = 'data' + ($dataLvl || '');
                var $valid = 'valid' + $lvl;
                var $errs = 'errs__' + $lvl;
                var $it = it.util.copy(it);
                var $closingBraces = '';
                $it.level++;
                var $nextValid = 'valid' + $it.level;
                var $idx = 'i' + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = 'data' + $dataNxt, $currentBaseId = it.baseId, $nonEmptySchema = (it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all));
                out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
                if ($nonEmptySchema) {
                    var $wasComposite = it.compositeRule;
                    it.compositeRule = $it.compositeRule = true;
                    $it.schema = $schema;
                    $it.schemaPath = $schemaPath;
                    $it.errSchemaPath = $errSchemaPath;
                    out += ' var ' + ($nextValid) + ' = false; for (var ' + ($idx) + ' = 0; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
                    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
                    var $passData = $data + '[' + $idx + ']';
                    $it.dataPathArr[$dataNxt] = $idx;
                    var $code = it.validate($it);
                    $it.baseId = $currentBaseId;
                    if (it.util.varOccurences($code, $nextData) < 2) {
                        out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
                    }
                    else {
                        out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
                    }
                    out += ' if (' + ($nextValid) + ') break; }  ';
                    it.compositeRule = $it.compositeRule = $wasComposite;
                    out += ' ' + ($closingBraces) + ' if (!' + ($nextValid) + ') {';
                }
                else {
                    out += ' if (' + ($data) + '.length == 0) {';
                }
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = ''; /* istanbul ignore else */
                if (it.createErrors !== false) {
                    out += ' { keyword: \'' + ('contains') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
                    if (it.opts.messages !== false) {
                        out += ' , message: \'should contain a valid item\' ';
                    }
                    if (it.opts.verbose) {
                        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                    }
                    out += ' } ';
                }
                else {
                    out += ' {} ';
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */
                    if (it.async) {
                        out += ' throw new ValidationError([' + (__err) + ']); ';
                    }
                    else {
                        out += ' validate.errors = [' + (__err) + ']; return false; ';
                    }
                }
                else {
                    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                }
                out += ' } else { ';
                if ($nonEmptySchema) {
                    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
                }
                if (it.opts.allErrors) {
                    out += ' } ';
                }
                out = it.util.cleanUpCode(out);
                return out;
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/dotjs/custom.js": 
        /*!**********************************************!*\
          !*** ./node_modules/ajv/lib/dotjs/custom.js ***!
          \**********************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            module.exports = function generate_custom(it, $keyword, $ruleType) {
                var out = ' ';
                var $lvl = it.level;
                var $dataLvl = it.dataLevel;
                var $schema = it.schema[$keyword];
                var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
                var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
                var $breakOnError = !it.opts.allErrors;
                var $errorKeyword;
                var $data = 'data' + ($dataLvl || '');
                var $valid = 'valid' + $lvl;
                var $errs = 'errs__' + $lvl;
                var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
                if ($isData) {
                    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
                    $schemaValue = 'schema' + $lvl;
                }
                else {
                    $schemaValue = $schema;
                }
                var $rule = this, $definition = 'definition' + $lvl, $rDef = $rule.definition, $closingBraces = '';
                var $compile, $inline, $macro, $ruleValidate, $validateCode;
                if ($isData && $rDef.$data) {
                    $validateCode = 'keywordValidate' + $lvl;
                    var $validateSchema = $rDef.validateSchema;
                    out += ' var ' + ($definition) + ' = RULES.custom[\'' + ($keyword) + '\'].definition; var ' + ($validateCode) + ' = ' + ($definition) + '.validate;';
                }
                else {
                    $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
                    if (!$ruleValidate)
                        return;
                    $schemaValue = 'validate.schema' + $schemaPath;
                    $validateCode = $ruleValidate.code;
                    $compile = $rDef.compile;
                    $inline = $rDef.inline;
                    $macro = $rDef.macro;
                }
                var $ruleErrs = $validateCode + '.errors', $i = 'i' + $lvl, $ruleErr = 'ruleErr' + $lvl, $asyncKeyword = $rDef.async;
                if ($asyncKeyword && !it.async)
                    throw new Error('async keyword in sync schema');
                if (!($inline || $macro)) {
                    out += '' + ($ruleErrs) + ' = null;';
                }
                out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
                if ($isData && $rDef.$data) {
                    $closingBraces += '}';
                    out += ' if (' + ($schemaValue) + ' === undefined) { ' + ($valid) + ' = true; } else { ';
                    if ($validateSchema) {
                        $closingBraces += '}';
                        out += ' ' + ($valid) + ' = ' + ($definition) + '.validateSchema(' + ($schemaValue) + '); if (' + ($valid) + ') { ';
                    }
                }
                if ($inline) {
                    if ($rDef.statements) {
                        out += ' ' + ($ruleValidate.validate) + ' ';
                    }
                    else {
                        out += ' ' + ($valid) + ' = ' + ($ruleValidate.validate) + '; ';
                    }
                }
                else if ($macro) {
                    var $it = it.util.copy(it);
                    var $closingBraces = '';
                    $it.level++;
                    var $nextValid = 'valid' + $it.level;
                    $it.schema = $ruleValidate.validate;
                    $it.schemaPath = '';
                    var $wasComposite = it.compositeRule;
                    it.compositeRule = $it.compositeRule = true;
                    var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
                    it.compositeRule = $it.compositeRule = $wasComposite;
                    out += ' ' + ($code);
                }
                else {
                    var $$outStack = $$outStack || [];
                    $$outStack.push(out);
                    out = '';
                    out += '  ' + ($validateCode) + '.call( ';
                    if (it.opts.passContext) {
                        out += 'this';
                    }
                    else {
                        out += 'self';
                    }
                    if ($compile || $rDef.schema === false) {
                        out += ' , ' + ($data) + ' ';
                    }
                    else {
                        out += ' , ' + ($schemaValue) + ' , ' + ($data) + ' , validate.schema' + (it.schemaPath) + ' ';
                    }
                    out += ' , (dataPath || \'\')';
                    if (it.errorPath != '""') {
                        out += ' + ' + (it.errorPath);
                    }
                    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData', $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
                    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ' , rootData )  ';
                    var def_callRuleValidate = out;
                    out = $$outStack.pop();
                    if ($rDef.errors === false) {
                        out += ' ' + ($valid) + ' = ';
                        if ($asyncKeyword) {
                            out += 'await ';
                        }
                        out += '' + (def_callRuleValidate) + '; ';
                    }
                    else {
                        if ($asyncKeyword) {
                            $ruleErrs = 'customErrors' + $lvl;
                            out += ' var ' + ($ruleErrs) + ' = null; try { ' + ($valid) + ' = await ' + (def_callRuleValidate) + '; } catch (e) { ' + ($valid) + ' = false; if (e instanceof ValidationError) ' + ($ruleErrs) + ' = e.errors; else throw e; } ';
                        }
                        else {
                            out += ' ' + ($ruleErrs) + ' = null; ' + ($valid) + ' = ' + (def_callRuleValidate) + '; ';
                        }
                    }
                }
                if ($rDef.modifying) {
                    out += ' if (' + ($parentData) + ') ' + ($data) + ' = ' + ($parentData) + '[' + ($parentDataProperty) + '];';
                }
                out += '' + ($closingBraces);
                if ($rDef.valid) {
                    if ($breakOnError) {
                        out += ' if (true) { ';
                    }
                }
                else {
                    out += ' if ( ';
                    if ($rDef.valid === undefined) {
                        out += ' !';
                        if ($macro) {
                            out += '' + ($nextValid);
                        }
                        else {
                            out += '' + ($valid);
                        }
                    }
                    else {
                        out += ' ' + (!$rDef.valid) + ' ';
                    }
                    out += ') { ';
                    $errorKeyword = $rule.keyword;
                    var $$outStack = $$outStack || [];
                    $$outStack.push(out);
                    out = '';
                    var $$outStack = $$outStack || [];
                    $$outStack.push(out);
                    out = ''; /* istanbul ignore else */
                    if (it.createErrors !== false) {
                        out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \'' + ($rule.keyword) + '\' } ';
                        if (it.opts.messages !== false) {
                            out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
                        }
                        if (it.opts.verbose) {
                            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                        }
                        out += ' } ';
                    }
                    else {
                        out += ' {} ';
                    }
                    var __err = out;
                    out = $$outStack.pop();
                    if (!it.compositeRule && $breakOnError) {
                        /* istanbul ignore if */
                        if (it.async) {
                            out += ' throw new ValidationError([' + (__err) + ']); ';
                        }
                        else {
                            out += ' validate.errors = [' + (__err) + ']; return false; ';
                        }
                    }
                    else {
                        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                    }
                    var def_customError = out;
                    out = $$outStack.pop();
                    if ($inline) {
                        if ($rDef.errors) {
                            if ($rDef.errors != 'full') {
                                out += '  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
                                if (it.opts.verbose) {
                                    out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
                                }
                                out += ' } ';
                            }
                        }
                        else {
                            if ($rDef.errors === false) {
                                out += ' ' + (def_customError) + ' ';
                            }
                            else {
                                out += ' if (' + ($errs) + ' == errors) { ' + (def_customError) + ' } else {  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
                                if (it.opts.verbose) {
                                    out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
                                }
                                out += ' } } ';
                            }
                        }
                    }
                    else if ($macro) {
                        out += '   var err =   '; /* istanbul ignore else */
                        if (it.createErrors !== false) {
                            out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \'' + ($rule.keyword) + '\' } ';
                            if (it.opts.messages !== false) {
                                out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
                            }
                            if (it.opts.verbose) {
                                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                            }
                            out += ' } ';
                        }
                        else {
                            out += ' {} ';
                        }
                        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                        if (!it.compositeRule && $breakOnError) {
                            /* istanbul ignore if */
                            if (it.async) {
                                out += ' throw new ValidationError(vErrors); ';
                            }
                            else {
                                out += ' validate.errors = vErrors; return false; ';
                            }
                        }
                    }
                    else {
                        if ($rDef.errors === false) {
                            out += ' ' + (def_customError) + ' ';
                        }
                        else {
                            out += ' if (Array.isArray(' + ($ruleErrs) + ')) { if (vErrors === null) vErrors = ' + ($ruleErrs) + '; else vErrors = vErrors.concat(' + ($ruleErrs) + '); errors = vErrors.length;  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + ';  ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '";  ';
                            if (it.opts.verbose) {
                                out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
                            }
                            out += ' } } else { ' + (def_customError) + ' } ';
                        }
                    }
                    out += ' } ';
                    if ($breakOnError) {
                        out += ' else { ';
                    }
                }
                return out;
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/dotjs/dependencies.js": 
        /*!****************************************************!*\
          !*** ./node_modules/ajv/lib/dotjs/dependencies.js ***!
          \****************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            module.exports = function generate_dependencies(it, $keyword, $ruleType) {
                var out = ' ';
                var $lvl = it.level;
                var $dataLvl = it.dataLevel;
                var $schema = it.schema[$keyword];
                var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
                var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
                var $breakOnError = !it.opts.allErrors;
                var $data = 'data' + ($dataLvl || '');
                var $errs = 'errs__' + $lvl;
                var $it = it.util.copy(it);
                var $closingBraces = '';
                $it.level++;
                var $nextValid = 'valid' + $it.level;
                var $schemaDeps = {}, $propertyDeps = {}, $ownProperties = it.opts.ownProperties;
                for ($property in $schema) {
                    var $sch = $schema[$property];
                    var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
                    $deps[$property] = $sch;
                }
                out += 'var ' + ($errs) + ' = errors;';
                var $currentErrorPath = it.errorPath;
                out += 'var missing' + ($lvl) + ';';
                for (var $property in $propertyDeps) {
                    $deps = $propertyDeps[$property];
                    if ($deps.length) {
                        out += ' if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
                        if ($ownProperties) {
                            out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($property)) + '\') ';
                        }
                        if ($breakOnError) {
                            out += ' && ( ';
                            var arr1 = $deps;
                            if (arr1) {
                                var $propertyKey, $i = -1, l1 = arr1.length - 1;
                                while ($i < l1) {
                                    $propertyKey = arr1[$i += 1];
                                    if ($i) {
                                        out += ' || ';
                                    }
                                    var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
                                    out += ' ( ( ' + ($useData) + ' === undefined ';
                                    if ($ownProperties) {
                                        out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                                    }
                                    out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';
                                }
                            }
                            out += ')) {  ';
                            var $propertyPath = 'missing' + $lvl, $missingProperty = '\' + ' + $propertyPath + ' + \'';
                            if (it.opts._errorDataPathProperty) {
                                it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
                            }
                            var $$outStack = $$outStack || [];
                            $$outStack.push(out);
                            out = ''; /* istanbul ignore else */
                            if (it.createErrors !== false) {
                                out += ' { keyword: \'' + ('dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' } ';
                                if (it.opts.messages !== false) {
                                    out += ' , message: \'should have ';
                                    if ($deps.length == 1) {
                                        out += 'property ' + (it.util.escapeQuotes($deps[0]));
                                    }
                                    else {
                                        out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
                                    }
                                    out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
                                }
                                if (it.opts.verbose) {
                                    out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                                }
                                out += ' } ';
                            }
                            else {
                                out += ' {} ';
                            }
                            var __err = out;
                            out = $$outStack.pop();
                            if (!it.compositeRule && $breakOnError) {
                                /* istanbul ignore if */
                                if (it.async) {
                                    out += ' throw new ValidationError([' + (__err) + ']); ';
                                }
                                else {
                                    out += ' validate.errors = [' + (__err) + ']; return false; ';
                                }
                            }
                            else {
                                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                            }
                        }
                        else {
                            out += ' ) { ';
                            var arr2 = $deps;
                            if (arr2) {
                                var $propertyKey, i2 = -1, l2 = arr2.length - 1;
                                while (i2 < l2) {
                                    $propertyKey = arr2[i2 += 1];
                                    var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                                    if (it.opts._errorDataPathProperty) {
                                        it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                                    }
                                    out += ' if ( ' + ($useData) + ' === undefined ';
                                    if ($ownProperties) {
                                        out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                                    }
                                    out += ') {  var err =   '; /* istanbul ignore else */
                                    if (it.createErrors !== false) {
                                        out += ' { keyword: \'' + ('dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' } ';
                                        if (it.opts.messages !== false) {
                                            out += ' , message: \'should have ';
                                            if ($deps.length == 1) {
                                                out += 'property ' + (it.util.escapeQuotes($deps[0]));
                                            }
                                            else {
                                                out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
                                            }
                                            out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
                                        }
                                        if (it.opts.verbose) {
                                            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                                        }
                                        out += ' } ';
                                    }
                                    else {
                                        out += ' {} ';
                                    }
                                    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
                                }
                            }
                        }
                        out += ' }   ';
                        if ($breakOnError) {
                            $closingBraces += '}';
                            out += ' else { ';
                        }
                    }
                }
                it.errorPath = $currentErrorPath;
                var $currentBaseId = $it.baseId;
                for (var $property in $schemaDeps) {
                    var $sch = $schemaDeps[$property];
                    if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
                        out += ' ' + ($nextValid) + ' = true; if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
                        if ($ownProperties) {
                            out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($property)) + '\') ';
                        }
                        out += ') { ';
                        $it.schema = $sch;
                        $it.schemaPath = $schemaPath + it.util.getProperty($property);
                        $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($property);
                        out += '  ' + (it.validate($it)) + ' ';
                        $it.baseId = $currentBaseId;
                        out += ' }  ';
                        if ($breakOnError) {
                            out += ' if (' + ($nextValid) + ') { ';
                            $closingBraces += '}';
                        }
                    }
                }
                if ($breakOnError) {
                    out += '   ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
                }
                out = it.util.cleanUpCode(out);
                return out;
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/dotjs/enum.js": 
        /*!********************************************!*\
          !*** ./node_modules/ajv/lib/dotjs/enum.js ***!
          \********************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            module.exports = function generate_enum(it, $keyword, $ruleType) {
                var out = ' ';
                var $lvl = it.level;
                var $dataLvl = it.dataLevel;
                var $schema = it.schema[$keyword];
                var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
                var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
                var $breakOnError = !it.opts.allErrors;
                var $data = 'data' + ($dataLvl || '');
                var $valid = 'valid' + $lvl;
                var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
                if ($isData) {
                    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
                    $schemaValue = 'schema' + $lvl;
                }
                else {
                    $schemaValue = $schema;
                }
                var $i = 'i' + $lvl, $vSchema = 'schema' + $lvl;
                if (!$isData) {
                    out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + ';';
                }
                out += 'var ' + ($valid) + ';';
                if ($isData) {
                    out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
                }
                out += '' + ($valid) + ' = false;for (var ' + ($i) + '=0; ' + ($i) + '<' + ($vSchema) + '.length; ' + ($i) + '++) if (equal(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + '])) { ' + ($valid) + ' = true; break; }';
                if ($isData) {
                    out += '  }  ';
                }
                out += ' if (!' + ($valid) + ') {   ';
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = ''; /* istanbul ignore else */
                if (it.createErrors !== false) {
                    out += ' { keyword: \'' + ('enum') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValues: schema' + ($lvl) + ' } ';
                    if (it.opts.messages !== false) {
                        out += ' , message: \'should be equal to one of the allowed values\' ';
                    }
                    if (it.opts.verbose) {
                        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                    }
                    out += ' } ';
                }
                else {
                    out += ' {} ';
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */
                    if (it.async) {
                        out += ' throw new ValidationError([' + (__err) + ']); ';
                    }
                    else {
                        out += ' validate.errors = [' + (__err) + ']; return false; ';
                    }
                }
                else {
                    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                }
                out += ' }';
                if ($breakOnError) {
                    out += ' else { ';
                }
                return out;
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/dotjs/format.js": 
        /*!**********************************************!*\
          !*** ./node_modules/ajv/lib/dotjs/format.js ***!
          \**********************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            module.exports = function generate_format(it, $keyword, $ruleType) {
                var out = ' ';
                var $lvl = it.level;
                var $dataLvl = it.dataLevel;
                var $schema = it.schema[$keyword];
                var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
                var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
                var $breakOnError = !it.opts.allErrors;
                var $data = 'data' + ($dataLvl || '');
                if (it.opts.format === false) {
                    if ($breakOnError) {
                        out += ' if (true) { ';
                    }
                    return out;
                }
                var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
                if ($isData) {
                    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
                    $schemaValue = 'schema' + $lvl;
                }
                else {
                    $schemaValue = $schema;
                }
                var $unknownFormats = it.opts.unknownFormats, $allowUnknown = Array.isArray($unknownFormats);
                if ($isData) {
                    var $format = 'format' + $lvl, $isObject = 'isObject' + $lvl, $formatType = 'formatType' + $lvl;
                    out += ' var ' + ($format) + ' = formats[' + ($schemaValue) + ']; var ' + ($isObject) + ' = typeof ' + ($format) + ' == \'object\' && !(' + ($format) + ' instanceof RegExp) && ' + ($format) + '.validate; var ' + ($formatType) + ' = ' + ($isObject) + ' && ' + ($format) + '.type || \'string\'; if (' + ($isObject) + ') { ';
                    if (it.async) {
                        out += ' var async' + ($lvl) + ' = ' + ($format) + '.async; ';
                    }
                    out += ' ' + ($format) + ' = ' + ($format) + '.validate; } if (  ';
                    if ($isData) {
                        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
                    }
                    out += ' (';
                    if ($unknownFormats != 'ignore') {
                        out += ' (' + ($schemaValue) + ' && !' + ($format) + ' ';
                        if ($allowUnknown) {
                            out += ' && self._opts.unknownFormats.indexOf(' + ($schemaValue) + ') == -1 ';
                        }
                        out += ') || ';
                    }
                    out += ' (' + ($format) + ' && ' + ($formatType) + ' == \'' + ($ruleType) + '\' && !(typeof ' + ($format) + ' == \'function\' ? ';
                    if (it.async) {
                        out += ' (async' + ($lvl) + ' ? await ' + ($format) + '(' + ($data) + ') : ' + ($format) + '(' + ($data) + ')) ';
                    }
                    else {
                        out += ' ' + ($format) + '(' + ($data) + ') ';
                    }
                    out += ' : ' + ($format) + '.test(' + ($data) + '))))) {';
                }
                else {
                    var $format = it.formats[$schema];
                    if (!$format) {
                        if ($unknownFormats == 'ignore') {
                            it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
                            if ($breakOnError) {
                                out += ' if (true) { ';
                            }
                            return out;
                        }
                        else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
                            if ($breakOnError) {
                                out += ' if (true) { ';
                            }
                            return out;
                        }
                        else {
                            throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
                        }
                    }
                    var $isObject = typeof $format == 'object' && !($format instanceof RegExp) && $format.validate;
                    var $formatType = $isObject && $format.type || 'string';
                    if ($isObject) {
                        var $async = $format.async === true;
                        $format = $format.validate;
                    }
                    if ($formatType != $ruleType) {
                        if ($breakOnError) {
                            out += ' if (true) { ';
                        }
                        return out;
                    }
                    if ($async) {
                        if (!it.async)
                            throw new Error('async format in sync schema');
                        var $formatRef = 'formats' + it.util.getProperty($schema) + '.validate';
                        out += ' if (!(await ' + ($formatRef) + '(' + ($data) + '))) { ';
                    }
                    else {
                        out += ' if (! ';
                        var $formatRef = 'formats' + it.util.getProperty($schema);
                        if ($isObject)
                            $formatRef += '.validate';
                        if (typeof $format == 'function') {
                            out += ' ' + ($formatRef) + '(' + ($data) + ') ';
                        }
                        else {
                            out += ' ' + ($formatRef) + '.test(' + ($data) + ') ';
                        }
                        out += ') { ';
                    }
                }
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = ''; /* istanbul ignore else */
                if (it.createErrors !== false) {
                    out += ' { keyword: \'' + ('format') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { format:  ';
                    if ($isData) {
                        out += '' + ($schemaValue);
                    }
                    else {
                        out += '' + (it.util.toQuotedString($schema));
                    }
                    out += '  } ';
                    if (it.opts.messages !== false) {
                        out += ' , message: \'should match format "';
                        if ($isData) {
                            out += '\' + ' + ($schemaValue) + ' + \'';
                        }
                        else {
                            out += '' + (it.util.escapeQuotes($schema));
                        }
                        out += '"\' ';
                    }
                    if (it.opts.verbose) {
                        out += ' , schema:  ';
                        if ($isData) {
                            out += 'validate.schema' + ($schemaPath);
                        }
                        else {
                            out += '' + (it.util.toQuotedString($schema));
                        }
                        out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                    }
                    out += ' } ';
                }
                else {
                    out += ' {} ';
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */
                    if (it.async) {
                        out += ' throw new ValidationError([' + (__err) + ']); ';
                    }
                    else {
                        out += ' validate.errors = [' + (__err) + ']; return false; ';
                    }
                }
                else {
                    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                }
                out += ' } ';
                if ($breakOnError) {
                    out += ' else { ';
                }
                return out;
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/dotjs/if.js": 
        /*!******************************************!*\
          !*** ./node_modules/ajv/lib/dotjs/if.js ***!
          \******************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            module.exports = function generate_if(it, $keyword, $ruleType) {
                var out = ' ';
                var $lvl = it.level;
                var $dataLvl = it.dataLevel;
                var $schema = it.schema[$keyword];
                var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
                var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
                var $breakOnError = !it.opts.allErrors;
                var $data = 'data' + ($dataLvl || '');
                var $valid = 'valid' + $lvl;
                var $errs = 'errs__' + $lvl;
                var $it = it.util.copy(it);
                $it.level++;
                var $nextValid = 'valid' + $it.level;
                var $thenSch = it.schema['then'], $elseSch = it.schema['else'], $thenPresent = $thenSch !== undefined && (it.opts.strictKeywords ? typeof $thenSch == 'object' && Object.keys($thenSch).length > 0 : it.util.schemaHasRules($thenSch, it.RULES.all)), $elsePresent = $elseSch !== undefined && (it.opts.strictKeywords ? typeof $elseSch == 'object' && Object.keys($elseSch).length > 0 : it.util.schemaHasRules($elseSch, it.RULES.all)), $currentBaseId = $it.baseId;
                if ($thenPresent || $elsePresent) {
                    var $ifClause;
                    $it.createErrors = false;
                    $it.schema = $schema;
                    $it.schemaPath = $schemaPath;
                    $it.errSchemaPath = $errSchemaPath;
                    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = true;  ';
                    var $wasComposite = it.compositeRule;
                    it.compositeRule = $it.compositeRule = true;
                    out += '  ' + (it.validate($it)) + ' ';
                    $it.baseId = $currentBaseId;
                    $it.createErrors = true;
                    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }  ';
                    it.compositeRule = $it.compositeRule = $wasComposite;
                    if ($thenPresent) {
                        out += ' if (' + ($nextValid) + ') {  ';
                        $it.schema = it.schema['then'];
                        $it.schemaPath = it.schemaPath + '.then';
                        $it.errSchemaPath = it.errSchemaPath + '/then';
                        out += '  ' + (it.validate($it)) + ' ';
                        $it.baseId = $currentBaseId;
                        out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';
                        if ($thenPresent && $elsePresent) {
                            $ifClause = 'ifClause' + $lvl;
                            out += ' var ' + ($ifClause) + ' = \'then\'; ';
                        }
                        else {
                            $ifClause = '\'then\'';
                        }
                        out += ' } ';
                        if ($elsePresent) {
                            out += ' else { ';
                        }
                    }
                    else {
                        out += ' if (!' + ($nextValid) + ') { ';
                    }
                    if ($elsePresent) {
                        $it.schema = it.schema['else'];
                        $it.schemaPath = it.schemaPath + '.else';
                        $it.errSchemaPath = it.errSchemaPath + '/else';
                        out += '  ' + (it.validate($it)) + ' ';
                        $it.baseId = $currentBaseId;
                        out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';
                        if ($thenPresent && $elsePresent) {
                            $ifClause = 'ifClause' + $lvl;
                            out += ' var ' + ($ifClause) + ' = \'else\'; ';
                        }
                        else {
                            $ifClause = '\'else\'';
                        }
                        out += ' } ';
                    }
                    out += ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
                    if (it.createErrors !== false) {
                        out += ' { keyword: \'' + ('if') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { failingKeyword: ' + ($ifClause) + ' } ';
                        if (it.opts.messages !== false) {
                            out += ' , message: \'should match "\' + ' + ($ifClause) + ' + \'" schema\' ';
                        }
                        if (it.opts.verbose) {
                            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                        }
                        out += ' } ';
                    }
                    else {
                        out += ' {} ';
                    }
                    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                    if (!it.compositeRule && $breakOnError) {
                        /* istanbul ignore if */
                        if (it.async) {
                            out += ' throw new ValidationError(vErrors); ';
                        }
                        else {
                            out += ' validate.errors = vErrors; return false; ';
                        }
                    }
                    out += ' }   ';
                    if ($breakOnError) {
                        out += ' else { ';
                    }
                    out = it.util.cleanUpCode(out);
                }
                else {
                    if ($breakOnError) {
                        out += ' if (true) { ';
                    }
                }
                return out;
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/dotjs/index.js": 
        /*!*********************************************!*\
          !*** ./node_modules/ajv/lib/dotjs/index.js ***!
          \*********************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            //all requires must be explicit because browserify won't work with dynamic requires
            module.exports = {
                '$ref': __webpack_require__(/*! ./ref */ "./node_modules/ajv/lib/dotjs/ref.js"),
                allOf: __webpack_require__(/*! ./allOf */ "./node_modules/ajv/lib/dotjs/allOf.js"),
                anyOf: __webpack_require__(/*! ./anyOf */ "./node_modules/ajv/lib/dotjs/anyOf.js"),
                '$comment': __webpack_require__(/*! ./comment */ "./node_modules/ajv/lib/dotjs/comment.js"),
                const: __webpack_require__(/*! ./const */ "./node_modules/ajv/lib/dotjs/const.js"),
                contains: __webpack_require__(/*! ./contains */ "./node_modules/ajv/lib/dotjs/contains.js"),
                dependencies: __webpack_require__(/*! ./dependencies */ "./node_modules/ajv/lib/dotjs/dependencies.js"),
                'enum': __webpack_require__(/*! ./enum */ "./node_modules/ajv/lib/dotjs/enum.js"),
                format: __webpack_require__(/*! ./format */ "./node_modules/ajv/lib/dotjs/format.js"),
                'if': __webpack_require__(/*! ./if */ "./node_modules/ajv/lib/dotjs/if.js"),
                items: __webpack_require__(/*! ./items */ "./node_modules/ajv/lib/dotjs/items.js"),
                maximum: __webpack_require__(/*! ./_limit */ "./node_modules/ajv/lib/dotjs/_limit.js"),
                minimum: __webpack_require__(/*! ./_limit */ "./node_modules/ajv/lib/dotjs/_limit.js"),
                maxItems: __webpack_require__(/*! ./_limitItems */ "./node_modules/ajv/lib/dotjs/_limitItems.js"),
                minItems: __webpack_require__(/*! ./_limitItems */ "./node_modules/ajv/lib/dotjs/_limitItems.js"),
                maxLength: __webpack_require__(/*! ./_limitLength */ "./node_modules/ajv/lib/dotjs/_limitLength.js"),
                minLength: __webpack_require__(/*! ./_limitLength */ "./node_modules/ajv/lib/dotjs/_limitLength.js"),
                maxProperties: __webpack_require__(/*! ./_limitProperties */ "./node_modules/ajv/lib/dotjs/_limitProperties.js"),
                minProperties: __webpack_require__(/*! ./_limitProperties */ "./node_modules/ajv/lib/dotjs/_limitProperties.js"),
                multipleOf: __webpack_require__(/*! ./multipleOf */ "./node_modules/ajv/lib/dotjs/multipleOf.js"),
                not: __webpack_require__(/*! ./not */ "./node_modules/ajv/lib/dotjs/not.js"),
                oneOf: __webpack_require__(/*! ./oneOf */ "./node_modules/ajv/lib/dotjs/oneOf.js"),
                pattern: __webpack_require__(/*! ./pattern */ "./node_modules/ajv/lib/dotjs/pattern.js"),
                properties: __webpack_require__(/*! ./properties */ "./node_modules/ajv/lib/dotjs/properties.js"),
                propertyNames: __webpack_require__(/*! ./propertyNames */ "./node_modules/ajv/lib/dotjs/propertyNames.js"),
                required: __webpack_require__(/*! ./required */ "./node_modules/ajv/lib/dotjs/required.js"),
                uniqueItems: __webpack_require__(/*! ./uniqueItems */ "./node_modules/ajv/lib/dotjs/uniqueItems.js"),
                validate: __webpack_require__(/*! ./validate */ "./node_modules/ajv/lib/dotjs/validate.js")
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/dotjs/items.js": 
        /*!*********************************************!*\
          !*** ./node_modules/ajv/lib/dotjs/items.js ***!
          \*********************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            module.exports = function generate_items(it, $keyword, $ruleType) {
                var out = ' ';
                var $lvl = it.level;
                var $dataLvl = it.dataLevel;
                var $schema = it.schema[$keyword];
                var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
                var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
                var $breakOnError = !it.opts.allErrors;
                var $data = 'data' + ($dataLvl || '');
                var $valid = 'valid' + $lvl;
                var $errs = 'errs__' + $lvl;
                var $it = it.util.copy(it);
                var $closingBraces = '';
                $it.level++;
                var $nextValid = 'valid' + $it.level;
                var $idx = 'i' + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = 'data' + $dataNxt, $currentBaseId = it.baseId;
                out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
                if (Array.isArray($schema)) {
                    var $additionalItems = it.schema.additionalItems;
                    if ($additionalItems === false) {
                        out += ' ' + ($valid) + ' = ' + ($data) + '.length <= ' + ($schema.length) + '; ';
                        var $currErrSchemaPath = $errSchemaPath;
                        $errSchemaPath = it.errSchemaPath + '/additionalItems';
                        out += '  if (!' + ($valid) + ') {   ';
                        var $$outStack = $$outStack || [];
                        $$outStack.push(out);
                        out = ''; /* istanbul ignore else */
                        if (it.createErrors !== false) {
                            out += ' { keyword: \'' + ('additionalItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schema.length) + ' } ';
                            if (it.opts.messages !== false) {
                                out += ' , message: \'should NOT have more than ' + ($schema.length) + ' items\' ';
                            }
                            if (it.opts.verbose) {
                                out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                            }
                            out += ' } ';
                        }
                        else {
                            out += ' {} ';
                        }
                        var __err = out;
                        out = $$outStack.pop();
                        if (!it.compositeRule && $breakOnError) {
                            /* istanbul ignore if */
                            if (it.async) {
                                out += ' throw new ValidationError([' + (__err) + ']); ';
                            }
                            else {
                                out += ' validate.errors = [' + (__err) + ']; return false; ';
                            }
                        }
                        else {
                            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                        }
                        out += ' } ';
                        $errSchemaPath = $currErrSchemaPath;
                        if ($breakOnError) {
                            $closingBraces += '}';
                            out += ' else { ';
                        }
                    }
                    var arr1 = $schema;
                    if (arr1) {
                        var $sch, $i = -1, l1 = arr1.length - 1;
                        while ($i < l1) {
                            $sch = arr1[$i += 1];
                            if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
                                out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($i) + ') { ';
                                var $passData = $data + '[' + $i + ']';
                                $it.schema = $sch;
                                $it.schemaPath = $schemaPath + '[' + $i + ']';
                                $it.errSchemaPath = $errSchemaPath + '/' + $i;
                                $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
                                $it.dataPathArr[$dataNxt] = $i;
                                var $code = it.validate($it);
                                $it.baseId = $currentBaseId;
                                if (it.util.varOccurences($code, $nextData) < 2) {
                                    out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
                                }
                                else {
                                    out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
                                }
                                out += ' }  ';
                                if ($breakOnError) {
                                    out += ' if (' + ($nextValid) + ') { ';
                                    $closingBraces += '}';
                                }
                            }
                        }
                    }
                    if (typeof $additionalItems == 'object' && (it.opts.strictKeywords ? typeof $additionalItems == 'object' && Object.keys($additionalItems).length > 0 : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
                        $it.schema = $additionalItems;
                        $it.schemaPath = it.schemaPath + '.additionalItems';
                        $it.errSchemaPath = it.errSchemaPath + '/additionalItems';
                        out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($schema.length) + ') {  for (var ' + ($idx) + ' = ' + ($schema.length) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
                        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
                        var $passData = $data + '[' + $idx + ']';
                        $it.dataPathArr[$dataNxt] = $idx;
                        var $code = it.validate($it);
                        $it.baseId = $currentBaseId;
                        if (it.util.varOccurences($code, $nextData) < 2) {
                            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
                        }
                        else {
                            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
                        }
                        if ($breakOnError) {
                            out += ' if (!' + ($nextValid) + ') break; ';
                        }
                        out += ' } }  ';
                        if ($breakOnError) {
                            out += ' if (' + ($nextValid) + ') { ';
                            $closingBraces += '}';
                        }
                    }
                }
                else if ((it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all))) {
                    $it.schema = $schema;
                    $it.schemaPath = $schemaPath;
                    $it.errSchemaPath = $errSchemaPath;
                    out += '  for (var ' + ($idx) + ' = ' + (0) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
                    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
                    var $passData = $data + '[' + $idx + ']';
                    $it.dataPathArr[$dataNxt] = $idx;
                    var $code = it.validate($it);
                    $it.baseId = $currentBaseId;
                    if (it.util.varOccurences($code, $nextData) < 2) {
                        out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
                    }
                    else {
                        out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
                    }
                    if ($breakOnError) {
                        out += ' if (!' + ($nextValid) + ') break; ';
                    }
                    out += ' }';
                }
                if ($breakOnError) {
                    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
                }
                out = it.util.cleanUpCode(out);
                return out;
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/dotjs/multipleOf.js": 
        /*!**************************************************!*\
          !*** ./node_modules/ajv/lib/dotjs/multipleOf.js ***!
          \**************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            module.exports = function generate_multipleOf(it, $keyword, $ruleType) {
                var out = ' ';
                var $lvl = it.level;
                var $dataLvl = it.dataLevel;
                var $schema = it.schema[$keyword];
                var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
                var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
                var $breakOnError = !it.opts.allErrors;
                var $data = 'data' + ($dataLvl || '');
                var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
                if ($isData) {
                    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
                    $schemaValue = 'schema' + $lvl;
                }
                else {
                    $schemaValue = $schema;
                }
                out += 'var division' + ($lvl) + ';if (';
                if ($isData) {
                    out += ' ' + ($schemaValue) + ' !== undefined && ( typeof ' + ($schemaValue) + ' != \'number\' || ';
                }
                out += ' (division' + ($lvl) + ' = ' + ($data) + ' / ' + ($schemaValue) + ', ';
                if (it.opts.multipleOfPrecision) {
                    out += ' Math.abs(Math.round(division' + ($lvl) + ') - division' + ($lvl) + ') > 1e-' + (it.opts.multipleOfPrecision) + ' ';
                }
                else {
                    out += ' division' + ($lvl) + ' !== parseInt(division' + ($lvl) + ') ';
                }
                out += ' ) ';
                if ($isData) {
                    out += '  )  ';
                }
                out += ' ) {   ';
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = ''; /* istanbul ignore else */
                if (it.createErrors !== false) {
                    out += ' { keyword: \'' + ('multipleOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { multipleOf: ' + ($schemaValue) + ' } ';
                    if (it.opts.messages !== false) {
                        out += ' , message: \'should be multiple of ';
                        if ($isData) {
                            out += '\' + ' + ($schemaValue);
                        }
                        else {
                            out += '' + ($schemaValue) + '\'';
                        }
                    }
                    if (it.opts.verbose) {
                        out += ' , schema:  ';
                        if ($isData) {
                            out += 'validate.schema' + ($schemaPath);
                        }
                        else {
                            out += '' + ($schema);
                        }
                        out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                    }
                    out += ' } ';
                }
                else {
                    out += ' {} ';
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */
                    if (it.async) {
                        out += ' throw new ValidationError([' + (__err) + ']); ';
                    }
                    else {
                        out += ' validate.errors = [' + (__err) + ']; return false; ';
                    }
                }
                else {
                    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                }
                out += '} ';
                if ($breakOnError) {
                    out += ' else { ';
                }
                return out;
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/dotjs/not.js": 
        /*!*******************************************!*\
          !*** ./node_modules/ajv/lib/dotjs/not.js ***!
          \*******************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            module.exports = function generate_not(it, $keyword, $ruleType) {
                var out = ' ';
                var $lvl = it.level;
                var $dataLvl = it.dataLevel;
                var $schema = it.schema[$keyword];
                var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
                var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
                var $breakOnError = !it.opts.allErrors;
                var $data = 'data' + ($dataLvl || '');
                var $errs = 'errs__' + $lvl;
                var $it = it.util.copy(it);
                $it.level++;
                var $nextValid = 'valid' + $it.level;
                if ((it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all))) {
                    $it.schema = $schema;
                    $it.schemaPath = $schemaPath;
                    $it.errSchemaPath = $errSchemaPath;
                    out += ' var ' + ($errs) + ' = errors;  ';
                    var $wasComposite = it.compositeRule;
                    it.compositeRule = $it.compositeRule = true;
                    $it.createErrors = false;
                    var $allErrorsOption;
                    if ($it.opts.allErrors) {
                        $allErrorsOption = $it.opts.allErrors;
                        $it.opts.allErrors = false;
                    }
                    out += ' ' + (it.validate($it)) + ' ';
                    $it.createErrors = true;
                    if ($allErrorsOption)
                        $it.opts.allErrors = $allErrorsOption;
                    it.compositeRule = $it.compositeRule = $wasComposite;
                    out += ' if (' + ($nextValid) + ') {   ';
                    var $$outStack = $$outStack || [];
                    $$outStack.push(out);
                    out = ''; /* istanbul ignore else */
                    if (it.createErrors !== false) {
                        out += ' { keyword: \'' + ('not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
                        if (it.opts.messages !== false) {
                            out += ' , message: \'should NOT be valid\' ';
                        }
                        if (it.opts.verbose) {
                            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                        }
                        out += ' } ';
                    }
                    else {
                        out += ' {} ';
                    }
                    var __err = out;
                    out = $$outStack.pop();
                    if (!it.compositeRule && $breakOnError) {
                        /* istanbul ignore if */
                        if (it.async) {
                            out += ' throw new ValidationError([' + (__err) + ']); ';
                        }
                        else {
                            out += ' validate.errors = [' + (__err) + ']; return false; ';
                        }
                    }
                    else {
                        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                    }
                    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
                    if (it.opts.allErrors) {
                        out += ' } ';
                    }
                }
                else {
                    out += '  var err =   '; /* istanbul ignore else */
                    if (it.createErrors !== false) {
                        out += ' { keyword: \'' + ('not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
                        if (it.opts.messages !== false) {
                            out += ' , message: \'should NOT be valid\' ';
                        }
                        if (it.opts.verbose) {
                            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                        }
                        out += ' } ';
                    }
                    else {
                        out += ' {} ';
                    }
                    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                    if ($breakOnError) {
                        out += ' if (false) { ';
                    }
                }
                return out;
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/dotjs/oneOf.js": 
        /*!*********************************************!*\
          !*** ./node_modules/ajv/lib/dotjs/oneOf.js ***!
          \*********************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            module.exports = function generate_oneOf(it, $keyword, $ruleType) {
                var out = ' ';
                var $lvl = it.level;
                var $dataLvl = it.dataLevel;
                var $schema = it.schema[$keyword];
                var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
                var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
                var $breakOnError = !it.opts.allErrors;
                var $data = 'data' + ($dataLvl || '');
                var $valid = 'valid' + $lvl;
                var $errs = 'errs__' + $lvl;
                var $it = it.util.copy(it);
                var $closingBraces = '';
                $it.level++;
                var $nextValid = 'valid' + $it.level;
                var $currentBaseId = $it.baseId, $prevValid = 'prevValid' + $lvl, $passingSchemas = 'passingSchemas' + $lvl;
                out += 'var ' + ($errs) + ' = errors , ' + ($prevValid) + ' = false , ' + ($valid) + ' = false , ' + ($passingSchemas) + ' = null; ';
                var $wasComposite = it.compositeRule;
                it.compositeRule = $it.compositeRule = true;
                var arr1 = $schema;
                if (arr1) {
                    var $sch, $i = -1, l1 = arr1.length - 1;
                    while ($i < l1) {
                        $sch = arr1[$i += 1];
                        if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
                            $it.schema = $sch;
                            $it.schemaPath = $schemaPath + '[' + $i + ']';
                            $it.errSchemaPath = $errSchemaPath + '/' + $i;
                            out += '  ' + (it.validate($it)) + ' ';
                            $it.baseId = $currentBaseId;
                        }
                        else {
                            out += ' var ' + ($nextValid) + ' = true; ';
                        }
                        if ($i) {
                            out += ' if (' + ($nextValid) + ' && ' + ($prevValid) + ') { ' + ($valid) + ' = false; ' + ($passingSchemas) + ' = [' + ($passingSchemas) + ', ' + ($i) + ']; } else { ';
                            $closingBraces += '}';
                        }
                        out += ' if (' + ($nextValid) + ') { ' + ($valid) + ' = ' + ($prevValid) + ' = true; ' + ($passingSchemas) + ' = ' + ($i) + '; }';
                    }
                }
                it.compositeRule = $it.compositeRule = $wasComposite;
                out += '' + ($closingBraces) + 'if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
                if (it.createErrors !== false) {
                    out += ' { keyword: \'' + ('oneOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { passingSchemas: ' + ($passingSchemas) + ' } ';
                    if (it.opts.messages !== false) {
                        out += ' , message: \'should match exactly one schema in oneOf\' ';
                    }
                    if (it.opts.verbose) {
                        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                    }
                    out += ' } ';
                }
                else {
                    out += ' {} ';
                }
                out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */
                    if (it.async) {
                        out += ' throw new ValidationError(vErrors); ';
                    }
                    else {
                        out += ' validate.errors = vErrors; return false; ';
                    }
                }
                out += '} else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }';
                if (it.opts.allErrors) {
                    out += ' } ';
                }
                return out;
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/dotjs/pattern.js": 
        /*!***********************************************!*\
          !*** ./node_modules/ajv/lib/dotjs/pattern.js ***!
          \***********************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            module.exports = function generate_pattern(it, $keyword, $ruleType) {
                var out = ' ';
                var $lvl = it.level;
                var $dataLvl = it.dataLevel;
                var $schema = it.schema[$keyword];
                var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
                var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
                var $breakOnError = !it.opts.allErrors;
                var $data = 'data' + ($dataLvl || '');
                var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
                if ($isData) {
                    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
                    $schemaValue = 'schema' + $lvl;
                }
                else {
                    $schemaValue = $schema;
                }
                var $regexp = $isData ? '(new RegExp(' + $schemaValue + '))' : it.usePattern($schema);
                out += 'if ( ';
                if ($isData) {
                    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
                }
                out += ' !' + ($regexp) + '.test(' + ($data) + ') ) {   ';
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = ''; /* istanbul ignore else */
                if (it.createErrors !== false) {
                    out += ' { keyword: \'' + ('pattern') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { pattern:  ';
                    if ($isData) {
                        out += '' + ($schemaValue);
                    }
                    else {
                        out += '' + (it.util.toQuotedString($schema));
                    }
                    out += '  } ';
                    if (it.opts.messages !== false) {
                        out += ' , message: \'should match pattern "';
                        if ($isData) {
                            out += '\' + ' + ($schemaValue) + ' + \'';
                        }
                        else {
                            out += '' + (it.util.escapeQuotes($schema));
                        }
                        out += '"\' ';
                    }
                    if (it.opts.verbose) {
                        out += ' , schema:  ';
                        if ($isData) {
                            out += 'validate.schema' + ($schemaPath);
                        }
                        else {
                            out += '' + (it.util.toQuotedString($schema));
                        }
                        out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                    }
                    out += ' } ';
                }
                else {
                    out += ' {} ';
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */
                    if (it.async) {
                        out += ' throw new ValidationError([' + (__err) + ']); ';
                    }
                    else {
                        out += ' validate.errors = [' + (__err) + ']; return false; ';
                    }
                }
                else {
                    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                }
                out += '} ';
                if ($breakOnError) {
                    out += ' else { ';
                }
                return out;
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/dotjs/properties.js": 
        /*!**************************************************!*\
          !*** ./node_modules/ajv/lib/dotjs/properties.js ***!
          \**************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            module.exports = function generate_properties(it, $keyword, $ruleType) {
                var out = ' ';
                var $lvl = it.level;
                var $dataLvl = it.dataLevel;
                var $schema = it.schema[$keyword];
                var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
                var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
                var $breakOnError = !it.opts.allErrors;
                var $data = 'data' + ($dataLvl || '');
                var $errs = 'errs__' + $lvl;
                var $it = it.util.copy(it);
                var $closingBraces = '';
                $it.level++;
                var $nextValid = 'valid' + $it.level;
                var $key = 'key' + $lvl, $idx = 'idx' + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = 'data' + $dataNxt, $dataProperties = 'dataProperties' + $lvl;
                var $schemaKeys = Object.keys($schema || {}), $pProperties = it.schema.patternProperties || {}, $pPropertyKeys = Object.keys($pProperties), $aProperties = it.schema.additionalProperties, $someProperties = $schemaKeys.length || $pPropertyKeys.length, $noAdditional = $aProperties === false, $additionalIsSchema = typeof $aProperties == 'object' && Object.keys($aProperties).length, $removeAdditional = it.opts.removeAdditional, $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
                var $required = it.schema.required;
                if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired)
                    var $requiredHash = it.util.toHash($required);
                out += 'var ' + ($errs) + ' = errors;var ' + ($nextValid) + ' = true;';
                if ($ownProperties) {
                    out += ' var ' + ($dataProperties) + ' = undefined;';
                }
                if ($checkAdditional) {
                    if ($ownProperties) {
                        out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
                    }
                    else {
                        out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
                    }
                    if ($someProperties) {
                        out += ' var isAdditional' + ($lvl) + ' = !(false ';
                        if ($schemaKeys.length) {
                            if ($schemaKeys.length > 8) {
                                out += ' || validate.schema' + ($schemaPath) + '.hasOwnProperty(' + ($key) + ') ';
                            }
                            else {
                                var arr1 = $schemaKeys;
                                if (arr1) {
                                    var $propertyKey, i1 = -1, l1 = arr1.length - 1;
                                    while (i1 < l1) {
                                        $propertyKey = arr1[i1 += 1];
                                        out += ' || ' + ($key) + ' == ' + (it.util.toQuotedString($propertyKey)) + ' ';
                                    }
                                }
                            }
                        }
                        if ($pPropertyKeys.length) {
                            var arr2 = $pPropertyKeys;
                            if (arr2) {
                                var $pProperty, $i = -1, l2 = arr2.length - 1;
                                while ($i < l2) {
                                    $pProperty = arr2[$i += 1];
                                    out += ' || ' + (it.usePattern($pProperty)) + '.test(' + ($key) + ') ';
                                }
                            }
                        }
                        out += ' ); if (isAdditional' + ($lvl) + ') { ';
                    }
                    if ($removeAdditional == 'all') {
                        out += ' delete ' + ($data) + '[' + ($key) + ']; ';
                    }
                    else {
                        var $currentErrorPath = it.errorPath;
                        var $additionalProperty = '\' + ' + $key + ' + \'';
                        if (it.opts._errorDataPathProperty) {
                            it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
                        }
                        if ($noAdditional) {
                            if ($removeAdditional) {
                                out += ' delete ' + ($data) + '[' + ($key) + ']; ';
                            }
                            else {
                                out += ' ' + ($nextValid) + ' = false; ';
                                var $currErrSchemaPath = $errSchemaPath;
                                $errSchemaPath = it.errSchemaPath + '/additionalProperties';
                                var $$outStack = $$outStack || [];
                                $$outStack.push(out);
                                out = ''; /* istanbul ignore else */
                                if (it.createErrors !== false) {
                                    out += ' { keyword: \'' + ('additionalProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { additionalProperty: \'' + ($additionalProperty) + '\' } ';
                                    if (it.opts.messages !== false) {
                                        out += ' , message: \'';
                                        if (it.opts._errorDataPathProperty) {
                                            out += 'is an invalid additional property';
                                        }
                                        else {
                                            out += 'should NOT have additional properties';
                                        }
                                        out += '\' ';
                                    }
                                    if (it.opts.verbose) {
                                        out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                                    }
                                    out += ' } ';
                                }
                                else {
                                    out += ' {} ';
                                }
                                var __err = out;
                                out = $$outStack.pop();
                                if (!it.compositeRule && $breakOnError) {
                                    /* istanbul ignore if */
                                    if (it.async) {
                                        out += ' throw new ValidationError([' + (__err) + ']); ';
                                    }
                                    else {
                                        out += ' validate.errors = [' + (__err) + ']; return false; ';
                                    }
                                }
                                else {
                                    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                                }
                                $errSchemaPath = $currErrSchemaPath;
                                if ($breakOnError) {
                                    out += ' break; ';
                                }
                            }
                        }
                        else if ($additionalIsSchema) {
                            if ($removeAdditional == 'failing') {
                                out += ' var ' + ($errs) + ' = errors;  ';
                                var $wasComposite = it.compositeRule;
                                it.compositeRule = $it.compositeRule = true;
                                $it.schema = $aProperties;
                                $it.schemaPath = it.schemaPath + '.additionalProperties';
                                $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
                                $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
                                var $passData = $data + '[' + $key + ']';
                                $it.dataPathArr[$dataNxt] = $key;
                                var $code = it.validate($it);
                                $it.baseId = $currentBaseId;
                                if (it.util.varOccurences($code, $nextData) < 2) {
                                    out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
                                }
                                else {
                                    out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
                                }
                                out += ' if (!' + ($nextValid) + ') { errors = ' + ($errs) + '; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete ' + ($data) + '[' + ($key) + ']; }  ';
                                it.compositeRule = $it.compositeRule = $wasComposite;
                            }
                            else {
                                $it.schema = $aProperties;
                                $it.schemaPath = it.schemaPath + '.additionalProperties';
                                $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
                                $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
                                var $passData = $data + '[' + $key + ']';
                                $it.dataPathArr[$dataNxt] = $key;
                                var $code = it.validate($it);
                                $it.baseId = $currentBaseId;
                                if (it.util.varOccurences($code, $nextData) < 2) {
                                    out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
                                }
                                else {
                                    out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
                                }
                                if ($breakOnError) {
                                    out += ' if (!' + ($nextValid) + ') break; ';
                                }
                            }
                        }
                        it.errorPath = $currentErrorPath;
                    }
                    if ($someProperties) {
                        out += ' } ';
                    }
                    out += ' }  ';
                    if ($breakOnError) {
                        out += ' if (' + ($nextValid) + ') { ';
                        $closingBraces += '}';
                    }
                }
                var $useDefaults = it.opts.useDefaults && !it.compositeRule;
                if ($schemaKeys.length) {
                    var arr3 = $schemaKeys;
                    if (arr3) {
                        var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                        while (i3 < l3) {
                            $propertyKey = arr3[i3 += 1];
                            var $sch = $schema[$propertyKey];
                            if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
                                var $prop = it.util.getProperty($propertyKey), $passData = $data + $prop, $hasDefault = $useDefaults && $sch.default !== undefined;
                                $it.schema = $sch;
                                $it.schemaPath = $schemaPath + $prop;
                                $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($propertyKey);
                                $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
                                $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
                                var $code = it.validate($it);
                                $it.baseId = $currentBaseId;
                                if (it.util.varOccurences($code, $nextData) < 2) {
                                    $code = it.util.varReplace($code, $nextData, $passData);
                                    var $useData = $passData;
                                }
                                else {
                                    var $useData = $nextData;
                                    out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ';
                                }
                                if ($hasDefault) {
                                    out += ' ' + ($code) + ' ';
                                }
                                else {
                                    if ($requiredHash && $requiredHash[$propertyKey]) {
                                        out += ' if ( ' + ($useData) + ' === undefined ';
                                        if ($ownProperties) {
                                            out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                                        }
                                        out += ') { ' + ($nextValid) + ' = false; ';
                                        var $currentErrorPath = it.errorPath, $currErrSchemaPath = $errSchemaPath, $missingProperty = it.util.escapeQuotes($propertyKey);
                                        if (it.opts._errorDataPathProperty) {
                                            it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                                        }
                                        $errSchemaPath = it.errSchemaPath + '/required';
                                        var $$outStack = $$outStack || [];
                                        $$outStack.push(out);
                                        out = ''; /* istanbul ignore else */
                                        if (it.createErrors !== false) {
                                            out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
                                            if (it.opts.messages !== false) {
                                                out += ' , message: \'';
                                                if (it.opts._errorDataPathProperty) {
                                                    out += 'is a required property';
                                                }
                                                else {
                                                    out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                                                }
                                                out += '\' ';
                                            }
                                            if (it.opts.verbose) {
                                                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                                            }
                                            out += ' } ';
                                        }
                                        else {
                                            out += ' {} ';
                                        }
                                        var __err = out;
                                        out = $$outStack.pop();
                                        if (!it.compositeRule && $breakOnError) {
                                            /* istanbul ignore if */
                                            if (it.async) {
                                                out += ' throw new ValidationError([' + (__err) + ']); ';
                                            }
                                            else {
                                                out += ' validate.errors = [' + (__err) + ']; return false; ';
                                            }
                                        }
                                        else {
                                            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                                        }
                                        $errSchemaPath = $currErrSchemaPath;
                                        it.errorPath = $currentErrorPath;
                                        out += ' } else { ';
                                    }
                                    else {
                                        if ($breakOnError) {
                                            out += ' if ( ' + ($useData) + ' === undefined ';
                                            if ($ownProperties) {
                                                out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                                            }
                                            out += ') { ' + ($nextValid) + ' = true; } else { ';
                                        }
                                        else {
                                            out += ' if (' + ($useData) + ' !== undefined ';
                                            if ($ownProperties) {
                                                out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                                            }
                                            out += ' ) { ';
                                        }
                                    }
                                    out += ' ' + ($code) + ' } ';
                                }
                            }
                            if ($breakOnError) {
                                out += ' if (' + ($nextValid) + ') { ';
                                $closingBraces += '}';
                            }
                        }
                    }
                }
                if ($pPropertyKeys.length) {
                    var arr4 = $pPropertyKeys;
                    if (arr4) {
                        var $pProperty, i4 = -1, l4 = arr4.length - 1;
                        while (i4 < l4) {
                            $pProperty = arr4[i4 += 1];
                            var $sch = $pProperties[$pProperty];
                            if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
                                $it.schema = $sch;
                                $it.schemaPath = it.schemaPath + '.patternProperties' + it.util.getProperty($pProperty);
                                $it.errSchemaPath = it.errSchemaPath + '/patternProperties/' + it.util.escapeFragment($pProperty);
                                if ($ownProperties) {
                                    out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
                                }
                                else {
                                    out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
                                }
                                out += ' if (' + (it.usePattern($pProperty)) + '.test(' + ($key) + ')) { ';
                                $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
                                var $passData = $data + '[' + $key + ']';
                                $it.dataPathArr[$dataNxt] = $key;
                                var $code = it.validate($it);
                                $it.baseId = $currentBaseId;
                                if (it.util.varOccurences($code, $nextData) < 2) {
                                    out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
                                }
                                else {
                                    out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
                                }
                                if ($breakOnError) {
                                    out += ' if (!' + ($nextValid) + ') break; ';
                                }
                                out += ' } ';
                                if ($breakOnError) {
                                    out += ' else ' + ($nextValid) + ' = true; ';
                                }
                                out += ' }  ';
                                if ($breakOnError) {
                                    out += ' if (' + ($nextValid) + ') { ';
                                    $closingBraces += '}';
                                }
                            }
                        }
                    }
                }
                if ($breakOnError) {
                    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
                }
                out = it.util.cleanUpCode(out);
                return out;
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/dotjs/propertyNames.js": 
        /*!*****************************************************!*\
          !*** ./node_modules/ajv/lib/dotjs/propertyNames.js ***!
          \*****************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            module.exports = function generate_propertyNames(it, $keyword, $ruleType) {
                var out = ' ';
                var $lvl = it.level;
                var $dataLvl = it.dataLevel;
                var $schema = it.schema[$keyword];
                var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
                var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
                var $breakOnError = !it.opts.allErrors;
                var $data = 'data' + ($dataLvl || '');
                var $errs = 'errs__' + $lvl;
                var $it = it.util.copy(it);
                var $closingBraces = '';
                $it.level++;
                var $nextValid = 'valid' + $it.level;
                out += 'var ' + ($errs) + ' = errors;';
                if ((it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all))) {
                    $it.schema = $schema;
                    $it.schemaPath = $schemaPath;
                    $it.errSchemaPath = $errSchemaPath;
                    var $key = 'key' + $lvl, $idx = 'idx' + $lvl, $i = 'i' + $lvl, $invalidName = '\' + ' + $key + ' + \'', $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = 'data' + $dataNxt, $dataProperties = 'dataProperties' + $lvl, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
                    if ($ownProperties) {
                        out += ' var ' + ($dataProperties) + ' = undefined; ';
                    }
                    if ($ownProperties) {
                        out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
                    }
                    else {
                        out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
                    }
                    out += ' var startErrs' + ($lvl) + ' = errors; ';
                    var $passData = $key;
                    var $wasComposite = it.compositeRule;
                    it.compositeRule = $it.compositeRule = true;
                    var $code = it.validate($it);
                    $it.baseId = $currentBaseId;
                    if (it.util.varOccurences($code, $nextData) < 2) {
                        out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
                    }
                    else {
                        out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
                    }
                    it.compositeRule = $it.compositeRule = $wasComposite;
                    out += ' if (!' + ($nextValid) + ') { for (var ' + ($i) + '=startErrs' + ($lvl) + '; ' + ($i) + '<errors; ' + ($i) + '++) { vErrors[' + ($i) + '].propertyName = ' + ($key) + '; }   var err =   '; /* istanbul ignore else */
                    if (it.createErrors !== false) {
                        out += ' { keyword: \'' + ('propertyNames') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { propertyName: \'' + ($invalidName) + '\' } ';
                        if (it.opts.messages !== false) {
                            out += ' , message: \'property name \\\'' + ($invalidName) + '\\\' is invalid\' ';
                        }
                        if (it.opts.verbose) {
                            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                        }
                        out += ' } ';
                    }
                    else {
                        out += ' {} ';
                    }
                    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                    if (!it.compositeRule && $breakOnError) {
                        /* istanbul ignore if */
                        if (it.async) {
                            out += ' throw new ValidationError(vErrors); ';
                        }
                        else {
                            out += ' validate.errors = vErrors; return false; ';
                        }
                    }
                    if ($breakOnError) {
                        out += ' break; ';
                    }
                    out += ' } }';
                }
                if ($breakOnError) {
                    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
                }
                out = it.util.cleanUpCode(out);
                return out;
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/dotjs/ref.js": 
        /*!*******************************************!*\
          !*** ./node_modules/ajv/lib/dotjs/ref.js ***!
          \*******************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            module.exports = function generate_ref(it, $keyword, $ruleType) {
                var out = ' ';
                var $lvl = it.level;
                var $dataLvl = it.dataLevel;
                var $schema = it.schema[$keyword];
                var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
                var $breakOnError = !it.opts.allErrors;
                var $data = 'data' + ($dataLvl || '');
                var $valid = 'valid' + $lvl;
                var $async, $refCode;
                if ($schema == '#' || $schema == '#/') {
                    if (it.isRoot) {
                        $async = it.async;
                        $refCode = 'validate';
                    }
                    else {
                        $async = it.root.schema.$async === true;
                        $refCode = 'root.refVal[0]';
                    }
                }
                else {
                    var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
                    if ($refVal === undefined) {
                        var $message = it.MissingRefError.message(it.baseId, $schema);
                        if (it.opts.missingRefs == 'fail') {
                            it.logger.error($message);
                            var $$outStack = $$outStack || [];
                            $$outStack.push(out);
                            out = ''; /* istanbul ignore else */
                            if (it.createErrors !== false) {
                                out += ' { keyword: \'' + ('$ref') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { ref: \'' + (it.util.escapeQuotes($schema)) + '\' } ';
                                if (it.opts.messages !== false) {
                                    out += ' , message: \'can\\\'t resolve reference ' + (it.util.escapeQuotes($schema)) + '\' ';
                                }
                                if (it.opts.verbose) {
                                    out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                                }
                                out += ' } ';
                            }
                            else {
                                out += ' {} ';
                            }
                            var __err = out;
                            out = $$outStack.pop();
                            if (!it.compositeRule && $breakOnError) {
                                /* istanbul ignore if */
                                if (it.async) {
                                    out += ' throw new ValidationError([' + (__err) + ']); ';
                                }
                                else {
                                    out += ' validate.errors = [' + (__err) + ']; return false; ';
                                }
                            }
                            else {
                                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                            }
                            if ($breakOnError) {
                                out += ' if (false) { ';
                            }
                        }
                        else if (it.opts.missingRefs == 'ignore') {
                            it.logger.warn($message);
                            if ($breakOnError) {
                                out += ' if (true) { ';
                            }
                        }
                        else {
                            throw new it.MissingRefError(it.baseId, $schema, $message);
                        }
                    }
                    else if ($refVal.inline) {
                        var $it = it.util.copy(it);
                        $it.level++;
                        var $nextValid = 'valid' + $it.level;
                        $it.schema = $refVal.schema;
                        $it.schemaPath = '';
                        $it.errSchemaPath = $schema;
                        var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
                        out += ' ' + ($code) + ' ';
                        if ($breakOnError) {
                            out += ' if (' + ($nextValid) + ') { ';
                        }
                    }
                    else {
                        $async = $refVal.$async === true || (it.async && $refVal.$async !== false);
                        $refCode = $refVal.code;
                    }
                }
                if ($refCode) {
                    var $$outStack = $$outStack || [];
                    $$outStack.push(out);
                    out = '';
                    if (it.opts.passContext) {
                        out += ' ' + ($refCode) + '.call(this, ';
                    }
                    else {
                        out += ' ' + ($refCode) + '( ';
                    }
                    out += ' ' + ($data) + ', (dataPath || \'\')';
                    if (it.errorPath != '""') {
                        out += ' + ' + (it.errorPath);
                    }
                    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData', $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
                    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ', rootData)  ';
                    var __callValidate = out;
                    out = $$outStack.pop();
                    if ($async) {
                        if (!it.async)
                            throw new Error('async schema referenced by sync schema');
                        if ($breakOnError) {
                            out += ' var ' + ($valid) + '; ';
                        }
                        out += ' try { await ' + (__callValidate) + '; ';
                        if ($breakOnError) {
                            out += ' ' + ($valid) + ' = true; ';
                        }
                        out += ' } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ';
                        if ($breakOnError) {
                            out += ' ' + ($valid) + ' = false; ';
                        }
                        out += ' } ';
                        if ($breakOnError) {
                            out += ' if (' + ($valid) + ') { ';
                        }
                    }
                    else {
                        out += ' if (!' + (__callValidate) + ') { if (vErrors === null) vErrors = ' + ($refCode) + '.errors; else vErrors = vErrors.concat(' + ($refCode) + '.errors); errors = vErrors.length; } ';
                        if ($breakOnError) {
                            out += ' else { ';
                        }
                    }
                }
                return out;
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/dotjs/required.js": 
        /*!************************************************!*\
          !*** ./node_modules/ajv/lib/dotjs/required.js ***!
          \************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            module.exports = function generate_required(it, $keyword, $ruleType) {
                var out = ' ';
                var $lvl = it.level;
                var $dataLvl = it.dataLevel;
                var $schema = it.schema[$keyword];
                var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
                var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
                var $breakOnError = !it.opts.allErrors;
                var $data = 'data' + ($dataLvl || '');
                var $valid = 'valid' + $lvl;
                var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
                if ($isData) {
                    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
                    $schemaValue = 'schema' + $lvl;
                }
                else {
                    $schemaValue = $schema;
                }
                var $vSchema = 'schema' + $lvl;
                if (!$isData) {
                    if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
                        var $required = [];
                        var arr1 = $schema;
                        if (arr1) {
                            var $property, i1 = -1, l1 = arr1.length - 1;
                            while (i1 < l1) {
                                $property = arr1[i1 += 1];
                                var $propertySch = it.schema.properties[$property];
                                if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == 'object' && Object.keys($propertySch).length > 0 : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
                                    $required[$required.length] = $property;
                                }
                            }
                        }
                    }
                    else {
                        var $required = $schema;
                    }
                }
                if ($isData || $required.length) {
                    var $currentErrorPath = it.errorPath, $loopRequired = $isData || $required.length >= it.opts.loopRequired, $ownProperties = it.opts.ownProperties;
                    if ($breakOnError) {
                        out += ' var missing' + ($lvl) + '; ';
                        if ($loopRequired) {
                            if (!$isData) {
                                out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
                            }
                            var $i = 'i' + $lvl, $propertyPath = 'schema' + $lvl + '[' + $i + ']', $missingProperty = '\' + ' + $propertyPath + ' + \'';
                            if (it.opts._errorDataPathProperty) {
                                it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
                            }
                            out += ' var ' + ($valid) + ' = true; ';
                            if ($isData) {
                                out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
                            }
                            out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { ' + ($valid) + ' = ' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] !== undefined ';
                            if ($ownProperties) {
                                out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';
                            }
                            out += '; if (!' + ($valid) + ') break; } ';
                            if ($isData) {
                                out += '  }  ';
                            }
                            out += '  if (!' + ($valid) + ') {   ';
                            var $$outStack = $$outStack || [];
                            $$outStack.push(out);
                            out = ''; /* istanbul ignore else */
                            if (it.createErrors !== false) {
                                out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
                                if (it.opts.messages !== false) {
                                    out += ' , message: \'';
                                    if (it.opts._errorDataPathProperty) {
                                        out += 'is a required property';
                                    }
                                    else {
                                        out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                                    }
                                    out += '\' ';
                                }
                                if (it.opts.verbose) {
                                    out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                                }
                                out += ' } ';
                            }
                            else {
                                out += ' {} ';
                            }
                            var __err = out;
                            out = $$outStack.pop();
                            if (!it.compositeRule && $breakOnError) {
                                /* istanbul ignore if */
                                if (it.async) {
                                    out += ' throw new ValidationError([' + (__err) + ']); ';
                                }
                                else {
                                    out += ' validate.errors = [' + (__err) + ']; return false; ';
                                }
                            }
                            else {
                                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                            }
                            out += ' } else { ';
                        }
                        else {
                            out += ' if ( ';
                            var arr2 = $required;
                            if (arr2) {
                                var $propertyKey, $i = -1, l2 = arr2.length - 1;
                                while ($i < l2) {
                                    $propertyKey = arr2[$i += 1];
                                    if ($i) {
                                        out += ' || ';
                                    }
                                    var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
                                    out += ' ( ( ' + ($useData) + ' === undefined ';
                                    if ($ownProperties) {
                                        out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                                    }
                                    out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';
                                }
                            }
                            out += ') {  ';
                            var $propertyPath = 'missing' + $lvl, $missingProperty = '\' + ' + $propertyPath + ' + \'';
                            if (it.opts._errorDataPathProperty) {
                                it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
                            }
                            var $$outStack = $$outStack || [];
                            $$outStack.push(out);
                            out = ''; /* istanbul ignore else */
                            if (it.createErrors !== false) {
                                out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
                                if (it.opts.messages !== false) {
                                    out += ' , message: \'';
                                    if (it.opts._errorDataPathProperty) {
                                        out += 'is a required property';
                                    }
                                    else {
                                        out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                                    }
                                    out += '\' ';
                                }
                                if (it.opts.verbose) {
                                    out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                                }
                                out += ' } ';
                            }
                            else {
                                out += ' {} ';
                            }
                            var __err = out;
                            out = $$outStack.pop();
                            if (!it.compositeRule && $breakOnError) {
                                /* istanbul ignore if */
                                if (it.async) {
                                    out += ' throw new ValidationError([' + (__err) + ']); ';
                                }
                                else {
                                    out += ' validate.errors = [' + (__err) + ']; return false; ';
                                }
                            }
                            else {
                                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                            }
                            out += ' } else { ';
                        }
                    }
                    else {
                        if ($loopRequired) {
                            if (!$isData) {
                                out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
                            }
                            var $i = 'i' + $lvl, $propertyPath = 'schema' + $lvl + '[' + $i + ']', $missingProperty = '\' + ' + $propertyPath + ' + \'';
                            if (it.opts._errorDataPathProperty) {
                                it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
                            }
                            if ($isData) {
                                out += ' if (' + ($vSchema) + ' && !Array.isArray(' + ($vSchema) + ')) {  var err =   '; /* istanbul ignore else */
                                if (it.createErrors !== false) {
                                    out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
                                    if (it.opts.messages !== false) {
                                        out += ' , message: \'';
                                        if (it.opts._errorDataPathProperty) {
                                            out += 'is a required property';
                                        }
                                        else {
                                            out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                                        }
                                        out += '\' ';
                                    }
                                    if (it.opts.verbose) {
                                        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                                    }
                                    out += ' } ';
                                }
                                else {
                                    out += ' {} ';
                                }
                                out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (' + ($vSchema) + ' !== undefined) { ';
                            }
                            out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { if (' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] === undefined ';
                            if ($ownProperties) {
                                out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';
                            }
                            out += ') {  var err =   '; /* istanbul ignore else */
                            if (it.createErrors !== false) {
                                out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
                                if (it.opts.messages !== false) {
                                    out += ' , message: \'';
                                    if (it.opts._errorDataPathProperty) {
                                        out += 'is a required property';
                                    }
                                    else {
                                        out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                                    }
                                    out += '\' ';
                                }
                                if (it.opts.verbose) {
                                    out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                                }
                                out += ' } ';
                            }
                            else {
                                out += ' {} ';
                            }
                            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ';
                            if ($isData) {
                                out += '  }  ';
                            }
                        }
                        else {
                            var arr3 = $required;
                            if (arr3) {
                                var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                                while (i3 < l3) {
                                    $propertyKey = arr3[i3 += 1];
                                    var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                                    if (it.opts._errorDataPathProperty) {
                                        it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                                    }
                                    out += ' if ( ' + ($useData) + ' === undefined ';
                                    if ($ownProperties) {
                                        out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                                    }
                                    out += ') {  var err =   '; /* istanbul ignore else */
                                    if (it.createErrors !== false) {
                                        out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
                                        if (it.opts.messages !== false) {
                                            out += ' , message: \'';
                                            if (it.opts._errorDataPathProperty) {
                                                out += 'is a required property';
                                            }
                                            else {
                                                out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                                            }
                                            out += '\' ';
                                        }
                                        if (it.opts.verbose) {
                                            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                                        }
                                        out += ' } ';
                                    }
                                    else {
                                        out += ' {} ';
                                    }
                                    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
                                }
                            }
                        }
                    }
                    it.errorPath = $currentErrorPath;
                }
                else if ($breakOnError) {
                    out += ' if (true) {';
                }
                return out;
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/dotjs/uniqueItems.js": 
        /*!***************************************************!*\
          !*** ./node_modules/ajv/lib/dotjs/uniqueItems.js ***!
          \***************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            module.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
                var out = ' ';
                var $lvl = it.level;
                var $dataLvl = it.dataLevel;
                var $schema = it.schema[$keyword];
                var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
                var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
                var $breakOnError = !it.opts.allErrors;
                var $data = 'data' + ($dataLvl || '');
                var $valid = 'valid' + $lvl;
                var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
                if ($isData) {
                    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
                    $schemaValue = 'schema' + $lvl;
                }
                else {
                    $schemaValue = $schema;
                }
                if (($schema || $isData) && it.opts.uniqueItems !== false) {
                    if ($isData) {
                        out += ' var ' + ($valid) + '; if (' + ($schemaValue) + ' === false || ' + ($schemaValue) + ' === undefined) ' + ($valid) + ' = true; else if (typeof ' + ($schemaValue) + ' != \'boolean\') ' + ($valid) + ' = false; else { ';
                    }
                    out += ' var i = ' + ($data) + '.length , ' + ($valid) + ' = true , j; if (i > 1) { ';
                    var $itemType = it.schema.items && it.schema.items.type, $typeIsArray = Array.isArray($itemType);
                    if (!$itemType || $itemType == 'object' || $itemType == 'array' || ($typeIsArray && ($itemType.indexOf('object') >= 0 || $itemType.indexOf('array') >= 0))) {
                        out += ' outer: for (;i--;) { for (j = i; j--;) { if (equal(' + ($data) + '[i], ' + ($data) + '[j])) { ' + ($valid) + ' = false; break outer; } } } ';
                    }
                    else {
                        out += ' var itemIndices = {}, item; for (;i--;) { var item = ' + ($data) + '[i]; ';
                        var $method = 'checkDataType' + ($typeIsArray ? 's' : '');
                        out += ' if (' + (it.util[$method]($itemType, 'item', true)) + ') continue; ';
                        if ($typeIsArray) {
                            out += ' if (typeof item == \'string\') item = \'"\' + item; ';
                        }
                        out += ' if (typeof itemIndices[item] == \'number\') { ' + ($valid) + ' = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ';
                    }
                    out += ' } ';
                    if ($isData) {
                        out += '  }  ';
                    }
                    out += ' if (!' + ($valid) + ') {   ';
                    var $$outStack = $$outStack || [];
                    $$outStack.push(out);
                    out = ''; /* istanbul ignore else */
                    if (it.createErrors !== false) {
                        out += ' { keyword: \'' + ('uniqueItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { i: i, j: j } ';
                        if (it.opts.messages !== false) {
                            out += ' , message: \'should NOT have duplicate items (items ## \' + j + \' and \' + i + \' are identical)\' ';
                        }
                        if (it.opts.verbose) {
                            out += ' , schema:  ';
                            if ($isData) {
                                out += 'validate.schema' + ($schemaPath);
                            }
                            else {
                                out += '' + ($schema);
                            }
                            out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                        }
                        out += ' } ';
                    }
                    else {
                        out += ' {} ';
                    }
                    var __err = out;
                    out = $$outStack.pop();
                    if (!it.compositeRule && $breakOnError) {
                        /* istanbul ignore if */
                        if (it.async) {
                            out += ' throw new ValidationError([' + (__err) + ']); ';
                        }
                        else {
                            out += ' validate.errors = [' + (__err) + ']; return false; ';
                        }
                    }
                    else {
                        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                    }
                    out += ' } ';
                    if ($breakOnError) {
                        out += ' else { ';
                    }
                }
                else {
                    if ($breakOnError) {
                        out += ' if (true) { ';
                    }
                }
                return out;
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/dotjs/validate.js": 
        /*!************************************************!*\
          !*** ./node_modules/ajv/lib/dotjs/validate.js ***!
          \************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            module.exports = function generate_validate(it, $keyword, $ruleType) {
                var out = '';
                var $async = it.schema.$async === true, $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, '$ref'), $id = it.self._getId(it.schema);
                if (it.opts.strictKeywords) {
                    var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
                    if ($unknownKwd) {
                        var $keywordsMsg = 'unknown keyword: ' + $unknownKwd;
                        if (it.opts.strictKeywords === 'log')
                            it.logger.warn($keywordsMsg);
                        else
                            throw new Error($keywordsMsg);
                    }
                }
                if (it.isTop) {
                    out += ' var validate = ';
                    if ($async) {
                        it.async = true;
                        out += 'async ';
                    }
                    out += 'function(data, dataPath, parentData, parentDataProperty, rootData) { \'use strict\'; ';
                    if ($id && (it.opts.sourceCode || it.opts.processCode)) {
                        out += ' ' + ('/\*# sourceURL=' + $id + ' */') + ' ';
                    }
                }
                if (typeof it.schema == 'boolean' || !($refKeywords || it.schema.$ref)) {
                    var $keyword = 'false schema';
                    var $lvl = it.level;
                    var $dataLvl = it.dataLevel;
                    var $schema = it.schema[$keyword];
                    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
                    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
                    var $breakOnError = !it.opts.allErrors;
                    var $errorKeyword;
                    var $data = 'data' + ($dataLvl || '');
                    var $valid = 'valid' + $lvl;
                    if (it.schema === false) {
                        if (it.isTop) {
                            $breakOnError = true;
                        }
                        else {
                            out += ' var ' + ($valid) + ' = false; ';
                        }
                        var $$outStack = $$outStack || [];
                        $$outStack.push(out);
                        out = ''; /* istanbul ignore else */
                        if (it.createErrors !== false) {
                            out += ' { keyword: \'' + ($errorKeyword || 'false schema') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
                            if (it.opts.messages !== false) {
                                out += ' , message: \'boolean schema is false\' ';
                            }
                            if (it.opts.verbose) {
                                out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                            }
                            out += ' } ';
                        }
                        else {
                            out += ' {} ';
                        }
                        var __err = out;
                        out = $$outStack.pop();
                        if (!it.compositeRule && $breakOnError) {
                            /* istanbul ignore if */
                            if (it.async) {
                                out += ' throw new ValidationError([' + (__err) + ']); ';
                            }
                            else {
                                out += ' validate.errors = [' + (__err) + ']; return false; ';
                            }
                        }
                        else {
                            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                        }
                    }
                    else {
                        if (it.isTop) {
                            if ($async) {
                                out += ' return data; ';
                            }
                            else {
                                out += ' validate.errors = null; return true; ';
                            }
                        }
                        else {
                            out += ' var ' + ($valid) + ' = true; ';
                        }
                    }
                    if (it.isTop) {
                        out += ' }; return validate; ';
                    }
                    return out;
                }
                if (it.isTop) {
                    var $top = it.isTop, $lvl = it.level = 0, $dataLvl = it.dataLevel = 0, $data = 'data';
                    it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
                    it.baseId = it.baseId || it.rootId;
                    delete it.isTop;
                    it.dataPathArr = [undefined];
                    if (it.schema.default !== undefined && it.opts.useDefaults && it.opts.strictDefaults) {
                        var $defaultMsg = 'default is ignored in the schema root';
                        if (it.opts.strictDefaults === 'log')
                            it.logger.warn($defaultMsg);
                        else
                            throw new Error($defaultMsg);
                    }
                    out += ' var vErrors = null; ';
                    out += ' var errors = 0;     ';
                    out += ' if (rootData === undefined) rootData = data; ';
                }
                else {
                    var $lvl = it.level, $dataLvl = it.dataLevel, $data = 'data' + ($dataLvl || '');
                    if ($id)
                        it.baseId = it.resolve.url(it.baseId, $id);
                    if ($async && !it.async)
                        throw new Error('async schema in sync schema');
                    out += ' var errs_' + ($lvl) + ' = errors;';
                }
                var $valid = 'valid' + $lvl, $breakOnError = !it.opts.allErrors, $closingBraces1 = '', $closingBraces2 = '';
                var $errorKeyword;
                var $typeSchema = it.schema.type, $typeIsArray = Array.isArray($typeSchema);
                if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
                    if ($typeIsArray) {
                        if ($typeSchema.indexOf('null') == -1)
                            $typeSchema = $typeSchema.concat('null');
                    }
                    else if ($typeSchema != 'null') {
                        $typeSchema = [$typeSchema, 'null'];
                        $typeIsArray = true;
                    }
                }
                if ($typeIsArray && $typeSchema.length == 1) {
                    $typeSchema = $typeSchema[0];
                    $typeIsArray = false;
                }
                if (it.schema.$ref && $refKeywords) {
                    if (it.opts.extendRefs == 'fail') {
                        throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
                    }
                    else if (it.opts.extendRefs !== true) {
                        $refKeywords = false;
                        it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
                    }
                }
                if (it.schema.$comment && it.opts.$comment) {
                    out += ' ' + (it.RULES.all.$comment.code(it, '$comment'));
                }
                if ($typeSchema) {
                    if (it.opts.coerceTypes) {
                        var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
                    }
                    var $rulesGroup = it.RULES.types[$typeSchema];
                    if ($coerceToTypes || $typeIsArray || $rulesGroup === true || ($rulesGroup && !$shouldUseGroup($rulesGroup))) {
                        var $schemaPath = it.schemaPath + '.type', $errSchemaPath = it.errSchemaPath + '/type';
                        var $schemaPath = it.schemaPath + '.type', $errSchemaPath = it.errSchemaPath + '/type', $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';
                        out += ' if (' + (it.util[$method]($typeSchema, $data, true)) + ') { ';
                        if ($coerceToTypes) {
                            var $dataType = 'dataType' + $lvl, $coerced = 'coerced' + $lvl;
                            out += ' var ' + ($dataType) + ' = typeof ' + ($data) + '; ';
                            if (it.opts.coerceTypes == 'array') {
                                out += ' if (' + ($dataType) + ' == \'object\' && Array.isArray(' + ($data) + ')) ' + ($dataType) + ' = \'array\'; ';
                            }
                            out += ' var ' + ($coerced) + ' = undefined; ';
                            var $bracesCoercion = '';
                            var arr1 = $coerceToTypes;
                            if (arr1) {
                                var $type, $i = -1, l1 = arr1.length - 1;
                                while ($i < l1) {
                                    $type = arr1[$i += 1];
                                    if ($i) {
                                        out += ' if (' + ($coerced) + ' === undefined) { ';
                                        $bracesCoercion += '}';
                                    }
                                    if (it.opts.coerceTypes == 'array' && $type != 'array') {
                                        out += ' if (' + ($dataType) + ' == \'array\' && ' + ($data) + '.length == 1) { ' + ($coerced) + ' = ' + ($data) + ' = ' + ($data) + '[0]; ' + ($dataType) + ' = typeof ' + ($data) + ';  } ';
                                    }
                                    if ($type == 'string') {
                                        out += ' if (' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\') ' + ($coerced) + ' = \'\' + ' + ($data) + '; else if (' + ($data) + ' === null) ' + ($coerced) + ' = \'\'; ';
                                    }
                                    else if ($type == 'number' || $type == 'integer') {
                                        out += ' if (' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' === null || (' + ($dataType) + ' == \'string\' && ' + ($data) + ' && ' + ($data) + ' == +' + ($data) + ' ';
                                        if ($type == 'integer') {
                                            out += ' && !(' + ($data) + ' % 1)';
                                        }
                                        out += ')) ' + ($coerced) + ' = +' + ($data) + '; ';
                                    }
                                    else if ($type == 'boolean') {
                                        out += ' if (' + ($data) + ' === \'false\' || ' + ($data) + ' === 0 || ' + ($data) + ' === null) ' + ($coerced) + ' = false; else if (' + ($data) + ' === \'true\' || ' + ($data) + ' === 1) ' + ($coerced) + ' = true; ';
                                    }
                                    else if ($type == 'null') {
                                        out += ' if (' + ($data) + ' === \'\' || ' + ($data) + ' === 0 || ' + ($data) + ' === false) ' + ($coerced) + ' = null; ';
                                    }
                                    else if (it.opts.coerceTypes == 'array' && $type == 'array') {
                                        out += ' if (' + ($dataType) + ' == \'string\' || ' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' == null) ' + ($coerced) + ' = [' + ($data) + ']; ';
                                    }
                                }
                            }
                            out += ' ' + ($bracesCoercion) + ' if (' + ($coerced) + ' === undefined) {   ';
                            var $$outStack = $$outStack || [];
                            $$outStack.push(out);
                            out = ''; /* istanbul ignore else */
                            if (it.createErrors !== false) {
                                out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
                                if ($typeIsArray) {
                                    out += '' + ($typeSchema.join(","));
                                }
                                else {
                                    out += '' + ($typeSchema);
                                }
                                out += '\' } ';
                                if (it.opts.messages !== false) {
                                    out += ' , message: \'should be ';
                                    if ($typeIsArray) {
                                        out += '' + ($typeSchema.join(","));
                                    }
                                    else {
                                        out += '' + ($typeSchema);
                                    }
                                    out += '\' ';
                                }
                                if (it.opts.verbose) {
                                    out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                                }
                                out += ' } ';
                            }
                            else {
                                out += ' {} ';
                            }
                            var __err = out;
                            out = $$outStack.pop();
                            if (!it.compositeRule && $breakOnError) {
                                /* istanbul ignore if */
                                if (it.async) {
                                    out += ' throw new ValidationError([' + (__err) + ']); ';
                                }
                                else {
                                    out += ' validate.errors = [' + (__err) + ']; return false; ';
                                }
                            }
                            else {
                                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                            }
                            out += ' } else {  ';
                            var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData', $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
                            out += ' ' + ($data) + ' = ' + ($coerced) + '; ';
                            if (!$dataLvl) {
                                out += 'if (' + ($parentData) + ' !== undefined)';
                            }
                            out += ' ' + ($parentData) + '[' + ($parentDataProperty) + '] = ' + ($coerced) + '; } ';
                        }
                        else {
                            var $$outStack = $$outStack || [];
                            $$outStack.push(out);
                            out = ''; /* istanbul ignore else */
                            if (it.createErrors !== false) {
                                out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
                                if ($typeIsArray) {
                                    out += '' + ($typeSchema.join(","));
                                }
                                else {
                                    out += '' + ($typeSchema);
                                }
                                out += '\' } ';
                                if (it.opts.messages !== false) {
                                    out += ' , message: \'should be ';
                                    if ($typeIsArray) {
                                        out += '' + ($typeSchema.join(","));
                                    }
                                    else {
                                        out += '' + ($typeSchema);
                                    }
                                    out += '\' ';
                                }
                                if (it.opts.verbose) {
                                    out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                                }
                                out += ' } ';
                            }
                            else {
                                out += ' {} ';
                            }
                            var __err = out;
                            out = $$outStack.pop();
                            if (!it.compositeRule && $breakOnError) {
                                /* istanbul ignore if */
                                if (it.async) {
                                    out += ' throw new ValidationError([' + (__err) + ']); ';
                                }
                                else {
                                    out += ' validate.errors = [' + (__err) + ']; return false; ';
                                }
                            }
                            else {
                                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                            }
                        }
                        out += ' } ';
                    }
                }
                if (it.schema.$ref && !$refKeywords) {
                    out += ' ' + (it.RULES.all.$ref.code(it, '$ref')) + ' ';
                    if ($breakOnError) {
                        out += ' } if (errors === ';
                        if ($top) {
                            out += '0';
                        }
                        else {
                            out += 'errs_' + ($lvl);
                        }
                        out += ') { ';
                        $closingBraces2 += '}';
                    }
                }
                else {
                    var arr2 = it.RULES;
                    if (arr2) {
                        var $rulesGroup, i2 = -1, l2 = arr2.length - 1;
                        while (i2 < l2) {
                            $rulesGroup = arr2[i2 += 1];
                            if ($shouldUseGroup($rulesGroup)) {
                                if ($rulesGroup.type) {
                                    out += ' if (' + (it.util.checkDataType($rulesGroup.type, $data)) + ') { ';
                                }
                                if (it.opts.useDefaults) {
                                    if ($rulesGroup.type == 'object' && it.schema.properties) {
                                        var $schema = it.schema.properties, $schemaKeys = Object.keys($schema);
                                        var arr3 = $schemaKeys;
                                        if (arr3) {
                                            var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                                            while (i3 < l3) {
                                                $propertyKey = arr3[i3 += 1];
                                                var $sch = $schema[$propertyKey];
                                                if ($sch.default !== undefined) {
                                                    var $passData = $data + it.util.getProperty($propertyKey);
                                                    if (it.compositeRule) {
                                                        if (it.opts.strictDefaults) {
                                                            var $defaultMsg = 'default is ignored for: ' + $passData;
                                                            if (it.opts.strictDefaults === 'log')
                                                                it.logger.warn($defaultMsg);
                                                            else
                                                                throw new Error($defaultMsg);
                                                        }
                                                    }
                                                    else {
                                                        out += ' if (' + ($passData) + ' === undefined ';
                                                        if (it.opts.useDefaults == 'empty') {
                                                            out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \'\' ';
                                                        }
                                                        out += ' ) ' + ($passData) + ' = ';
                                                        if (it.opts.useDefaults == 'shared') {
                                                            out += ' ' + (it.useDefault($sch.default)) + ' ';
                                                        }
                                                        else {
                                                            out += ' ' + (JSON.stringify($sch.default)) + ' ';
                                                        }
                                                        out += '; ';
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    else if ($rulesGroup.type == 'array' && Array.isArray(it.schema.items)) {
                                        var arr4 = it.schema.items;
                                        if (arr4) {
                                            var $sch, $i = -1, l4 = arr4.length - 1;
                                            while ($i < l4) {
                                                $sch = arr4[$i += 1];
                                                if ($sch.default !== undefined) {
                                                    var $passData = $data + '[' + $i + ']';
                                                    if (it.compositeRule) {
                                                        if (it.opts.strictDefaults) {
                                                            var $defaultMsg = 'default is ignored for: ' + $passData;
                                                            if (it.opts.strictDefaults === 'log')
                                                                it.logger.warn($defaultMsg);
                                                            else
                                                                throw new Error($defaultMsg);
                                                        }
                                                    }
                                                    else {
                                                        out += ' if (' + ($passData) + ' === undefined ';
                                                        if (it.opts.useDefaults == 'empty') {
                                                            out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \'\' ';
                                                        }
                                                        out += ' ) ' + ($passData) + ' = ';
                                                        if (it.opts.useDefaults == 'shared') {
                                                            out += ' ' + (it.useDefault($sch.default)) + ' ';
                                                        }
                                                        else {
                                                            out += ' ' + (JSON.stringify($sch.default)) + ' ';
                                                        }
                                                        out += '; ';
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                var arr5 = $rulesGroup.rules;
                                if (arr5) {
                                    var $rule, i5 = -1, l5 = arr5.length - 1;
                                    while (i5 < l5) {
                                        $rule = arr5[i5 += 1];
                                        if ($shouldUseRule($rule)) {
                                            var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                                            if ($code) {
                                                out += ' ' + ($code) + ' ';
                                                if ($breakOnError) {
                                                    $closingBraces1 += '}';
                                                }
                                            }
                                        }
                                    }
                                }
                                if ($breakOnError) {
                                    out += ' ' + ($closingBraces1) + ' ';
                                    $closingBraces1 = '';
                                }
                                if ($rulesGroup.type) {
                                    out += ' } ';
                                    if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
                                        out += ' else { ';
                                        var $schemaPath = it.schemaPath + '.type', $errSchemaPath = it.errSchemaPath + '/type';
                                        var $$outStack = $$outStack || [];
                                        $$outStack.push(out);
                                        out = ''; /* istanbul ignore else */
                                        if (it.createErrors !== false) {
                                            out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
                                            if ($typeIsArray) {
                                                out += '' + ($typeSchema.join(","));
                                            }
                                            else {
                                                out += '' + ($typeSchema);
                                            }
                                            out += '\' } ';
                                            if (it.opts.messages !== false) {
                                                out += ' , message: \'should be ';
                                                if ($typeIsArray) {
                                                    out += '' + ($typeSchema.join(","));
                                                }
                                                else {
                                                    out += '' + ($typeSchema);
                                                }
                                                out += '\' ';
                                            }
                                            if (it.opts.verbose) {
                                                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                                            }
                                            out += ' } ';
                                        }
                                        else {
                                            out += ' {} ';
                                        }
                                        var __err = out;
                                        out = $$outStack.pop();
                                        if (!it.compositeRule && $breakOnError) {
                                            /* istanbul ignore if */
                                            if (it.async) {
                                                out += ' throw new ValidationError([' + (__err) + ']); ';
                                            }
                                            else {
                                                out += ' validate.errors = [' + (__err) + ']; return false; ';
                                            }
                                        }
                                        else {
                                            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                                        }
                                        out += ' } ';
                                    }
                                }
                                if ($breakOnError) {
                                    out += ' if (errors === ';
                                    if ($top) {
                                        out += '0';
                                    }
                                    else {
                                        out += 'errs_' + ($lvl);
                                    }
                                    out += ') { ';
                                    $closingBraces2 += '}';
                                }
                            }
                        }
                    }
                }
                if ($breakOnError) {
                    out += ' ' + ($closingBraces2) + ' ';
                }
                if ($top) {
                    if ($async) {
                        out += ' if (errors === 0) return data;           ';
                        out += ' else throw new ValidationError(vErrors); ';
                    }
                    else {
                        out += ' validate.errors = vErrors; ';
                        out += ' return errors === 0;       ';
                    }
                    out += ' }; return validate;';
                }
                else {
                    out += ' var ' + ($valid) + ' = errors === errs_' + ($lvl) + ';';
                }
                out = it.util.cleanUpCode(out);
                if ($top) {
                    out = it.util.finalCleanUpCode(out, $async);
                }
                function $shouldUseGroup($rulesGroup) {
                    var rules = $rulesGroup.rules;
                    for (var i = 0; i < rules.length; i++)
                        if ($shouldUseRule(rules[i]))
                            return true;
                }
                function $shouldUseRule($rule) {
                    return it.schema[$rule.keyword] !== undefined || ($rule.implements && $ruleImplementsSomeKeyword($rule));
                }
                function $ruleImplementsSomeKeyword($rule) {
                    var impl = $rule.implements;
                    for (var i = 0; i < impl.length; i++)
                        if (it.schema[impl[i]] !== undefined)
                            return true;
                }
                return out;
            };
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/keyword.js": 
        /*!*****************************************!*\
          !*** ./node_modules/ajv/lib/keyword.js ***!
          \*****************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
            var customRuleCode = __webpack_require__(/*! ./dotjs/custom */ "./node_modules/ajv/lib/dotjs/custom.js");
            var definitionSchema = __webpack_require__(/*! ./definition_schema */ "./node_modules/ajv/lib/definition_schema.js");
            module.exports = {
                add: addKeyword,
                get: getKeyword,
                remove: removeKeyword,
                validate: validateKeyword
            };
            /**
             * Define custom keyword
             * @this  Ajv
             * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
             * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.
             * @return {Ajv} this for method chaining
             */
            function addKeyword(keyword, definition) {
                /* jshint validthis: true */
                /* eslint no-shadow: 0 */
                var RULES = this.RULES;
                if (RULES.keywords[keyword])
                    throw new Error('Keyword ' + keyword + ' is already defined');
                if (!IDENTIFIER.test(keyword))
                    throw new Error('Keyword ' + keyword + ' is not a valid identifier');
                if (definition) {
                    this.validateKeyword(definition, true);
                    var dataType = definition.type;
                    if (Array.isArray(dataType)) {
                        for (var i = 0; i < dataType.length; i++)
                            _addRule(keyword, dataType[i], definition);
                    }
                    else {
                        _addRule(keyword, dataType, definition);
                    }
                    var metaSchema = definition.metaSchema;
                    if (metaSchema) {
                        if (definition.$data && this._opts.$data) {
                            metaSchema = {
                                anyOf: [
                                    metaSchema,
                                    { '$ref': 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#' }
                                ]
                            };
                        }
                        definition.validateSchema = this.compile(metaSchema, true);
                    }
                }
                RULES.keywords[keyword] = RULES.all[keyword] = true;
                function _addRule(keyword, dataType, definition) {
                    var ruleGroup;
                    for (var i = 0; i < RULES.length; i++) {
                        var rg = RULES[i];
                        if (rg.type == dataType) {
                            ruleGroup = rg;
                            break;
                        }
                    }
                    if (!ruleGroup) {
                        ruleGroup = { type: dataType, rules: [] };
                        RULES.push(ruleGroup);
                    }
                    var rule = {
                        keyword: keyword,
                        definition: definition,
                        custom: true,
                        code: customRuleCode,
                        implements: definition.implements
                    };
                    ruleGroup.rules.push(rule);
                    RULES.custom[keyword] = rule;
                }
                return this;
            }
            /**
             * Get keyword
             * @this  Ajv
             * @param {String} keyword pre-defined or custom keyword.
             * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.
             */
            function getKeyword(keyword) {
                /* jshint validthis: true */
                var rule = this.RULES.custom[keyword];
                return rule ? rule.definition : this.RULES.keywords[keyword] || false;
            }
            /**
             * Remove keyword
             * @this  Ajv
             * @param {String} keyword pre-defined or custom keyword.
             * @return {Ajv} this for method chaining
             */
            function removeKeyword(keyword) {
                /* jshint validthis: true */
                var RULES = this.RULES;
                delete RULES.keywords[keyword];
                delete RULES.all[keyword];
                delete RULES.custom[keyword];
                for (var i = 0; i < RULES.length; i++) {
                    var rules = RULES[i].rules;
                    for (var j = 0; j < rules.length; j++) {
                        if (rules[j].keyword == keyword) {
                            rules.splice(j, 1);
                            break;
                        }
                    }
                }
                return this;
            }
            /**
             * Validate keyword definition
             * @this  Ajv
             * @param {Object} definition keyword definition object.
             * @param {Boolean} throwError true to throw exception if definition is invalid
             * @return {boolean} validation result
             */
            function validateKeyword(definition, throwError) {
                validateKeyword.errors = null;
                var v = this._validateKeyword = this._validateKeyword
                    || this.compile(definitionSchema, true);
                if (v(definition))
                    return true;
                validateKeyword.errors = v.errors;
                if (throwError)
                    throw new Error('custom keyword definition is invalid: ' + this.errorsText(v.errors));
                else
                    return false;
            }
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/refs/data.json": 
        /*!*********************************************!*\
          !*** ./node_modules/ajv/lib/refs/data.json ***!
          \*********************************************/
        /*! exports provided: $schema, $id, description, type, required, properties, additionalProperties, default */
        /***/ (function (module) {
            module.exports = JSON.parse("{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"$id\":\"https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#\",\"description\":\"Meta-schema for $data reference (JSON Schema extension proposal)\",\"type\":\"object\",\"required\":[\"$data\"],\"properties\":{\"$data\":{\"type\":\"string\",\"anyOf\":[{\"format\":\"relative-json-pointer\"},{\"format\":\"json-pointer\"}]}},\"additionalProperties\":false}");
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/refs/json-schema-draft-06.json": 
        /*!*************************************************************!*\
          !*** ./node_modules/ajv/lib/refs/json-schema-draft-06.json ***!
          \*************************************************************/
        /*! exports provided: $schema, $id, title, definitions, type, properties, default */
        /***/ (function (module) {
            module.exports = JSON.parse("{\"$schema\":\"http://json-schema.org/draft-06/schema#\",\"$id\":\"http://json-schema.org/draft-06/schema#\",\"title\":\"Core schema meta-schema\",\"definitions\":{\"schemaArray\":{\"type\":\"array\",\"minItems\":1,\"items\":{\"$ref\":\"#\"}},\"nonNegativeInteger\":{\"type\":\"integer\",\"minimum\":0},\"nonNegativeIntegerDefault0\":{\"allOf\":[{\"$ref\":\"#/definitions/nonNegativeInteger\"},{\"default\":0}]},\"simpleTypes\":{\"enum\":[\"array\",\"boolean\",\"integer\",\"null\",\"number\",\"object\",\"string\"]},\"stringArray\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"uniqueItems\":true,\"default\":[]}},\"type\":[\"object\",\"boolean\"],\"properties\":{\"$id\":{\"type\":\"string\",\"format\":\"uri-reference\"},\"$schema\":{\"type\":\"string\",\"format\":\"uri\"},\"$ref\":{\"type\":\"string\",\"format\":\"uri-reference\"},\"title\":{\"type\":\"string\"},\"description\":{\"type\":\"string\"},\"default\":{},\"examples\":{\"type\":\"array\",\"items\":{}},\"multipleOf\":{\"type\":\"number\",\"exclusiveMinimum\":0},\"maximum\":{\"type\":\"number\"},\"exclusiveMaximum\":{\"type\":\"number\"},\"minimum\":{\"type\":\"number\"},\"exclusiveMinimum\":{\"type\":\"number\"},\"maxLength\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minLength\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"pattern\":{\"type\":\"string\",\"format\":\"regex\"},\"additionalItems\":{\"$ref\":\"#\"},\"items\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/schemaArray\"}],\"default\":{}},\"maxItems\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minItems\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"uniqueItems\":{\"type\":\"boolean\",\"default\":false},\"contains\":{\"$ref\":\"#\"},\"maxProperties\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minProperties\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"required\":{\"$ref\":\"#/definitions/stringArray\"},\"additionalProperties\":{\"$ref\":\"#\"},\"definitions\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"properties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"patternProperties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"dependencies\":{\"type\":\"object\",\"additionalProperties\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/stringArray\"}]}},\"propertyNames\":{\"$ref\":\"#\"},\"const\":{},\"enum\":{\"type\":\"array\",\"minItems\":1,\"uniqueItems\":true},\"type\":{\"anyOf\":[{\"$ref\":\"#/definitions/simpleTypes\"},{\"type\":\"array\",\"items\":{\"$ref\":\"#/definitions/simpleTypes\"},\"minItems\":1,\"uniqueItems\":true}]},\"format\":{\"type\":\"string\"},\"allOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"anyOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"oneOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"not\":{\"$ref\":\"#\"}},\"default\":{}}");
            /***/ 
        }),
        /***/ "./node_modules/ajv/lib/refs/json-schema-draft-07.json": 
        /*!*************************************************************!*\
          !*** ./node_modules/ajv/lib/refs/json-schema-draft-07.json ***!
          \*************************************************************/
        /*! exports provided: $schema, $id, title, definitions, type, properties, default */
        /***/ (function (module) {
            module.exports = JSON.parse("{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"$id\":\"http://json-schema.org/draft-07/schema#\",\"title\":\"Core schema meta-schema\",\"definitions\":{\"schemaArray\":{\"type\":\"array\",\"minItems\":1,\"items\":{\"$ref\":\"#\"}},\"nonNegativeInteger\":{\"type\":\"integer\",\"minimum\":0},\"nonNegativeIntegerDefault0\":{\"allOf\":[{\"$ref\":\"#/definitions/nonNegativeInteger\"},{\"default\":0}]},\"simpleTypes\":{\"enum\":[\"array\",\"boolean\",\"integer\",\"null\",\"number\",\"object\",\"string\"]},\"stringArray\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"uniqueItems\":true,\"default\":[]}},\"type\":[\"object\",\"boolean\"],\"properties\":{\"$id\":{\"type\":\"string\",\"format\":\"uri-reference\"},\"$schema\":{\"type\":\"string\",\"format\":\"uri\"},\"$ref\":{\"type\":\"string\",\"format\":\"uri-reference\"},\"$comment\":{\"type\":\"string\"},\"title\":{\"type\":\"string\"},\"description\":{\"type\":\"string\"},\"default\":true,\"readOnly\":{\"type\":\"boolean\",\"default\":false},\"examples\":{\"type\":\"array\",\"items\":true},\"multipleOf\":{\"type\":\"number\",\"exclusiveMinimum\":0},\"maximum\":{\"type\":\"number\"},\"exclusiveMaximum\":{\"type\":\"number\"},\"minimum\":{\"type\":\"number\"},\"exclusiveMinimum\":{\"type\":\"number\"},\"maxLength\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minLength\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"pattern\":{\"type\":\"string\",\"format\":\"regex\"},\"additionalItems\":{\"$ref\":\"#\"},\"items\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/schemaArray\"}],\"default\":true},\"maxItems\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minItems\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"uniqueItems\":{\"type\":\"boolean\",\"default\":false},\"contains\":{\"$ref\":\"#\"},\"maxProperties\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minProperties\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"required\":{\"$ref\":\"#/definitions/stringArray\"},\"additionalProperties\":{\"$ref\":\"#\"},\"definitions\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"properties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"patternProperties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"propertyNames\":{\"format\":\"regex\"},\"default\":{}},\"dependencies\":{\"type\":\"object\",\"additionalProperties\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/stringArray\"}]}},\"propertyNames\":{\"$ref\":\"#\"},\"const\":true,\"enum\":{\"type\":\"array\",\"items\":true,\"minItems\":1,\"uniqueItems\":true},\"type\":{\"anyOf\":[{\"$ref\":\"#/definitions/simpleTypes\"},{\"type\":\"array\",\"items\":{\"$ref\":\"#/definitions/simpleTypes\"},\"minItems\":1,\"uniqueItems\":true}]},\"format\":{\"type\":\"string\"},\"contentMediaType\":{\"type\":\"string\"},\"contentEncoding\":{\"type\":\"string\"},\"if\":{\"$ref\":\"#\"},\"then\":{\"$ref\":\"#\"},\"else\":{\"$ref\":\"#\"},\"allOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"anyOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"oneOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"not\":{\"$ref\":\"#\"}},\"default\":true}");
            /***/ 
        }),
        /***/ "./node_modules/angular6-json-schema-form/fesm2015/angular6-json-schema-form.js": 
        /*!**************************************************************************************!*\
          !*** ./node_modules/angular6-json-schema-form/fesm2015/angular6-json-schema-form.js ***!
          \**************************************************************************************/
        /*! exports provided: ANGULAR_MATERIAL_MODULES, AddReferenceComponent, BASIC_WIDGETS, Bootstrap3Framework, Bootstrap3FrameworkModule, Bootstrap4Framework, Bootstrap4FrameworkModule, ButtonComponent, CheckboxComponent, CheckboxesComponent, FileComponent, FrameworkLibraryService, HiddenComponent, InputComponent, JSON_SCHEMA_FORM_VALUE_ACCESSOR, JsonPointer, JsonSchemaFormComponent, JsonSchemaFormService, JsonValidators, MaterialDesignFramework, MaterialDesignFrameworkModule, MessageComponent, NoFramework, NoFrameworkModule, NoneComponent, NumberComponent, OneOfComponent, OrderableDirective, RadiosComponent, RootComponent, SectionComponent, SelectComponent, SelectFrameworkComponent, SelectWidgetComponent, SubmitComponent, TabComponent, TabsComponent, TemplateComponent, TextareaComponent, WidgetLibraryService, _executeAsyncValidators, _executeValidators, _mergeErrors, _mergeObjects, _toPromise, addClasses, buildFormGroup, buildFormGroupTemplate, buildLayout, buildLayoutFromSchema, buildSchemaFromData, buildSchemaFromLayout, buildTitleMap, checkInlineType, combineAllOf, commonItems, convertSchemaToDraft6, copy, dateToString, findDate, fixRequiredArrayProperties, fixTitle, forEach, forEachCopy, formatFormData, getControl, getControlValidators, getFromSchema, getInputType, getLayoutNode, getSubSchema, getTitleMapFromOneOf, getType, hasOwn, hasValue, inArray, isArray, isBoolean, isDate, isDefined, isEmpty, isFunction, isInputRequired, isInteger, isMap, isNumber, isObject, isObservable, isPrimitive, isPromise, isSet, isString, isType, mapLayout, mergeFilteredObject, mergeSchemas, removeRecursiveReferences, resolveSchemaReferences, setRequiredFields, stringToDate, toJavaScriptType, toObservable, toSchemaType, toTitleCase, uniqueItems, updateInputOptions, xor, ɵa, ɵb, ɵba, ɵbb, ɵbc, ɵbd, ɵbe, ɵbf, ɵbg, ɵbh, ɵbi, ɵbj, ɵbk, ɵbl, ɵbm, ɵbn, ɵbo, ɵbp, ɵbq, ɵbr, ɵbs, ɵbt, ɵbu, ɵbv, ɵbw, ɵbx, ɵby, ɵbz, ɵc, ɵca, ɵcb, ɵcc, ɵcd, ɵce, ɵd, ɵe, ɵf, ɵg, ɵh, ɵi, ɵj, ɵk, ɵl, ɵm, ɵn, ɵo, ɵp, ɵq, ɵr, ɵs, ɵt, ɵu, ɵv, ɵw, ɵx, ɵy, ɵz */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ANGULAR_MATERIAL_MODULES", function () { return ANGULAR_MATERIAL_MODULES; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddReferenceComponent", function () { return AddReferenceComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BASIC_WIDGETS", function () { return BASIC_WIDGETS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bootstrap3Framework", function () { return Bootstrap3Framework; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bootstrap3FrameworkModule", function () { return Bootstrap3FrameworkModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bootstrap4Framework", function () { return Bootstrap4Framework; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bootstrap4FrameworkModule", function () { return Bootstrap4FrameworkModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ButtonComponent", function () { return ButtonComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CheckboxComponent", function () { return CheckboxComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CheckboxesComponent", function () { return CheckboxesComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FileComponent", function () { return FileComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrameworkLibraryService", function () { return FrameworkLibraryService; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HiddenComponent", function () { return HiddenComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InputComponent", function () { return InputComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JSON_SCHEMA_FORM_VALUE_ACCESSOR", function () { return JSON_SCHEMA_FORM_VALUE_ACCESSOR; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JsonPointer", function () { return JsonPointer; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JsonSchemaFormComponent", function () { return JsonSchemaFormComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JsonSchemaFormService", function () { return JsonSchemaFormService; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JsonValidators", function () { return JsonValidators; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MaterialDesignFramework", function () { return MaterialDesignFramework; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MaterialDesignFrameworkModule", function () { return MaterialDesignFrameworkModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MessageComponent", function () { return MessageComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoFramework", function () { return NoFramework; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoFrameworkModule", function () { return NoFrameworkModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoneComponent", function () { return NoneComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NumberComponent", function () { return NumberComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneOfComponent", function () { return OneOfComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OrderableDirective", function () { return OrderableDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RadiosComponent", function () { return RadiosComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RootComponent", function () { return RootComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SectionComponent", function () { return SectionComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectComponent", function () { return SelectComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectFrameworkComponent", function () { return SelectFrameworkComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectWidgetComponent", function () { return SelectWidgetComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubmitComponent", function () { return SubmitComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TabComponent", function () { return TabComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TabsComponent", function () { return TabsComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TemplateComponent", function () { return TemplateComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextareaComponent", function () { return TextareaComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WidgetLibraryService", function () { return WidgetLibraryService; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_executeAsyncValidators", function () { return _executeAsyncValidators; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_executeValidators", function () { return _executeValidators; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_mergeErrors", function () { return _mergeErrors; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_mergeObjects", function () { return _mergeObjects; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_toPromise", function () { return _toPromise; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addClasses", function () { return addClasses; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildFormGroup", function () { return buildFormGroup; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildFormGroupTemplate", function () { return buildFormGroupTemplate; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildLayout", function () { return buildLayout; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildLayoutFromSchema", function () { return buildLayoutFromSchema; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildSchemaFromData", function () { return buildSchemaFromData; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildSchemaFromLayout", function () { return buildSchemaFromLayout; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildTitleMap", function () { return buildTitleMap; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkInlineType", function () { return checkInlineType; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "combineAllOf", function () { return combineAllOf; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "commonItems", function () { return commonItems; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convertSchemaToDraft6", function () { return convertSchemaToDraft6; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function () { return copy; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dateToString", function () { return dateToString; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findDate", function () { return findDate; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fixRequiredArrayProperties", function () { return fixRequiredArrayProperties; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fixTitle", function () { return fixTitle; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function () { return forEach; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEachCopy", function () { return forEachCopy; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatFormData", function () { return formatFormData; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getControl", function () { return getControl; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getControlValidators", function () { return getControlValidators; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFromSchema", function () { return getFromSchema; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getInputType", function () { return getInputType; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLayoutNode", function () { return getLayoutNode; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSubSchema", function () { return getSubSchema; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTitleMapFromOneOf", function () { return getTitleMapFromOneOf; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getType", function () { return getType; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasOwn", function () { return hasOwn; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasValue", function () { return hasValue; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inArray", function () { return inArray; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isArray", function () { return isArray; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBoolean", function () { return isBoolean; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDate", function () { return isDate; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDefined", function () { return isDefined; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEmpty", function () { return isEmpty; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFunction", function () { return isFunction; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isInputRequired", function () { return isInputRequired; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isInteger", function () { return isInteger; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isMap", function () { return isMap; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNumber", function () { return isNumber; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObject", function () { return isObject; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObservable", function () { return isObservable; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPrimitive", function () { return isPrimitive; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPromise", function () { return isPromise; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSet", function () { return isSet; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isString", function () { return isString; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isType", function () { return isType; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapLayout", function () { return mapLayout; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeFilteredObject", function () { return mergeFilteredObject; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeSchemas", function () { return mergeSchemas; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeRecursiveReferences", function () { return removeRecursiveReferences; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolveSchemaReferences", function () { return resolveSchemaReferences; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setRequiredFields", function () { return setRequiredFields; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stringToDate", function () { return stringToDate; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toJavaScriptType", function () { return toJavaScriptType; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toObservable", function () { return toObservable; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toSchemaType", function () { return toSchemaType; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toTitleCase", function () { return toTitleCase; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uniqueItems", function () { return uniqueItems; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateInputOptions", function () { return updateInputOptions; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xor", function () { return xor; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵa", function () { return FrameworkLibraryService; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵb", function () { return Framework; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵba", function () { return TemplateComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbb", function () { return TextareaComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbc", function () { return NoFrameworkComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbd", function () { return NoFramework; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbe", function () { return JsonSchemaFormModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbf", function () { return MATERIAL_FRAMEWORK_COMPONENTS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbg", function () { return FlexLayoutRootComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbh", function () { return FlexLayoutSectionComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbi", function () { return MaterialAddReferenceComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbj", function () { return MaterialOneOfComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbk", function () { return MaterialButtonComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbl", function () { return MaterialButtonGroupComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbm", function () { return MaterialCheckboxComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbn", function () { return MaterialCheckboxesComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbo", function () { return MaterialChipListComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbp", function () { return MaterialDatepickerComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbq", function () { return MaterialFileComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbr", function () { return MaterialInputComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbs", function () { return MaterialNumberComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbt", function () { return MaterialRadiosComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbu", function () { return MaterialSelectComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbv", function () { return MaterialSliderComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbw", function () { return MaterialStepperComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbx", function () { return MaterialTabsComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵby", function () { return MaterialTextareaComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵbz", function () { return MaterialDesignFrameworkComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵc", function () { return WidgetLibraryService; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵca", function () { return MaterialDesignFramework; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵcb", function () { return Bootstrap3FrameworkComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵcc", function () { return Bootstrap3Framework; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵcd", function () { return Bootstrap4FrameworkComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵce", function () { return Bootstrap4Framework; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵd", function () { return WidgetLibraryModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵe", function () { return BASIC_WIDGETS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵf", function () { return AddReferenceComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵg", function () { return OneOfComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵh", function () { return ButtonComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵi", function () { return CheckboxComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵj", function () { return CheckboxesComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵk", function () { return FileComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵl", function () { return HiddenComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵm", function () { return InputComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵn", function () { return MessageComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵo", function () { return NoneComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵp", function () { return NumberComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵq", function () { return OrderableDirective; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵr", function () { return RadiosComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵs", function () { return RootComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵt", function () { return SectionComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵu", function () { return SelectComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵv", function () { return SelectFrameworkComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵw", function () { return SelectWidgetComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵx", function () { return SubmitComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵy", function () { return TabComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵz", function () { return TabsComponent; });
            /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
            /* harmony import */ var lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash-es/cloneDeep */ "./node_modules/lodash-es/cloneDeep.js");
            /* harmony import */ var ajv__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ajv */ "./node_modules/ajv/lib/ajv.js");
            /* harmony import */ var ajv__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __webpack_require__.n(ajv__WEBPACK_IMPORTED_MODULE_2__);
            /* harmony import */ var ajv_lib_refs_json_schema_draft_06_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ajv/lib/refs/json-schema-draft-06.json */ "./node_modules/ajv/lib/refs/json-schema-draft-06.json");
            var ajv_lib_refs_json_schema_draft_06_json__WEBPACK_IMPORTED_MODULE_3___namespace = /*#__PURE__*/ __webpack_require__.t(/*! ajv/lib/refs/json-schema-draft-06.json */ "./node_modules/ajv/lib/refs/json-schema-draft-06.json", 1);
            /* harmony import */ var lodash_es_filter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es/filter */ "./node_modules/lodash-es/filter.js");
            /* harmony import */ var lodash_es_map__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es/map */ "./node_modules/lodash-es/map.js");
            /* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var lodash_es_isEqual__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash-es/isEqual */ "./node_modules/lodash-es/isEqual.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var lodash_es_uniqueId__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lodash-es/uniqueId */ "./node_modules/lodash-es/uniqueId.js");
            /* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @angular/platform-browser */ "./node_modules/@angular/platform-browser/fesm2015/platform-browser.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_material_form_field__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @angular/material/form-field */ "./node_modules/@angular/material/esm2015/form-field.js");
            /* harmony import */ var _angular_flex_layout__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @angular/flex-layout */ "./node_modules/@angular/flex-layout/esm2015/flex-layout.js");
            /* harmony import */ var _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @angular/flex-layout/core */ "./node_modules/@angular/flex-layout/esm2015/core.js");
            /* harmony import */ var _angular_material_autocomplete__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @angular/material/autocomplete */ "./node_modules/@angular/material/esm2015/autocomplete.js");
            /* harmony import */ var _angular_material_button__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @angular/material/button */ "./node_modules/@angular/material/esm2015/button.js");
            /* harmony import */ var _angular_material_button_toggle__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @angular/material/button-toggle */ "./node_modules/@angular/material/esm2015/button-toggle.js");
            /* harmony import */ var _angular_material_card__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @angular/material/card */ "./node_modules/@angular/material/esm2015/card.js");
            /* harmony import */ var _angular_material_checkbox__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @angular/material/checkbox */ "./node_modules/@angular/material/esm2015/checkbox.js");
            /* harmony import */ var _angular_material_chips__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @angular/material/chips */ "./node_modules/@angular/material/esm2015/chips.js");
            /* harmony import */ var _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @angular/material/datepicker */ "./node_modules/@angular/material/esm2015/datepicker.js");
            /* harmony import */ var _angular_material_expansion__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @angular/material/expansion */ "./node_modules/@angular/material/esm2015/expansion.js");
            /* harmony import */ var _angular_material_icon__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! @angular/material/icon */ "./node_modules/@angular/material/esm2015/icon.js");
            /* harmony import */ var _angular_material_input__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! @angular/material/input */ "./node_modules/@angular/material/esm2015/input.js");
            /* harmony import */ var _angular_material_radio__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! @angular/material/radio */ "./node_modules/@angular/material/esm2015/radio.js");
            /* harmony import */ var _angular_material_select__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! @angular/material/select */ "./node_modules/@angular/material/esm2015/select.js");
            /* harmony import */ var _angular_material_slide_toggle__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! @angular/material/slide-toggle */ "./node_modules/@angular/material/esm2015/slide-toggle.js");
            /* harmony import */ var _angular_material_slider__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! @angular/material/slider */ "./node_modules/@angular/material/esm2015/slider.js");
            /* harmony import */ var _angular_material_stepper__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! @angular/material/stepper */ "./node_modules/@angular/material/esm2015/stepper.js");
            /* harmony import */ var _angular_material_tabs__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! @angular/material/tabs */ "./node_modules/@angular/material/esm2015/tabs.js");
            /* harmony import */ var _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! @angular/material/tooltip */ "./node_modules/@angular/material/esm2015/tooltip.js");
            /**
             * '_executeValidators' utility function
             *
             * Validates a control against an array of validators, and returns
             * an array of the same length containing a combination of error messages
             * (from invalid validators) and null values (from valid validators)
             *
             * //  { AbstractControl } control - control to validate
             * //  { IValidatorFn[] } validators - array of validators
             * //  { boolean } invert - invert?
             * // { PlainObject[] } - array of nulls and error message
             */
            function _executeValidators(control, validators, invert) {
                if (invert === void 0) { invert = false; }
                return validators.map(function (validator) { return validator(control, invert); });
            }
            /**
             * '_executeAsyncValidators' utility function
             *
             * Validates a control against an array of async validators, and returns
             * an array of observabe results of the same length containing a combination of
             * error messages (from invalid validators) and null values (from valid ones)
             *
             * //  { AbstractControl } control - control to validate
             * //  { AsyncIValidatorFn[] } validators - array of async validators
             * //  { boolean } invert - invert?
             * //  - array of observable nulls and error message
             */
            function _executeAsyncValidators(control, validators, invert) {
                if (invert === void 0) { invert = false; }
                return validators.map(function (validator) { return validator(control, invert); });
            }
            /**
             * '_mergeObjects' utility function
             *
             * Recursively Merges one or more objects into a single object with combined keys.
             * Automatically detects and ignores null and undefined inputs.
             * Also detects duplicated boolean 'not' keys and XORs their values.
             *
             * //  { PlainObject[] } objects - one or more objects to merge
             * // { PlainObject } - merged object
             */
            function _mergeObjects() {
                var objects = [];
                for (var _a = 0; _a < arguments.length; _a++) {
                    objects[_a] = arguments[_a];
                }
                var mergedObject = {};
                for (var _b = 0, objects_1 = objects; _b < objects_1.length; _b++) {
                    var currentObject = objects_1[_b];
                    if (isObject(currentObject)) {
                        for (var _f = 0, _g = Object.keys(currentObject); _f < _g.length; _f++) {
                            var key = _g[_f];
                            var currentValue = currentObject[key];
                            var mergedValue = mergedObject[key];
                            mergedObject[key] = !isDefined(mergedValue) ? currentValue :
                                key === 'not' && isBoolean(mergedValue, 'strict') &&
                                    isBoolean(currentValue, 'strict') ? xor(mergedValue, currentValue) :
                                    getType(mergedValue) === 'object' && getType(currentValue) === 'object' ?
                                        _mergeObjects(mergedValue, currentValue) :
                                        currentValue;
                        }
                    }
                }
                return mergedObject;
            }
            /**
             * '_mergeErrors' utility function
             *
             * Merges an array of objects.
             * Used for combining the validator errors returned from 'executeValidators'
             *
             * //  { PlainObject[] } arrayOfErrors - array of objects
             * // { PlainObject } - merged object, or null if no usable input objectcs
             */
            function _mergeErrors(arrayOfErrors) {
                var mergedErrors = _mergeObjects.apply(void 0, arrayOfErrors);
                return isEmpty(mergedErrors) ? null : mergedErrors;
            }
            /**
             * 'isDefined' utility function
             *
             * Checks if a variable contains a value of any type.
             * Returns true even for otherwise 'falsey' values of 0, '', and false.
             *
             * //   value - the value to check
             * // { boolean } - false if undefined or null, otherwise true
             */
            function isDefined(value) {
                return value !== undefined && value !== null;
            }
            /**
             * 'hasValue' utility function
             *
             * Checks if a variable contains a value.
             * Returs false for null, undefined, or a zero-length strng, '',
             * otherwise returns true.
             * (Stricter than 'isDefined' because it also returns false for '',
             * though it stil returns true for otherwise 'falsey' values 0 and false.)
             *
             * //   value - the value to check
             * // { boolean } - false if undefined, null, or '', otherwise true
             */
            function hasValue(value) {
                return value !== undefined && value !== null && value !== '';
            }
            /**
             * 'isEmpty' utility function
             *
             * Similar to !hasValue, but also returns true for empty arrays and objects.
             *
             * //   value - the value to check
             * // { boolean } - false if undefined, null, or '', otherwise true
             */
            function isEmpty(value) {
                if (isArray(value)) {
                    return !value.length;
                }
                if (isObject(value)) {
                    return !Object.keys(value).length;
                }
                return value === undefined || value === null || value === '';
            }
            /**
             * 'isString' utility function
             *
             * Checks if a value is a string.
             *
             * //   value - the value to check
             * // { boolean } - true if string, false if not
             */
            function isString(value) {
                return typeof value === 'string';
            }
            /**
             * 'isNumber' utility function
             *
             * Checks if a value is a regular number, numeric string, or JavaScript Date.
             *
             * //   value - the value to check
             * //  { any = false } strict - if truthy, also checks JavaScript tyoe
             * // { boolean } - true if number, false if not
             */
            function isNumber(value, strict) {
                if (strict === void 0) { strict = false; }
                if (strict && typeof value !== 'number') {
                    return false;
                }
                return !isNaN(value) && value !== value / 0;
            }
            /**
             * 'isInteger' utility function
             *
             * Checks if a value is an integer.
             *
             * //   value - the value to check
             * //  { any = false } strict - if truthy, also checks JavaScript tyoe
             * // {boolean } - true if number, false if not
             */
            function isInteger(value, strict) {
                if (strict === void 0) { strict = false; }
                if (strict && typeof value !== 'number') {
                    return false;
                }
                return !isNaN(value) && value !== value / 0 && value % 1 === 0;
            }
            /**
             * 'isBoolean' utility function
             *
             * Checks if a value is a boolean.
             *
             * //   value - the value to check
             * //  { any = null } option - if 'strict', also checks JavaScript type
             *                              if TRUE or FALSE, checks only for that value
             * // { boolean } - true if boolean, false if not
             */
            function isBoolean(value, option) {
                if (option === void 0) { option = null; }
                if (option === 'strict') {
                    return value === true || value === false;
                }
                if (option === true) {
                    return value === true || value === 1 || value === 'true' || value === '1';
                }
                if (option === false) {
                    return value === false || value === 0 || value === 'false' || value === '0';
                }
                return value === true || value === 1 || value === 'true' || value === '1' ||
                    value === false || value === 0 || value === 'false' || value === '0';
            }
            function isFunction(item) {
                return typeof item === 'function';
            }
            function isObject(item) {
                return item !== null && typeof item === 'object' &&
                    Object.prototype.toString.call(item) === '[object Object]';
            }
            function isArray(item) {
                return Array.isArray(item) ||
                    Object.prototype.toString.call(item) === '[object Array]';
            }
            function isDate(item) {
                return typeof item === 'object' &&
                    Object.prototype.toString.call(item) === '[object Date]';
            }
            function isMap(item) {
                return typeof item === 'object' &&
                    Object.prototype.toString.call(item) === '[object Map]';
            }
            function isSet(item) {
                return typeof item === 'object' &&
                    Object.prototype.toString.call(item) === '[object Set]';
            }
            /**
             * 'getType' function
             *
             * Detects the JSON Schema Type of a value.
             * By default, detects numbers and integers even if formatted as strings.
             * (So all integers are also numbers, and any number may also be a string.)
             * However, it only detects true boolean values (to detect boolean values
             * in non-boolean formats, use isBoolean() instead).
             *
             * If passed a second optional parameter of 'strict', it will only detect
             * numbers and integers if they are formatted as JavaScript numbers.
             *
             * Examples:
             * getType('10.5') = 'number'
             * getType(10.5) = 'number'
             * getType('10') = 'integer'
             * getType(10) = 'integer'
             * getType('true') = 'string'
             * getType(true) = 'boolean'
             * getType(null) = 'null'
             * getType({ }) = 'object'
             * getType([]) = 'array'
             *
             * getType('10.5', 'strict') = 'string'
             * getType(10.5, 'strict') = 'number'
             * getType('10', 'strict') = 'string'
             * getType(10, 'strict') = 'integer'
             * getType('true', 'strict') = 'string'
             * getType(true, 'strict') = 'boolean'
             *
             * //   value - value to check
             * //  { any = false } strict - if truthy, also checks JavaScript tyoe
             * // { SchemaType }
             */
            function getType(value, strict) {
                if (strict === void 0) { strict = false; }
                if (!isDefined(value)) {
                    return 'null';
                }
                if (isArray(value)) {
                    return 'array';
                }
                if (isObject(value)) {
                    return 'object';
                }
                if (isBoolean(value, 'strict')) {
                    return 'boolean';
                }
                if (isInteger(value, strict)) {
                    return 'integer';
                }
                if (isNumber(value, strict)) {
                    return 'number';
                }
                if (isString(value) || (!strict && isDate(value))) {
                    return 'string';
                }
                return null;
            }
            /**
             * 'isType' function
             *
             * Checks wether an input (probably string) value contains data of
             * a specified JSON Schema type
             *
             * //  { PrimitiveValue } value - value to check
             * //  { SchemaPrimitiveType } type - type to check
             * // { boolean }
             */
            function isType(value, type) {
                switch (type) {
                    case 'string':
                        return isString(value) || isDate(value);
                    case 'number':
                        return isNumber(value);
                    case 'integer':
                        return isInteger(value);
                    case 'boolean':
                        return isBoolean(value);
                    case 'null':
                        return !hasValue(value);
                    default:
                        console.error("isType error: \"" + type + "\" is not a recognized type.");
                        return null;
                }
            }
            /**
             * 'isPrimitive' function
             *
             * Checks wether an input value is a JavaScript primitive type:
             * string, number, boolean, or null.
             *
             * //   value - value to check
             * // { boolean }
             */
            function isPrimitive(value) {
                return (isString(value) || isNumber(value) ||
                    isBoolean(value, 'strict') || value === null);
            }
            /**
             * 'toJavaScriptType' function
             *
             * Converts an input (probably string) value to a JavaScript primitive type -
             * 'string', 'number', 'boolean', or 'null' - before storing in a JSON object.
             *
             * Does not coerce values (other than null), and only converts the types
             * of values that would otherwise be valid.
             *
             * If the optional third parameter 'strictIntegers' is TRUE, and the
             * JSON Schema type 'integer' is specified, it also verifies the input value
             * is an integer and, if it is, returns it as a JaveScript number.
             * If 'strictIntegers' is FALSE (or not set) the type 'integer' is treated
             * exactly the same as 'number', and allows decimals.
             *
             * Valid Examples:
             * toJavaScriptType('10',   'number' ) = 10   // '10'   is a number
             * toJavaScriptType('10',   'integer') = 10   // '10'   is also an integer
             * toJavaScriptType( 10,    'integer') = 10   //  10    is still an integer
             * toJavaScriptType( 10,    'string' ) = '10' //  10    can be made into a string
             * toJavaScriptType('10.5', 'number' ) = 10.5 // '10.5' is a number
             *
             * Invalid Examples:
             * toJavaScriptType('10.5', 'integer') = null // '10.5' is not an integer
             * toJavaScriptType( 10.5,  'integer') = null //  10.5  is still not an integer
             *
             * //  { PrimitiveValue } value - value to convert
             * //  { SchemaPrimitiveType | SchemaPrimitiveType[] } types - types to convert to
             * //  { boolean = false } strictIntegers - if FALSE, treat integers as numbers
             * // { PrimitiveValue }
             */
            function toJavaScriptType(value, types, strictIntegers) {
                if (strictIntegers === void 0) { strictIntegers = true; }
                if (!isDefined(value)) {
                    return null;
                }
                if (isString(types)) {
                    types = [types];
                }
                if (strictIntegers && inArray('integer', types)) {
                    if (isInteger(value, 'strict')) {
                        return value;
                    }
                    if (isInteger(value)) {
                        return parseInt(value, 10);
                    }
                }
                if (inArray('number', types) || (!strictIntegers && inArray('integer', types))) {
                    if (isNumber(value, 'strict')) {
                        return value;
                    }
                    if (isNumber(value)) {
                        return parseFloat(value);
                    }
                }
                if (inArray('string', types)) {
                    if (isString(value)) {
                        return value;
                    }
                    // If value is a date, and types includes 'string',
                    // convert the date to a string
                    if (isDate(value)) {
                        return value.toISOString().slice(0, 10);
                    }
                    if (isNumber(value)) {
                        return value.toString();
                    }
                }
                // If value is a date, and types includes 'integer' or 'number',
                // but not 'string', convert the date to a number
                if (isDate(value) && (inArray('integer', types) || inArray('number', types))) {
                    return value.getTime();
                }
                if (inArray('boolean', types)) {
                    if (isBoolean(value, true)) {
                        return true;
                    }
                    if (isBoolean(value, false)) {
                        return false;
                    }
                }
                return null;
            }
            /**
             * 'toSchemaType' function
             *
             * Converts an input (probably string) value to the "best" JavaScript
             * equivalent available from an allowed list of JSON Schema types, which may
             * contain 'string', 'number', 'integer', 'boolean', and/or 'null'.
             * If necssary, it does progressively agressive type coersion.
             * It will not return null unless null is in the list of allowed types.
             *
             * Number conversion examples:
             * toSchemaType('10', ['number','integer','string']) = 10 // integer
             * toSchemaType('10', ['number','string']) = 10 // number
             * toSchemaType('10', ['string']) = '10' // string
             * toSchemaType('10.5', ['number','integer','string']) = 10.5 // number
             * toSchemaType('10.5', ['integer','string']) = '10.5' // string
             * toSchemaType('10.5', ['integer']) = 10 // integer
             * toSchemaType(10.5, ['null','boolean','string']) = '10.5' // string
             * toSchemaType(10.5, ['null','boolean']) = true // boolean
             *
             * String conversion examples:
             * toSchemaType('1.5x', ['boolean','number','integer','string']) = '1.5x' // string
             * toSchemaType('1.5x', ['boolean','number','integer']) = '1.5' // number
             * toSchemaType('1.5x', ['boolean','integer']) = '1' // integer
             * toSchemaType('1.5x', ['boolean']) = true // boolean
             * toSchemaType('xyz', ['number','integer','boolean','null']) = true // boolean
             * toSchemaType('xyz', ['number','integer','null']) = null // null
             * toSchemaType('xyz', ['number','integer']) = 0 // number
             *
             * Boolean conversion examples:
             * toSchemaType('1', ['integer','number','string','boolean']) = 1 // integer
             * toSchemaType('1', ['number','string','boolean']) = 1 // number
             * toSchemaType('1', ['string','boolean']) = '1' // string
             * toSchemaType('1', ['boolean']) = true // boolean
             * toSchemaType('true', ['number','string','boolean']) = 'true' // string
             * toSchemaType('true', ['boolean']) = true // boolean
             * toSchemaType('true', ['number']) = 0 // number
             * toSchemaType(true, ['number','string','boolean']) = true // boolean
             * toSchemaType(true, ['number','string']) = 'true' // string
             * toSchemaType(true, ['number']) = 1 // number
             *
             * //  { PrimitiveValue } value - value to convert
             * //  { SchemaPrimitiveType | SchemaPrimitiveType[] } types - allowed types to convert to
             * // { PrimitiveValue }
             */
            function toSchemaType(value, types) {
                if (!isArray(types)) {
                    types = [types];
                }
                if (types.includes('null') && !hasValue(value)) {
                    return null;
                }
                if (types.includes('boolean') && !isBoolean(value, 'strict')) {
                    return value;
                }
                if (types.includes('integer')) {
                    var testValue = toJavaScriptType(value, 'integer');
                    if (testValue !== null) {
                        return +testValue;
                    }
                }
                if (types.includes('number')) {
                    var testValue = toJavaScriptType(value, 'number');
                    if (testValue !== null) {
                        return +testValue;
                    }
                }
                if ((isString(value) || isNumber(value, 'strict')) &&
                    types.includes('string')) { // Convert number to string
                    return toJavaScriptType(value, 'string');
                }
                if (types.includes('boolean') && isBoolean(value)) {
                    return toJavaScriptType(value, 'boolean');
                }
                if (types.includes('string')) { // Convert null & boolean to string
                    if (value === null) {
                        return '';
                    }
                    var testValue = toJavaScriptType(value, 'string');
                    if (testValue !== null) {
                        return testValue;
                    }
                }
                if ((types.includes('number') ||
                    types.includes('integer'))) {
                    if (value === true) {
                        return 1;
                    } // Convert boolean & null to number
                    if (value === false || value === null || value === '') {
                        return 0;
                    }
                }
                if (types.includes('number')) { // Convert mixed string to number
                    var testValue = parseFloat(value);
                    if (!!testValue) {
                        return testValue;
                    }
                }
                if (types.includes('integer')) { // Convert string or number to integer
                    var testValue = parseInt(value, 10);
                    if (!!testValue) {
                        return testValue;
                    }
                }
                if (types.includes('boolean')) { // Convert anything to boolean
                    return !!value;
                }
                if ((types.includes('number') ||
                    types.includes('integer')) && !types.includes('null')) {
                    return 0; // If null not allowed, return 0 for non-convertable values
                }
            }
            /**
             * 'isPromise' function
             *
             * //   object
             * // { boolean }
             */
            function isPromise(object) {
                return !!object && typeof object.then === 'function';
            }
            /**
             * 'isObservable' function
             *
             * //   object
             * // { boolean }
             */
            function isObservable(object) {
                return !!object && typeof object.subscribe === 'function';
            }
            /**
             * '_toPromise' function
             *
             * //  { object } object
             * // { Promise<any> }
             */
            function _toPromise(object) {
                return isPromise(object) ? object : object.toPromise();
            }
            /**
             * 'toObservable' function
             *
             * //  { object } object
             * // { Observable<any> }
             */
            function toObservable(object) {
                var observable = isPromise(object) ? Object(rxjs__WEBPACK_IMPORTED_MODULE_7__["from"])(object) : object;
                if (isObservable(observable)) {
                    return observable;
                }
                console.error('toObservable error: Expected validator to return Promise or Observable.');
                return new rxjs__WEBPACK_IMPORTED_MODULE_7__["Observable"]();
            }
            /**
             * 'inArray' function
             *
             * Searches an array for an item, or one of a list of items, and returns true
             * as soon as a match is found, or false if no match.
             *
             * If the optional third parameter allIn is set to TRUE, and the item to find
             * is an array, then the function returns true only if all elements from item
             * are found in the array list, and false if any element is not found. If the
             * item to find is not an array, setting allIn to TRUE has no effect.
             *
             * //  { any|any[] } item - the item to search for
             * //   array - the array to search
             * //  { boolean = false } allIn - if TRUE, all items must be in array
             * // { boolean } - true if item(s) in array, false otherwise
             */
            function inArray(item, array, allIn) {
                if (allIn === void 0) { allIn = false; }
                if (!isDefined(item) || !isArray(array)) {
                    return false;
                }
                return isArray(item) ?
                    item[allIn ? 'every' : 'some'](function (subItem) { return array.includes(subItem); }) :
                    array.includes(item);
            }
            /**
             * 'xor' utility function - exclusive or
             *
             * Returns true if exactly one of two values is truthy.
             *
             * //   value1 - first value to check
             * //   value2 - second value to check
             * // { boolean } - true if exactly one input value is truthy, false if not
             */
            function xor(value1, value2) {
                return (!!value1 && !value2) || (!value1 && !!value2);
            }
            /**
             * Utility function library:
             *
             * addClasses, copy, forEach, forEachCopy, hasOwn, mergeFilteredObject,
             * uniqueItems, commonItems, fixTitle, toTitleCase
            */
            /**
             * 'addClasses' function
             *
             * Merges two space-delimited lists of CSS classes and removes duplicates.
             *
             * // {string | string[] | Set<string>} oldClasses
             * // {string | string[] | Set<string>} newClasses
             * // {string | string[] | Set<string>} - Combined classes
             */
            function addClasses(oldClasses, newClasses) {
                var badType = function (i) { return !isSet(i) && !isArray(i) && !isString(i); };
                if (badType(newClasses)) {
                    return oldClasses;
                }
                if (badType(oldClasses)) {
                    oldClasses = '';
                }
                var toSet = function (i) { return isSet(i) ? i : isArray(i) ? new Set(i) : new Set(i.split(' ')); };
                var combinedSet = toSet(oldClasses);
                var newSet = toSet(newClasses);
                newSet.forEach(function (c) { return combinedSet.add(c); });
                if (isSet(oldClasses)) {
                    return combinedSet;
                }
                if (isArray(oldClasses)) {
                    return Array.from(combinedSet);
                }
                return Array.from(combinedSet).join(' ');
            }
            /**
             * 'copy' function
             *
             * Makes a shallow copy of a JavaScript object, array, Map, or Set.
             * If passed a JavaScript primitive value (string, number, boolean, or null),
             * it returns the value.
             *
             * // {Object|Array|string|number|boolean|null} object - The object to copy
             * // {boolean = false} errors - Show errors?
             * // {Object|Array|string|number|boolean|null} - The copied object
             */
            function copy(object, errors) {
                if (errors === void 0) { errors = false; }
                if (typeof object !== 'object' || object === null) {
                    return object;
                }
                if (isMap(object)) {
                    return new Map(object);
                }
                if (isSet(object)) {
                    return new Set(object);
                }
                if (isArray(object)) {
                    return object.slice();
                }
                if (isObject(object)) {
                    return Object.assign({}, object);
                }
                if (errors) {
                    console.error('copy error: Object to copy must be a JavaScript object or value.');
                }
                return object;
            }
            /**
             * 'forEach' function
             *
             * Iterates over all items in the first level of an object or array
             * and calls an iterator funciton on each item.
             *
             * The iterator function is called with four values:
             * 1. The current item's value
             * 2. The current item's key
             * 3. The parent object, which contains the current item
             * 4. The root object
             *
             * Setting the optional third parameter to 'top-down' or 'bottom-up' will cause
             * it to also recursively iterate over items in sub-objects or sub-arrays in the
             * specified direction.
             *
             * // {Object|Array} object - The object or array to iterate over
             * // {function} fn - the iterator funciton to call on each item
             * // {boolean = false} errors - Show errors?
             * // {void}
             */
            function forEach(object, fn, recurse, rootObject, errors) {
                if (recurse === void 0) { recurse = false; }
                if (rootObject === void 0) { rootObject = object; }
                if (errors === void 0) { errors = false; }
                if (isEmpty(object)) {
                    return;
                }
                if ((isObject(object) || isArray(object)) && typeof fn === 'function') {
                    for (var _a = 0, _b = Object.keys(object); _a < _b.length; _a++) {
                        var key = _b[_a];
                        var value = object[key];
                        if (recurse === 'bottom-up' && (isObject(value) || isArray(value))) {
                            forEach(value, fn, recurse, rootObject);
                        }
                        fn(value, key, object, rootObject);
                        if (recurse === 'top-down' && (isObject(value) || isArray(value))) {
                            forEach(value, fn, recurse, rootObject);
                        }
                    }
                }
                if (errors) {
                    if (typeof fn !== 'function') {
                        console.error('forEach error: Iterator must be a function.');
                        console.error('function', fn);
                    }
                    if (!isObject(object) && !isArray(object)) {
                        console.error('forEach error: Input object must be an object or array.');
                        console.error('object', object);
                    }
                }
            }
            /**
             * 'forEachCopy' function
             *
             * Iterates over all items in the first level of an object or array
             * and calls an iterator function on each item. Returns a new object or array
             * with the same keys or indexes as the original, and values set to the results
             * of the iterator function.
             *
             * Does NOT recursively iterate over items in sub-objects or sub-arrays.
             *
             * // {Object | Array} object - The object or array to iterate over
             * // {function} fn - The iterator funciton to call on each item
             * // {boolean = false} errors - Show errors?
             * // {Object | Array} - The resulting object or array
             */
            function forEachCopy(object, fn, errors) {
                if (errors === void 0) { errors = false; }
                if (!hasValue(object)) {
                    return;
                }
                if ((isObject(object) || isArray(object)) && typeof object !== 'function') {
                    var newObject = isArray(object) ? [] : {};
                    for (var _a = 0, _b = Object.keys(object); _a < _b.length; _a++) {
                        var key = _b[_a];
                        newObject[key] = fn(object[key], key, object);
                    }
                    return newObject;
                }
                if (errors) {
                    if (typeof fn !== 'function') {
                        console.error('forEachCopy error: Iterator must be a function.');
                        console.error('function', fn);
                    }
                    if (!isObject(object) && !isArray(object)) {
                        console.error('forEachCopy error: Input object must be an object or array.');
                        console.error('object', object);
                    }
                }
            }
            /**
             * 'hasOwn' utility function
             *
             * Checks whether an object or array has a particular property.
             *
             * // {any} object - the object to check
             * // {string} property - the property to look for
             * // {boolean} - true if object has property, false if not
             */
            function hasOwn(object, property) {
                if (!object || !['number', 'string', 'symbol'].includes(typeof property) ||
                    (!isObject(object) && !isArray(object) && !isMap(object) && !isSet(object))) {
                    return false;
                }
                if (isMap(object) || isSet(object)) {
                    return object.has(property);
                }
                if (typeof property === 'number') {
                    if (isArray(object)) {
                        return object[property];
                    }
                    property = property + '';
                }
                return object.hasOwnProperty(property);
            }
            /**
             * Types of possible expressions which the app is able to evaluate.
             */
            var ExpressionType;
            (function (ExpressionType) {
                ExpressionType[ExpressionType["EQUALS"] = 0] = "EQUALS";
                ExpressionType[ExpressionType["NOT_EQUALS"] = 1] = "NOT_EQUALS";
                ExpressionType[ExpressionType["NOT_AN_EXPRESSION"] = 2] = "NOT_AN_EXPRESSION";
            })(ExpressionType || (ExpressionType = {}));
            /**
             * Detects the type of expression from the given candidate. `==` for equals,
             * `!=` for not equals. If none of these are contained in the candidate, the candidate
             * is not considered to be an expression at all and thus `NOT_AN_EXPRESSION` is returned.
             * // {expressionCandidate} expressionCandidate - potential expression
             */
            function getExpressionType(expressionCandidate) {
                if (expressionCandidate.indexOf('==') !== -1) {
                    return ExpressionType.EQUALS;
                }
                if (expressionCandidate.toString().indexOf('!=') !== -1) {
                    return ExpressionType.NOT_EQUALS;
                }
                return ExpressionType.NOT_AN_EXPRESSION;
            }
            function isEqual(expressionType) {
                return expressionType === ExpressionType.EQUALS;
            }
            function isNotEqual(expressionType) {
                return expressionType === ExpressionType.NOT_EQUALS;
            }
            function isNotExpression(expressionType) {
                return expressionType === ExpressionType.NOT_AN_EXPRESSION;
            }
            /**
             * Splits the expression key by the expressionType on a pair of values
             * before and after the equals or nor equals sign.
             * // {expressionType} enum of an expression type
             * // {key} the given key from a for loop iver all conditions
             */
            function getKeyAndValueByExpressionType(expressionType, key) {
                if (isEqual(expressionType)) {
                    return key.split('==', 2);
                }
                if (isNotEqual(expressionType)) {
                    return key.split('!=', 2);
                }
                return null;
            }
            function cleanValueOfQuotes(keyAndValue) {
                if (keyAndValue.charAt(0) === '\'' && keyAndValue.charAt(keyAndValue.length - 1) === '\'') {
                    return keyAndValue.replace('\'', '').replace('\'', '');
                }
                return keyAndValue;
            }
            /**
             * 'mergeFilteredObject' utility function
             *
             * Shallowly merges two objects, setting key and values from source object
             * in target object, excluding specified keys.
             *
             * Optionally, it can also use functions to transform the key names and/or
             * the values of the merging object.
             *
             * // {PlainObject} targetObject - Target object to add keys and values to
             * // {PlainObject} sourceObject - Source object to copy keys and values from
             * // {string[]} excludeKeys - Array of keys to exclude
             * // {(string: string) => string = (k) => k} keyFn - Function to apply to keys
             * // {(any: any) => any = (v) => v} valueFn - Function to apply to values
             * // {PlainObject} - Returns targetObject
             */
            function mergeFilteredObject(targetObject, sourceObject, excludeKeys, keyFn, valFn) {
                if (excludeKeys === void 0) { excludeKeys = []; }
                if (keyFn === void 0) { keyFn = function (key) { return key; }; }
                if (valFn === void 0) { valFn = function (val) { return val; }; }
                if (!isObject(sourceObject)) {
                    return targetObject;
                }
                if (!isObject(targetObject)) {
                    targetObject = {};
                }
                for (var _a = 0, _b = Object.keys(sourceObject); _a < _b.length; _a++) {
                    var key = _b[_a];
                    if (!inArray(key, excludeKeys) && isDefined(sourceObject[key])) {
                        targetObject[keyFn(key)] = valFn(sourceObject[key]);
                    }
                }
                return targetObject;
            }
            /**
             * 'uniqueItems' function
             *
             * Accepts any number of string value inputs,
             * and returns an array of all input vaues, excluding duplicates.
             *
             * // {...string} ...items -
             * // {string[]} -
             */
            function uniqueItems() {
                var items = [];
                for (var _a = 0; _a < arguments.length; _a++) {
                    items[_a] = arguments[_a];
                }
                var returnItems = [];
                for (var _b = 0, items_1 = items; _b < items_1.length; _b++) {
                    var item = items_1[_b];
                    if (!returnItems.includes(item)) {
                        returnItems.push(item);
                    }
                }
                return returnItems;
            }
            /**
             * 'commonItems' function
             *
             * Accepts any number of strings or arrays of string values,
             * and returns a single array containing only values present in all inputs.
             *
             * // {...string|string[]} ...arrays -
             * // {string[]} -
             */
            function commonItems() {
                var arrays = [];
                for (var _a = 0; _a < arguments.length; _a++) {
                    arrays[_a] = arguments[_a];
                }
                var returnItems = null;
                var _loop_1 = function (array) {
                    if (isString(array)) {
                        array = [array];
                    }
                    returnItems = returnItems === null ? array.slice() :
                        returnItems.filter(function (item) { return array.includes(item); });
                    if (!returnItems.length) {
                        return { value: [] };
                    }
                };
                for (var _b = 0, arrays_1 = arrays; _b < arrays_1.length; _b++) {
                    var array = arrays_1[_b];
                    var state_1 = _loop_1(array);
                    if (typeof state_1 === "object")
                        return state_1.value;
                }
                return returnItems;
            }
            /**
             * 'fixTitle' function
             *
             *
             * // {string} input -
             * // {string} -
             */
            function fixTitle(name) {
                return name && toTitleCase(name.replace(/([a-z])([A-Z])/g, '$1 $2').replace(/_/g, ' '));
            }
            /**
             * 'toTitleCase' function
             *
             * Intelligently converts an input string to Title Case.
             *
             * Accepts an optional second parameter with a list of additional
             * words and abbreviations to force into a particular case.
             *
             * This function is built on prior work by John Gruber and David Gouch:
             * http://daringfireball.net/2008/08/title_case_update
             * https://github.com/gouch/to-title-case
             *
             * // {string} input -
             * // {string|string[]} forceWords? -
             * // {string} -
             */
            function toTitleCase(input, forceWords) {
                if (!isString(input)) {
                    return input;
                }
                var forceArray = ['a', 'an', 'and', 'as', 'at', 'but', 'by', 'en',
                    'for', 'if', 'in', 'nor', 'of', 'on', 'or', 'per', 'the', 'to', 'v', 'v.',
                    'vs', 'vs.', 'via'];
                if (isString(forceWords)) {
                    forceWords = forceWords.split('|');
                }
                if (isArray(forceWords)) {
                    forceArray = forceArray.concat(forceWords);
                }
                var forceArrayLower = forceArray.map(function (w) { return w.toLowerCase(); });
                var noInitialCase = input === input.toUpperCase() || input === input.toLowerCase();
                var prevLastChar = '';
                input = input.trim();
                return input.replace(/[A-Za-z0-9\u00C0-\u00FF]+[^\s-]*/g, function (word, idx) {
                    if (!noInitialCase && word.slice(1).search(/[A-Z]|\../) !== -1) {
                        return word;
                    }
                    else {
                        var newWord = void 0;
                        var forceWord = forceArray[forceArrayLower.indexOf(word.toLowerCase())];
                        if (!forceWord) {
                            if (noInitialCase) {
                                if (word.slice(1).search(/\../) !== -1) {
                                    newWord = word.toLowerCase();
                                }
                                else {
                                    newWord = word[0].toUpperCase() + word.slice(1).toLowerCase();
                                }
                            }
                            else {
                                newWord = word[0].toUpperCase() + word.slice(1);
                            }
                        }
                        else if (forceWord === forceWord.toLowerCase() && (idx === 0 || idx + word.length === input.length ||
                            prevLastChar === ':' || input[idx - 1].search(/[^\s-]/) !== -1 ||
                            (input[idx - 1] !== '-' && input[idx + word.length] === '-'))) {
                            newWord = forceWord[0].toUpperCase() + forceWord.slice(1);
                        }
                        else {
                            newWord = forceWord;
                        }
                        prevLastChar = word.slice(-1);
                        return newWord;
                    }
                });
            }
            var JsonPointer_1;
            var JsonPointer = JsonPointer_1 = /** @class */ (function () {
                function JsonPointer() {
                }
                /**
                 * 'get' function
                 *
                 * Uses a JSON Pointer to retrieve a value from an object.
                 *
                 * //  { object } object - Object to get value from
                 * //  { Pointer } pointer - JSON Pointer (string or array)
                 * //  { number = 0 } startSlice - Zero-based index of first Pointer key to use
                 * //  { number } endSlice - Zero-based index of last Pointer key to use
                 * //  { boolean = false } getBoolean - Return only true or false?
                 * //  { boolean = false } errors - Show error if not found?
                 * // { object } - Located value (or true or false if getBoolean = true)
                 */
                JsonPointer.get = function (object, pointer, startSlice, endSlice, getBoolean, errors) {
                    if (startSlice === void 0) { startSlice = 0; }
                    if (endSlice === void 0) { endSlice = null; }
                    if (getBoolean === void 0) { getBoolean = false; }
                    if (errors === void 0) { errors = false; }
                    if (object === null) {
                        return getBoolean ? false : undefined;
                    }
                    var keyArray = this.parse(pointer, errors);
                    if (typeof object === 'object' && keyArray !== null) {
                        var subObject = object;
                        if (startSlice >= keyArray.length || endSlice <= -keyArray.length) {
                            return object;
                        }
                        if (startSlice <= -keyArray.length) {
                            startSlice = 0;
                        }
                        if (!isDefined(endSlice) || endSlice >= keyArray.length) {
                            endSlice = keyArray.length;
                        }
                        keyArray = keyArray.slice(startSlice, endSlice);
                        for (var _a = 0, keyArray_1 = keyArray; _a < keyArray_1.length; _a++) {
                            var key = keyArray_1[_a];
                            if (key === '-' && isArray(subObject) && subObject.length) {
                                key = subObject.length - 1;
                            }
                            if (isMap(subObject) && subObject.has(key)) {
                                subObject = subObject.get(key);
                            }
                            else if (typeof subObject === 'object' && subObject !== null &&
                                hasOwn(subObject, key)) {
                                subObject = subObject[key];
                            }
                            else {
                                var evaluatedExpression = JsonPointer_1.evaluateExpression(subObject, key);
                                if (evaluatedExpression.passed) {
                                    subObject = evaluatedExpression.key ? subObject[evaluatedExpression.key] : subObject;
                                }
                                else {
                                    this.logErrors(errors, key, pointer, object);
                                    return getBoolean ? false : undefined;
                                }
                            }
                        }
                        return getBoolean ? true : subObject;
                    }
                    if (errors && keyArray === null) {
                        console.error("get error: Invalid JSON Pointer: " + pointer);
                    }
                    if (errors && typeof object !== 'object') {
                        console.error('get error: Invalid object:');
                        console.error(object);
                    }
                    return getBoolean ? false : undefined;
                };
                JsonPointer.logErrors = function (errors, key, pointer, object) {
                    if (errors) {
                        console.error("get error: \"" + key + "\" key not found in object.");
                        console.error(pointer);
                        console.error(object);
                    }
                };
                /**
                 * Evaluates conditional expression in form of `model.<property>==<value>` or
                 * `model.<property>!=<value>` where the first one means that the value must match to be
                 * shown in a form, while the former shows the property only when the property value is not
                 * set, or does not equal the given value.
                 *
                 * // { subObject } subObject -  an object containing the data values of properties
                 * // { key } key - the key from the for loop in a form of `<property>==<value>`
                 *
                 * Returns the object with two properties. The property passed informs whether
                 * the expression evaluated successfully and the property key returns either the same
                 * key if it is not contained inside the subObject or the key of the property if it is contained.
                 */
                JsonPointer.evaluateExpression = function (subObject, key) {
                    var defaultResult = { passed: false, key: key };
                    var keysAndExpression = this.parseKeysAndExpression(key, subObject);
                    if (!keysAndExpression) {
                        return defaultResult;
                    }
                    var ownCheckResult = this.doOwnCheckResult(subObject, keysAndExpression);
                    if (ownCheckResult) {
                        return ownCheckResult;
                    }
                    var cleanedValue = cleanValueOfQuotes(keysAndExpression.keyAndValue[1]);
                    var evaluatedResult = this.performExpressionOnValue(keysAndExpression, cleanedValue, subObject);
                    if (evaluatedResult) {
                        return evaluatedResult;
                    }
                    return defaultResult;
                };
                /**
                 * Performs the actual evaluation on the given expression with given values and keys.
                 * // { cleanedValue } cleanedValue - the given valued cleaned of quotes if it had any
                 * // { subObject } subObject - the object with properties values
                 * // { keysAndExpression } keysAndExpression - an object holding the expressions with
                 */
                JsonPointer.performExpressionOnValue = function (keysAndExpression, cleanedValue, subObject) {
                    var propertyByKey = subObject[keysAndExpression.keyAndValue[0]];
                    if (this.doComparisonByExpressionType(keysAndExpression.expressionType, propertyByKey, cleanedValue)) {
                        return { passed: true, key: keysAndExpression.keyAndValue[0] };
                    }
                    return null;
                };
                JsonPointer.doComparisonByExpressionType = function (expressionType, propertyByKey, cleanedValue) {
                    if (isEqual(expressionType)) {
                        return propertyByKey === cleanedValue;
                    }
                    if (isNotEqual(expressionType)) {
                        return propertyByKey !== cleanedValue;
                    }
                    return false;
                };
                /**
                 * Does the checks when the parsed key is actually no a property inside subObject.
                 * That would mean that the equal comparison makes no sense and thus the negative result
                 * is returned, and the not equal comparison is not necessary because it doesn't equal
                 * obviously. Returns null when the given key is a real property inside the subObject.
                 * // { subObject } subObject - the object with properties values
                 * // { keysAndExpression } keysAndExpression - an object holding the expressions with
                 * the associated keys.
                 */
                JsonPointer.doOwnCheckResult = function (subObject, keysAndExpression) {
                    var ownCheckResult = null;
                    if (!hasOwn(subObject, keysAndExpression.keyAndValue[0])) {
                        if (isEqual(keysAndExpression.expressionType)) {
                            ownCheckResult = { passed: false, key: null };
                        }
                        if (isNotEqual(keysAndExpression.expressionType)) {
                            ownCheckResult = { passed: true, key: null };
                        }
                    }
                    return ownCheckResult;
                };
                /**
                 * Does the basic checks and tries to parse an expression and a pair
                 * of key and value.
                 * // { key } key - the original for loop created value containing key and value in one string
                 * // { subObject } subObject - the object with properties values
                 */
                JsonPointer.parseKeysAndExpression = function (key, subObject) {
                    if (this.keyOrSubObjEmpty(key, subObject)) {
                        return null;
                    }
                    var expressionType = getExpressionType(key.toString());
                    if (isNotExpression(expressionType)) {
                        return null;
                    }
                    var keyAndValue = getKeyAndValueByExpressionType(expressionType, key);
                    if (!keyAndValue || !keyAndValue[0] || !keyAndValue[1]) {
                        return null;
                    }
                    return { expressionType: expressionType, keyAndValue: keyAndValue };
                };
                JsonPointer.keyOrSubObjEmpty = function (key, subObject) {
                    return !key || !subObject;
                };
                /**
                 * 'getCopy' function
                 *
                 * Uses a JSON Pointer to deeply clone a value from an object.
                 *
                 * //  { object } object - Object to get value from
                 * //  { Pointer } pointer - JSON Pointer (string or array)
                 * //  { number = 0 } startSlice - Zero-based index of first Pointer key to use
                 * //  { number } endSlice - Zero-based index of last Pointer key to use
                 * //  { boolean = false } getBoolean - Return only true or false?
                 * //  { boolean = false } errors - Show error if not found?
                 * // { object } - Located value (or true or false if getBoolean = true)
                 */
                JsonPointer.getCopy = function (object, pointer, startSlice, endSlice, getBoolean, errors) {
                    if (startSlice === void 0) { startSlice = 0; }
                    if (endSlice === void 0) { endSlice = null; }
                    if (getBoolean === void 0) { getBoolean = false; }
                    if (errors === void 0) { errors = false; }
                    var objectToCopy = this.get(object, pointer, startSlice, endSlice, getBoolean, errors);
                    return this.forEachDeepCopy(objectToCopy);
                };
                /**
                 * 'getFirst' function
                 *
                 * Takes an array of JSON Pointers and objects,
                 * checks each object for a value specified by the pointer,
                 * and returns the first value found.
                 *
                 * //  { [object, pointer][] } items - Array of objects and pointers to check
                 * //  { any = null } defaultValue - Value to return if nothing found
                 * //  { boolean = false } getCopy - Return a copy instead?
                 * //  - First value found
                 */
                JsonPointer.getFirst = function (items, defaultValue, getCopy) {
                    if (defaultValue === void 0) { defaultValue = null; }
                    if (getCopy === void 0) { getCopy = false; }
                    if (isEmpty(items)) {
                        return;
                    }
                    if (isArray(items)) {
                        for (var _a = 0, items_2 = items; _a < items_2.length; _a++) {
                            var item = items_2[_a];
                            if (isEmpty(item)) {
                                continue;
                            }
                            if (isArray(item) && item.length >= 2) {
                                if (isEmpty(item[0]) || isEmpty(item[1])) {
                                    continue;
                                }
                                var value = getCopy ?
                                    this.getCopy(item[0], item[1]) :
                                    this.get(item[0], item[1]);
                                if (value) {
                                    return value;
                                }
                                continue;
                            }
                            console.error('getFirst error: Input not in correct format.\n' +
                                'Should be: [ [ object1, pointer1 ], [ object 2, pointer2 ], etc... ]');
                            return;
                        }
                        return defaultValue;
                    }
                    if (isMap(items)) {
                        for (var _b = 0, items_3 = items; _b < items_3.length; _b++) {
                            var _f = items_3[_b], object = _f[0], pointer = _f[1];
                            if (object === null || !this.isJsonPointer(pointer)) {
                                continue;
                            }
                            var value = getCopy ?
                                this.getCopy(object, pointer) :
                                this.get(object, pointer);
                            if (value) {
                                return value;
                            }
                        }
                        return defaultValue;
                    }
                    console.error('getFirst error: Input not in correct format.\n' +
                        'Should be: [ [ object1, pointer1 ], [ object 2, pointer2 ], etc... ]');
                    return defaultValue;
                };
                /**
                 * 'getFirstCopy' function
                 *
                 * Similar to getFirst, but always returns a copy.
                 *
                 * //  { [object, pointer][] } items - Array of objects and pointers to check
                 * //  { any = null } defaultValue - Value to return if nothing found
                 * //  - Copy of first value found
                 */
                JsonPointer.getFirstCopy = function (items, defaultValue) {
                    if (defaultValue === void 0) { defaultValue = null; }
                    var firstCopy = this.getFirst(items, defaultValue, true);
                    return firstCopy;
                };
                /**
                 * 'set' function
                 *
                 * Uses a JSON Pointer to set a value on an object.
                 * Also creates any missing sub objects or arrays to contain that value.
                 *
                 * If the optional fourth parameter is TRUE and the inner-most container
                 * is an array, the function will insert the value as a new item at the
                 * specified location in the array, rather than overwriting the existing
                 * value (if any) at that location.
                 *
                 * So set([1, 2, 3], '/1', 4) => [1, 4, 3]
                 * and
                 * So set([1, 2, 3], '/1', 4, true) => [1, 4, 2, 3]
                 *
                 * //  { object } object - The object to set value in
                 * //  { Pointer } pointer - The JSON Pointer (string or array)
                 * //   value - The new value to set
                 * //  { boolean } insert - insert value?
                 * // { object } - The original object, modified with the set value
                 */
                JsonPointer.set = function (object, pointer, value, insert) {
                    if (insert === void 0) { insert = false; }
                    var keyArray = this.parse(pointer);
                    if (keyArray !== null && keyArray.length) {
                        var subObject = object;
                        for (var i = 0; i < keyArray.length - 1; ++i) {
                            var key = keyArray[i];
                            if (key === '-' && isArray(subObject)) {
                                key = subObject.length;
                            }
                            if (isMap(subObject) && subObject.has(key)) {
                                subObject = subObject.get(key);
                            }
                            else {
                                if (!hasOwn(subObject, key)) {
                                    subObject[key] = (keyArray[i + 1].match(/^(\d+|-)$/)) ? [] : {};
                                }
                                subObject = subObject[key];
                            }
                        }
                        var lastKey = keyArray[keyArray.length - 1];
                        if (isArray(subObject) && lastKey === '-') {
                            subObject.push(value);
                        }
                        else if (insert && isArray(subObject) && !isNaN(+lastKey)) {
                            subObject.splice(lastKey, 0, value);
                        }
                        else if (isMap(subObject)) {
                            subObject.set(lastKey, value);
                        }
                        else {
                            subObject[lastKey] = value;
                        }
                        return object;
                    }
                    console.error("set error: Invalid JSON Pointer: " + pointer);
                    return object;
                };
                /**
                 * 'setCopy' function
                 *
                 * Copies an object and uses a JSON Pointer to set a value on the copy.
                 * Also creates any missing sub objects or arrays to contain that value.
                 *
                 * If the optional fourth parameter is TRUE and the inner-most container
                 * is an array, the function will insert the value as a new item at the
                 * specified location in the array, rather than overwriting the existing value.
                 *
                 * //  { object } object - The object to copy and set value in
                 * //  { Pointer } pointer - The JSON Pointer (string or array)
                 * //   value - The value to set
                 * //  { boolean } insert - insert value?
                 * // { object } - The new object with the set value
                 */
                JsonPointer.setCopy = function (object, pointer, value, insert) {
                    if (insert === void 0) { insert = false; }
                    var keyArray = this.parse(pointer);
                    if (keyArray !== null) {
                        var newObject = copy(object);
                        var subObject = newObject;
                        for (var i = 0; i < keyArray.length - 1; ++i) {
                            var key = keyArray[i];
                            if (key === '-' && isArray(subObject)) {
                                key = subObject.length;
                            }
                            if (isMap(subObject) && subObject.has(key)) {
                                subObject.set(key, copy(subObject.get(key)));
                                subObject = subObject.get(key);
                            }
                            else {
                                if (!hasOwn(subObject, key)) {
                                    subObject[key] = (keyArray[i + 1].match(/^(\d+|-)$/)) ? [] : {};
                                }
                                subObject[key] = copy(subObject[key]);
                                subObject = subObject[key];
                            }
                        }
                        var lastKey = keyArray[keyArray.length - 1];
                        if (isArray(subObject) && lastKey === '-') {
                            subObject.push(value);
                        }
                        else if (insert && isArray(subObject) && !isNaN(+lastKey)) {
                            subObject.splice(lastKey, 0, value);
                        }
                        else if (isMap(subObject)) {
                            subObject.set(lastKey, value);
                        }
                        else {
                            subObject[lastKey] = value;
                        }
                        return newObject;
                    }
                    console.error("setCopy error: Invalid JSON Pointer: " + pointer);
                    return object;
                };
                /**
                 * 'insert' function
                 *
                 * Calls 'set' with insert = TRUE
                 *
                 * //  { object } object - object to insert value in
                 * //  { Pointer } pointer - JSON Pointer (string or array)
                 * //   value - value to insert
                 * // { object }
                 */
                JsonPointer.insert = function (object, pointer, value) {
                    var updatedObject = this.set(object, pointer, value, true);
                    return updatedObject;
                };
                /**
                 * 'insertCopy' function
                 *
                 * Calls 'setCopy' with insert = TRUE
                 *
                 * //  { object } object - object to insert value in
                 * //  { Pointer } pointer - JSON Pointer (string or array)
                 * //   value - value to insert
                 * // { object }
                 */
                JsonPointer.insertCopy = function (object, pointer, value) {
                    var updatedObject = this.setCopy(object, pointer, value, true);
                    return updatedObject;
                };
                /**
                 * 'remove' function
                 *
                 * Uses a JSON Pointer to remove a key and its attribute from an object
                 *
                 * //  { object } object - object to delete attribute from
                 * //  { Pointer } pointer - JSON Pointer (string or array)
                 * // { object }
                 */
                JsonPointer.remove = function (object, pointer) {
                    var keyArray = this.parse(pointer);
                    if (keyArray !== null && keyArray.length) {
                        var lastKey = keyArray.pop();
                        var parentObject = this.get(object, keyArray);
                        if (isArray(parentObject)) {
                            if (lastKey === '-') {
                                lastKey = parentObject.length - 1;
                            }
                            parentObject.splice(lastKey, 1);
                        }
                        else if (isObject(parentObject)) {
                            delete parentObject[lastKey];
                        }
                        return object;
                    }
                    console.error("remove error: Invalid JSON Pointer: " + pointer);
                    return object;
                };
                /**
                 * 'has' function
                 *
                 * Tests if an object has a value at the location specified by a JSON Pointer
                 *
                 * //  { object } object - object to chek for value
                 * //  { Pointer } pointer - JSON Pointer (string or array)
                 * // { boolean }
                 */
                JsonPointer.has = function (object, pointer) {
                    var hasValue = this.get(object, pointer, 0, null, true);
                    return hasValue;
                };
                /**
                 * 'dict' function
                 *
                 * Returns a (pointer -> value) dictionary for an object
                 *
                 * //  { object } object - The object to create a dictionary from
                 * // { object } - The resulting dictionary object
                 */
                JsonPointer.dict = function (object) {
                    var results = {};
                    this.forEachDeep(object, function (value, pointer) {
                        if (typeof value !== 'object') {
                            results[pointer] = value;
                        }
                    });
                    return results;
                };
                /**
                 * 'forEachDeep' function
                 *
                 * Iterates over own enumerable properties of an object or items in an array
                 * and invokes an iteratee function for each key/value or index/value pair.
                 * By default, iterates over items within objects and arrays after calling
                 * the iteratee function on the containing object or array itself.
                 *
                 * The iteratee is invoked with three arguments: (value, pointer, rootObject),
                 * where pointer is a JSON pointer indicating the location of the current
                 * value within the root object, and rootObject is the root object initially
                 * submitted to th function.
                 *
                 * If a third optional parameter 'bottomUp' is set to TRUE, the iterator
                 * function will be called on sub-objects and arrays after being
                 * called on their contents, rather than before, which is the default.
                 *
                 * This function can also optionally be called directly on a sub-object by
                 * including optional 4th and 5th parameterss to specify the initial
                 * root object and pointer.
                 *
                 * //  { object } object - the initial object or array
                 * //  { (v: any, p?: string, o?: any) => any } function - iteratee function
                 * //  { boolean = false } bottomUp - optional, set to TRUE to reverse direction
                 * //  { object = object } rootObject - optional, root object or array
                 * //  { string = '' } pointer - optional, JSON Pointer to object within rootObject
                 * // { object } - The modified object
                 */
                JsonPointer.forEachDeep = function (object, fn, bottomUp, pointer, rootObject) {
                    if (fn === void 0) { fn = function (v) { return v; }; }
                    if (bottomUp === void 0) { bottomUp = false; }
                    if (pointer === void 0) { pointer = ''; }
                    if (rootObject === void 0) { rootObject = object; }
                    if (typeof fn !== 'function') {
                        console.error("forEachDeep error: Iterator is not a function:", fn);
                        return;
                    }
                    if (!bottomUp) {
                        fn(object, pointer, rootObject);
                    }
                    if (isObject(object) || isArray(object)) {
                        for (var _a = 0, _b = Object.keys(object); _a < _b.length; _a++) {
                            var key = _b[_a];
                            var newPointer = pointer + '/' + this.escape(key);
                            this.forEachDeep(object[key], fn, bottomUp, newPointer, rootObject);
                        }
                    }
                    if (bottomUp) {
                        fn(object, pointer, rootObject);
                    }
                };
                /**
                 * 'forEachDeepCopy' function
                 *
                 * Similar to forEachDeep, but returns a copy of the original object, with
                 * the same keys and indexes, but with values replaced with the result of
                 * the iteratee function.
                 *
                 * //  { object } object - the initial object or array
                 * //  { (v: any, k?: string, o?: any, p?: any) => any } function - iteratee function
                 * //  { boolean = false } bottomUp - optional, set to TRUE to reverse direction
                 * //  { object = object } rootObject - optional, root object or array
                 * //  { string = '' } pointer - optional, JSON Pointer to object within rootObject
                 * // { object } - The copied object
                 */
                JsonPointer.forEachDeepCopy = function (object, fn, bottomUp, pointer, rootObject) {
                    if (fn === void 0) { fn = function (v) { return v; }; }
                    if (bottomUp === void 0) { bottomUp = false; }
                    if (pointer === void 0) { pointer = ''; }
                    if (rootObject === void 0) { rootObject = object; }
                    if (typeof fn !== 'function') {
                        console.error("forEachDeepCopy error: Iterator is not a function:", fn);
                        return null;
                    }
                    if (isObject(object) || isArray(object)) {
                        var newObject = isArray(object) ? object.slice() : Object.assign({}, object);
                        if (!bottomUp) {
                            newObject = fn(newObject, pointer, rootObject);
                        }
                        for (var _a = 0, _b = Object.keys(newObject); _a < _b.length; _a++) {
                            var key = _b[_a];
                            var newPointer = pointer + '/' + this.escape(key);
                            newObject[key] = this.forEachDeepCopy(newObject[key], fn, bottomUp, newPointer, rootObject);
                        }
                        if (bottomUp) {
                            newObject = fn(newObject, pointer, rootObject);
                        }
                        return newObject;
                    }
                    else {
                        return fn(object, pointer, rootObject);
                    }
                };
                /**
                 * 'escape' function
                 *
                 * Escapes a string reference key
                 *
                 * //  { string } key - string key to escape
                 * // { string } - escaped key
                 */
                JsonPointer.escape = function (key) {
                    var escaped = key.toString().replace(/~/g, '~0').replace(/\//g, '~1');
                    return escaped;
                };
                /**
                 * 'unescape' function
                 *
                 * Unescapes a string reference key
                 *
                 * //  { string } key - string key to unescape
                 * // { string } - unescaped key
                 */
                JsonPointer.unescape = function (key) {
                    var unescaped = key.toString().replace(/~1/g, '/').replace(/~0/g, '~');
                    return unescaped;
                };
                /**
                 * 'parse' function
                 *
                 * Converts a string JSON Pointer into a array of keys
                 * (if input is already an an array of keys, it is returned unchanged)
                 *
                 * //  { Pointer } pointer - JSON Pointer (string or array)
                 * //  { boolean = false } errors - Show error if invalid pointer?
                 * // { string[] } - JSON Pointer array of keys
                 */
                JsonPointer.parse = function (pointer, errors) {
                    if (errors === void 0) { errors = false; }
                    if (!this.isJsonPointer(pointer)) {
                        if (errors) {
                            console.error("parse error: Invalid JSON Pointer: " + pointer);
                        }
                        return null;
                    }
                    if (isArray(pointer)) {
                        return pointer;
                    }
                    if (typeof pointer === 'string') {
                        if (pointer[0] === '#') {
                            pointer = pointer.slice(1);
                        }
                        if (pointer === '' || pointer === '/') {
                            return [];
                        }
                        return pointer.slice(1).split('/').map(this.unescape);
                    }
                };
                /**
                 * 'compile' function
                 *
                 * Converts an array of keys into a JSON Pointer string
                 * (if input is already a string, it is normalized and returned)
                 *
                 * The optional second parameter is a default which will replace any empty keys.
                 *
                 * //  { Pointer } pointer - JSON Pointer (string or array)
                 * //  { string | number = '' } defaultValue - Default value
                 * //  { boolean = false } errors - Show error if invalid pointer?
                 * // { string } - JSON Pointer string
                 */
                JsonPointer.compile = function (pointer, defaultValue, errors) {
                    var _this_1 = this;
                    if (defaultValue === void 0) { defaultValue = ''; }
                    if (errors === void 0) { errors = false; }
                    if (pointer === '#') {
                        return '';
                    }
                    if (!this.isJsonPointer(pointer)) {
                        if (errors) {
                            console.error("compile error: Invalid JSON Pointer: " + pointer);
                        }
                        return null;
                    }
                    if (isArray(pointer)) {
                        if (pointer.length === 0) {
                            return '';
                        }
                        return '/' + pointer.map(function (key) { return key === '' ? defaultValue : _this_1.escape(key); }).join('/');
                    }
                    if (typeof pointer === 'string') {
                        if (pointer[0] === '#') {
                            pointer = pointer.slice(1);
                        }
                        return pointer;
                    }
                };
                /**
                 * 'toKey' function
                 *
                 * Extracts name of the final key from a JSON Pointer.
                 *
                 * //  { Pointer } pointer - JSON Pointer (string or array)
                 * //  { boolean = false } errors - Show error if invalid pointer?
                 * // { string } - the extracted key
                 */
                JsonPointer.toKey = function (pointer, errors) {
                    if (errors === void 0) { errors = false; }
                    var keyArray = this.parse(pointer, errors);
                    if (keyArray === null) {
                        return null;
                    }
                    if (!keyArray.length) {
                        return '';
                    }
                    return keyArray[keyArray.length - 1];
                };
                /**
                 * 'isJsonPointer' function
                 *
                 * Checks a string or array value to determine if it is a valid JSON Pointer.
                 * Returns true if a string is empty, or starts with '/' or '#/'.
                 * Returns true if an array contains only string values.
                 *
                 * //   value - value to check
                 * // { boolean } - true if value is a valid JSON Pointer, otherwise false
                 */
                JsonPointer.isJsonPointer = function (value) {
                    if (isArray(value)) {
                        return value.every(function (key) { return typeof key === 'string'; });
                    }
                    else if (isString(value)) {
                        if (value === '' || value === '#') {
                            return true;
                        }
                        if (value[0] === '/' || value.slice(0, 2) === '#/') {
                            return !/(~[^01]|~$)/g.test(value);
                        }
                    }
                    return false;
                };
                /**
                 * 'isSubPointer' function
                 *
                 * Checks whether one JSON Pointer is a subset of another.
                 *
                 * //  { Pointer } shortPointer - potential subset JSON Pointer
                 * //  { Pointer } longPointer - potential superset JSON Pointer
                 * //  { boolean = false } trueIfMatching - return true if pointers match?
                 * //  { boolean = false } errors - Show error if invalid pointer?
                 * // { boolean } - true if shortPointer is a subset of longPointer, false if not
                 */
                JsonPointer.isSubPointer = function (shortPointer, longPointer, trueIfMatching, errors) {
                    if (trueIfMatching === void 0) { trueIfMatching = false; }
                    if (errors === void 0) { errors = false; }
                    if (!this.isJsonPointer(shortPointer) || !this.isJsonPointer(longPointer)) {
                        if (errors) {
                            var invalid = '';
                            if (!this.isJsonPointer(shortPointer)) {
                                invalid += " 1: " + shortPointer;
                            }
                            if (!this.isJsonPointer(longPointer)) {
                                invalid += " 2: " + longPointer;
                            }
                            console.error("isSubPointer error: Invalid JSON Pointer " + invalid);
                        }
                        return;
                    }
                    shortPointer = this.compile(shortPointer, '', errors);
                    longPointer = this.compile(longPointer, '', errors);
                    return shortPointer === longPointer ? trueIfMatching :
                        shortPointer + "/" === longPointer.slice(0, shortPointer.length + 1);
                };
                /**
                 * 'toIndexedPointer' function
                 *
                 * Merges an array of numeric indexes and a generic pointer to create an
                 * indexed pointer for a specific item.
                 *
                 * For example, merging the generic pointer '/foo/-/bar/-/baz' and
                 * the array [4, 2] would result in the indexed pointer '/foo/4/bar/2/baz'
                 *
                 *
                 * //  { Pointer } genericPointer - The generic pointer
                 * //  { number[] } indexArray - The array of numeric indexes
                 * //  { Map<string, number> } arrayMap - An optional array map
                 * // { string } - The merged pointer with indexes
                 */
                JsonPointer.toIndexedPointer = function (genericPointer, indexArray, arrayMap) {
                    if (arrayMap === void 0) { arrayMap = null; }
                    if (this.isJsonPointer(genericPointer) && isArray(indexArray)) {
                        var indexedPointer_1 = this.compile(genericPointer);
                        if (isMap(arrayMap)) {
                            var arrayIndex_1 = 0;
                            return indexedPointer_1.replace(/\/\-(?=\/|$)/g, function (key, stringIndex) { return arrayMap.has(indexedPointer_1.slice(0, stringIndex)) ?
                                '/' + indexArray[arrayIndex_1++] : key; });
                        }
                        else {
                            for (var _a = 0, indexArray_1 = indexArray; _a < indexArray_1.length; _a++) {
                                var pointerIndex = indexArray_1[_a];
                                indexedPointer_1 = indexedPointer_1.replace('/-', '/' + pointerIndex);
                            }
                            return indexedPointer_1;
                        }
                    }
                    if (!this.isJsonPointer(genericPointer)) {
                        console.error("toIndexedPointer error: Invalid JSON Pointer: " + genericPointer);
                    }
                    if (!isArray(indexArray)) {
                        console.error("toIndexedPointer error: Invalid indexArray: " + indexArray);
                    }
                };
                /**
                 * 'toGenericPointer' function
                 *
                 * Compares an indexed pointer to an array map and removes list array
                 * indexes (but leaves tuple arrray indexes and all object keys, including
                 * numeric keys) to create a generic pointer.
                 *
                 * For example, using the indexed pointer '/foo/1/bar/2/baz/3' and
                 * the arrayMap [['/foo', 0], ['/foo/-/bar', 3], ['/foo/-/bar/-/baz', 0]]
                 * would result in the generic pointer '/foo/-/bar/2/baz/-'
                 * Using the indexed pointer '/foo/1/bar/4/baz/3' and the same arrayMap
                 * would result in the generic pointer '/foo/-/bar/-/baz/-'
                 * (the bar array has 3 tuple items, so index 2 is retained, but 4 is removed)
                 *
                 * The structure of the arrayMap is: [['path to array', number of tuple items]...]
                 *
                 *
                 * //  { Pointer } indexedPointer - The indexed pointer (array or string)
                 * //  { Map<string, number> } arrayMap - The optional array map (for preserving tuple indexes)
                 * // { string } - The generic pointer with indexes removed
                 */
                JsonPointer.toGenericPointer = function (indexedPointer, arrayMap) {
                    if (arrayMap === void 0) { arrayMap = new Map(); }
                    if (this.isJsonPointer(indexedPointer) && isMap(arrayMap)) {
                        var pointerArray = this.parse(indexedPointer);
                        for (var i = 1; i < pointerArray.length; i++) {
                            var subPointer = this.compile(pointerArray.slice(0, i));
                            if (arrayMap.has(subPointer) &&
                                arrayMap.get(subPointer) <= +pointerArray[i]) {
                                pointerArray[i] = '-';
                            }
                        }
                        return this.compile(pointerArray);
                    }
                    if (!this.isJsonPointer(indexedPointer)) {
                        console.error("toGenericPointer error: invalid JSON Pointer: " + indexedPointer);
                    }
                    if (!isMap(arrayMap)) {
                        console.error("toGenericPointer error: invalid arrayMap: " + arrayMap);
                    }
                };
                /**
                 * 'toControlPointer' function
                 *
                 * Accepts a JSON Pointer for a data object and returns a JSON Pointer for the
                 * matching control in an Angular FormGroup.
                 *
                 * //  { Pointer } dataPointer - JSON Pointer (string or array) to a data object
                 * //  { FormGroup } formGroup - Angular FormGroup to get value from
                 * //  { boolean = false } controlMustExist - Only return if control exists?
                 * // { Pointer } - JSON Pointer (string) to the formGroup object
                 */
                JsonPointer.toControlPointer = function (dataPointer, formGroup, controlMustExist) {
                    if (controlMustExist === void 0) { controlMustExist = false; }
                    var dataPointerArray = this.parse(dataPointer);
                    var controlPointerArray = [];
                    var subGroup = formGroup;
                    if (dataPointerArray !== null) {
                        for (var _a = 0, dataPointerArray_1 = dataPointerArray; _a < dataPointerArray_1.length; _a++) {
                            var key = dataPointerArray_1[_a];
                            if (hasOwn(subGroup, 'controls')) {
                                controlPointerArray.push('controls');
                                subGroup = subGroup.controls;
                            }
                            if (isArray(subGroup) && (key === '-')) {
                                controlPointerArray.push((subGroup.length - 1).toString());
                                subGroup = subGroup[subGroup.length - 1];
                            }
                            else if (hasOwn(subGroup, key)) {
                                controlPointerArray.push(key);
                                subGroup = subGroup[key];
                            }
                            else if (controlMustExist) {
                                console.error("toControlPointer error: Unable to find \"" + key + "\" item in FormGroup.");
                                console.error(dataPointer);
                                console.error(formGroup);
                                return;
                            }
                            else {
                                controlPointerArray.push(key);
                                subGroup = { controls: {} };
                            }
                        }
                        return this.compile(controlPointerArray);
                    }
                    console.error("toControlPointer error: Invalid JSON Pointer: " + dataPointer);
                };
                /**
                 * 'toSchemaPointer' function
                 *
                 * Accepts a JSON Pointer to a value inside a data object and a JSON schema
                 * for that object.
                 *
                 * Returns a Pointer to the sub-schema for the value inside the object's schema.
                 *
                 * //  { Pointer } dataPointer - JSON Pointer (string or array) to an object
                 * //   schema - JSON schema for the object
                 * // { Pointer } - JSON Pointer (string) to the object's schema
                 */
                JsonPointer.toSchemaPointer = function (dataPointer, schema) {
                    if (this.isJsonPointer(dataPointer) && typeof schema === 'object') {
                        var pointerArray = this.parse(dataPointer);
                        if (!pointerArray.length) {
                            return '';
                        }
                        var firstKey = pointerArray.shift();
                        if (schema.type === 'object' || schema.properties || schema.additionalProperties) {
                            if ((schema.properties || {})[firstKey]) {
                                return "/properties/" + this.escape(firstKey) +
                                    this.toSchemaPointer(pointerArray, schema.properties[firstKey]);
                            }
                            else if (schema.additionalProperties) {
                                return '/additionalProperties' +
                                    this.toSchemaPointer(pointerArray, schema.additionalProperties);
                            }
                        }
                        if ((schema.type === 'array' || schema.items) &&
                            (isNumber(firstKey) || firstKey === '-' || firstKey === '')) {
                            var arrayItem = firstKey === '-' || firstKey === '' ? 0 : +firstKey;
                            if (isArray(schema.items)) {
                                if (arrayItem < schema.items.length) {
                                    return '/items/' + arrayItem +
                                        this.toSchemaPointer(pointerArray, schema.items[arrayItem]);
                                }
                                else if (schema.additionalItems) {
                                    return '/additionalItems' +
                                        this.toSchemaPointer(pointerArray, schema.additionalItems);
                                }
                            }
                            else if (isObject(schema.items)) {
                                return '/items' + this.toSchemaPointer(pointerArray, schema.items);
                            }
                            else if (isObject(schema.additionalItems)) {
                                return '/additionalItems' +
                                    this.toSchemaPointer(pointerArray, schema.additionalItems);
                            }
                        }
                        console.error("toSchemaPointer error: Data pointer " + dataPointer + " " +
                            ("not compatible with schema " + schema));
                        return null;
                    }
                    if (!this.isJsonPointer(dataPointer)) {
                        console.error("toSchemaPointer error: Invalid JSON Pointer: " + dataPointer);
                    }
                    if (typeof schema !== 'object') {
                        console.error("toSchemaPointer error: Invalid JSON Schema: " + schema);
                    }
                    return null;
                };
                /**
                 * 'toDataPointer' function
                 *
                 * Accepts a JSON Pointer to a sub-schema inside a JSON schema and the schema.
                 *
                 * If possible, returns a generic Pointer to the corresponding value inside
                 * the data object described by the JSON schema.
                 *
                 * Returns null if the sub-schema is in an ambiguous location (such as
                 * definitions or additionalProperties) where the corresponding value
                 * location cannot be determined.
                 *
                 * //  { Pointer } schemaPointer - JSON Pointer (string or array) to a JSON schema
                 * //   schema - the JSON schema
                 * //  { boolean = false } errors - Show errors?
                 * // { Pointer } - JSON Pointer (string) to the value in the data object
                 */
                JsonPointer.toDataPointer = function (schemaPointer, schema, errors) {
                    if (errors === void 0) { errors = false; }
                    if (this.isJsonPointer(schemaPointer) && typeof schema === 'object' &&
                        this.has(schema, schemaPointer)) {
                        var pointerArray = this.parse(schemaPointer);
                        if (!pointerArray.length) {
                            return '';
                        }
                        var firstKey = pointerArray.shift();
                        if (firstKey === 'properties' ||
                            (firstKey === 'items' && isArray(schema.items))) {
                            var secondKey = pointerArray.shift();
                            var pointerSuffix = this.toDataPointer(pointerArray, schema[firstKey][secondKey]);
                            return pointerSuffix === null ? null : '/' + secondKey + pointerSuffix;
                        }
                        else if (firstKey === 'additionalItems' ||
                            (firstKey === 'items' && isObject(schema.items))) {
                            var pointerSuffix = this.toDataPointer(pointerArray, schema[firstKey]);
                            return pointerSuffix === null ? null : '/-' + pointerSuffix;
                        }
                        else if (['allOf', 'anyOf', 'oneOf'].includes(firstKey)) {
                            var secondKey = pointerArray.shift();
                            return this.toDataPointer(pointerArray, schema[firstKey][secondKey]);
                        }
                        else if (firstKey === 'not') {
                            return this.toDataPointer(pointerArray, schema[firstKey]);
                        }
                        else if (['contains', 'definitions', 'dependencies', 'additionalItems',
                            'additionalProperties', 'patternProperties', 'propertyNames'].includes(firstKey)) {
                            if (errors) {
                                console.error("toDataPointer error: Ambiguous location");
                            }
                        }
                        return '';
                    }
                    if (errors) {
                        if (!this.isJsonPointer(schemaPointer)) {
                            console.error("toDataPointer error: Invalid JSON Pointer: " + schemaPointer);
                        }
                        if (typeof schema !== 'object') {
                            console.error("toDataPointer error: Invalid JSON Schema: " + schema);
                        }
                        if (typeof schema !== 'object') {
                            console.error("toDataPointer error: Pointer " + schemaPointer + " invalid for Schema: " + schema);
                        }
                    }
                    return null;
                };
                /**
                 * 'parseObjectPath' function
                 *
                 * Parses a JavaScript object path into an array of keys, which
                 * can then be passed to compile() to convert into a string JSON Pointer.
                 *
                 * Based on mike-marcacci's excellent objectpath parse function:
                 * https://github.com/mike-marcacci/objectpath
                 *
                 * //  { Pointer } path - The object path to parse
                 * // { string[] } - The resulting array of keys
                 */
                JsonPointer.parseObjectPath = function (path) {
                    if (isArray(path)) {
                        return path;
                    }
                    if (this.isJsonPointer(path)) {
                        return this.parse(path);
                    }
                    if (typeof path === 'string') {
                        var index = 0;
                        var parts = [];
                        while (index < path.length) {
                            var nextDot = path.indexOf('.', index);
                            var nextOB = path.indexOf('[', index); // next open bracket
                            if (nextDot === -1 && nextOB === -1) { // last item
                                parts.push(path.slice(index));
                                index = path.length;
                            }
                            else if (nextDot !== -1 && (nextDot < nextOB || nextOB === -1)) { // dot notation
                                parts.push(path.slice(index, nextDot));
                                index = nextDot + 1;
                            }
                            else { // bracket notation
                                if (nextOB > index) {
                                    parts.push(path.slice(index, nextOB));
                                    index = nextOB;
                                }
                                var quote = path.charAt(nextOB + 1);
                                if (quote === '"' || quote === '\'') { // enclosing quotes
                                    var nextCB = path.indexOf(quote + ']', nextOB); // next close bracket
                                    while (nextCB !== -1 && path.charAt(nextCB - 1) === '\\') {
                                        nextCB = path.indexOf(quote + ']', nextCB + 2);
                                    }
                                    if (nextCB === -1) {
                                        nextCB = path.length;
                                    }
                                    parts.push(path.slice(index + 2, nextCB)
                                        .replace(new RegExp('\\' + quote, 'g'), quote));
                                    index = nextCB + 2;
                                }
                                else { // no enclosing quotes
                                    var nextCB = path.indexOf(']', nextOB); // next close bracket
                                    if (nextCB === -1) {
                                        nextCB = path.length;
                                    }
                                    parts.push(path.slice(index + 1, nextCB));
                                    index = nextCB + 1;
                                }
                                if (path.charAt(index) === '.') {
                                    index++;
                                }
                            }
                        }
                        return parts;
                    }
                    console.error('parseObjectPath error: Input object path must be a string.');
                };
                return JsonPointer;
            }());
            JsonPointer = JsonPointer_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Injectable"])()
            ], JsonPointer);
            /**
             * 'mergeSchemas' function
             *
             * Merges multiple JSON schemas into a single schema with combined rules.
             *
             * If able to logically merge properties from all schemas,
             * returns a single schema object containing all merged properties.
             *
             * Example: ({ a: b, max: 1 }, { c: d, max: 2 }) => { a: b, c: d, max: 1 }
             *
             * If unable to logically merge, returns an allOf schema object containing
             * an array of the original schemas;
             *
             * Example: ({ a: b }, { a: d }) => { allOf: [ { a: b }, { a: d } ] }
             *
             * //   schemas - one or more input schemas
             * //  - merged schema
             */
            function mergeSchemas() {
                var schemas = [];
                for (var _a = 0; _a < arguments.length; _a++) {
                    schemas[_a] = arguments[_a];
                }
                schemas = schemas.filter(function (schema) { return !isEmpty(schema); });
                if (schemas.some(function (schema) { return !isObject(schema); })) {
                    return null;
                }
                var combinedSchema = {};
                for (var _b = 0, schemas_1 = schemas; _b < schemas_1.length; _b++) {
                    var schema = schemas_1[_b];
                    var _loop_2 = function (key) {
                        var combinedValue = combinedSchema[key];
                        var schemaValue = schema[key];
                        if (!hasOwn(combinedSchema, key) || Object(lodash_es_isEqual__WEBPACK_IMPORTED_MODULE_9__["default"])(combinedValue, schemaValue)) {
                            combinedSchema[key] = schemaValue;
                        }
                        else {
                            switch (key) {
                                case 'allOf':
                                    // Combine all items from both arrays
                                    if (isArray(combinedValue) && isArray(schemaValue)) {
                                        combinedSchema.allOf = mergeSchemas.apply(void 0, combinedValue.concat(schemaValue));
                                    }
                                    else {
                                        return { value: { allOf: schemas.slice() } };
                                    }
                                    break;
                                case 'additionalItems':
                                case 'additionalProperties':
                                case 'contains':
                                case 'propertyNames':
                                    // Merge schema objects
                                    if (isObject(combinedValue) && isObject(schemaValue)) {
                                        combinedSchema[key] = mergeSchemas(combinedValue, schemaValue);
                                        // additionalProperties == false in any schema overrides all other values
                                    }
                                    else if (key === 'additionalProperties' &&
                                        (combinedValue === false || schemaValue === false)) {
                                        combinedSchema.combinedSchema = false;
                                    }
                                    else {
                                        return { value: { allOf: schemas.slice() } };
                                    }
                                    break;
                                case 'anyOf':
                                case 'oneOf':
                                case 'enum':
                                    // Keep only items that appear in both arrays
                                    if (isArray(combinedValue) && isArray(schemaValue)) {
                                        combinedSchema[key] = combinedValue.filter(function (item1) { return schemaValue.findIndex(function (item2) { return Object(lodash_es_isEqual__WEBPACK_IMPORTED_MODULE_9__["default"])(item1, item2); }) > -1; });
                                        if (!combinedSchema[key].length) {
                                            return { value: { allOf: schemas.slice() } };
                                        }
                                    }
                                    else {
                                        return { value: { allOf: schemas.slice() } };
                                    }
                                    break;
                                case 'definitions':
                                    // Combine keys from both objects
                                    if (isObject(combinedValue) && isObject(schemaValue)) {
                                        var combinedObject = Object.assign({}, combinedValue);
                                        for (var _a = 0, _b = Object.keys(schemaValue); _a < _b.length; _a++) {
                                            var subKey = _b[_a];
                                            if (!hasOwn(combinedObject, subKey) ||
                                                Object(lodash_es_isEqual__WEBPACK_IMPORTED_MODULE_9__["default"])(combinedObject[subKey], schemaValue[subKey])) {
                                                combinedObject[subKey] = schemaValue[subKey];
                                                // Don't combine matching keys with different values
                                            }
                                            else {
                                                return { value: { allOf: schemas.slice() } };
                                            }
                                        }
                                        combinedSchema.definitions = combinedObject;
                                    }
                                    else {
                                        return { value: { allOf: schemas.slice() } };
                                    }
                                    break;
                                case 'dependencies':
                                    // Combine all keys from both objects
                                    // and merge schemas on matching keys,
                                    // converting from arrays to objects if necessary
                                    if (isObject(combinedValue) && isObject(schemaValue)) {
                                        var combinedObject = Object.assign({}, combinedValue);
                                        for (var _f = 0, _g = Object.keys(schemaValue); _f < _g.length; _f++) {
                                            var subKey = _g[_f];
                                            if (!hasOwn(combinedObject, subKey) ||
                                                Object(lodash_es_isEqual__WEBPACK_IMPORTED_MODULE_9__["default"])(combinedObject[subKey], schemaValue[subKey])) {
                                                combinedObject[subKey] = schemaValue[subKey];
                                                // If both keys are arrays, include all items from both arrays,
                                                // excluding duplicates
                                            }
                                            else if (isArray(schemaValue[subKey]) && isArray(combinedObject[subKey])) {
                                                combinedObject[subKey] = uniqueItems.apply(void 0, combinedObject[subKey].concat(schemaValue[subKey]));
                                                // If either key is an object, merge the schemas
                                            }
                                            else if ((isArray(schemaValue[subKey]) || isObject(schemaValue[subKey])) &&
                                                (isArray(combinedObject[subKey]) || isObject(combinedObject[subKey]))) {
                                                // If either key is an array, convert it to an object first
                                                var required = isArray(combinedSchema.required) ?
                                                    combinedSchema.required : [];
                                                var combinedDependency = isArray(combinedObject[subKey]) ?
                                                    { required: uniqueItems.apply(void 0, required.concat([combinedObject[subKey]])) } :
                                                    combinedObject[subKey];
                                                var schemaDependency = isArray(schemaValue[subKey]) ?
                                                    { required: uniqueItems.apply(void 0, required.concat([schemaValue[subKey]])) } :
                                                    schemaValue[subKey];
                                                combinedObject[subKey] =
                                                    mergeSchemas(combinedDependency, schemaDependency);
                                            }
                                            else {
                                                return { value: { allOf: schemas.slice() } };
                                            }
                                        }
                                        combinedSchema.dependencies = combinedObject;
                                    }
                                    else {
                                        return { value: { allOf: schemas.slice() } };
                                    }
                                    break;
                                case 'items':
                                    // If arrays, keep only items that appear in both arrays
                                    if (isArray(combinedValue) && isArray(schemaValue)) {
                                        combinedSchema.items = combinedValue.filter(function (item1) { return schemaValue.findIndex(function (item2) { return Object(lodash_es_isEqual__WEBPACK_IMPORTED_MODULE_9__["default"])(item1, item2); }) > -1; });
                                        if (!combinedSchema.items.length) {
                                            return { value: { allOf: schemas.slice() } };
                                        }
                                        // If both keys are objects, merge them
                                    }
                                    else if (isObject(combinedValue) && isObject(schemaValue)) {
                                        combinedSchema.items = mergeSchemas(combinedValue, schemaValue);
                                        // If object + array, combine object with each array item
                                    }
                                    else if (isArray(combinedValue) && isObject(schemaValue)) {
                                        combinedSchema.items =
                                            combinedValue.map(function (item) { return mergeSchemas(item, schemaValue); });
                                    }
                                    else if (isObject(combinedValue) && isArray(schemaValue)) {
                                        combinedSchema.items =
                                            schemaValue.map(function (item) { return mergeSchemas(item, combinedValue); });
                                    }
                                    else {
                                        return { value: { allOf: schemas.slice() } };
                                    }
                                    break;
                                case 'multipleOf':
                                    // TODO: Adjust to correctly handle decimal values
                                    // If numbers, set to least common multiple
                                    if (isNumber(combinedValue) && isNumber(schemaValue)) {
                                        var gcd_1 = function (x, y) { return !y ? x : gcd_1(y, x % y); };
                                        var lcm = function (x, y) { return (x * y) / gcd_1(x, y); };
                                        combinedSchema.multipleOf = lcm(combinedValue, schemaValue);
                                    }
                                    else {
                                        return { value: { allOf: schemas.slice() } };
                                    }
                                    break;
                                case 'maximum':
                                case 'exclusiveMaximum':
                                case 'maxLength':
                                case 'maxItems':
                                case 'maxProperties':
                                    // If numbers, set to lowest value
                                    if (isNumber(combinedValue) && isNumber(schemaValue)) {
                                        combinedSchema[key] = Math.min(combinedValue, schemaValue);
                                    }
                                    else {
                                        return { value: { allOf: schemas.slice() } };
                                    }
                                    break;
                                case 'minimum':
                                case 'exclusiveMinimum':
                                case 'minLength':
                                case 'minItems':
                                case 'minProperties':
                                    // If numbers, set to highest value
                                    if (isNumber(combinedValue) && isNumber(schemaValue)) {
                                        combinedSchema[key] = Math.max(combinedValue, schemaValue);
                                    }
                                    else {
                                        return { value: { allOf: schemas.slice() } };
                                    }
                                    break;
                                case 'not':
                                    // Combine not values into anyOf array
                                    if (isObject(combinedValue) && isObject(schemaValue)) {
                                        var notAnyOf = [combinedValue, schemaValue]
                                            .reduce(function (notAnyOfArray, notSchema) { return isArray(notSchema.anyOf) &&
                                            Object.keys(notSchema).length === 1 ? notAnyOfArray.concat(notSchema.anyOf) : notAnyOfArray.concat([notSchema]); }, []);
                                        // TODO: Remove duplicate items from array
                                        combinedSchema.not = { anyOf: notAnyOf };
                                    }
                                    else {
                                        return { value: { allOf: schemas.slice() } };
                                    }
                                    break;
                                case 'patternProperties':
                                    // Combine all keys from both objects
                                    // and merge schemas on matching keys
                                    if (isObject(combinedValue) && isObject(schemaValue)) {
                                        var combinedObject = Object.assign({}, combinedValue);
                                        for (var _h = 0, _j = Object.keys(schemaValue); _h < _j.length; _h++) {
                                            var subKey = _j[_h];
                                            if (!hasOwn(combinedObject, subKey) ||
                                                Object(lodash_es_isEqual__WEBPACK_IMPORTED_MODULE_9__["default"])(combinedObject[subKey], schemaValue[subKey])) {
                                                combinedObject[subKey] = schemaValue[subKey];
                                                // If both keys are objects, merge them
                                            }
                                            else if (isObject(schemaValue[subKey]) && isObject(combinedObject[subKey])) {
                                                combinedObject[subKey] =
                                                    mergeSchemas(combinedObject[subKey], schemaValue[subKey]);
                                            }
                                            else {
                                                return { value: { allOf: schemas.slice() } };
                                            }
                                        }
                                        combinedSchema.patternProperties = combinedObject;
                                    }
                                    else {
                                        return { value: { allOf: schemas.slice() } };
                                    }
                                    break;
                                case 'properties':
                                    // Combine all keys from both objects
                                    // unless additionalProperties === false
                                    // and merge schemas on matching keys
                                    if (isObject(combinedValue) && isObject(schemaValue)) {
                                        var combinedObject_1 = Object.assign({}, combinedValue);
                                        // If new schema has additionalProperties,
                                        // merge or remove non-matching property keys in combined schema
                                        if (hasOwn(schemaValue, 'additionalProperties')) {
                                            Object.keys(combinedValue)
                                                .filter(function (combinedKey) { return !Object.keys(schemaValue).includes(combinedKey); })
                                                .forEach(function (nonMatchingKey) {
                                                if (schemaValue.additionalProperties === false) {
                                                    delete combinedObject_1[nonMatchingKey];
                                                }
                                                else if (isObject(schemaValue.additionalProperties)) {
                                                    combinedObject_1[nonMatchingKey] = mergeSchemas(combinedObject_1[nonMatchingKey], schemaValue.additionalProperties);
                                                }
                                            });
                                        }
                                        for (var _k = 0, _l = Object.keys(schemaValue); _k < _l.length; _k++) {
                                            var subKey = _l[_k];
                                            if (Object(lodash_es_isEqual__WEBPACK_IMPORTED_MODULE_9__["default"])(combinedObject_1[subKey], schemaValue[subKey]) || (!hasOwn(combinedObject_1, subKey) &&
                                                !hasOwn(combinedObject_1, 'additionalProperties'))) {
                                                combinedObject_1[subKey] = schemaValue[subKey];
                                                // If combined schema has additionalProperties,
                                                // merge or ignore non-matching property keys in new schema
                                            }
                                            else if (!hasOwn(combinedObject_1, subKey) &&
                                                hasOwn(combinedObject_1, 'additionalProperties')) {
                                                // If combinedObject.additionalProperties === false,
                                                // do nothing (don't set key)
                                                // If additionalProperties is object, merge with new key
                                                if (isObject(combinedObject_1.additionalProperties)) {
                                                    combinedObject_1[subKey] = mergeSchemas(combinedObject_1.additionalProperties, schemaValue[subKey]);
                                                }
                                                // If both keys are objects, merge them
                                            }
                                            else if (isObject(schemaValue[subKey]) &&
                                                isObject(combinedObject_1[subKey])) {
                                                combinedObject_1[subKey] =
                                                    mergeSchemas(combinedObject_1[subKey], schemaValue[subKey]);
                                            }
                                            else {
                                                return { value: { allOf: schemas.slice() } };
                                            }
                                        }
                                        combinedSchema.properties = combinedObject_1;
                                    }
                                    else {
                                        return { value: { allOf: schemas.slice() } };
                                    }
                                    break;
                                case 'required':
                                    // If arrays, include all items from both arrays, excluding duplicates
                                    if (isArray(combinedValue) && isArray(schemaValue)) {
                                        combinedSchema.required = uniqueItems.apply(void 0, combinedValue.concat(schemaValue));
                                        // If booleans, aet true if either true
                                    }
                                    else if (typeof schemaValue === 'boolean' &&
                                        typeof combinedValue === 'boolean') {
                                        combinedSchema.required = !!combinedValue || !!schemaValue;
                                    }
                                    else {
                                        return { value: { allOf: schemas.slice() } };
                                    }
                                    break;
                                case '$schema':
                                case '$id':
                                case 'id':
                                    // Don't combine these keys
                                    break;
                                case 'title':
                                case 'description':
                                case '$comment':
                                    // Return the last value, overwriting any previous one
                                    // These properties are not used for validation, so conflicts don't matter
                                    combinedSchema[key] = schemaValue;
                                    break;
                                case 'type':
                                    if ((isArray(schemaValue) || isString(schemaValue)) &&
                                        (isArray(combinedValue) || isString(combinedValue))) {
                                        var combinedTypes = commonItems(combinedValue, schemaValue);
                                        if (!combinedTypes.length) {
                                            return { value: { allOf: schemas.slice() } };
                                        }
                                        combinedSchema.type = combinedTypes.length > 1 ? combinedTypes : combinedTypes[0];
                                    }
                                    else {
                                        return { value: { allOf: schemas.slice() } };
                                    }
                                    break;
                                case 'uniqueItems':
                                    // Set true if either true
                                    combinedSchema.uniqueItems = !!combinedValue || !!schemaValue;
                                    break;
                                default: return { value: { allOf: schemas.slice() } };
                            }
                        }
                    };
                    for (var _f = 0, _g = Object.keys(schema); _f < _g.length; _f++) {
                        var key = _g[_f];
                        var state_2 = _loop_2(key);
                        if (typeof state_2 === "object")
                            return state_2.value;
                    }
                }
                return combinedSchema;
            }
            /**
             * JSON Schema function library:
             *
             * buildSchemaFromLayout:   TODO: Write this function
             *
             * buildSchemaFromData:
             *
             * getFromSchema:
             *
             * removeRecursiveReferences:
             *
             * getInputType:
             *
             * checkInlineType:
             *
             * isInputRequired:
             *
             * updateInputOptions:
             *
             * getTitleMapFromOneOf:
             *
             * getControlValidators:
             *
             * resolveSchemaReferences:
             *
             * getSubSchema:
             *
             * combineAllOf:
             *
             * fixRequiredArrayProperties:
             */
            /**
             * 'buildSchemaFromLayout' function
             *
             * TODO: Build a JSON Schema from a JSON Form layout
             *
             * //   layout - The JSON Form layout
             * //  - The new JSON Schema
             */
            function buildSchemaFromLayout(layout) {
                return;
                // let newSchema: any = { };
                // const walkLayout = (layoutItems: any[], callback: Function): any[] => {
                //   let returnArray: any[] = [];
                //   for (let layoutItem of layoutItems) {
                //     const returnItem: any = callback(layoutItem);
                //     if (returnItem) { returnArray = returnArray.concat(callback(layoutItem)); }
                //     if (layoutItem.items) {
                //       returnArray = returnArray.concat(walkLayout(layoutItem.items, callback));
                //     }
                //   }
                //   return returnArray;
                // };
                // walkLayout(layout, layoutItem => {
                //   let itemKey: string;
                //   if (typeof layoutItem === 'string') {
                //     itemKey = layoutItem;
                //   } else if (layoutItem.key) {
                //     itemKey = layoutItem.key;
                //   }
                //   if (!itemKey) { return; }
                //   //
                // });
            }
            /**
             * 'buildSchemaFromData' function
             *
             * Build a JSON Schema from a data object
             *
             * //   data - The data object
             * //  { boolean = false } requireAllFields - Require all fields?
             * //  { boolean = true } isRoot - is root
             * //  - The new JSON Schema
             */
            function buildSchemaFromData(data, requireAllFields, isRoot) {
                if (requireAllFields === void 0) { requireAllFields = false; }
                if (isRoot === void 0) { isRoot = true; }
                var newSchema = {};
                var getFieldType = function (value) {
                    var fieldType = getType(value, 'strict');
                    return { integer: 'number', null: 'string' }[fieldType] || fieldType;
                };
                var buildSubSchema = function (value) { return buildSchemaFromData(value, requireAllFields, false); };
                if (isRoot) {
                    newSchema.$schema = 'http://json-schema.org/draft-06/schema#';
                }
                newSchema.type = getFieldType(data);
                if (newSchema.type === 'object') {
                    newSchema.properties = {};
                    if (requireAllFields) {
                        newSchema.required = [];
                    }
                    for (var _a = 0, _b = Object.keys(data); _a < _b.length; _a++) {
                        var key = _b[_a];
                        newSchema.properties[key] = buildSubSchema(data[key]);
                        if (requireAllFields) {
                            newSchema.required.push(key);
                        }
                    }
                }
                else if (newSchema.type === 'array') {
                    newSchema.items = data.map(buildSubSchema);
                    // If all items are the same type, use an object for items instead of an array
                    if ((new Set(data.map(getFieldType))).size === 1) {
                        newSchema.items = newSchema.items.reduce(function (a, b) { return (Object.assign({}, a, b)); }, {});
                    }
                    if (requireAllFields) {
                        newSchema.minItems = 1;
                    }
                }
                return newSchema;
            }
            /**
             * 'getFromSchema' function
             *
             * Uses a JSON Pointer for a value within a data object to retrieve
             * the schema for that value within schema for the data object.
             *
             * The optional third parameter can also be set to return something else:
             * 'schema' (default): the schema for the value indicated by the data pointer
             * 'parentSchema': the schema for the value's parent object or array
             * 'schemaPointer': a pointer to the value's schema within the object's schema
             * 'parentSchemaPointer': a pointer to the schema for the value's parent object or array
             *
             * //   schema - The schema to get the sub-schema from
             * //  { Pointer } dataPointer - JSON Pointer (string or array)
             * //  { string = 'schema' } returnType - what to return?
             * //  - The located sub-schema
             */
            function getFromSchema(schema, dataPointer, returnType) {
                if (returnType === void 0) { returnType = 'schema'; }
                var dataPointerArray = JsonPointer.parse(dataPointer);
                if (dataPointerArray === null) {
                    console.error("getFromSchema error: Invalid JSON Pointer: " + dataPointer);
                    return null;
                }
                var subSchema = schema;
                var schemaPointer = [];
                var length = dataPointerArray.length;
                if (returnType.slice(0, 6) === 'parent') {
                    dataPointerArray.length--;
                }
                for (var i = 0; i < length; ++i) {
                    var key = dataPointerArray[i];
                    var subSchemaFound = false;
                    if (typeof subSchema !== 'object') {
                        console.error("getFromSchema error: Unable to find \"" + key + "\" key in schema.");
                        console.error(schema);
                        console.error(dataPointer);
                        return null;
                    }
                    if (subSchema.type === 'array' && (!isNaN(key) || key === '-')) {
                        if (hasOwn(subSchema, 'items')) {
                            if (isObject(subSchema.items)) {
                                subSchemaFound = true;
                                subSchema = subSchema.items;
                                schemaPointer.push('items');
                            }
                            else if (isArray(subSchema.items)) {
                                if (!isNaN(key) && subSchema.items.length >= +key) {
                                    subSchemaFound = true;
                                    subSchema = subSchema.items[+key];
                                    schemaPointer.push('items', key);
                                }
                            }
                        }
                        if (!subSchemaFound && isObject(subSchema.additionalItems)) {
                            subSchemaFound = true;
                            subSchema = subSchema.additionalItems;
                            schemaPointer.push('additionalItems');
                        }
                        else if (subSchema.additionalItems !== false) {
                            subSchemaFound = true;
                            subSchema = {};
                            schemaPointer.push('additionalItems');
                        }
                    }
                    else if (subSchema.type === 'object') {
                        if (isObject(subSchema.properties) && hasOwn(subSchema.properties, key)) {
                            subSchemaFound = true;
                            subSchema = subSchema.properties[key];
                            schemaPointer.push('properties', key);
                        }
                        else if (isObject(subSchema.additionalProperties)) {
                            subSchemaFound = true;
                            subSchema = subSchema.additionalProperties;
                            schemaPointer.push('additionalProperties');
                        }
                        else if (subSchema.additionalProperties !== false) {
                            subSchemaFound = true;
                            subSchema = {};
                            schemaPointer.push('additionalProperties');
                        }
                    }
                    if (!subSchemaFound) {
                        console.error("getFromSchema error: Unable to find \"" + key + "\" item in schema.");
                        console.error(schema);
                        console.error(dataPointer);
                        return;
                    }
                }
                return returnType.slice(-7) === 'Pointer' ? schemaPointer : subSchema;
            }
            /**
             * 'removeRecursiveReferences' function
             *
             * Checks a JSON Pointer against a map of recursive references and returns
             * a JSON Pointer to the shallowest equivalent location in the same object.
             *
             * Using this functions enables an object to be constructed with unlimited
             * recursion, while maintaing a fixed set of metadata, such as field data types.
             * The object can grow as large as it wants, and deeply recursed nodes can
             * just refer to the metadata for their shallow equivalents, instead of having
             * to add additional redundant metadata for each recursively added node.
             *
             * Example:
             *
             * pointer:         '/stuff/and/more/and/more/and/more/and/more/stuff'
             * recursiveRefMap: [['/stuff/and/more/and/more', '/stuff/and/more/']]
             * returned:        '/stuff/and/more/stuff'
             *
             * //  { Pointer } pointer -
             * //  { Map<string, string> } recursiveRefMap -
             * //  { Map<string, number> = new Map() } arrayMap - optional
             * // { string } -
             */
            function removeRecursiveReferences(pointer, recursiveRefMap, arrayMap) {
                if (arrayMap === void 0) { arrayMap = new Map(); }
                if (!pointer) {
                    return '';
                }
                var genericPointer = JsonPointer.toGenericPointer(JsonPointer.compile(pointer), arrayMap);
                if (genericPointer.indexOf('/') === -1) {
                    return genericPointer;
                }
                var possibleReferences = true;
                while (possibleReferences) {
                    possibleReferences = false;
                    recursiveRefMap.forEach(function (toPointer, fromPointer) {
                        if (JsonPointer.isSubPointer(toPointer, fromPointer)) {
                            while (JsonPointer.isSubPointer(fromPointer, genericPointer, true)) {
                                genericPointer = JsonPointer.toGenericPointer(toPointer + genericPointer.slice(fromPointer.length), arrayMap);
                                possibleReferences = true;
                            }
                        }
                    });
                }
                return genericPointer;
            }
            /**
             * 'getInputType' function
             *
             * //   schema
             * //  { any = null } layoutNode
             * // { string }
             */
            function getInputType(schema, layoutNode) {
                if (layoutNode === void 0) { layoutNode = null; }
                // x-schema-form = Angular Schema Form compatibility
                // widget & component = React Jsonschema Form compatibility
                var controlType = JsonPointer.getFirst([
                    [schema, '/x-schema-form/type'],
                    [schema, '/x-schema-form/widget/component'],
                    [schema, '/x-schema-form/widget'],
                    [schema, '/widget/component'],
                    [schema, '/widget']
                ]);
                if (isString(controlType)) {
                    return checkInlineType(controlType, schema, layoutNode);
                }
                var schemaType = schema.type;
                if (schemaType) {
                    if (isArray(schemaType)) { // If multiple types listed, use most inclusive type
                        schemaType =
                            inArray('object', schemaType) && hasOwn(schema, 'properties') ? 'object' :
                                inArray('array', schemaType) && hasOwn(schema, 'items') ? 'array' :
                                    inArray('array', schemaType) && hasOwn(schema, 'additionalItems') ? 'array' :
                                        inArray('string', schemaType) ? 'string' :
                                            inArray('number', schemaType) ? 'number' :
                                                inArray('integer', schemaType) ? 'integer' :
                                                    inArray('boolean', schemaType) ? 'boolean' : 'unknown';
                    }
                    if (schemaType === 'boolean') {
                        return 'checkbox';
                    }
                    if (schemaType === 'object') {
                        if (hasOwn(schema, 'properties') || hasOwn(schema, 'additionalProperties')) {
                            return 'section';
                        }
                        // TODO: Figure out how to handle additionalProperties
                        if (hasOwn(schema, '$ref')) {
                            return '$ref';
                        }
                    }
                    if (schemaType === 'array') {
                        var itemsObject = JsonPointer.getFirst([
                            [schema, '/items'],
                            [schema, '/additionalItems']
                        ]) || {};
                        return hasOwn(itemsObject, 'enum') && schema.maxItems !== 1 ?
                            checkInlineType('checkboxes', schema, layoutNode) : 'array';
                    }
                    if (schemaType === 'null') {
                        return 'none';
                    }
                    if (JsonPointer.has(layoutNode, '/options/titleMap') ||
                        hasOwn(schema, 'enum') || getTitleMapFromOneOf(schema, null, true)) {
                        return 'select';
                    }
                    if (schemaType === 'number' || schemaType === 'integer') {
                        return (schemaType === 'integer' || hasOwn(schema, 'multipleOf')) &&
                            hasOwn(schema, 'maximum') && hasOwn(schema, 'minimum') ? 'range' : schemaType;
                    }
                    if (schemaType === 'string') {
                        return {
                            'color': 'color',
                            'date': 'date',
                            'date-time': 'datetime-local',
                            'email': 'email',
                            'uri': 'url',
                        }[schema.format] || 'text';
                    }
                }
                if (hasOwn(schema, '$ref')) {
                    return '$ref';
                }
                if (isArray(schema.oneOf) || isArray(schema.anyOf)) {
                    return 'one-of';
                }
                console.error("getInputType error: Unable to determine input type for " + schemaType);
                console.error('schema', schema);
                if (layoutNode) {
                    console.error('layoutNode', layoutNode);
                }
                return 'none';
            }
            /**
             * 'checkInlineType' function
             *
             * Checks layout and schema nodes for 'inline: true', and converts
             * 'radios' or 'checkboxes' to 'radios-inline' or 'checkboxes-inline'
             *
             * //  { string } controlType -
             * //   schema -
             * //  { any = null } layoutNode -
             * // { string }
             */
            function checkInlineType(controlType, schema, layoutNode) {
                if (layoutNode === void 0) { layoutNode = null; }
                if (!isString(controlType) || (controlType.slice(0, 8) !== 'checkbox' && controlType.slice(0, 5) !== 'radio')) {
                    return controlType;
                }
                if (JsonPointer.getFirst([
                    [layoutNode, '/inline'],
                    [layoutNode, '/options/inline'],
                    [schema, '/inline'],
                    [schema, '/x-schema-form/inline'],
                    [schema, '/x-schema-form/options/inline'],
                    [schema, '/x-schema-form/widget/inline'],
                    [schema, '/x-schema-form/widget/component/inline'],
                    [schema, '/x-schema-form/widget/component/options/inline'],
                    [schema, '/widget/inline'],
                    [schema, '/widget/component/inline'],
                    [schema, '/widget/component/options/inline'],
                ]) === true) {
                    return controlType.slice(0, 5) === 'radio' ?
                        'radios-inline' : 'checkboxes-inline';
                }
                else {
                    return controlType;
                }
            }
            /**
             * 'isInputRequired' function
             *
             * Checks a JSON Schema to see if an item is required
             *
             * //   schema - the schema to check
             * //  { string } schemaPointer - the pointer to the item to check
             * // { boolean } - true if the item is required, false if not
             */
            function isInputRequired(schema, schemaPointer) {
                if (!isObject(schema)) {
                    console.error('isInputRequired error: Input schema must be an object.');
                    return false;
                }
                var listPointerArray = JsonPointer.parse(schemaPointer);
                if (isArray(listPointerArray)) {
                    if (!listPointerArray.length) {
                        return schema.required === true;
                    }
                    var keyName = listPointerArray.pop();
                    var nextToLastKey = listPointerArray[listPointerArray.length - 1];
                    if (['properties', 'additionalProperties', 'patternProperties', 'items', 'additionalItems']
                        .includes(nextToLastKey)) {
                        listPointerArray.pop();
                    }
                    var parentSchema = JsonPointer.get(schema, listPointerArray) || {};
                    if (isArray(parentSchema.required)) {
                        return parentSchema.required.includes(keyName);
                    }
                    if (parentSchema.type === 'array') {
                        return hasOwn(parentSchema, 'minItems') &&
                            isNumber(keyName) &&
                            +parentSchema.minItems > +keyName;
                    }
                }
                return false;
            }
            /**
             * 'updateInputOptions' function
             *
             * //   layoutNode
             * //   schema
             * //   jsf
             * // { void }
             */
            function updateInputOptions(layoutNode, schema, jsf) {
                if (!isObject(layoutNode) || !isObject(layoutNode.options)) {
                    return;
                }
                // Set all option values in layoutNode.options
                var newOptions = {};
                var fixUiKeys = function (key) { return key.slice(0, 3).toLowerCase() === 'ui:' ? key.slice(3) : key; };
                mergeFilteredObject(newOptions, jsf.formOptions.defautWidgetOptions, [], fixUiKeys);
                [[JsonPointer.get(schema, '/ui:widget/options'), []],
                    [JsonPointer.get(schema, '/ui:widget'), []],
                    [schema, [
                            'additionalProperties', 'additionalItems', 'properties', 'items',
                            'required', 'type', 'x-schema-form', '$ref'
                        ]],
                    [JsonPointer.get(schema, '/x-schema-form/options'), []],
                    [JsonPointer.get(schema, '/x-schema-form'), ['items', 'options']],
                    [layoutNode, [
                            '_id', '$ref', 'arrayItem', 'arrayItemType', 'dataPointer', 'dataType',
                            'items', 'key', 'name', 'options', 'recursiveReference', 'type', 'widget'
                        ]],
                    [layoutNode.options, []],
                ].forEach(function (_a) {
                    var object = _a[0], excludeKeys = _a[1];
                    return mergeFilteredObject(newOptions, object, excludeKeys, fixUiKeys);
                });
                if (!hasOwn(newOptions, 'titleMap')) {
                    var newTitleMap = null;
                    newTitleMap = getTitleMapFromOneOf(schema, newOptions.flatList);
                    if (newTitleMap) {
                        newOptions.titleMap = newTitleMap;
                    }
                    if (!hasOwn(newOptions, 'titleMap') && !hasOwn(newOptions, 'enum') && hasOwn(schema, 'items')) {
                        if (JsonPointer.has(schema, '/items/titleMap')) {
                            newOptions.titleMap = schema.items.titleMap;
                        }
                        else if (JsonPointer.has(schema, '/items/enum')) {
                            newOptions.enum = schema.items.enum;
                            if (!hasOwn(newOptions, 'enumNames') && JsonPointer.has(schema, '/items/enumNames')) {
                                newOptions.enumNames = schema.items.enumNames;
                            }
                        }
                        else if (JsonPointer.has(schema, '/items/oneOf')) {
                            newTitleMap = getTitleMapFromOneOf(schema.items, newOptions.flatList);
                            if (newTitleMap) {
                                newOptions.titleMap = newTitleMap;
                            }
                        }
                    }
                }
                // If schema type is integer, enforce by setting multipleOf = 1
                if (schema.type === 'integer' && !hasValue(newOptions.multipleOf)) {
                    newOptions.multipleOf = 1;
                }
                // Copy any typeahead word lists to options.typeahead.source
                if (JsonPointer.has(newOptions, '/autocomplete/source')) {
                    newOptions.typeahead = newOptions.autocomplete;
                }
                else if (JsonPointer.has(newOptions, '/tagsinput/source')) {
                    newOptions.typeahead = newOptions.tagsinput;
                }
                else if (JsonPointer.has(newOptions, '/tagsinput/typeahead/source')) {
                    newOptions.typeahead = newOptions.tagsinput.typeahead;
                }
                layoutNode.options = newOptions;
            }
            /**
             * 'getTitleMapFromOneOf' function
             *
             * //  { schema } schema
             * //  { boolean = null } flatList
             * //  { boolean = false } validateOnly
             * // { validators }
             */
            function getTitleMapFromOneOf(schema, flatList, validateOnly) {
                if (schema === void 0) { schema = {}; }
                if (flatList === void 0) { flatList = null; }
                if (validateOnly === void 0) { validateOnly = false; }
                var titleMap = null;
                var oneOf = schema.oneOf || schema.anyOf || null;
                if (isArray(oneOf) && oneOf.every(function (item) { return item.title; })) {
                    if (oneOf.every(function (item) { return isArray(item.enum) && item.enum.length === 1; })) {
                        if (validateOnly) {
                            return true;
                        }
                        titleMap = oneOf.map(function (item) { return ({ name: item.title, value: item.enum[0] }); });
                    }
                    else if (oneOf.every(function (item) { return item.const; })) {
                        if (validateOnly) {
                            return true;
                        }
                        titleMap = oneOf.map(function (item) { return ({ name: item.title, value: item.const }); });
                    }
                    // if flatList !== false and some items have colons, make grouped map
                    if (flatList !== false && (titleMap || [])
                        .filter(function (title) { return ((title || {}).name || '').indexOf(': '); }).length > 1) {
                        // Split name on first colon to create grouped map (name -> group: name)
                        var newTitleMap_1 = titleMap.map(function (title) {
                            var _a = title.name.split(/: (.+)/), group = _a[0], name = _a[1];
                            return group && name ? Object.assign({}, title, { group: group, name: name }) : title;
                        });
                        // If flatList === true or at least one group has multiple items, use grouped map
                        if (flatList === true || newTitleMap_1.some(function (title, index) { return index &&
                            hasOwn(title, 'group') && title.group === newTitleMap_1[index - 1].group; })) {
                            titleMap = newTitleMap_1;
                        }
                    }
                }
                return validateOnly ? false : titleMap;
            }
            /**
             * 'getControlValidators' function
             *
             * //  schema
             * // { validators }
             */
            function getControlValidators(schema) {
                if (!isObject(schema)) {
                    return null;
                }
                var validators = {};
                if (hasOwn(schema, 'type')) {
                    switch (schema.type) {
                        case 'string':
                            forEach(['pattern', 'format', 'minLength', 'maxLength'], function (prop) {
                                if (hasOwn(schema, prop)) {
                                    validators[prop] = [schema[prop]];
                                }
                            });
                            break;
                        case 'number':
                        case 'integer':
                            forEach(['Minimum', 'Maximum'], function (ucLimit) {
                                var eLimit = 'exclusive' + ucLimit;
                                var limit = ucLimit.toLowerCase();
                                if (hasOwn(schema, limit)) {
                                    var exclusive = hasOwn(schema, eLimit) && schema[eLimit] === true;
                                    validators[limit] = [schema[limit], exclusive];
                                }
                            });
                            forEach(['multipleOf', 'type'], function (prop) {
                                if (hasOwn(schema, prop)) {
                                    validators[prop] = [schema[prop]];
                                }
                            });
                            break;
                        case 'object':
                            forEach(['minProperties', 'maxProperties', 'dependencies'], function (prop) {
                                if (hasOwn(schema, prop)) {
                                    validators[prop] = [schema[prop]];
                                }
                            });
                            break;
                        case 'array':
                            forEach(['minItems', 'maxItems', 'uniqueItems'], function (prop) {
                                if (hasOwn(schema, prop)) {
                                    validators[prop] = [schema[prop]];
                                }
                            });
                            break;
                    }
                }
                if (hasOwn(schema, 'enum')) {
                    validators.enum = [schema.enum];
                }
                return validators;
            }
            /**
             * 'resolveSchemaReferences' function
             *
             * Find all $ref links in schema and save links and referenced schemas in
             * schemaRefLibrary, schemaRecursiveRefMap, and dataRecursiveRefMap
             *
             * //  schema
             * //  schemaRefLibrary
             * // { Map<string, string> } schemaRecursiveRefMap
             * // { Map<string, string> } dataRecursiveRefMap
             * // { Map<string, number> } arrayMap
             * //
             */
            function resolveSchemaReferences(schema, schemaRefLibrary, schemaRecursiveRefMap, dataRecursiveRefMap, arrayMap) {
                if (!isObject(schema)) {
                    console.error('resolveSchemaReferences error: schema must be an object.');
                    return;
                }
                var refLinks = new Set();
                var refMapSet = new Set();
                var refMap = new Map();
                var recursiveRefMap = new Map();
                var refLibrary = {};
                // Search schema for all $ref links, and build full refLibrary
                JsonPointer.forEachDeep(schema, function (subSchema, subSchemaPointer) {
                    if (hasOwn(subSchema, '$ref') && isString(subSchema['$ref'])) {
                        var refPointer = JsonPointer.compile(subSchema['$ref']);
                        refLinks.add(refPointer);
                        refMapSet.add(subSchemaPointer + '~~' + refPointer);
                        refMap.set(subSchemaPointer, refPointer);
                    }
                });
                refLinks.forEach(function (ref) { return refLibrary[ref] = getSubSchema(schema, ref); });
                // Follow all ref links and save in refMapSet,
                // to find any multi-link recursive refernces
                var checkRefLinks = true;
                while (checkRefLinks) {
                    checkRefLinks = false;
                    Array.from(refMap).forEach(function (_a) {
                        var fromRef1 = _a[0], toRef1 = _a[1];
                        return Array.from(refMap)
                            .filter(function (_a) {
                            var fromRef2 = _a[0], toRef2 = _a[1];
                            return JsonPointer.isSubPointer(toRef1, fromRef2, true) &&
                                !JsonPointer.isSubPointer(toRef2, toRef1, true) &&
                                !refMapSet.has(fromRef1 + fromRef2.slice(toRef1.length) + '~~' + toRef2);
                        })
                            .forEach(function (_a) {
                            var fromRef2 = _a[0], toRef2 = _a[1];
                            refMapSet.add(fromRef1 + fromRef2.slice(toRef1.length) + '~~' + toRef2);
                            checkRefLinks = true;
                        });
                    });
                }
                // Build full recursiveRefMap
                // First pass - save all internally recursive refs from refMapSet
                Array.from(refMapSet)
                    .map(function (refLink) { return refLink.split('~~'); })
                    .filter(function (_a) {
                    var fromRef = _a[0], toRef = _a[1];
                    return JsonPointer.isSubPointer(toRef, fromRef);
                })
                    .forEach(function (_a) {
                    var fromRef = _a[0], toRef = _a[1];
                    return recursiveRefMap.set(fromRef, toRef);
                });
                // Second pass - create recursive versions of any other refs that link to recursive refs
                Array.from(refMap)
                    .filter(function (_a) {
                    var fromRef1 = _a[0], toRef1 = _a[1];
                    return Array.from(recursiveRefMap.keys())
                        .every(function (fromRef2) { return !JsonPointer.isSubPointer(fromRef1, fromRef2, true); });
                })
                    .forEach(function (_a) {
                    var fromRef1 = _a[0], toRef1 = _a[1];
                    return Array.from(recursiveRefMap)
                        .filter(function (_a) {
                        var fromRef2 = _a[0], toRef2 = _a[1];
                        return !recursiveRefMap.has(fromRef1 + fromRef2.slice(toRef1.length)) &&
                            JsonPointer.isSubPointer(toRef1, fromRef2, true) &&
                            !JsonPointer.isSubPointer(toRef1, fromRef1, true);
                    })
                        .forEach(function (_a) {
                        var fromRef2 = _a[0], toRef2 = _a[1];
                        return recursiveRefMap.set(fromRef1 + fromRef2.slice(toRef1.length), fromRef1 + toRef2.slice(toRef1.length));
                    });
                });
                // Create compiled schema by replacing all non-recursive $ref links with
                // thieir linked schemas and, where possible, combining schemas in allOf arrays.
                var compiledSchema = Object.assign({}, schema);
                delete compiledSchema.definitions;
                compiledSchema =
                    getSubSchema(compiledSchema, '', refLibrary, recursiveRefMap);
                // Make sure all remaining schema $refs are recursive, and build final
                // schemaRefLibrary, schemaRecursiveRefMap, dataRecursiveRefMap, & arrayMap
                JsonPointer.forEachDeep(compiledSchema, function (subSchema, subSchemaPointer) {
                    if (isString(subSchema['$ref'])) {
                        var refPointer = JsonPointer.compile(subSchema['$ref']);
                        if (!JsonPointer.isSubPointer(refPointer, subSchemaPointer, true)) {
                            refPointer = removeRecursiveReferences(subSchemaPointer, recursiveRefMap);
                            JsonPointer.set(compiledSchema, subSchemaPointer, { $ref: "#" + refPointer });
                        }
                        if (!hasOwn(schemaRefLibrary, 'refPointer')) {
                            schemaRefLibrary[refPointer] = !refPointer.length ? compiledSchema :
                                getSubSchema(compiledSchema, refPointer, schemaRefLibrary, recursiveRefMap);
                        }
                        if (!schemaRecursiveRefMap.has(subSchemaPointer)) {
                            schemaRecursiveRefMap.set(subSchemaPointer, refPointer);
                        }
                        var fromDataRef = JsonPointer.toDataPointer(subSchemaPointer, compiledSchema);
                        if (!dataRecursiveRefMap.has(fromDataRef)) {
                            var toDataRef = JsonPointer.toDataPointer(refPointer, compiledSchema);
                            dataRecursiveRefMap.set(fromDataRef, toDataRef);
                        }
                    }
                    if (subSchema.type === 'array' &&
                        (hasOwn(subSchema, 'items') || hasOwn(subSchema, 'additionalItems'))) {
                        var dataPointer = JsonPointer.toDataPointer(subSchemaPointer, compiledSchema);
                        if (!arrayMap.has(dataPointer)) {
                            var tupleItems = isArray(subSchema.items) ? subSchema.items.length : 0;
                            arrayMap.set(dataPointer, tupleItems);
                        }
                    }
                }, true);
                return compiledSchema;
            }
            /**
             * 'getSubSchema' function
             *
             * //   schema
             * //  { Pointer } pointer
             * //  { object } schemaRefLibrary
             * //  { Map<string, string> } schemaRecursiveRefMap
             * //  { string[] = [] } usedPointers
             * //
             */
            function getSubSchema(schema, pointer, schemaRefLibrary, schemaRecursiveRefMap, usedPointers) {
                if (schemaRefLibrary === void 0) { schemaRefLibrary = null; }
                if (schemaRecursiveRefMap === void 0) { schemaRecursiveRefMap = null; }
                if (usedPointers === void 0) { usedPointers = []; }
                if (!schemaRefLibrary || !schemaRecursiveRefMap) {
                    return JsonPointer.getCopy(schema, pointer);
                }
                if (typeof pointer !== 'string') {
                    pointer = JsonPointer.compile(pointer);
                }
                usedPointers = usedPointers.concat([pointer]);
                var newSchema = null;
                if (pointer === '') {
                    newSchema = Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(schema);
                }
                else {
                    var shortPointer = removeRecursiveReferences(pointer, schemaRecursiveRefMap);
                    if (shortPointer !== pointer) {
                        usedPointers = usedPointers.concat([shortPointer]);
                    }
                    newSchema = JsonPointer.getFirstCopy([
                        [schemaRefLibrary, [shortPointer]],
                        [schema, pointer],
                        [schema, shortPointer]
                    ]);
                }
                return JsonPointer.forEachDeepCopy(newSchema, function (subSchema, subPointer) {
                    if (isObject(subSchema)) {
                        // Replace non-recursive $ref links with referenced schemas
                        if (isString(subSchema.$ref)) {
                            var refPointer_1 = JsonPointer.compile(subSchema.$ref);
                            if (refPointer_1.length && usedPointers.every(function (ptr) { return !JsonPointer.isSubPointer(refPointer_1, ptr, true); })) {
                                var refSchema = getSubSchema(schema, refPointer_1, schemaRefLibrary, schemaRecursiveRefMap, usedPointers);
                                if (Object.keys(subSchema).length === 1) {
                                    return refSchema;
                                }
                                else {
                                    var extraKeys = Object.assign({}, subSchema);
                                    delete extraKeys.$ref;
                                    return mergeSchemas(refSchema, extraKeys);
                                }
                            }
                        }
                        // TODO: Convert schemas with 'type' arrays to 'oneOf'
                        // Combine allOf subSchemas
                        if (isArray(subSchema.allOf)) {
                            return combineAllOf(subSchema);
                        }
                        // Fix incorrectly placed array object required lists
                        if (subSchema.type === 'array' && isArray(subSchema.required)) {
                            return fixRequiredArrayProperties(subSchema);
                        }
                    }
                    return subSchema;
                }, true, pointer);
            }
            /**
             * 'combineAllOf' function
             *
             * Attempt to convert an allOf schema object into
             * a non-allOf schema object with equivalent rules.
             *
             * //   schema - allOf schema object
             * //  - converted schema object
             */
            function combineAllOf(schema) {
                if (!isObject(schema) || !isArray(schema.allOf)) {
                    return schema;
                }
                var mergedSchema = mergeSchemas.apply(void 0, schema.allOf);
                if (Object.keys(schema).length > 1) {
                    var extraKeys = Object.assign({}, schema);
                    delete extraKeys.allOf;
                    mergedSchema = mergeSchemas(mergedSchema, extraKeys);
                }
                return mergedSchema;
            }
            /**
             * 'fixRequiredArrayProperties' function
             *
             * Fixes an incorrectly placed required list inside an array schema, by moving
             * it into items.properties or additionalItems.properties, where it belongs.
             *
             * //   schema - allOf schema object
             * //  - converted schema object
             */
            function fixRequiredArrayProperties(schema) {
                if (schema.type === 'array' && isArray(schema.required)) {
                    var itemsObject_1 = hasOwn(schema.items, 'properties') ? 'items' :
                        hasOwn(schema.additionalItems, 'properties') ? 'additionalItems' : null;
                    if (itemsObject_1 && !hasOwn(schema[itemsObject_1], 'required') && (hasOwn(schema[itemsObject_1], 'additionalProperties') ||
                        schema.required.every(function (key) { return hasOwn(schema[itemsObject_1].properties, key); }))) {
                        schema = Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(schema);
                        schema[itemsObject_1].required = schema.required;
                        delete schema.required;
                    }
                }
                return schema;
            }
            // updated from AJV fast format regular expressions:
            // https://github.com/epoberezkin/ajv/blob/master/lib/compile/formats.js
            var jsonSchemaFormatTests = {
                'date': /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
                'time': /^[0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?(?:z|[+-]\d\d:\d\d)?$/i,
                // Modified to allow incomplete entries, such as
                // "2000-03-14T01:59:26.535" (needs "Z") or "2000-03-14T01:59" (needs ":00Z")
                'date-time': /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s][0-2]\d:[0-5]\d(?::[0-5]\d)?(?:\.\d+)?(?:z|[+-]\d\d:\d\d)?$/i,
                // email (sources from jsen validator):
                // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
                // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
                'email': /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
                'hostname': /^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*$/i,
                // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
                'ipv4': /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
                // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
                // tslint:disable-next-line:max-line-length
                'ipv6': /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
                // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
                'uri': /^(?:[a-z][a-z0-9+-.]*)(?::|\/)\/?[^\s]*$/i,
                // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
                'uri-reference': /^(?:(?:[a-z][a-z0-9+-.]*:)?\/\/)?[^\s]*$/i,
                // uri-template: https://tools.ietf.org/html/rfc6570
                // tslint:disable-next-line:max-line-length
                'uri-template': /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
                // For the source: https://gist.github.com/dperini/729294
                // For test cases: https://mathiasbynens.be/demo/url-regex
                // tslint:disable-next-line:max-line-length
                // @todo Delete current URL in favour of the commented out URL rule when this ajv issue is fixed https://github.com/eslint/eslint/issues/7983.
                // tslint:disable-next-line:max-line-length
                // URL: /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
                // tslint:disable-next-line:max-line-length
                'url': /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i,
                // uuid: http://tools.ietf.org/html/rfc4122
                'uuid': /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
                // optimized https://gist.github.com/olmokramer/82ccce673f86db7cda5e
                // tslint:disable-next-line:max-line-length
                'color': /^\s*(#(?:[\da-f]{3}){1,2}|rgb\((?:\d{1,3},\s*){2}\d{1,3}\)|rgba\((?:\d{1,3},\s*){3}\d*\.?\d+\)|hsl\(\d{1,3}(?:,\s*\d{1,3}%){2}\)|hsla\(\d{1,3}(?:,\s*\d{1,3}%){2},\s*\d*\.?\d+\))\s*$/gi,
                // JSON-pointer: https://tools.ietf.org/html/rfc6901
                'json-pointer': /^(?:\/(?:[^~/]|~0|~1)*)*$|^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
                'relative-json-pointer': /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
                'regex': function (str) {
                    if (/[^\\]\\Z/.test(str)) {
                        return false;
                    }
                    try {
                        return true;
                    }
                    catch (e) {
                        return false;
                    }
                }
            };
            /**
             * 'JsonValidators' class
             *
             * Provides an extended set of validators to be used by form controls,
             * compatible with standard JSON Schema validation options.
             * http://json-schema.org/latest/json-schema-validation.html
             *
             * Note: This library is designed as a drop-in replacement for the Angular
             * Validators library, and except for one small breaking change to the 'pattern'
             * validator (described below) it can even be imported as a substitute, like so:
             *
             *   import { JsonValidators as Validators } from 'json-validators';
             *
             * and it should work with existing code as a complete replacement.
             *
             * The one exception is the 'pattern' validator, which has been changed to
             * matche partial values by default (the standard 'pattern' validator wrapped
             * all patterns in '^' and '$', forcing them to always match an entire value).
             * However, the old behavior can be restored by simply adding '^' and '$'
             * around your patterns, or by passing an optional second parameter of TRUE.
             * This change is to make the 'pattern' validator match the behavior of a
             * JSON Schema pattern, which allows partial matches, rather than the behavior
             * of an HTML input control pattern, which does not.
             *
             * This library replaces Angular's validators and combination functions
             * with the following validators and transformation functions:
             *
             * Validators:
             *   For all formControls:     required (*), type, enum, const
             *   For text formControls:    minLength (*), maxLength (*), pattern (*), format
             *   For numeric formControls: maximum, exclusiveMaximum,
             *                             minimum, exclusiveMinimum, multipleOf
             *   For formGroup objects:    minProperties, maxProperties, dependencies
             *   For formArray arrays:     minItems, maxItems, uniqueItems, contains
             *   Not used by JSON Schema:  min (*), max (*), requiredTrue (*), email (*)
             * (Validators originally included with Angular are maked with (*).)
             *
             * NOTE / TODO: The dependencies validator is not complete.
             * NOTE / TODO: The contains validator is not complete.
             *
             * Validators not used by JSON Schema (but included for compatibility)
             * and their JSON Schema equivalents:
             *
             *   Angular validator | JSON Schema equivalent
             *   ------------------|-----------------------
             *     min(number)     |   minimum(number)
             *     max(number)     |   maximum(number)
             *     requiredTrue()  |   const(true)
             *     email()         |   format('email')
             *
             * Validator transformation functions:
             *   composeAnyOf, composeOneOf, composeAllOf, composeNot
             * (Angular's original combination funciton, 'compose', is also included for
             * backward compatibility, though it is functionally equivalent to composeAllOf,
             * asside from its more generic error message.)
             *
             * All validators have also been extended to accept an optional second argument
             * which, if passed a TRUE value, causes the validator to perform the opposite
             * of its original finction. (This is used internally to enable 'not' and
             * 'composeOneOf' to function and return useful error messages.)
             *
             * The 'required' validator has also been overloaded so that if called with
             * a boolean parameter (or no parameters) it returns the original validator
             * function (rather than executing it). However, if it is called with an
             * AbstractControl parameter (as was previously required), it behaves
             * exactly as before.
             *
             * This enables all validators (including 'required') to be constructed in
             * exactly the same way, so they can be automatically applied using the
             * equivalent key names and values taken directly from a JSON Schema.
             *
             * This source code is partially derived from Angular,
             * which is Copyright (c) 2014-2017 Google, Inc.
             * Use of this source code is therefore governed by the same MIT-style license
             * that can be found in the LICENSE file at https://angular.io/license
             *
             * Original Angular Validators:
             * https://github.com/angular/angular/blob/master/packages/forms/src/validators.ts
             */
            var JsonValidators = /** @class */ (function () {
                function JsonValidators() {
                }
                JsonValidators.required = function (input) {
                    if (input === undefined) {
                        input = true;
                    }
                    switch (input) {
                        case true: // Return required function (do not execute it yet)
                            return function (control, invert) {
                                if (invert === void 0) { invert = false; }
                                if (invert) {
                                    return null;
                                } // if not required, always return valid
                                return hasValue(control.value) ? null : { 'required': true };
                            };
                        case false: // Do nothing (if field is not required, it is always valid)
                            return JsonValidators.nullValidator;
                        default: // Execute required function
                            return hasValue(input.value) ? null : { 'required': true };
                    }
                };
                /**
                 * 'type' validator
                 *
                 * Requires a control to only accept values of a specified type,
                 * or one of an array of types.
                 *
                 * Note: SchemaPrimitiveType = 'string'|'number'|'integer'|'boolean'|'null'
                 *
                 * // {SchemaPrimitiveType|SchemaPrimitiveType[]} type - type(s) to accept
                 * // {IValidatorFn}
                 */
                JsonValidators.type = function (requiredType) {
                    if (!hasValue(requiredType)) {
                        return JsonValidators.nullValidator;
                    }
                    return function (control, invert) {
                        if (invert === void 0) { invert = false; }
                        if (isEmpty(control.value)) {
                            return null;
                        }
                        var currentValue = control.value;
                        var isValid = isArray(requiredType) ?
                            requiredType.some(function (type) { return isType(currentValue, type); }) :
                            isType(currentValue, requiredType);
                        return xor(isValid, invert) ?
                            null : { 'type': { requiredType: requiredType, currentValue: currentValue } };
                    };
                };
                /**
                 * 'enum' validator
                 *
                 * Requires a control to have a value from an enumerated list of values.
                 *
                 * Converts types as needed to allow string inputs to still correctly
                 * match number, boolean, and null enum values.
                 *
                 * // {any[]} allowedValues - array of acceptable values
                 * // {IValidatorFn}
                 */
                JsonValidators.enum = function (allowedValues) {
                    if (!isArray(allowedValues)) {
                        return JsonValidators.nullValidator;
                    }
                    return function (control, invert) {
                        if (invert === void 0) { invert = false; }
                        if (isEmpty(control.value)) {
                            return null;
                        }
                        var currentValue = control.value;
                        var isEqualVal = function (enumValue, inputValue) { return enumValue === inputValue ||
                            (isNumber(enumValue) && +inputValue === +enumValue) ||
                            (isBoolean(enumValue, 'strict') &&
                                toJavaScriptType(inputValue, 'boolean') === enumValue) ||
                            (enumValue === null && !hasValue(inputValue)) ||
                            Object(lodash_es_isEqual__WEBPACK_IMPORTED_MODULE_9__["default"])(enumValue, inputValue); };
                        var isValid = isArray(currentValue) ?
                            currentValue.every(function (inputValue) { return allowedValues.some(function (enumValue) { return isEqualVal(enumValue, inputValue); }); }) :
                            allowedValues.some(function (enumValue) { return isEqualVal(enumValue, currentValue); });
                        return xor(isValid, invert) ?
                            null : { 'enum': { allowedValues: allowedValues, currentValue: currentValue } };
                    };
                };
                /**
                 * 'const' validator
                 *
                 * Requires a control to have a specific value.
                 *
                 * Converts types as needed to allow string inputs to still correctly
                 * match number, boolean, and null values.
                 *
                 * TODO: modify to work with objects
                 *
                 * // {any[]} requiredValue - required value
                 * // {IValidatorFn}
                 */
                JsonValidators.const = function (requiredValue) {
                    if (!hasValue(requiredValue)) {
                        return JsonValidators.nullValidator;
                    }
                    return function (control, invert) {
                        if (invert === void 0) { invert = false; }
                        if (isEmpty(control.value)) {
                            return null;
                        }
                        var currentValue = control.value;
                        var isEqualVal = function (constValue, inputValue) { return constValue === inputValue ||
                            isNumber(constValue) && +inputValue === +constValue ||
                            isBoolean(constValue, 'strict') &&
                                toJavaScriptType(inputValue, 'boolean') === constValue ||
                            constValue === null && !hasValue(inputValue); };
                        var isValid = isEqualVal(requiredValue, currentValue);
                        return xor(isValid, invert) ?
                            null : { 'const': { requiredValue: requiredValue, currentValue: currentValue } };
                    };
                };
                /**
                 * 'minLength' validator
                 *
                 * Requires a control's text value to be greater than a specified length.
                 *
                 * // {number} minimumLength - minimum allowed string length
                 * // {boolean = false} invert - instead return error object only if valid
                 * // {IValidatorFn}
                 */
                JsonValidators.minLength = function (minimumLength) {
                    if (!hasValue(minimumLength)) {
                        return JsonValidators.nullValidator;
                    }
                    return function (control, invert) {
                        if (invert === void 0) { invert = false; }
                        if (isEmpty(control.value)) {
                            return null;
                        }
                        var currentLength = isString(control.value) ? control.value.length : 0;
                        var isValid = currentLength >= minimumLength;
                        return xor(isValid, invert) ?
                            null : { 'minLength': { minimumLength: minimumLength, currentLength: currentLength } };
                    };
                };
                /**
                 * 'maxLength' validator
                 *
                 * Requires a control's text value to be less than a specified length.
                 *
                 * // {number} maximumLength - maximum allowed string length
                 * // {boolean = false} invert - instead return error object only if valid
                 * // {IValidatorFn}
                 */
                JsonValidators.maxLength = function (maximumLength) {
                    if (!hasValue(maximumLength)) {
                        return JsonValidators.nullValidator;
                    }
                    return function (control, invert) {
                        if (invert === void 0) { invert = false; }
                        var currentLength = isString(control.value) ? control.value.length : 0;
                        var isValid = currentLength <= maximumLength;
                        return xor(isValid, invert) ?
                            null : { 'maxLength': { maximumLength: maximumLength, currentLength: currentLength } };
                    };
                };
                /**
                 * 'pattern' validator
                 *
                 * Note: NOT the same as Angular's default pattern validator.
                 *
                 * Requires a control's value to match a specified regular expression pattern.
                 *
                 * This validator changes the behavior of default pattern validator
                 * by replacing RegExp(`^${pattern}$`) with RegExp(`${pattern}`),
                 * which allows for partial matches.
                 *
                 * To return to the default funcitonality, and match the entire string,
                 * pass TRUE as the optional second parameter.
                 *
                 * // {string} pattern - regular expression pattern
                 * // {boolean = false} wholeString - match whole value string?
                 * // {IValidatorFn}
                 */
                JsonValidators.pattern = function (pattern, wholeString) {
                    if (wholeString === void 0) { wholeString = false; }
                    if (!hasValue(pattern)) {
                        return JsonValidators.nullValidator;
                    }
                    return function (control, invert) {
                        if (invert === void 0) { invert = false; }
                        if (isEmpty(control.value)) {
                            return null;
                        }
                        var regex;
                        var requiredPattern;
                        if (typeof pattern === 'string') {
                            requiredPattern = (wholeString) ? "^" + pattern + "$" : pattern;
                            regex = new RegExp(requiredPattern);
                        }
                        else {
                            requiredPattern = pattern.toString();
                            regex = pattern;
                        }
                        var currentValue = control.value;
                        var isValid = isString(currentValue) ? regex.test(currentValue) : false;
                        return xor(isValid, invert) ?
                            null : { 'pattern': { requiredPattern: requiredPattern, currentValue: currentValue } };
                    };
                };
                /**
                 * 'format' validator
                 *
                 * Requires a control to have a value of a certain format.
                 *
                 * This validator currently checks the following formsts:
                 *   date, time, date-time, email, hostname, ipv4, ipv6,
                 *   uri, uri-reference, uri-template, url, uuid, color,
                 *   json-pointer, relative-json-pointer, regex
                 *
                 * Fast format regular expressions copied from AJV:
                 * https://github.com/epoberezkin/ajv/blob/master/lib/compile/formats.js
                 *
                 * // {JsonSchemaFormatNames} requiredFormat - format to check
                 * // {IValidatorFn}
                 */
                JsonValidators.format = function (requiredFormat) {
                    if (!hasValue(requiredFormat)) {
                        return JsonValidators.nullValidator;
                    }
                    return function (control, invert) {
                        if (invert === void 0) { invert = false; }
                        if (isEmpty(control.value)) {
                            return null;
                        }
                        var isValid;
                        var currentValue = control.value;
                        if (isString(currentValue)) {
                            var formatTest = jsonSchemaFormatTests[requiredFormat];
                            if (typeof formatTest === 'object') {
                                isValid = formatTest.test(currentValue);
                            }
                            else if (typeof formatTest === 'function') {
                                isValid = formatTest(currentValue);
                            }
                            else {
                                console.error("format validator error: \"" + requiredFormat + "\" is not a recognized format.");
                                isValid = true;
                            }
                        }
                        else {
                            // Allow JavaScript Date objects
                            isValid = ['date', 'time', 'date-time'].includes(requiredFormat) &&
                                Object.prototype.toString.call(currentValue) === '[object Date]';
                        }
                        return xor(isValid, invert) ?
                            null : { 'format': { requiredFormat: requiredFormat, currentValue: currentValue } };
                    };
                };
                /**
                 * 'minimum' validator
                 *
                 * Requires a control's numeric value to be greater than or equal to
                 * a minimum amount.
                 *
                 * Any non-numeric value is also valid (according to the HTML forms spec,
                 * a non-numeric value doesn't have a minimum).
                 * https://www.w3.org/TR/html5/forms.html#attr-input-max
                 *
                 * // {number} minimum - minimum allowed value
                 * // {IValidatorFn}
                 */
                JsonValidators.minimum = function (minimumValue) {
                    if (!hasValue(minimumValue)) {
                        return JsonValidators.nullValidator;
                    }
                    return function (control, invert) {
                        if (invert === void 0) { invert = false; }
                        if (isEmpty(control.value)) {
                            return null;
                        }
                        var currentValue = control.value;
                        var isValid = !isNumber(currentValue) || currentValue >= minimumValue;
                        return xor(isValid, invert) ?
                            null : { 'minimum': { minimumValue: minimumValue, currentValue: currentValue } };
                    };
                };
                /**
                 * 'exclusiveMinimum' validator
                 *
                 * Requires a control's numeric value to be less than a maximum amount.
                 *
                 * Any non-numeric value is also valid (according to the HTML forms spec,
                 * a non-numeric value doesn't have a maximum).
                 * https://www.w3.org/TR/html5/forms.html#attr-input-max
                 *
                 * // {number} exclusiveMinimumValue - maximum allowed value
                 * // {IValidatorFn}
                 */
                JsonValidators.exclusiveMinimum = function (exclusiveMinimumValue) {
                    if (!hasValue(exclusiveMinimumValue)) {
                        return JsonValidators.nullValidator;
                    }
                    return function (control, invert) {
                        if (invert === void 0) { invert = false; }
                        if (isEmpty(control.value)) {
                            return null;
                        }
                        var currentValue = control.value;
                        var isValid = !isNumber(currentValue) || +currentValue < exclusiveMinimumValue;
                        return xor(isValid, invert) ?
                            null : { 'exclusiveMinimum': { exclusiveMinimumValue: exclusiveMinimumValue, currentValue: currentValue } };
                    };
                };
                /**
                 * 'maximum' validator
                 *
                 * Requires a control's numeric value to be less than or equal to
                 * a maximum amount.
                 *
                 * Any non-numeric value is also valid (according to the HTML forms spec,
                 * a non-numeric value doesn't have a maximum).
                 * https://www.w3.org/TR/html5/forms.html#attr-input-max
                 *
                 * // {number} maximumValue - maximum allowed value
                 * // {IValidatorFn}
                 */
                JsonValidators.maximum = function (maximumValue) {
                    if (!hasValue(maximumValue)) {
                        return JsonValidators.nullValidator;
                    }
                    return function (control, invert) {
                        if (invert === void 0) { invert = false; }
                        if (isEmpty(control.value)) {
                            return null;
                        }
                        var currentValue = control.value;
                        var isValid = !isNumber(currentValue) || +currentValue <= maximumValue;
                        return xor(isValid, invert) ?
                            null : { 'maximum': { maximumValue: maximumValue, currentValue: currentValue } };
                    };
                };
                /**
                 * 'exclusiveMaximum' validator
                 *
                 * Requires a control's numeric value to be less than a maximum amount.
                 *
                 * Any non-numeric value is also valid (according to the HTML forms spec,
                 * a non-numeric value doesn't have a maximum).
                 * https://www.w3.org/TR/html5/forms.html#attr-input-max
                 *
                 * // {number} exclusiveMaximumValue - maximum allowed value
                 * // {IValidatorFn}
                 */
                JsonValidators.exclusiveMaximum = function (exclusiveMaximumValue) {
                    if (!hasValue(exclusiveMaximumValue)) {
                        return JsonValidators.nullValidator;
                    }
                    return function (control, invert) {
                        if (invert === void 0) { invert = false; }
                        if (isEmpty(control.value)) {
                            return null;
                        }
                        var currentValue = control.value;
                        var isValid = !isNumber(currentValue) || +currentValue < exclusiveMaximumValue;
                        return xor(isValid, invert) ?
                            null : { 'exclusiveMaximum': { exclusiveMaximumValue: exclusiveMaximumValue, currentValue: currentValue } };
                    };
                };
                /**
                 * 'multipleOf' validator
                 *
                 * Requires a control to have a numeric value that is a multiple
                 * of a specified number.
                 *
                 * // {number} multipleOfValue - number value must be a multiple of
                 * // {IValidatorFn}
                 */
                JsonValidators.multipleOf = function (multipleOfValue) {
                    if (!hasValue(multipleOfValue)) {
                        return JsonValidators.nullValidator;
                    }
                    return function (control, invert) {
                        if (invert === void 0) { invert = false; }
                        if (isEmpty(control.value)) {
                            return null;
                        }
                        var currentValue = control.value;
                        var isValid = isNumber(currentValue) &&
                            currentValue % multipleOfValue === 0;
                        return xor(isValid, invert) ?
                            null : { 'multipleOf': { multipleOfValue: multipleOfValue, currentValue: currentValue } };
                    };
                };
                /**
                 * 'minProperties' validator
                 *
                 * Requires a form group to have a minimum number of properties (i.e. have
                 * values entered in a minimum number of controls within the group).
                 *
                 * // {number} minimumProperties - minimum number of properties allowed
                 * // {IValidatorFn}
                 */
                JsonValidators.minProperties = function (minimumProperties) {
                    if (!hasValue(minimumProperties)) {
                        return JsonValidators.nullValidator;
                    }
                    return function (control, invert) {
                        if (invert === void 0) { invert = false; }
                        if (isEmpty(control.value)) {
                            return null;
                        }
                        var currentProperties = Object.keys(control.value).length || 0;
                        var isValid = currentProperties >= minimumProperties;
                        return xor(isValid, invert) ?
                            null : { 'minProperties': { minimumProperties: minimumProperties, currentProperties: currentProperties } };
                    };
                };
                /**
                 * 'maxProperties' validator
                 *
                 * Requires a form group to have a maximum number of properties (i.e. have
                 * values entered in a maximum number of controls within the group).
                 *
                 * Note: Has no effect if the form group does not contain more than the
                 * maximum number of controls.
                 *
                 * // {number} maximumProperties - maximum number of properties allowed
                 * // {IValidatorFn}
                 */
                JsonValidators.maxProperties = function (maximumProperties) {
                    if (!hasValue(maximumProperties)) {
                        return JsonValidators.nullValidator;
                    }
                    return function (control, invert) {
                        if (invert === void 0) { invert = false; }
                        var currentProperties = Object.keys(control.value).length || 0;
                        var isValid = currentProperties <= maximumProperties;
                        return xor(isValid, invert) ?
                            null : { 'maxProperties': { maximumProperties: maximumProperties, currentProperties: currentProperties } };
                    };
                };
                /**
                 * 'dependencies' validator
                 *
                 * Requires the controls in a form group to meet additional validation
                 * criteria, depending on the values of other controls in the group.
                 *
                 * Examples:
                 * https://spacetelescope.github.io/understanding-json-schema/reference/object.html#dependencies
                 *
                 * // {any} dependencies - required dependencies
                 * // {IValidatorFn}
                 */
                JsonValidators.dependencies = function (dependencies) {
                    if (getType(dependencies) !== 'object' || isEmpty(dependencies)) {
                        return JsonValidators.nullValidator;
                    }
                    return function (control, invert) {
                        if (invert === void 0) { invert = false; }
                        if (isEmpty(control.value)) {
                            return null;
                        }
                        var allErrors = _mergeObjects(forEachCopy(dependencies, function (value, requiringField) {
                            var _a;
                            if (!hasValue(control.value[requiringField])) {
                                return null;
                            }
                            var requiringFieldErrors = {};
                            var requiredFields;
                            var properties = {};
                            if (getType(dependencies[requiringField]) === 'array') {
                                requiredFields = dependencies[requiringField];
                            }
                            else if (getType(dependencies[requiringField]) === 'object') {
                                requiredFields = dependencies[requiringField]['required'] || [];
                                properties = dependencies[requiringField]['properties'] || {};
                            }
                            // Validate property dependencies
                            for (var _b = 0, requiredFields_1 = requiredFields; _b < requiredFields_1.length; _b++) {
                                var requiredField = requiredFields_1[_b];
                                if (xor(!hasValue(control.value[requiredField]), invert)) {
                                    requiringFieldErrors[requiredField] = { 'required': true };
                                }
                            }
                            // Validate schema dependencies
                            requiringFieldErrors = _mergeObjects(requiringFieldErrors, forEachCopy(properties, function (requirements, requiredField) {
                                var _a;
                                var requiredFieldErrors = _mergeObjects(forEachCopy(requirements, function (requirement, parameter) {
                                    var validator = null;
                                    if (requirement === 'maximum' || requirement === 'minimum') {
                                        var exclusive = !!requirements['exclusiveM' + requirement.slice(1)];
                                        validator = JsonValidators[requirement](parameter, exclusive);
                                    }
                                    else if (typeof JsonValidators[requirement] === 'function') {
                                        validator = JsonValidators[requirement](parameter);
                                    }
                                    return !isDefined(validator) ?
                                        null : validator(control.value[requiredField]);
                                }));
                                return isEmpty(requiredFieldErrors) ?
                                    null : (_a = {}, _a[requiredField] = requiredFieldErrors, _a);
                            }));
                            return isEmpty(requiringFieldErrors) ?
                                null : (_a = {}, _a[requiringField] = requiringFieldErrors, _a);
                        }));
                        return isEmpty(allErrors) ? null : allErrors;
                    };
                };
                /**
                 * 'minItems' validator
                 *
                 * Requires a form array to have a minimum number of values.
                 *
                 * // {number} minimumItems - minimum number of items allowed
                 * // {IValidatorFn}
                 */
                JsonValidators.minItems = function (minimumItems) {
                    if (!hasValue(minimumItems)) {
                        return JsonValidators.nullValidator;
                    }
                    return function (control, invert) {
                        if (invert === void 0) { invert = false; }
                        if (isEmpty(control.value)) {
                            return null;
                        }
                        var currentItems = isArray(control.value) ? control.value.length : 0;
                        var isValid = currentItems >= minimumItems;
                        return xor(isValid, invert) ?
                            null : { 'minItems': { minimumItems: minimumItems, currentItems: currentItems } };
                    };
                };
                /**
                 * 'maxItems' validator
                 *
                 * Requires a form array to have a maximum number of values.
                 *
                 * // {number} maximumItems - maximum number of items allowed
                 * // {IValidatorFn}
                 */
                JsonValidators.maxItems = function (maximumItems) {
                    if (!hasValue(maximumItems)) {
                        return JsonValidators.nullValidator;
                    }
                    return function (control, invert) {
                        if (invert === void 0) { invert = false; }
                        var currentItems = isArray(control.value) ? control.value.length : 0;
                        var isValid = currentItems <= maximumItems;
                        return xor(isValid, invert) ?
                            null : { 'maxItems': { maximumItems: maximumItems, currentItems: currentItems } };
                    };
                };
                /**
                 * 'uniqueItems' validator
                 *
                 * Requires values in a form array to be unique.
                 *
                 * // {boolean = true} unique? - true to validate, false to disable
                 * // {IValidatorFn}
                 */
                JsonValidators.uniqueItems = function (unique) {
                    if (unique === void 0) { unique = true; }
                    if (!unique) {
                        return JsonValidators.nullValidator;
                    }
                    return function (control, invert) {
                        if (invert === void 0) { invert = false; }
                        if (isEmpty(control.value)) {
                            return null;
                        }
                        var sorted = control.value.slice().sort();
                        var duplicateItems = [];
                        for (var i = 1; i < sorted.length; i++) {
                            if (sorted[i - 1] === sorted[i] && duplicateItems.includes(sorted[i])) {
                                duplicateItems.push(sorted[i]);
                            }
                        }
                        var isValid = !duplicateItems.length;
                        return xor(isValid, invert) ?
                            null : { 'uniqueItems': { duplicateItems: duplicateItems } };
                    };
                };
                /**
                 * 'contains' validator
                 *
                 * TODO: Complete this validator
                 *
                 * Requires values in a form array to be unique.
                 *
                 * // {boolean = true} unique? - true to validate, false to disable
                 * // {IValidatorFn}
                 */
                JsonValidators.contains = function (requiredItem) {
                    if (requiredItem === void 0) { requiredItem = true; }
                    if (!requiredItem) {
                        return JsonValidators.nullValidator;
                    }
                    return function (control, invert) {
                        if (invert === void 0) { invert = false; }
                        if (isEmpty(control.value) || !isArray(control.value)) {
                            return null;
                        }
                        var currentItems = control.value;
                        // const isValid = currentItems.some(item =>
                        //
                        // );
                        var isValid = true;
                        return xor(isValid, invert) ?
                            null : { 'contains': { requiredItem: requiredItem, currentItems: currentItems } };
                    };
                };
                /**
                 * No-op validator. Included for backward compatibility.
                 */
                JsonValidators.nullValidator = function (control) {
                    return null;
                };
                /**
                 * Validator transformation functions:
                 * composeAnyOf, composeOneOf, composeAllOf, composeNot,
                 * compose, composeAsync
                 *
                 * TODO: Add composeAnyOfAsync, composeOneOfAsync,
                 *           composeAllOfAsync, composeNotAsync
                 */
                /**
                 * 'composeAnyOf' validator combination function
                 *
                 * Accepts an array of validators and returns a single validator that
                 * evaluates to valid if any one or more of the submitted validators are
                 * valid. If every validator is invalid, it returns combined errors from
                 * all validators.
                 *
                 * // {IValidatorFn[]} validators - array of validators to combine
                 * // {IValidatorFn} - single combined validator function
                 */
                JsonValidators.composeAnyOf = function (validators) {
                    if (!validators) {
                        return null;
                    }
                    var presentValidators = validators.filter(isDefined);
                    if (presentValidators.length === 0) {
                        return null;
                    }
                    return function (control, invert) {
                        if (invert === void 0) { invert = false; }
                        var arrayOfErrors = _executeValidators(control, presentValidators, invert).filter(isDefined);
                        var isValid = validators.length > arrayOfErrors.length;
                        return xor(isValid, invert) ?
                            null : _mergeObjects.apply(void 0, arrayOfErrors.concat([{ 'anyOf': !invert }]));
                    };
                };
                /**
                 * 'composeOneOf' validator combination function
                 *
                 * Accepts an array of validators and returns a single validator that
                 * evaluates to valid only if exactly one of the submitted validators
                 * is valid. Otherwise returns combined information from all validators,
                 * both valid and invalid.
                 *
                 * // {IValidatorFn[]} validators - array of validators to combine
                 * // {IValidatorFn} - single combined validator function
                 */
                JsonValidators.composeOneOf = function (validators) {
                    if (!validators) {
                        return null;
                    }
                    var presentValidators = validators.filter(isDefined);
                    if (presentValidators.length === 0) {
                        return null;
                    }
                    return function (control, invert) {
                        if (invert === void 0) { invert = false; }
                        var arrayOfErrors = _executeValidators(control, presentValidators);
                        var validControls = validators.length - arrayOfErrors.filter(isDefined).length;
                        var isValid = validControls === 1;
                        if (xor(isValid, invert)) {
                            return null;
                        }
                        var arrayOfValids = _executeValidators(control, presentValidators, invert);
                        return _mergeObjects.apply(void 0, arrayOfErrors.concat(arrayOfValids, [{ 'oneOf': !invert }]));
                    };
                };
                /**
                 * 'composeAllOf' validator combination function
                 *
                 * Accepts an array of validators and returns a single validator that
                 * evaluates to valid only if all the submitted validators are individually
                 * valid. Otherwise it returns combined errors from all invalid validators.
                 *
                 * // {IValidatorFn[]} validators - array of validators to combine
                 * // {IValidatorFn} - single combined validator function
                 */
                JsonValidators.composeAllOf = function (validators) {
                    if (!validators) {
                        return null;
                    }
                    var presentValidators = validators.filter(isDefined);
                    if (presentValidators.length === 0) {
                        return null;
                    }
                    return function (control, invert) {
                        if (invert === void 0) { invert = false; }
                        var combinedErrors = _mergeErrors(_executeValidators(control, presentValidators, invert));
                        var isValid = combinedErrors === null;
                        return (xor(isValid, invert)) ?
                            null : _mergeObjects(combinedErrors, { 'allOf': !invert });
                    };
                };
                /**
                 * 'composeNot' validator inversion function
                 *
                 * Accepts a single validator function and inverts its result.
                 * Returns valid if the submitted validator is invalid, and
                 * returns invalid if the submitted validator is valid.
                 * (Note: this function can itself be inverted
                 *   - e.g. composeNot(composeNot(validator)) -
                 *   but this can be confusing and is therefore not recommended.)
                 *
                 * // {IValidatorFn[]} validators - validator(s) to invert
                 * // {IValidatorFn} - new validator function that returns opposite result
                 */
                JsonValidators.composeNot = function (validator) {
                    if (!validator) {
                        return null;
                    }
                    return function (control, invert) {
                        if (invert === void 0) { invert = false; }
                        if (isEmpty(control.value)) {
                            return null;
                        }
                        var error = validator(control, !invert);
                        var isValid = error === null;
                        return (xor(isValid, invert)) ?
                            null : _mergeObjects(error, { 'not': !invert });
                    };
                };
                /**
                 * 'compose' validator combination function
                 *
                 * // {IValidatorFn[]} validators - array of validators to combine
                 * // {IValidatorFn} - single combined validator function
                 */
                JsonValidators.compose = function (validators) {
                    if (!validators) {
                        return null;
                    }
                    var presentValidators = validators.filter(isDefined);
                    if (presentValidators.length === 0) {
                        return null;
                    }
                    return function (control, invert) {
                        if (invert === void 0) { invert = false; }
                        return _mergeErrors(_executeValidators(control, presentValidators, invert));
                    };
                };
                /**
                 * 'composeAsync' async validator combination function
                 *
                 * // {AsyncIValidatorFn[]} async validators - array of async validators
                 * // {AsyncIValidatorFn} - single combined async validator function
                 */
                JsonValidators.composeAsync = function (validators) {
                    if (!validators) {
                        return null;
                    }
                    var presentValidators = validators.filter(isDefined);
                    if (presentValidators.length === 0) {
                        return null;
                    }
                    return function (control) {
                        var observables = _executeAsyncValidators(control, presentValidators).map(toObservable);
                        return rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["map"].call(Object(rxjs__WEBPACK_IMPORTED_MODULE_7__["forkJoin"])(observables), _mergeErrors);
                    };
                };
                // Additional angular validators (not used by Angualr JSON Schema Form)
                // From https://github.com/angular/angular/blob/master/packages/forms/src/validators.ts
                /**
                 * Validator that requires controls to have a value greater than a number.
                 */
                JsonValidators.min = function (min) {
                    if (!hasValue(min)) {
                        return JsonValidators.nullValidator;
                    }
                    return function (control) {
                        // don't validate empty values to allow optional controls
                        if (isEmpty(control.value) || isEmpty(min)) {
                            return null;
                        }
                        var value = parseFloat(control.value);
                        var actual = control.value;
                        // Controls with NaN values after parsing should be treated as not having a
                        // minimum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-min
                        return isNaN(value) || value >= min ? null : { 'min': { min: min, actual: actual } };
                    };
                };
                /**
                 * Validator that requires controls to have a value less than a number.
                 */
                JsonValidators.max = function (max) {
                    if (!hasValue(max)) {
                        return JsonValidators.nullValidator;
                    }
                    return function (control) {
                        // don't validate empty values to allow optional controls
                        if (isEmpty(control.value) || isEmpty(max)) {
                            return null;
                        }
                        var value = parseFloat(control.value);
                        var actual = control.value;
                        // Controls with NaN values after parsing should be treated as not having a
                        // maximum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-max
                        return isNaN(value) || value <= max ? null : { 'max': { max: max, actual: actual } };
                    };
                };
                /**
                 * Validator that requires control value to be true.
                 */
                JsonValidators.requiredTrue = function (control) {
                    if (!control) {
                        return JsonValidators.nullValidator;
                    }
                    return control.value === true ? null : { 'required': true };
                };
                /**
                 * Validator that performs email validation.
                 */
                JsonValidators.email = function (control) {
                    if (!control) {
                        return JsonValidators.nullValidator;
                    }
                    var EMAIL_REGEXP = 
                    // tslint:disable-next-line:max-line-length
                    /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;
                    return EMAIL_REGEXP.test(control.value) ? null : { 'email': true };
                };
                return JsonValidators;
            }());
            /**
             * FormGroup function library:
             *
             * buildFormGroupTemplate:  Builds a FormGroupTemplate from schema
             *
             * buildFormGroup:          Builds an Angular FormGroup from a FormGroupTemplate
             *
             * mergeValues:
             *
             * setRequiredFields:
             *
             * formatFormData:
             *
             * getControl:
             *
             * ---- TODO: ----
             * TODO: add buildFormGroupTemplateFromLayout function
             * buildFormGroupTemplateFromLayout: Builds a FormGroupTemplate from a form layout
             */
            /**
             * 'buildFormGroupTemplate' function
             *
             * Builds a template for an Angular FormGroup from a JSON Schema.
             *
             * TODO: add support for pattern properties
             * https://spacetelescope.github.io/understanding-json-schema/reference/object.html
             *
             * //  {any} jsf -
             * //  {any = null} nodeValue -
             * //  {boolean = true} mapArrays -
             * //  {string = ''} schemaPointer -
             * //  {string = ''} dataPointer -
             * //  {any = ''} templatePointer -
             * // {any} -
             */
            function buildFormGroupTemplate(jsf, nodeValue, setValues, schemaPointer, dataPointer, templatePointer) {
                if (nodeValue === void 0) { nodeValue = null; }
                if (setValues === void 0) { setValues = true; }
                if (schemaPointer === void 0) { schemaPointer = ''; }
                if (dataPointer === void 0) { dataPointer = ''; }
                if (templatePointer === void 0) { templatePointer = ''; }
                var schema = JsonPointer.get(jsf.schema, schemaPointer);
                if (setValues) {
                    if (!isDefined(nodeValue) && (jsf.formOptions.setSchemaDefaults === true ||
                        (jsf.formOptions.setSchemaDefaults === 'auto' && isEmpty(jsf.formValues)))) {
                        nodeValue = JsonPointer.get(jsf.schema, schemaPointer + '/default');
                    }
                }
                else {
                    nodeValue = null;
                }
                // TODO: If nodeValue still not set, check layout for default value
                var schemaType = JsonPointer.get(schema, '/type');
                var controlType = (hasOwn(schema, 'properties') || hasOwn(schema, 'additionalProperties')) &&
                    schemaType === 'object' ? 'FormGroup' :
                    (hasOwn(schema, 'items') || hasOwn(schema, 'additionalItems')) &&
                        schemaType === 'array' ? 'FormArray' :
                        !schemaType && hasOwn(schema, '$ref') ? '$ref' : 'FormControl';
                var shortDataPointer = removeRecursiveReferences(dataPointer, jsf.dataRecursiveRefMap, jsf.arrayMap);
                if (!jsf.dataMap.has(shortDataPointer)) {
                    jsf.dataMap.set(shortDataPointer, new Map());
                }
                var nodeOptions = jsf.dataMap.get(shortDataPointer);
                if (!nodeOptions.has('schemaType')) {
                    nodeOptions.set('schemaPointer', schemaPointer);
                    nodeOptions.set('schemaType', schema.type);
                    if (schema.format) {
                        nodeOptions.set('schemaFormat', schema.format);
                        if (!schema.type) {
                            nodeOptions.set('schemaType', 'string');
                        }
                    }
                    if (controlType) {
                        nodeOptions.set('templatePointer', templatePointer);
                        nodeOptions.set('templateType', controlType);
                    }
                }
                var controls;
                var validators = getControlValidators(schema);
                switch (controlType) {
                    case 'FormGroup':
                        controls = {};
                        if (hasOwn(schema, 'ui:order') || hasOwn(schema, 'properties')) {
                            var propertyKeys_1 = schema['ui:order'] || Object.keys(schema.properties);
                            if (propertyKeys_1.includes('*') && !hasOwn(schema.properties, '*')) {
                                var unnamedKeys = Object.keys(schema.properties)
                                    .filter(function (key) { return !propertyKeys_1.includes(key); });
                                for (var i = propertyKeys_1.length - 1; i >= 0; i--) {
                                    if (propertyKeys_1[i] === '*') {
                                        propertyKeys_1.splice.apply(propertyKeys_1, [i, 1].concat(unnamedKeys));
                                    }
                                }
                            }
                            propertyKeys_1
                                .filter(function (key) { return hasOwn(schema.properties, key) ||
                                hasOwn(schema, 'additionalProperties'); })
                                .forEach(function (key) { return controls[key] = buildFormGroupTemplate(jsf, JsonPointer.get(nodeValue, [key]), setValues, schemaPointer + (hasOwn(schema.properties, key) ?
                                '/properties/' + key : '/additionalProperties'), dataPointer + '/' + key, templatePointer + '/controls/' + key); });
                            jsf.formOptions.fieldsRequired = setRequiredFields(schema, controls);
                        }
                        return { controlType: controlType, controls: controls, validators: validators };
                    case 'FormArray':
                        controls = [];
                        var minItems = Math.max(schema.minItems || 0, nodeOptions.get('minItems') || 0);
                        var maxItems = Math.min(schema.maxItems || 1000, nodeOptions.get('maxItems') || 1000);
                        var additionalItemsPointer = null;
                        if (isArray(schema.items)) { // 'items' is an array = tuple items
                            var tupleItems = nodeOptions.get('tupleItems') ||
                                (isArray(schema.items) ? Math.min(schema.items.length, maxItems) : 0);
                            for (var i = 0; i < tupleItems; i++) {
                                if (i < minItems) {
                                    controls.push(buildFormGroupTemplate(jsf, isArray(nodeValue) ? nodeValue[i] : nodeValue, setValues, schemaPointer + '/items/' + i, dataPointer + '/' + i, templatePointer + '/controls/' + i));
                                }
                                else {
                                    var schemaRefPointer = removeRecursiveReferences(schemaPointer + '/items/' + i, jsf.schemaRecursiveRefMap);
                                    var itemRefPointer = removeRecursiveReferences(shortDataPointer + '/' + i, jsf.dataRecursiveRefMap, jsf.arrayMap);
                                    var itemRecursive = itemRefPointer !== shortDataPointer + '/' + i;
                                    if (!hasOwn(jsf.templateRefLibrary, itemRefPointer)) {
                                        jsf.templateRefLibrary[itemRefPointer] = null;
                                        jsf.templateRefLibrary[itemRefPointer] = buildFormGroupTemplate(jsf, null, setValues, schemaRefPointer, itemRefPointer, templatePointer + '/controls/' + i);
                                    }
                                    controls.push(isArray(nodeValue) ?
                                        buildFormGroupTemplate(jsf, nodeValue[i], setValues, schemaPointer + '/items/' + i, dataPointer + '/' + i, templatePointer + '/controls/' + i) :
                                        itemRecursive ?
                                            null : Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(jsf.templateRefLibrary[itemRefPointer]));
                                }
                            }
                            // If 'additionalItems' is an object = additional list items (after tuple items)
                            if (schema.items.length < maxItems && isObject(schema.additionalItems)) {
                                additionalItemsPointer = schemaPointer + '/additionalItems';
                            }
                            // If 'items' is an object = list items only (no tuple items)
                        }
                        else {
                            additionalItemsPointer = schemaPointer + '/items';
                        }
                        if (additionalItemsPointer) {
                            var schemaRefPointer = removeRecursiveReferences(additionalItemsPointer, jsf.schemaRecursiveRefMap);
                            var itemRefPointer = removeRecursiveReferences(shortDataPointer + '/-', jsf.dataRecursiveRefMap, jsf.arrayMap);
                            var itemRecursive = itemRefPointer !== shortDataPointer + '/-';
                            if (!hasOwn(jsf.templateRefLibrary, itemRefPointer)) {
                                jsf.templateRefLibrary[itemRefPointer] = null;
                                jsf.templateRefLibrary[itemRefPointer] = buildFormGroupTemplate(jsf, null, setValues, schemaRefPointer, itemRefPointer, templatePointer + '/controls/-');
                            }
                            // const itemOptions = jsf.dataMap.get(itemRefPointer) || new Map();
                            var itemOptions = nodeOptions;
                            if (!itemRecursive || hasOwn(validators, 'required')) {
                                var arrayLength = Math.min(Math.max(itemRecursive ? 0 :
                                    (itemOptions.get('tupleItems') + itemOptions.get('listItems')) || 0, isArray(nodeValue) ? nodeValue.length : 0), maxItems);
                                for (var i = controls.length; i < arrayLength; i++) {
                                    controls.push(isArray(nodeValue) ?
                                        buildFormGroupTemplate(jsf, nodeValue[i], setValues, schemaRefPointer, dataPointer + '/-', templatePointer + '/controls/-') :
                                        itemRecursive ?
                                            null : Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(jsf.templateRefLibrary[itemRefPointer]));
                                }
                            }
                        }
                        return { controlType: controlType, controls: controls, validators: validators };
                    case '$ref':
                        var schemaRef = JsonPointer.compile(schema.$ref);
                        var dataRef = JsonPointer.toDataPointer(schemaRef, schema);
                        var refPointer = removeRecursiveReferences(dataRef, jsf.dataRecursiveRefMap, jsf.arrayMap);
                        if (refPointer && !hasOwn(jsf.templateRefLibrary, refPointer)) {
                            // Set to null first to prevent recursive reference from causing endless loop
                            jsf.templateRefLibrary[refPointer] = null;
                            var newTemplate = buildFormGroupTemplate(jsf, setValues, setValues, schemaRef);
                            if (newTemplate) {
                                jsf.templateRefLibrary[refPointer] = newTemplate;
                            }
                            else {
                                delete jsf.templateRefLibrary[refPointer];
                            }
                        }
                        return null;
                    case 'FormControl':
                        var value = {
                            value: setValues && isPrimitive(nodeValue) ? nodeValue : null,
                            disabled: nodeOptions.get('disabled') || false
                        };
                        return { controlType: controlType, value: value, validators: validators };
                    default:
                        return null;
                }
            }
            /**
             * 'buildFormGroup' function
             *
             * // {any} template -
             * // {AbstractControl}
            */
            function buildFormGroup(template) {
                var validatorFns = [];
                var validatorFn = null;
                if (hasOwn(template, 'validators')) {
                    forEach(template.validators, function (parameters, validator) {
                        if (typeof JsonValidators[validator] === 'function') {
                            validatorFns.push(JsonValidators[validator].apply(null, parameters));
                        }
                    });
                    if (validatorFns.length &&
                        inArray(template.controlType, ['FormGroup', 'FormArray'])) {
                        validatorFn = validatorFns.length > 1 ?
                            JsonValidators.compose(validatorFns) : validatorFns[0];
                    }
                }
                if (hasOwn(template, 'controlType')) {
                    switch (template.controlType) {
                        case 'FormGroup':
                            var groupControls_1 = {};
                            forEach(template.controls, function (controls, key) {
                                var newControl = buildFormGroup(controls);
                                if (newControl) {
                                    groupControls_1[key] = newControl;
                                }
                            });
                            return new _angular_forms__WEBPACK_IMPORTED_MODULE_6__["FormGroup"](groupControls_1, validatorFn);
                        case 'FormArray':
                            return new _angular_forms__WEBPACK_IMPORTED_MODULE_6__["FormArray"](Object(lodash_es_filter__WEBPACK_IMPORTED_MODULE_4__["default"])(Object(lodash_es_map__WEBPACK_IMPORTED_MODULE_5__["default"])(template.controls, function (controls) { return buildFormGroup(controls); })), validatorFn);
                        case 'FormControl':
                            return new _angular_forms__WEBPACK_IMPORTED_MODULE_6__["FormControl"](template.value, validatorFns);
                    }
                }
                return null;
            }
            /**
             * 'setRequiredFields' function
             *
             * // {schema} schema - JSON Schema
             * // {object} formControlTemplate - Form Control Template object
             * // {boolean} - true if any fields have been set to required, false if not
             */
            function setRequiredFields(schema, formControlTemplate) {
                var fieldsRequired = false;
                if (hasOwn(schema, 'required') && !isEmpty(schema.required)) {
                    fieldsRequired = true;
                    var requiredArray = isArray(schema.required) ? schema.required : [schema.required];
                    requiredArray = forEach(requiredArray, function (key) { return JsonPointer.set(formControlTemplate, '/' + key + '/validators/required', []); });
                }
                return fieldsRequired;
                // TODO: Add support for patternProperties
                // https://spacetelescope.github.io/understanding-json-schema/reference/object.html#pattern-properties
            }
            /**
             * 'formatFormData' function
             *
             * // {any} formData - Angular FormGroup data object
             * // {Map<string, any>} dataMap -
             * // {Map<string, string>} recursiveRefMap -
             * // {Map<string, number>} arrayMap -
             * // {boolean = false} fixErrors - if TRUE, tries to fix data
             * // {any} - formatted data object
             */
            function formatFormData(formData, dataMap, recursiveRefMap, arrayMap, returnEmptyFields, fixErrors) {
                if (returnEmptyFields === void 0) { returnEmptyFields = false; }
                if (fixErrors === void 0) { fixErrors = false; }
                if (formData === null || typeof formData !== 'object') {
                    return formData;
                }
                var formattedData = isArray(formData) ? [] : {};
                JsonPointer.forEachDeep(formData, function (value, dataPointer) {
                    // If returnEmptyFields === true,
                    // add empty arrays and objects to all allowed keys
                    if (returnEmptyFields && isArray(value)) {
                        JsonPointer.set(formattedData, dataPointer, []);
                    }
                    else if (returnEmptyFields && isObject(value) && !isDate(value)) {
                        JsonPointer.set(formattedData, dataPointer, {});
                    }
                    else {
                        var genericPointer_1 = JsonPointer.has(dataMap, [dataPointer, 'schemaType']) ? dataPointer :
                            removeRecursiveReferences(dataPointer, recursiveRefMap, arrayMap);
                        if (JsonPointer.has(dataMap, [genericPointer_1, 'schemaType'])) {
                            var schemaType = dataMap.get(genericPointer_1).get('schemaType');
                            if (schemaType === 'null') {
                                JsonPointer.set(formattedData, dataPointer, null);
                            }
                            else if ((hasValue(value) || returnEmptyFields) &&
                                inArray(schemaType, ['string', 'integer', 'number', 'boolean'])) {
                                var newValue = (fixErrors || (value === null && returnEmptyFields)) ?
                                    toSchemaType(value, schemaType) : toJavaScriptType(value, schemaType);
                                if (isDefined(newValue) || returnEmptyFields) {
                                    JsonPointer.set(formattedData, dataPointer, newValue);
                                }
                                // If returnEmptyFields === false,
                                // only add empty arrays and objects to required keys
                            }
                            else if (schemaType === 'object' && !returnEmptyFields) {
                                (dataMap.get(genericPointer_1).get('required') || []).forEach(function (key) {
                                    var keySchemaType = dataMap.get(genericPointer_1 + "/" + key).get('schemaType');
                                    if (keySchemaType === 'array') {
                                        JsonPointer.set(formattedData, dataPointer + "/" + key, []);
                                    }
                                    else if (keySchemaType === 'object') {
                                        JsonPointer.set(formattedData, dataPointer + "/" + key, {});
                                    }
                                });
                            }
                            // Finish incomplete 'date-time' entries
                            if (dataMap.get(genericPointer_1).get('schemaFormat') === 'date-time') {
                                // "2000-03-14T01:59:26.535" -> "2000-03-14T01:59:26.535Z" (add "Z")
                                if (/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s][0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?$/i.test(value)) {
                                    JsonPointer.set(formattedData, dataPointer, value + "Z");
                                    // "2000-03-14T01:59" -> "2000-03-14T01:59:00Z" (add ":00Z")
                                }
                                else if (/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s][0-2]\d:[0-5]\d$/i.test(value)) {
                                    JsonPointer.set(formattedData, dataPointer, value + ":00Z");
                                    // "2000-03-14" -> "2000-03-14T00:00:00Z" (add "T00:00:00Z")
                                }
                                else if (fixErrors && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value)) {
                                    JsonPointer.set(formattedData, dataPointer, value + ":00:00:00Z");
                                }
                            }
                        }
                        else if (typeof value !== 'object' || isDate(value) ||
                            (value === null && returnEmptyFields)) {
                            console.error('formatFormData error: ' +
                                ("Schema type not found for form value at " + genericPointer_1));
                            console.error('dataMap', dataMap);
                            console.error('recursiveRefMap', recursiveRefMap);
                            console.error('genericPointer', genericPointer_1);
                        }
                    }
                });
                return formattedData;
            }
            /**
             * 'getControl' function
             *
             * Uses a JSON Pointer for a data object to retrieve a control from
             * an Angular formGroup or formGroup template. (Note: though a formGroup
             * template is much simpler, its basic structure is idential to a formGroup).
             *
             * If the optional third parameter 'returnGroup' is set to TRUE, the group
             * containing the control is returned, rather than the control itself.
             *
             * // {FormGroup} formGroup - Angular FormGroup to get value from
             * // {Pointer} dataPointer - JSON Pointer (string or array)
             * // {boolean = false} returnGroup - If true, return group containing control
             * // {group} - Located value (or null, if no control found)
             */
            function getControl(formGroup, dataPointer, returnGroup) {
                if (returnGroup === void 0) { returnGroup = false; }
                if (!isObject(formGroup) || !JsonPointer.isJsonPointer(dataPointer)) {
                    if (!JsonPointer.isJsonPointer(dataPointer)) {
                        // If dataPointer input is not a valid JSON pointer, check to
                        // see if it is instead a valid object path, using dot notaion
                        if (typeof dataPointer === 'string') {
                            var formControl = formGroup.get(dataPointer);
                            if (formControl) {
                                return formControl;
                            }
                        }
                        console.error("getControl error: Invalid JSON Pointer: " + dataPointer);
                    }
                    if (!isObject(formGroup)) {
                        console.error("getControl error: Invalid formGroup: " + formGroup);
                    }
                    return null;
                }
                var dataPointerArray = JsonPointer.parse(dataPointer);
                if (returnGroup) {
                    dataPointerArray = dataPointerArray.slice(0, -1);
                }
                // If formGroup input is a real formGroup (not a formGroup template)
                // try using formGroup.get() to return the control
                if (typeof formGroup.get === 'function' &&
                    dataPointerArray.every(function (key) { return key.indexOf('.') === -1; })) {
                    var formControl = formGroup.get(dataPointerArray.join('.'));
                    if (formControl) {
                        return formControl;
                    }
                }
                // If formGroup input is a formGroup template,
                // or formGroup.get() failed to return the control,
                // search the formGroup object for dataPointer's control
                var subGroup = formGroup;
                for (var _a = 0, dataPointerArray_2 = dataPointerArray; _a < dataPointerArray_2.length; _a++) {
                    var key = dataPointerArray_2[_a];
                    if (hasOwn(subGroup, 'controls')) {
                        subGroup = subGroup.controls;
                    }
                    if (isArray(subGroup) && (key === '-')) {
                        subGroup = subGroup[subGroup.length - 1];
                    }
                    else if (hasOwn(subGroup, key)) {
                        subGroup = subGroup[key];
                    }
                    else {
                        console.error("getControl error: Unable to find \"" + key + "\" item in FormGroup.");
                        console.error(dataPointer);
                        console.error(formGroup);
                        return;
                    }
                }
                return subGroup;
            }
            /**
             * Layout function library:
             *
             * buildLayout:            Builds a complete layout from an input layout and schema
             *
             * buildLayoutFromSchema:  Builds a complete layout entirely from an input schema
             *
             * mapLayout:
             *
             * getLayoutNode:
             *
             * buildTitleMap:
             */
            /**
             * 'buildLayout' function
             *
             * //   jsf
             * //   widgetLibrary
             * //
             */
            function buildLayout(jsf, widgetLibrary) {
                var hasSubmitButton = !JsonPointer.get(jsf, '/formOptions/addSubmit');
                var formLayout = mapLayout(jsf.layout, function (layoutItem, index, layoutPointer) {
                    var newNode = {
                        _id: Object(lodash_es_uniqueId__WEBPACK_IMPORTED_MODULE_11__["default"])(),
                        options: {},
                    };
                    if (isObject(layoutItem)) {
                        Object.assign(newNode, layoutItem);
                        Object.keys(newNode)
                            .filter(function (option) { return !inArray(option, [
                            '_id', '$ref', 'arrayItem', 'arrayItemType', 'dataPointer', 'dataType',
                            'items', 'key', 'name', 'options', 'recursiveReference', 'type', 'widget'
                        ]); })
                            .forEach(function (option) {
                            newNode.options[option] = newNode[option];
                            delete newNode[option];
                        });
                        if (!hasOwn(newNode, 'type') && isString(newNode.widget)) {
                            newNode.type = newNode.widget;
                            delete newNode.widget;
                        }
                        if (!hasOwn(newNode.options, 'title')) {
                            if (hasOwn(newNode.options, 'legend')) {
                                newNode.options.title = newNode.options.legend;
                                delete newNode.options.legend;
                            }
                        }
                        if (!hasOwn(newNode.options, 'validationMessages')) {
                            if (hasOwn(newNode.options, 'errorMessages')) {
                                newNode.options.validationMessages = newNode.options.errorMessages;
                                delete newNode.options.errorMessages;
                                // Convert Angular Schema Form (AngularJS) 'validationMessage' to
                                // Angular JSON Schema Form 'validationMessages'
                                // TV4 codes from https://github.com/geraintluff/tv4/blob/master/source/api.js
                            }
                            else if (hasOwn(newNode.options, 'validationMessage')) {
                                if (typeof newNode.options.validationMessage === 'string') {
                                    newNode.options.validationMessages = newNode.options.validationMessage;
                                }
                                else {
                                    newNode.options.validationMessages = {};
                                    Object.keys(newNode.options.validationMessage).forEach(function (key) {
                                        var code = key + '';
                                        var newKey = code === '0' ? 'type' :
                                            code === '1' ? 'enum' :
                                                code === '100' ? 'multipleOf' :
                                                    code === '101' ? 'minimum' :
                                                        code === '102' ? 'exclusiveMinimum' :
                                                            code === '103' ? 'maximum' :
                                                                code === '104' ? 'exclusiveMaximum' :
                                                                    code === '200' ? 'minLength' :
                                                                        code === '201' ? 'maxLength' :
                                                                            code === '202' ? 'pattern' :
                                                                                code === '300' ? 'minProperties' :
                                                                                    code === '301' ? 'maxProperties' :
                                                                                        code === '302' ? 'required' :
                                                                                            code === '304' ? 'dependencies' :
                                                                                                code === '400' ? 'minItems' :
                                                                                                    code === '401' ? 'maxItems' :
                                                                                                        code === '402' ? 'uniqueItems' :
                                                                                                            code === '500' ? 'format' : code + '';
                                        newNode.options.validationMessages[newKey] = newNode.options.validationMessage[key];
                                    });
                                }
                                delete newNode.options.validationMessage;
                            }
                        }
                    }
                    else if (JsonPointer.isJsonPointer(layoutItem)) {
                        newNode.dataPointer = layoutItem;
                    }
                    else if (isString(layoutItem)) {
                        newNode.key = layoutItem;
                    }
                    else {
                        console.error('buildLayout error: Form layout element not recognized:');
                        console.error(layoutItem);
                        return null;
                    }
                    var nodeSchema = null;
                    // If newNode does not have a dataPointer, try to find an equivalent
                    if (!hasOwn(newNode, 'dataPointer')) {
                        // If newNode has a key, change it to a dataPointer
                        if (hasOwn(newNode, 'key')) {
                            newNode.dataPointer = newNode.key === '*' ? newNode.key :
                                JsonPointer.compile(JsonPointer.parseObjectPath(newNode.key), '-');
                            delete newNode.key;
                            // If newNode is an array, search for dataPointer in child nodes
                        }
                        else if (hasOwn(newNode, 'type') && newNode.type.slice(-5) === 'array') {
                            var findDataPointer_1 = function (items) {
                                if (items === null || typeof items !== 'object') {
                                    return;
                                }
                                if (hasOwn(items, 'dataPointer')) {
                                    return items.dataPointer;
                                }
                                if (isArray(items.items)) {
                                    for (var _a = 0, _b = items.items; _a < _b.length; _a++) {
                                        var item = _b[_a];
                                        if (hasOwn(item, 'dataPointer') && item.dataPointer.indexOf('/-') !== -1) {
                                            return item.dataPointer;
                                        }
                                        if (hasOwn(item, 'items')) {
                                            var searchItem = findDataPointer_1(item);
                                            if (searchItem) {
                                                return searchItem;
                                            }
                                        }
                                    }
                                }
                            };
                            var childDataPointer = findDataPointer_1(newNode);
                            if (childDataPointer) {
                                newNode.dataPointer =
                                    childDataPointer.slice(0, childDataPointer.lastIndexOf('/-'));
                            }
                        }
                    }
                    if (hasOwn(newNode, 'dataPointer')) {
                        if (newNode.dataPointer === '*') {
                            return buildLayoutFromSchema(jsf, widgetLibrary, jsf.formValues);
                        }
                        var nodeValue = JsonPointer.get(jsf.formValues, newNode.dataPointer.replace(/\/-/g, '/1'));
                        // TODO: Create function getFormValues(jsf, dataPointer, forRefLibrary)
                        // check formOptions.setSchemaDefaults and formOptions.setLayoutDefaults
                        // then set apropriate values from initialVaues, schema, or layout
                        newNode.dataPointer =
                            JsonPointer.toGenericPointer(newNode.dataPointer, jsf.arrayMap);
                        var LastKey = JsonPointer.toKey(newNode.dataPointer);
                        if (!newNode.name && isString(LastKey) && LastKey !== '-') {
                            newNode.name = LastKey;
                        }
                        var shortDataPointer = removeRecursiveReferences(newNode.dataPointer, jsf.dataRecursiveRefMap, jsf.arrayMap);
                        var recursive_1 = !shortDataPointer.length ||
                            shortDataPointer !== newNode.dataPointer;
                        var schemaPointer = void 0;
                        if (!jsf.dataMap.has(shortDataPointer)) {
                            jsf.dataMap.set(shortDataPointer, new Map());
                        }
                        var nodeDataMap = jsf.dataMap.get(shortDataPointer);
                        if (nodeDataMap.has('schemaPointer')) {
                            schemaPointer = nodeDataMap.get('schemaPointer');
                        }
                        else {
                            schemaPointer = JsonPointer.toSchemaPointer(shortDataPointer, jsf.schema);
                            nodeDataMap.set('schemaPointer', schemaPointer);
                        }
                        nodeDataMap.set('disabled', !!newNode.options.disabled);
                        nodeSchema = JsonPointer.get(jsf.schema, schemaPointer);
                        if (nodeSchema) {
                            if (!hasOwn(newNode, 'type')) {
                                newNode.type = getInputType(nodeSchema, newNode);
                            }
                            else if (!widgetLibrary.hasWidget(newNode.type)) {
                                var oldWidgetType = newNode.type;
                                newNode.type = getInputType(nodeSchema, newNode);
                                console.error("error: widget type \"" + oldWidgetType + "\" " +
                                    ("not found in library. Replacing with \"" + newNode.type + "\"."));
                            }
                            else {
                                newNode.type = checkInlineType(newNode.type, nodeSchema, newNode);
                            }
                            if (nodeSchema.type === 'object' && isArray(nodeSchema.required)) {
                                nodeDataMap.set('required', nodeSchema.required);
                            }
                            newNode.dataType =
                                nodeSchema.type || (hasOwn(nodeSchema, '$ref') ? '$ref' : null);
                            updateInputOptions(newNode, nodeSchema, jsf);
                            // Present checkboxes as single control, rather than array
                            if (newNode.type === 'checkboxes' && hasOwn(nodeSchema, 'items')) {
                                updateInputOptions(newNode, nodeSchema.items, jsf);
                            }
                            else if (newNode.dataType === 'array') {
                                newNode.options.maxItems = Math.min(nodeSchema.maxItems || 1000, newNode.options.maxItems || 1000);
                                newNode.options.minItems = Math.max(nodeSchema.minItems || 0, newNode.options.minItems || 0);
                                newNode.options.listItems = Math.max(newNode.options.listItems || 0, isArray(nodeValue) ? nodeValue.length : 0);
                                newNode.options.tupleItems =
                                    isArray(nodeSchema.items) ? nodeSchema.items.length : 0;
                                if (newNode.options.maxItems < newNode.options.tupleItems) {
                                    newNode.options.tupleItems = newNode.options.maxItems;
                                    newNode.options.listItems = 0;
                                }
                                else if (newNode.options.maxItems <
                                    newNode.options.tupleItems + newNode.options.listItems) {
                                    newNode.options.listItems =
                                        newNode.options.maxItems - newNode.options.tupleItems;
                                }
                                else if (newNode.options.minItems >
                                    newNode.options.tupleItems + newNode.options.listItems) {
                                    newNode.options.listItems =
                                        newNode.options.minItems - newNode.options.tupleItems;
                                }
                                if (!nodeDataMap.has('maxItems')) {
                                    nodeDataMap.set('maxItems', newNode.options.maxItems);
                                    nodeDataMap.set('minItems', newNode.options.minItems);
                                    nodeDataMap.set('tupleItems', newNode.options.tupleItems);
                                    nodeDataMap.set('listItems', newNode.options.listItems);
                                }
                                if (!jsf.arrayMap.has(shortDataPointer)) {
                                    jsf.arrayMap.set(shortDataPointer, newNode.options.tupleItems);
                                }
                            }
                            if (isInputRequired(jsf.schema, schemaPointer)) {
                                newNode.options.required = true;
                                jsf.fieldsRequired = true;
                            }
                        }
                        else {
                            // TODO: create item in FormGroup model from layout key (?)
                            updateInputOptions(newNode, {}, jsf);
                        }
                        if (!newNode.options.title && !/^\d+$/.test(newNode.name)) {
                            newNode.options.title = fixTitle(newNode.name);
                        }
                        if (hasOwn(newNode.options, 'copyValueTo')) {
                            if (typeof newNode.options.copyValueTo === 'string') {
                                newNode.options.copyValueTo = [newNode.options.copyValueTo];
                            }
                            if (isArray(newNode.options.copyValueTo)) {
                                newNode.options.copyValueTo = newNode.options.copyValueTo.map(function (item) { return JsonPointer.compile(JsonPointer.parseObjectPath(item), '-'); });
                            }
                        }
                        newNode.widget = widgetLibrary.getWidget(newNode.type);
                        nodeDataMap.set('inputType', newNode.type);
                        nodeDataMap.set('widget', newNode.widget);
                        if (newNode.dataType === 'array' &&
                            (hasOwn(newNode, 'items') || hasOwn(newNode, 'additionalItems'))) {
                            var itemRefPointer_1 = removeRecursiveReferences(newNode.dataPointer + '/-', jsf.dataRecursiveRefMap, jsf.arrayMap);
                            if (!jsf.dataMap.has(itemRefPointer_1)) {
                                jsf.dataMap.set(itemRefPointer_1, new Map());
                            }
                            jsf.dataMap.get(itemRefPointer_1).set('inputType', 'section');
                            // Fix insufficiently nested array item groups
                            if (newNode.items.length > 1) {
                                var arrayItemGroup = [];
                                for (var i = newNode.items.length - 1; i >= 0; i--) {
                                    var subItem = newNode.items[i];
                                    if (hasOwn(subItem, 'dataPointer') &&
                                        subItem.dataPointer.slice(0, itemRefPointer_1.length) === itemRefPointer_1) {
                                        var arrayItem = newNode.items.splice(i, 1)[0];
                                        arrayItem.dataPointer = newNode.dataPointer + '/-' +
                                            arrayItem.dataPointer.slice(itemRefPointer_1.length);
                                        arrayItemGroup.unshift(arrayItem);
                                    }
                                    else {
                                        subItem.arrayItem = true;
                                        // TODO: Check schema to get arrayItemType and removable
                                        subItem.arrayItemType = 'list';
                                        subItem.removable = newNode.options.removable !== false;
                                    }
                                }
                                if (arrayItemGroup.length) {
                                    newNode.items.push({
                                        _id: Object(lodash_es_uniqueId__WEBPACK_IMPORTED_MODULE_11__["default"])(),
                                        arrayItem: true,
                                        arrayItemType: newNode.options.tupleItems > newNode.items.length ?
                                            'tuple' : 'list',
                                        items: arrayItemGroup,
                                        options: { removable: newNode.options.removable !== false, },
                                        dataPointer: newNode.dataPointer + '/-',
                                        type: 'section',
                                        widget: widgetLibrary.getWidget('section'),
                                    });
                                }
                            }
                            else {
                                // TODO: Fix to hndle multiple items
                                newNode.items[0].arrayItem = true;
                                if (!newNode.items[0].dataPointer) {
                                    newNode.items[0].dataPointer =
                                        JsonPointer.toGenericPointer(itemRefPointer_1, jsf.arrayMap);
                                }
                                if (!JsonPointer.has(newNode, '/items/0/options/removable')) {
                                    newNode.items[0].options.removable = true;
                                }
                                if (newNode.options.orderable === false) {
                                    newNode.items[0].options.orderable = false;
                                }
                                newNode.items[0].arrayItemType =
                                    newNode.options.tupleItems ? 'tuple' : 'list';
                            }
                            if (isArray(newNode.items)) {
                                var arrayListItems = newNode.items.filter(function (item) { return item.type !== '$ref'; }).length -
                                    newNode.options.tupleItems;
                                if (arrayListItems > newNode.options.listItems) {
                                    newNode.options.listItems = arrayListItems;
                                    nodeDataMap.set('listItems', arrayListItems);
                                }
                            }
                            if (!hasOwn(jsf.layoutRefLibrary, itemRefPointer_1)) {
                                jsf.layoutRefLibrary[itemRefPointer_1] =
                                    Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(newNode.items[newNode.items.length - 1]);
                                if (recursive_1) {
                                    jsf.layoutRefLibrary[itemRefPointer_1].recursiveReference = true;
                                }
                                forEach(jsf.layoutRefLibrary[itemRefPointer_1], function (item, key) {
                                    if (hasOwn(item, '_id')) {
                                        item._id = null;
                                    }
                                    if (recursive_1) {
                                        if (hasOwn(item, 'dataPointer')) {
                                            item.dataPointer = item.dataPointer.slice(itemRefPointer_1.length);
                                        }
                                    }
                                }, 'top-down');
                            }
                            // Add any additional default items
                            if (!newNode.recursiveReference || newNode.options.required) {
                                var arrayLength = Math.min(Math.max(newNode.options.tupleItems + newNode.options.listItems, isArray(nodeValue) ? nodeValue.length : 0), newNode.options.maxItems);
                                for (var i = newNode.items.length; i < arrayLength; i++) {
                                    newNode.items.push(getLayoutNode({
                                        $ref: itemRefPointer_1,
                                        dataPointer: newNode.dataPointer,
                                        recursiveReference: newNode.recursiveReference,
                                    }, jsf, widgetLibrary));
                                }
                            }
                            // If needed, add button to add items to array
                            if (newNode.options.addable !== false &&
                                newNode.options.minItems < newNode.options.maxItems &&
                                (newNode.items[newNode.items.length - 1] || {}).type !== '$ref') {
                                var buttonText = 'Add';
                                if (newNode.options.title) {
                                    if (/^add\b/i.test(newNode.options.title)) {
                                        buttonText = newNode.options.title;
                                    }
                                    else {
                                        buttonText += ' ' + newNode.options.title;
                                    }
                                }
                                else if (newNode.name && !/^\d+$/.test(newNode.name)) {
                                    if (/^add\b/i.test(newNode.name)) {
                                        buttonText += ' ' + fixTitle(newNode.name);
                                    }
                                    else {
                                        buttonText = fixTitle(newNode.name);
                                    }
                                    // If newNode doesn't have a title, look for title of parent array item
                                }
                                else {
                                    var parentSchema = getFromSchema(jsf.schema, newNode.dataPointer, 'parentSchema');
                                    if (hasOwn(parentSchema, 'title')) {
                                        buttonText += ' to ' + parentSchema.title;
                                    }
                                    else {
                                        var pointerArray = JsonPointer.parse(newNode.dataPointer);
                                        buttonText += ' to ' + fixTitle(pointerArray[pointerArray.length - 2]);
                                    }
                                }
                                newNode.items.push({
                                    _id: Object(lodash_es_uniqueId__WEBPACK_IMPORTED_MODULE_11__["default"])(),
                                    arrayItem: true,
                                    arrayItemType: 'list',
                                    dataPointer: newNode.dataPointer + '/-',
                                    options: {
                                        listItems: newNode.options.listItems,
                                        maxItems: newNode.options.maxItems,
                                        minItems: newNode.options.minItems,
                                        removable: false,
                                        title: buttonText,
                                        tupleItems: newNode.options.tupleItems,
                                    },
                                    recursiveReference: recursive_1,
                                    type: '$ref',
                                    widget: widgetLibrary.getWidget('$ref'),
                                    $ref: itemRefPointer_1,
                                });
                                if (isString(JsonPointer.get(newNode, '/style/add'))) {
                                    newNode.items[newNode.items.length - 1].options.fieldStyle =
                                        newNode.style.add;
                                    delete newNode.style.add;
                                    if (isEmpty(newNode.style)) {
                                        delete newNode.style;
                                    }
                                }
                            }
                        }
                        else {
                            newNode.arrayItem = false;
                        }
                    }
                    else if (hasOwn(newNode, 'type') || hasOwn(newNode, 'items')) {
                        var parentType = JsonPointer.get(jsf.layout, layoutPointer, 0, -2).type;
                        if (!hasOwn(newNode, 'type')) {
                            newNode.type =
                                inArray(parentType, ['tabs', 'tabarray']) ? 'tab' : 'array';
                        }
                        newNode.arrayItem = parentType === 'array';
                        newNode.widget = widgetLibrary.getWidget(newNode.type);
                        updateInputOptions(newNode, {}, jsf);
                    }
                    if (newNode.type === 'submit') {
                        hasSubmitButton = true;
                    }
                    return newNode;
                });
                if (jsf.hasRootReference) {
                    var fullLayout = Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(formLayout);
                    if (fullLayout[fullLayout.length - 1].type === 'submit') {
                        fullLayout.pop();
                    }
                    jsf.layoutRefLibrary[''] = {
                        _id: null,
                        dataPointer: '',
                        dataType: 'object',
                        items: fullLayout,
                        name: '',
                        options: Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(jsf.formOptions.defautWidgetOptions),
                        recursiveReference: true,
                        required: false,
                        type: 'section',
                        widget: widgetLibrary.getWidget('section'),
                    };
                }
                if (!hasSubmitButton) {
                    formLayout.push({
                        _id: Object(lodash_es_uniqueId__WEBPACK_IMPORTED_MODULE_11__["default"])(),
                        options: { title: 'Submit' },
                        type: 'submit',
                        widget: widgetLibrary.getWidget('submit'),
                    });
                }
                return formLayout;
            }
            /**
             * 'buildLayoutFromSchema' function
             *
             * //   jsf -
             * //   widgetLibrary -
             * //   nodeValue -
             * //  { string = '' } schemaPointer -
             * //  { string = '' } dataPointer -
             * //  { boolean = false } arrayItem -
             * //  { string = null } arrayItemType -
             * //  { boolean = null } removable -
             * //  { boolean = false } forRefLibrary -
             * //  { string = '' } dataPointerPrefix -
             * //
             */
            function buildLayoutFromSchema(jsf, widgetLibrary, nodeValue, schemaPointer, dataPointer, arrayItem, arrayItemType, removable, forRefLibrary, dataPointerPrefix) {
                if (nodeValue === void 0) { nodeValue = null; }
                if (schemaPointer === void 0) { schemaPointer = ''; }
                if (dataPointer === void 0) { dataPointer = ''; }
                if (arrayItem === void 0) { arrayItem = false; }
                if (arrayItemType === void 0) { arrayItemType = null; }
                if (removable === void 0) { removable = null; }
                if (forRefLibrary === void 0) { forRefLibrary = false; }
                if (dataPointerPrefix === void 0) { dataPointerPrefix = ''; }
                var schema = JsonPointer.get(jsf.schema, schemaPointer);
                if (!hasOwn(schema, 'type') && !hasOwn(schema, '$ref') &&
                    !hasOwn(schema, 'x-schema-form')) {
                    return null;
                }
                var newNodeType = getInputType(schema);
                if (!isDefined(nodeValue) && (jsf.formOptions.setSchemaDefaults === true ||
                    (jsf.formOptions.setSchemaDefaults === 'auto' && isEmpty(jsf.formValues)))) {
                    nodeValue = JsonPointer.get(jsf.schema, schemaPointer + '/default');
                }
                var newNode = {
                    _id: forRefLibrary ? null : Object(lodash_es_uniqueId__WEBPACK_IMPORTED_MODULE_11__["default"])(),
                    arrayItem: arrayItem,
                    dataPointer: JsonPointer.toGenericPointer(dataPointer, jsf.arrayMap),
                    dataType: schema.type || (hasOwn(schema, '$ref') ? '$ref' : null),
                    options: {},
                    required: isInputRequired(jsf.schema, schemaPointer),
                    type: newNodeType,
                    widget: widgetLibrary.getWidget(newNodeType),
                };
                var lastDataKey = JsonPointer.toKey(newNode.dataPointer);
                if (lastDataKey !== '-') {
                    newNode.name = lastDataKey;
                }
                if (newNode.arrayItem) {
                    newNode.arrayItemType = arrayItemType;
                    newNode.options.removable = removable !== false;
                }
                var shortDataPointer = removeRecursiveReferences(dataPointerPrefix + dataPointer, jsf.dataRecursiveRefMap, jsf.arrayMap);
                var recursive = !shortDataPointer.length ||
                    shortDataPointer !== dataPointerPrefix + dataPointer;
                if (!jsf.dataMap.has(shortDataPointer)) {
                    jsf.dataMap.set(shortDataPointer, new Map());
                }
                var nodeDataMap = jsf.dataMap.get(shortDataPointer);
                if (!nodeDataMap.has('inputType')) {
                    nodeDataMap.set('schemaPointer', schemaPointer);
                    nodeDataMap.set('inputType', newNode.type);
                    nodeDataMap.set('widget', newNode.widget);
                    nodeDataMap.set('disabled', !!newNode.options.disabled);
                }
                updateInputOptions(newNode, schema, jsf);
                if (!newNode.options.title && newNode.name && !/^\d+$/.test(newNode.name)) {
                    newNode.options.title = fixTitle(newNode.name);
                }
                if (newNode.dataType === 'object') {
                    if (isArray(schema.required) && !nodeDataMap.has('required')) {
                        nodeDataMap.set('required', schema.required);
                    }
                    if (isObject(schema.properties)) {
                        var newSection_1 = [];
                        var propertyKeys_2 = schema['ui:order'] || Object.keys(schema.properties);
                        if (propertyKeys_2.includes('*') && !hasOwn(schema.properties, '*')) {
                            var unnamedKeys = Object.keys(schema.properties)
                                .filter(function (key) { return !propertyKeys_2.includes(key); });
                            for (var i = propertyKeys_2.length - 1; i >= 0; i--) {
                                if (propertyKeys_2[i] === '*') {
                                    propertyKeys_2.splice.apply(propertyKeys_2, [i, 1].concat(unnamedKeys));
                                }
                            }
                        }
                        propertyKeys_2
                            .filter(function (key) { return hasOwn(schema.properties, key) ||
                            hasOwn(schema, 'additionalProperties'); })
                            .forEach(function (key) {
                            var keySchemaPointer = hasOwn(schema.properties, key) ?
                                '/properties/' + key : '/additionalProperties';
                            var innerItem = buildLayoutFromSchema(jsf, widgetLibrary, isObject(nodeValue) ? nodeValue[key] : null, schemaPointer + keySchemaPointer, dataPointer + '/' + key, false, null, null, forRefLibrary, dataPointerPrefix);
                            if (innerItem) {
                                if (isInputRequired(schema, '/' + key)) {
                                    innerItem.options.required = true;
                                    jsf.fieldsRequired = true;
                                }
                                newSection_1.push(innerItem);
                            }
                        });
                        if (dataPointer === '' && !forRefLibrary) {
                            newNode = newSection_1;
                        }
                        else {
                            newNode.items = newSection_1;
                        }
                    }
                    // TODO: Add patternProperties and additionalProperties inputs?
                    // ... possibly provide a way to enter both key names and values?
                    // if (isObject(schema.patternProperties)) { }
                    // if (isObject(schema.additionalProperties)) { }
                }
                else if (newNode.dataType === 'array') {
                    newNode.items = [];
                    newNode.options.maxItems = Math.min(schema.maxItems || 1000, newNode.options.maxItems || 1000);
                    newNode.options.minItems = Math.max(schema.minItems || 0, newNode.options.minItems || 0);
                    if (!newNode.options.minItems && isInputRequired(jsf.schema, schemaPointer)) {
                        newNode.options.minItems = 1;
                    }
                    if (!hasOwn(newNode.options, 'listItems')) {
                        newNode.options.listItems = 1;
                    }
                    newNode.options.tupleItems = isArray(schema.items) ? schema.items.length : 0;
                    if (newNode.options.maxItems <= newNode.options.tupleItems) {
                        newNode.options.tupleItems = newNode.options.maxItems;
                        newNode.options.listItems = 0;
                    }
                    else if (newNode.options.maxItems <
                        newNode.options.tupleItems + newNode.options.listItems) {
                        newNode.options.listItems = newNode.options.maxItems - newNode.options.tupleItems;
                    }
                    else if (newNode.options.minItems >
                        newNode.options.tupleItems + newNode.options.listItems) {
                        newNode.options.listItems = newNode.options.minItems - newNode.options.tupleItems;
                    }
                    if (!nodeDataMap.has('maxItems')) {
                        nodeDataMap.set('maxItems', newNode.options.maxItems);
                        nodeDataMap.set('minItems', newNode.options.minItems);
                        nodeDataMap.set('tupleItems', newNode.options.tupleItems);
                        nodeDataMap.set('listItems', newNode.options.listItems);
                    }
                    if (!jsf.arrayMap.has(shortDataPointer)) {
                        jsf.arrayMap.set(shortDataPointer, newNode.options.tupleItems);
                    }
                    removable = newNode.options.removable !== false;
                    var additionalItemsSchemaPointer = null;
                    // If 'items' is an array = tuple items
                    if (isArray(schema.items)) {
                        newNode.items = [];
                        for (var i = 0; i < newNode.options.tupleItems; i++) {
                            var newItem = void 0;
                            var itemRefPointer = removeRecursiveReferences(shortDataPointer + '/' + i, jsf.dataRecursiveRefMap, jsf.arrayMap);
                            var itemRecursive = !itemRefPointer.length ||
                                itemRefPointer !== shortDataPointer + '/' + i;
                            // If removable, add tuple item layout to layoutRefLibrary
                            if (removable && i >= newNode.options.minItems) {
                                if (!hasOwn(jsf.layoutRefLibrary, itemRefPointer)) {
                                    // Set to null first to prevent recursive reference from causing endless loop
                                    jsf.layoutRefLibrary[itemRefPointer] = null;
                                    jsf.layoutRefLibrary[itemRefPointer] = buildLayoutFromSchema(jsf, widgetLibrary, isArray(nodeValue) ? nodeValue[i] : null, schemaPointer + '/items/' + i, itemRecursive ? '' : dataPointer + '/' + i, true, 'tuple', true, true, itemRecursive ? dataPointer + '/' + i : '');
                                    if (itemRecursive) {
                                        jsf.layoutRefLibrary[itemRefPointer].recursiveReference = true;
                                    }
                                }
                                newItem = getLayoutNode({
                                    $ref: itemRefPointer,
                                    dataPointer: dataPointer + '/' + i,
                                    recursiveReference: itemRecursive,
                                }, jsf, widgetLibrary, isArray(nodeValue) ? nodeValue[i] : null);
                            }
                            else {
                                newItem = buildLayoutFromSchema(jsf, widgetLibrary, isArray(nodeValue) ? nodeValue[i] : null, schemaPointer + '/items/' + i, dataPointer + '/' + i, true, 'tuple', false, forRefLibrary, dataPointerPrefix);
                            }
                            if (newItem) {
                                newNode.items.push(newItem);
                            }
                        }
                        // If 'additionalItems' is an object = additional list items, after tuple items
                        if (isObject(schema.additionalItems)) {
                            additionalItemsSchemaPointer = schemaPointer + '/additionalItems';
                        }
                        // If 'items' is an object = list items only (no tuple items)
                    }
                    else if (isObject(schema.items)) {
                        additionalItemsSchemaPointer = schemaPointer + '/items';
                    }
                    if (additionalItemsSchemaPointer) {
                        var itemRefPointer = removeRecursiveReferences(shortDataPointer + '/-', jsf.dataRecursiveRefMap, jsf.arrayMap);
                        var itemRecursive = !itemRefPointer.length ||
                            itemRefPointer !== shortDataPointer + '/-';
                        var itemSchemaPointer = removeRecursiveReferences(additionalItemsSchemaPointer, jsf.schemaRecursiveRefMap, jsf.arrayMap);
                        // Add list item layout to layoutRefLibrary
                        if (itemRefPointer.length && !hasOwn(jsf.layoutRefLibrary, itemRefPointer)) {
                            // Set to null first to prevent recursive reference from causing endless loop
                            jsf.layoutRefLibrary[itemRefPointer] = null;
                            jsf.layoutRefLibrary[itemRefPointer] = buildLayoutFromSchema(jsf, widgetLibrary, null, itemSchemaPointer, itemRecursive ? '' : dataPointer + '/-', true, 'list', removable, true, itemRecursive ? dataPointer + '/-' : '');
                            if (itemRecursive) {
                                jsf.layoutRefLibrary[itemRefPointer].recursiveReference = true;
                            }
                        }
                        // Add any additional default items
                        if (!itemRecursive || newNode.options.required) {
                            var arrayLength = Math.min(Math.max(itemRecursive ? 0 :
                                newNode.options.tupleItems + newNode.options.listItems, isArray(nodeValue) ? nodeValue.length : 0), newNode.options.maxItems);
                            if (newNode.items.length < arrayLength) {
                                for (var i = newNode.items.length; i < arrayLength; i++) {
                                    newNode.items.push(getLayoutNode({
                                        $ref: itemRefPointer,
                                        dataPointer: dataPointer + '/-',
                                        recursiveReference: itemRecursive,
                                    }, jsf, widgetLibrary, isArray(nodeValue) ? nodeValue[i] : null));
                                }
                            }
                        }
                        // If needed, add button to add items to array
                        if (newNode.options.addable !== false &&
                            newNode.options.minItems < newNode.options.maxItems &&
                            (newNode.items[newNode.items.length - 1] || {}).type !== '$ref') {
                            var buttonText = ((jsf.layoutRefLibrary[itemRefPointer] || {}).options || {}).title;
                            var prefix = buttonText ? 'Add ' : 'Add to ';
                            if (!buttonText) {
                                buttonText = schema.title || fixTitle(JsonPointer.toKey(dataPointer));
                            }
                            if (!/^add\b/i.test(buttonText)) {
                                buttonText = prefix + buttonText;
                            }
                            newNode.items.push({
                                _id: Object(lodash_es_uniqueId__WEBPACK_IMPORTED_MODULE_11__["default"])(),
                                arrayItem: true,
                                arrayItemType: 'list',
                                dataPointer: newNode.dataPointer + '/-',
                                options: {
                                    listItems: newNode.options.listItems,
                                    maxItems: newNode.options.maxItems,
                                    minItems: newNode.options.minItems,
                                    removable: false,
                                    title: buttonText,
                                    tupleItems: newNode.options.tupleItems,
                                },
                                recursiveReference: itemRecursive,
                                type: '$ref',
                                widget: widgetLibrary.getWidget('$ref'),
                                $ref: itemRefPointer,
                            });
                        }
                    }
                }
                else if (newNode.dataType === '$ref') {
                    var schemaRef = JsonPointer.compile(schema.$ref);
                    var dataRef = JsonPointer.toDataPointer(schemaRef, jsf.schema);
                    var buttonText = '';
                    // Get newNode title
                    if (newNode.options.add) {
                        buttonText = newNode.options.add;
                    }
                    else if (newNode.name && !/^\d+$/.test(newNode.name)) {
                        buttonText =
                            (/^add\b/i.test(newNode.name) ? '' : 'Add ') + fixTitle(newNode.name);
                        // If newNode doesn't have a title, look for title of parent array item
                    }
                    else {
                        var parentSchema = JsonPointer.get(jsf.schema, schemaPointer, 0, -1);
                        if (hasOwn(parentSchema, 'title')) {
                            buttonText = 'Add to ' + parentSchema.title;
                        }
                        else {
                            var pointerArray = JsonPointer.parse(newNode.dataPointer);
                            buttonText = 'Add to ' + fixTitle(pointerArray[pointerArray.length - 2]);
                        }
                    }
                    Object.assign(newNode, {
                        recursiveReference: true,
                        widget: widgetLibrary.getWidget('$ref'),
                        $ref: dataRef,
                    });
                    Object.assign(newNode.options, {
                        removable: false,
                        title: buttonText,
                    });
                    if (isNumber(JsonPointer.get(jsf.schema, schemaPointer, 0, -1).maxItems)) {
                        newNode.options.maxItems =
                            JsonPointer.get(jsf.schema, schemaPointer, 0, -1).maxItems;
                    }
                    // Add layout template to layoutRefLibrary
                    if (dataRef.length) {
                        if (!hasOwn(jsf.layoutRefLibrary, dataRef)) {
                            // Set to null first to prevent recursive reference from causing endless loop
                            jsf.layoutRefLibrary[dataRef] = null;
                            var newLayout = buildLayoutFromSchema(jsf, widgetLibrary, null, schemaRef, '', newNode.arrayItem, newNode.arrayItemType, true, true, dataPointer);
                            if (newLayout) {
                                newLayout.recursiveReference = true;
                                jsf.layoutRefLibrary[dataRef] = newLayout;
                            }
                            else {
                                delete jsf.layoutRefLibrary[dataRef];
                            }
                        }
                        else if (!jsf.layoutRefLibrary[dataRef].recursiveReference) {
                            jsf.layoutRefLibrary[dataRef].recursiveReference = true;
                        }
                    }
                }
                return newNode;
            }
            /**
             * 'mapLayout' function
             *
             * Creates a new layout by running each element in an existing layout through
             * an iteratee. Recursively maps within array elements 'items' and 'tabs'.
             * The iteratee is invoked with four arguments: (value, index, layout, path)
             *
             * The returned layout may be longer (or shorter) then the source layout.
             *
             * If an item from the source layout returns multiple items (as '*' usually will),
             * this function will keep all returned items in-line with the surrounding items.
             *
             * If an item from the source layout causes an error and returns null, it is
             * skipped without error, and the function will still return all non-null items.
             *
             * //   layout - the layout to map
             * //  { (v: any, i?: number, l?: any, p?: string) => any }
             *   function - the funciton to invoke on each element
             * //  { string|string[] = '' } layoutPointer - the layoutPointer to layout, inside rootLayout
             * //  { any[] = layout } rootLayout - the root layout, which conatins layout
             * //
             */
            function mapLayout(layout, fn, layoutPointer, rootLayout) {
                if (layoutPointer === void 0) { layoutPointer = ''; }
                if (rootLayout === void 0) { rootLayout = layout; }
                var indexPad = 0;
                var newLayout = [];
                forEach(layout, function (item, index) {
                    var realIndex = +index + indexPad;
                    var newLayoutPointer = layoutPointer + '/' + realIndex;
                    var newNode = copy(item);
                    var itemsArray = [];
                    if (isObject(item)) {
                        if (hasOwn(item, 'tabs')) {
                            item.items = item.tabs;
                            delete item.tabs;
                        }
                        if (hasOwn(item, 'items')) {
                            itemsArray = isArray(item.items) ? item.items : [item.items];
                        }
                    }
                    if (itemsArray.length) {
                        newNode.items = mapLayout(itemsArray, fn, newLayoutPointer + '/items', rootLayout);
                    }
                    newNode = fn(newNode, realIndex, newLayoutPointer, rootLayout);
                    if (!isDefined(newNode)) {
                        indexPad--;
                    }
                    else {
                        if (isArray(newNode)) {
                            indexPad += newNode.length - 1;
                        }
                        newLayout = newLayout.concat(newNode);
                    }
                });
                return newLayout;
            }
            /**
             * 'getLayoutNode' function
             * Copy a new layoutNode from layoutRefLibrary
             *
             * //   refNode -
             * //   layoutRefLibrary -
             * //  { any = null } widgetLibrary -
             * //  { any = null } nodeValue -
             * //  copied layoutNode
             */
            function getLayoutNode(refNode, jsf, widgetLibrary, nodeValue) {
                if (widgetLibrary === void 0) { widgetLibrary = null; }
                if (nodeValue === void 0) { nodeValue = null; }
                // If recursive reference and building initial layout, return Add button
                if (refNode.recursiveReference && widgetLibrary) {
                    var newLayoutNode = Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(refNode);
                    if (!newLayoutNode.options) {
                        newLayoutNode.options = {};
                    }
                    Object.assign(newLayoutNode, {
                        recursiveReference: true,
                        widget: widgetLibrary.getWidget('$ref'),
                    });
                    Object.assign(newLayoutNode.options, {
                        removable: false,
                        title: 'Add ' + newLayoutNode.$ref,
                    });
                    return newLayoutNode;
                    // Otherwise, return referenced layout
                }
                else {
                    var newLayoutNode = jsf.layoutRefLibrary[refNode.$ref];
                    // If value defined, build new node from schema (to set array lengths)
                    if (isDefined(nodeValue)) {
                        newLayoutNode = buildLayoutFromSchema(jsf, widgetLibrary, nodeValue, JsonPointer.toSchemaPointer(refNode.$ref, jsf.schema), refNode.$ref, newLayoutNode.arrayItem, newLayoutNode.arrayItemType, newLayoutNode.options.removable, false);
                    }
                    else {
                        // If value not defined, copy node from layoutRefLibrary
                        newLayoutNode = Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(newLayoutNode);
                        JsonPointer.forEachDeep(newLayoutNode, function (subNode, pointer) {
                            // Reset all _id's in newLayoutNode to unique values
                            if (hasOwn(subNode, '_id')) {
                                subNode._id = Object(lodash_es_uniqueId__WEBPACK_IMPORTED_MODULE_11__["default"])();
                            }
                            // If adding a recursive item, prefix current dataPointer
                            // to all dataPointers in new layoutNode
                            if (refNode.recursiveReference && hasOwn(subNode, 'dataPointer')) {
                                subNode.dataPointer = refNode.dataPointer + subNode.dataPointer;
                            }
                        });
                    }
                    return newLayoutNode;
                }
            }
            /**
             * 'buildTitleMap' function
             *
             * //   titleMap -
             * //   enumList -
             * //  { boolean = true } fieldRequired -
             * //  { boolean = true } flatList -
             * // { TitleMapItem[] }
             */
            function buildTitleMap(titleMap, enumList, fieldRequired, flatList) {
                if (fieldRequired === void 0) { fieldRequired = true; }
                if (flatList === void 0) { flatList = true; }
                var newTitleMap = [];
                var hasEmptyValue = false;
                if (titleMap) {
                    if (isArray(titleMap)) {
                        if (enumList) {
                            for (var _a = 0, _b = Object.keys(titleMap); _a < _b.length; _a++) {
                                var i = _b[_a];
                                if (isObject(titleMap[i])) { // JSON Form style
                                    var value = titleMap[i].value;
                                    if (enumList.includes(value)) {
                                        var name = titleMap[i].name;
                                        newTitleMap.push({ name: name, value: value });
                                        if (value === undefined || value === null) {
                                            hasEmptyValue = true;
                                        }
                                    }
                                }
                                else if (isString(titleMap[i])) { // React Jsonschema Form style
                                    if (i < enumList.length) {
                                        var name = titleMap[i];
                                        var value = enumList[i];
                                        newTitleMap.push({ name: name, value: value });
                                        if (value === undefined || value === null) {
                                            hasEmptyValue = true;
                                        }
                                    }
                                }
                            }
                        }
                        else { // If array titleMap and no enum list, just return the titleMap - Angular Schema Form style
                            newTitleMap = titleMap;
                            if (!fieldRequired) {
                                hasEmptyValue = !!newTitleMap
                                    .filter(function (i) { return i.value === undefined || i.value === null; })
                                    .length;
                            }
                        }
                    }
                    else if (enumList) { // Alternate JSON Form style, with enum list
                        for (var _f = 0, _g = Object.keys(enumList); _f < _g.length; _f++) {
                            var i = _g[_f];
                            var value = enumList[i];
                            if (hasOwn(titleMap, value)) {
                                var name = titleMap[value];
                                newTitleMap.push({ name: name, value: value });
                                if (value === undefined || value === null) {
                                    hasEmptyValue = true;
                                }
                            }
                        }
                    }
                    else { // Alternate JSON Form style, without enum list
                        for (var _h = 0, _j = Object.keys(titleMap); _h < _j.length; _h++) {
                            var value = _j[_h];
                            var name = titleMap[value];
                            newTitleMap.push({ name: name, value: value });
                            if (value === undefined || value === null) {
                                hasEmptyValue = true;
                            }
                        }
                    }
                }
                else if (enumList) { // Build map from enum list alone
                    for (var _k = 0, _l = Object.keys(enumList); _k < _l.length; _k++) {
                        var i = _l[_k];
                        var name = enumList[i];
                        var value = enumList[i];
                        newTitleMap.push({ name: name, value: value });
                        if (value === undefined || value === null) {
                            hasEmptyValue = true;
                        }
                    }
                }
                else { // If no titleMap and no enum list, return default map of boolean values
                    newTitleMap = [{ name: 'True', value: true }, { name: 'False', value: false }];
                }
                // Does titleMap have groups?
                if (newTitleMap.some(function (title) { return hasOwn(title, 'group'); })) {
                    hasEmptyValue = false;
                    // If flatList = true, flatten items & update name to group: name
                    if (flatList) {
                        newTitleMap = newTitleMap.reduce(function (groupTitleMap, title) {
                            if (hasOwn(title, 'group')) {
                                if (isArray(title.items)) {
                                    groupTitleMap = groupTitleMap.concat(title.items.map(function (item) { return (Object.assign({}, item, { name: title.group + ": " + item.name })); }));
                                    if (title.items.some(function (item) { return item.value === undefined || item.value === null; })) {
                                        hasEmptyValue = true;
                                    }
                                }
                                if (hasOwn(title, 'name') && hasOwn(title, 'value')) {
                                    title.name = title.group + ": " + title.name;
                                    delete title.group;
                                    groupTitleMap.push(title);
                                    if (title.value === undefined || title.value === null) {
                                        hasEmptyValue = true;
                                    }
                                }
                            }
                            else {
                                groupTitleMap.push(title);
                                if (title.value === undefined || title.value === null) {
                                    hasEmptyValue = true;
                                }
                            }
                            return groupTitleMap;
                        }, []);
                        // If flatList = false, combine items from matching groups
                    }
                    else {
                        newTitleMap = newTitleMap.reduce(function (groupTitleMap, title) {
                            if (hasOwn(title, 'group')) {
                                if (title.group !== (groupTitleMap[groupTitleMap.length - 1] || {}).group) {
                                    groupTitleMap.push({ group: title.group, items: title.items || [] });
                                }
                                if (hasOwn(title, 'name') && hasOwn(title, 'value')) {
                                    groupTitleMap[groupTitleMap.length - 1].items
                                        .push({ name: title.name, value: title.value });
                                    if (title.value === undefined || title.value === null) {
                                        hasEmptyValue = true;
                                    }
                                }
                            }
                            else {
                                groupTitleMap.push(title);
                                if (title.value === undefined || title.value === null) {
                                    hasEmptyValue = true;
                                }
                            }
                            return groupTitleMap;
                        }, []);
                    }
                }
                if (!fieldRequired && !hasEmptyValue) {
                    newTitleMap.unshift({ name: '<em>None</em>', value: null });
                }
                return newTitleMap;
            }
            var ɵ0 = function (error) {
                switch (error.requiredFormat) {
                    case 'date':
                        return 'Must be a date, like "2000-12-31"';
                    case 'time':
                        return 'Must be a time, like "16:20" or "03:14:15.9265"';
                    case 'date-time':
                        return 'Must be a date-time, like "2000-03-14T01:59" or "2000-03-14T01:59:26.535Z"';
                    case 'email':
                        return 'Must be an email address, like "name@example.com"';
                    case 'hostname':
                        return 'Must be a hostname, like "example.com"';
                    case 'ipv4':
                        return 'Must be an IPv4 address, like "127.0.0.1"';
                    case 'ipv6':
                        return 'Must be an IPv6 address, like "1234:5678:9ABC:DEF0:1234:5678:9ABC:DEF0"';
                    // TODO: add examples for 'uri', 'uri-reference', and 'uri-template'
                    // case 'uri': case 'uri-reference': case 'uri-template':
                    case 'url':
                        return 'Must be a url, like "http://www.example.com/page.html"';
                    case 'uuid':
                        return 'Must be a uuid, like "12345678-9ABC-DEF0-1234-56789ABCDEF0"';
                    case 'color':
                        return 'Must be a color, like "#FFFFFF" or "rgb(255, 255, 255)"';
                    case 'json-pointer':
                        return 'Must be a JSON Pointer, like "/pointer/to/something"';
                    case 'relative-json-pointer':
                        return 'Must be a relative JSON Pointer, like "2/pointer/to/something"';
                    case 'regex':
                        return 'Must be a regular expression, like "(1-)?\\d{3}-\\d{3}-\\d{4}"';
                    default:
                        return 'Must be a correctly formatted ' + error.requiredFormat;
                }
            }, ɵ1 = function (error) {
                if ((1 / error.multipleOfValue) % 10 === 0) {
                    var decimals = Math.log10(1 / error.multipleOfValue);
                    return "Must have " + decimals + " or fewer decimal places.";
                }
                else {
                    return "Must be a multiple of " + error.multipleOfValue + ".";
                }
            };
            var enValidationMessages = {
                required: 'This field is required.',
                minLength: 'Must be {{minimumLength}} characters or longer (current length: {{currentLength}})',
                maxLength: 'Must be {{maximumLength}} characters or shorter (current length: {{currentLength}})',
                pattern: 'Must match pattern: {{requiredPattern}}',
                format: ɵ0,
                minimum: 'Must be {{minimumValue}} or more',
                exclusiveMinimum: 'Must be more than {{exclusiveMinimumValue}}',
                maximum: 'Must be {{maximumValue}} or less',
                exclusiveMaximum: 'Must be less than {{exclusiveMaximumValue}}',
                multipleOf: ɵ1,
                minProperties: 'Must have {{minimumProperties}} or more items (current items: {{currentProperties}})',
                maxProperties: 'Must have {{maximumProperties}} or fewer items (current items: {{currentProperties}})',
                minItems: 'Must have {{minimumItems}} or more items (current items: {{currentItems}})',
                maxItems: 'Must have {{maximumItems}} or fewer items (current items: {{currentItems}})',
                uniqueItems: 'All items must be unique',
            };
            var ɵ0$1 = function (error) {
                switch (error.requiredFormat) {
                    case 'date':
                        return 'Doit être une date, tel que "2000-12-31"';
                    case 'time':
                        return 'Doit être une heure, tel que "16:20" ou "03:14:15.9265"';
                    case 'date-time':
                        return 'Doit être une date et une heure, tel que "2000-03-14T01:59" ou "2000-03-14T01:59:26.535Z"';
                    case 'email':
                        return 'Doit être une adresse e-mail, tel que "name@example.com"';
                    case 'hostname':
                        return 'Doit être un nom de domaine, tel que "example.com"';
                    case 'ipv4':
                        return 'Doit être une adresse IPv4, tel que "127.0.0.1"';
                    case 'ipv6':
                        return 'Doit être une adresse IPv6, tel que "1234:5678:9ABC:DEF0:1234:5678:9ABC:DEF0"';
                    // TODO: add examples for 'uri', 'uri-reference', and 'uri-template'
                    // case 'uri': case 'uri-reference': case 'uri-template':
                    case 'url':
                        return 'Doit être une URL, tel que "http://www.example.com/page.html"';
                    case 'uuid':
                        return 'Doit être un UUID, tel que "12345678-9ABC-DEF0-1234-56789ABCDEF0"';
                    case 'color':
                        return 'Doit être une couleur, tel que "#FFFFFF" or "rgb(255, 255, 255)"';
                    case 'json-pointer':
                        return 'Doit être un JSON Pointer, tel que "/pointer/to/something"';
                    case 'relative-json-pointer':
                        return 'Doit être un relative JSON Pointer, tel que "2/pointer/to/something"';
                    case 'regex':
                        return 'Doit être une expression régulière, tel que "(1-)?\\d{3}-\\d{3}-\\d{4}"';
                    default:
                        return 'Doit être avoir le format correct: ' + error.requiredFormat;
                }
            }, ɵ1$1 = function (error) {
                if ((1 / error.multipleOfValue) % 10 === 0) {
                    var decimals = Math.log10(1 / error.multipleOfValue);
                    return "Doit comporter " + decimals + " ou moins de decimales.";
                }
                else {
                    return "Doit \u00EAtre un multiple de " + error.multipleOfValue + ".";
                }
            };
            var frValidationMessages = {
                required: 'Est obligatoire.',
                minLength: 'Doit avoir minimum {{minimumLength}} caractères (actuellement: {{currentLength}})',
                maxLength: 'Doit avoir maximum {{maximumLength}} caractères (actuellement: {{currentLength}})',
                pattern: 'Doit respecter: {{requiredPattern}}',
                format: ɵ0$1,
                minimum: 'Doit être supérieur à {{minimumValue}}',
                exclusiveMinimum: 'Doit avoir minimum {{exclusiveMinimumValue}} charactères',
                maximum: 'Doit être inférieur à {{maximumValue}}',
                exclusiveMaximum: 'Doit avoir maximum {{exclusiveMaximumValue}} charactères',
                multipleOf: ɵ1$1,
                minProperties: 'Doit comporter au minimum {{minimumProperties}} éléments',
                maxProperties: 'Doit comporter au maximum {{maximumProperties}} éléments',
                minItems: 'Doit comporter au minimum {{minimumItems}} éléments',
                maxItems: 'Doit comporter au maximum {{minimumItems}} éléments',
                uniqueItems: 'Tous les éléments doivent être uniques',
            };
            var ɵ0$2 = function (error) {
                switch (error.requiredFormat) {
                    case 'date':
                        return '必须为日期格式, 比如 "2000-12-31"';
                    case 'time':
                        return '必须为时间格式, 比如 "16:20" 或者 "03:14:15.9265"';
                    case 'date-time':
                        return '必须为日期时间格式, 比如 "2000-03-14T01:59" 或者 "2000-03-14T01:59:26.535Z"';
                    case 'email':
                        return '必须为邮箱地址, 比如 "name@example.com"';
                    case 'hostname':
                        return '必须为主机名, 比如 "example.com"';
                    case 'ipv4':
                        return '必须为 IPv4 地址, 比如 "127.0.0.1"';
                    case 'ipv6':
                        return '必须为 IPv6 地址, 比如 "1234:5678:9ABC:DEF0:1234:5678:9ABC:DEF0"';
                    // TODO: add examples for 'uri', 'uri-reference', and 'uri-template'
                    // case 'uri': case 'uri-reference': case 'uri-template':
                    case 'url':
                        return '必须为 url, 比如 "http://www.example.com/page.html"';
                    case 'uuid':
                        return '必须为 uuid, 比如 "12345678-9ABC-DEF0-1234-56789ABCDEF0"';
                    case 'color':
                        return '必须为颜色值, 比如 "#FFFFFF" 或者 "rgb(255, 255, 255)"';
                    case 'json-pointer':
                        return '必须为 JSON Pointer, 比如 "/pointer/to/something"';
                    case 'relative-json-pointer':
                        return '必须为相对的 JSON Pointer, 比如 "2/pointer/to/something"';
                    case 'regex':
                        return '必须为正则表达式, 比如 "(1-)?\\d{3}-\\d{3}-\\d{4}"';
                    default:
                        return '必须为格式正确的 ' + error.requiredFormat;
                }
            }, ɵ1$2 = function (error) {
                if ((1 / error.multipleOfValue) % 10 === 0) {
                    var decimals = Math.log10(1 / error.multipleOfValue);
                    return "\u5FC5\u987B\u6709 " + decimals + " \u4F4D\u6216\u66F4\u5C11\u7684\u5C0F\u6570\u4F4D";
                }
                else {
                    return "\u5FC5\u987B\u4E3A " + error.multipleOfValue + " \u7684\u500D\u6570";
                }
            };
            var zhValidationMessages = {
                required: '必填字段.',
                minLength: '字符长度必须大于或者等于 {{minimumLength}} (当前长度: {{currentLength}})',
                maxLength: '字符长度必须小于或者等于 {{maximumLength}} (当前长度: {{currentLength}})',
                pattern: '必须匹配正则表达式: {{requiredPattern}}',
                format: ɵ0$2,
                minimum: '必须大于或者等于最小值: {{minimumValue}}',
                exclusiveMinimum: '必须大于最小值: {{exclusiveMinimumValue}}',
                maximum: '必须小于或者等于最大值: {{maximumValue}}',
                exclusiveMaximum: '必须小于最大值: {{exclusiveMaximumValue}}',
                multipleOf: ɵ1$2,
                minProperties: '项目数必须大于或者等于 {{minimumProperties}} (当前项目数: {{currentProperties}})',
                maxProperties: '项目数必须小于或者等于 {{maximumProperties}} (当前项目数: {{currentProperties}})',
                minItems: '项目数必须大于或者等于 {{minimumItems}} (当前项目数: {{currentItems}})',
                maxItems: '项目数必须小于或者等于 {{maximumItems}} (当前项目数: {{currentItems}})',
                uniqueItems: '所有项目必须是唯一的',
            };
            var JsonSchemaFormService = /** @class */ (function () {
                function JsonSchemaFormService() {
                    this.JsonFormCompatibility = false;
                    this.ReactJsonSchemaFormCompatibility = false;
                    this.AngularSchemaFormCompatibility = false;
                    this.tpldata = {};
                    this.ajvOptions = { allErrors: true, jsonPointers: true, unknownFormats: 'ignore' };
                    this.ajv = new ajv__WEBPACK_IMPORTED_MODULE_2___default.a(this.ajvOptions); // AJV: Another JSON Schema Validator
                    this.validateFormData = null; // Compiled AJV function to validate active form's schema
                    this.formValues = {}; // Internal form data (may not have correct types)
                    this.data = {}; // Output form data (formValues, formatted with correct data types)
                    this.schema = {}; // Internal JSON Schema
                    this.layout = []; // Internal form layout
                    this.formGroupTemplate = {}; // Template used to create formGroup
                    this.formGroup = null; // Angular formGroup, which powers the reactive form
                    this.framework = null; // Active framework component
                    this.validData = null; // Valid form data (or null) (=== isValid ? data : null)
                    this.isValid = null; // Is current form data valid?
                    this.ajvErrors = null; // Ajv errors for current data
                    this.validationErrors = null; // Any validation errors for current data
                    this.dataErrors = new Map(); //
                    this.formValueSubscription = null; // Subscription to formGroup.valueChanges observable (for un- and re-subscribing)
                    this.dataChanges = new rxjs__WEBPACK_IMPORTED_MODULE_7__["Subject"](); // Form data observable
                    this.isValidChanges = new rxjs__WEBPACK_IMPORTED_MODULE_7__["Subject"](); // isValid observable
                    this.validationErrorChanges = new rxjs__WEBPACK_IMPORTED_MODULE_7__["Subject"](); // validationErrors observable
                    this.arrayMap = new Map(); // Maps arrays in data object and number of tuple values
                    this.dataMap = new Map(); // Maps paths in form data to schema and formGroup paths
                    this.dataRecursiveRefMap = new Map(); // Maps recursive reference points in form data
                    this.schemaRecursiveRefMap = new Map(); // Maps recursive reference points in schema
                    this.schemaRefLibrary = {}; // Library of schemas for resolving schema $refs
                    this.layoutRefLibrary = { '': null }; // Library of layout nodes for adding to form
                    this.templateRefLibrary = {}; // Library of formGroup templates for adding to form
                    this.hasRootReference = false; // Does the form include a recursive reference to itself?
                    this.language = 'en-US'; // Does the form include a recursive reference to itself?
                    // Default global form options
                    this.defaultFormOptions = {
                        autocomplete: true,
                        addSubmit: 'auto',
                        // for addSubmit: true = always, false = never,
                        // 'auto' = only if layout is undefined (form is built from schema alone)
                        debug: false,
                        disableInvalidSubmit: true,
                        formDisabled: false,
                        formReadonly: false,
                        fieldsRequired: false,
                        framework: 'no-framework',
                        loadExternalAssets: false,
                        pristine: { errors: true, success: true },
                        supressPropertyTitles: false,
                        setSchemaDefaults: 'auto',
                        // true = always set (unless overridden by layout default or formValues)
                        // false = never set
                        // 'auto' = set in addable components, and everywhere if formValues not set
                        setLayoutDefaults: 'auto',
                        // true = always set (unless overridden by formValues)
                        // false = never set
                        // 'auto' = set in addable components, and everywhere if formValues not set
                        validateOnRender: 'auto',
                        // true = validate all fields immediately
                        // false = only validate fields after they are touched by user
                        // 'auto' = validate fields with values immediately, empty fields after they are touched
                        widgets: {},
                        defautWidgetOptions: {
                            listItems: 1,
                            addable: true,
                            orderable: true,
                            removable: true,
                            enableErrorState: true,
                            // disableErrorState: false, // Don't apply 'has-error' class when field fails validation?
                            enableSuccessState: true,
                            // disableSuccessState: false, // Don't apply 'has-success' class when field validates?
                            feedback: false,
                            feedbackOnRender: false,
                            notitle: false,
                            disabled: false,
                            readonly: false,
                            returnEmptyFields: true,
                            validationMessages: {} // set by setLanguage()
                        },
                    };
                    this.setLanguage(this.language);
                    this.ajv.addMetaSchema(ajv_lib_refs_json_schema_draft_06_json__WEBPACK_IMPORTED_MODULE_3__);
                }
                JsonSchemaFormService.prototype.setLanguage = function (language) {
                    if (language === void 0) { language = 'en-US'; }
                    this.language = language;
                    var languageValidationMessages = {
                        fr: frValidationMessages,
                        en: enValidationMessages,
                        zh: zhValidationMessages
                    };
                    var languageCode = language.slice(0, 2);
                    var validationMessages = languageValidationMessages[languageCode];
                    this.defaultFormOptions.defautWidgetOptions.validationMessages =
                        Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(validationMessages);
                };
                JsonSchemaFormService.prototype.getData = function () { return this.data; };
                JsonSchemaFormService.prototype.getSchema = function () { return this.schema; };
                JsonSchemaFormService.prototype.getLayout = function () { return this.layout; };
                JsonSchemaFormService.prototype.resetAllValues = function () {
                    this.JsonFormCompatibility = false;
                    this.ReactJsonSchemaFormCompatibility = false;
                    this.AngularSchemaFormCompatibility = false;
                    this.tpldata = {};
                    this.validateFormData = null;
                    this.formValues = {};
                    this.schema = {};
                    this.layout = [];
                    this.formGroupTemplate = {};
                    this.formGroup = null;
                    this.framework = null;
                    this.data = {};
                    this.validData = null;
                    this.isValid = null;
                    this.validationErrors = null;
                    this.arrayMap = new Map();
                    this.dataMap = new Map();
                    this.dataRecursiveRefMap = new Map();
                    this.schemaRecursiveRefMap = new Map();
                    this.layoutRefLibrary = {};
                    this.schemaRefLibrary = {};
                    this.templateRefLibrary = {};
                    this.formOptions = Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(this.defaultFormOptions);
                };
                /**
                 * 'buildRemoteError' function
                 *
                 * Example errors:
                 * {
                 *   last_name: [ {
                 *     message: 'Last name must by start with capital letter.',
                 *     code: 'capital_letter'
                 *   } ],
                 *   email: [ {
                 *     message: 'Email must be from example.com domain.',
                 *     code: 'special_domain'
                 *   }, {
                 *     message: 'Email must contain an @ symbol.',
                 *     code: 'at_symbol'
                 *   } ]
                 * }
                 * //{ErrorMessages} errors
                 */
                JsonSchemaFormService.prototype.buildRemoteError = function (errors) {
                    var _this_1 = this;
                    forEach(errors, function (value, key) {
                        if (key in _this_1.formGroup.controls) {
                            for (var _a = 0, value_1 = value; _a < value_1.length; _a++) {
                                var error = value_1[_a];
                                var err = {};
                                err[error['code']] = error['message'];
                                _this_1.formGroup.get(key).setErrors(err, { emitEvent: true });
                            }
                        }
                    });
                };
                JsonSchemaFormService.prototype.validateData = function (newValue, updateSubscriptions) {
                    if (updateSubscriptions === void 0) { updateSubscriptions = true; }
                    // Format raw form data to correct data types
                    this.data = formatFormData(newValue, this.dataMap, this.dataRecursiveRefMap, this.arrayMap, this.formOptions.returnEmptyFields);
                    this.isValid = this.validateFormData(this.data);
                    this.validData = this.isValid ? this.data : null;
                    var compileErrors = function (errors) {
                        var compiledErrors = {};
                        (errors || []).forEach(function (error) {
                            if (!compiledErrors[error.dataPath]) {
                                compiledErrors[error.dataPath] = [];
                            }
                            compiledErrors[error.dataPath].push(error.message);
                        });
                        return compiledErrors;
                    };
                    this.ajvErrors = this.validateFormData.errors;
                    this.validationErrors = compileErrors(this.validateFormData.errors);
                    if (updateSubscriptions) {
                        this.dataChanges.next(this.data);
                        this.isValidChanges.next(this.isValid);
                        this.validationErrorChanges.next(this.ajvErrors);
                    }
                };
                JsonSchemaFormService.prototype.buildFormGroupTemplate = function (formValues, setValues) {
                    if (formValues === void 0) { formValues = null; }
                    if (setValues === void 0) { setValues = true; }
                    this.formGroupTemplate = buildFormGroupTemplate(this, formValues, setValues);
                };
                JsonSchemaFormService.prototype.buildFormGroup = function () {
                    var _this_1 = this;
                    this.formGroup = buildFormGroup(this.formGroupTemplate);
                    if (this.formGroup) {
                        this.compileAjvSchema();
                        this.validateData(this.formGroup.value);
                        // Set up observables to emit data and validation info when form data changes
                        if (this.formValueSubscription) {
                            this.formValueSubscription.unsubscribe();
                        }
                        this.formValueSubscription = this.formGroup.valueChanges
                            .subscribe(function (formValue) { return _this_1.validateData(formValue); });
                    }
                };
                JsonSchemaFormService.prototype.buildLayout = function (widgetLibrary) {
                    this.layout = buildLayout(this, widgetLibrary);
                };
                JsonSchemaFormService.prototype.setOptions = function (newOptions) {
                    if (isObject(newOptions)) {
                        var addOptions = Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(newOptions);
                        // Backward compatibility for 'defaultOptions' (renamed 'defautWidgetOptions')
                        if (isObject(addOptions.defaultOptions)) {
                            Object.assign(this.formOptions.defautWidgetOptions, addOptions.defaultOptions);
                            delete addOptions.defaultOptions;
                        }
                        if (isObject(addOptions.defautWidgetOptions)) {
                            Object.assign(this.formOptions.defautWidgetOptions, addOptions.defautWidgetOptions);
                            delete addOptions.defautWidgetOptions;
                        }
                        Object.assign(this.formOptions, addOptions);
                        // convert disableErrorState / disableSuccessState to enable...
                        var globalDefaults_1 = this.formOptions.defautWidgetOptions;
                        ['ErrorState', 'SuccessState']
                            .filter(function (suffix) { return hasOwn(globalDefaults_1, 'disable' + suffix); })
                            .forEach(function (suffix) {
                            globalDefaults_1['enable' + suffix] = !globalDefaults_1['disable' + suffix];
                            delete globalDefaults_1['disable' + suffix];
                        });
                    }
                };
                JsonSchemaFormService.prototype.compileAjvSchema = function () {
                    if (!this.validateFormData) {
                        // if 'ui:order' exists in properties, move it to root before compiling with ajv
                        if (Array.isArray(this.schema.properties['ui:order'])) {
                            this.schema['ui:order'] = this.schema.properties['ui:order'];
                            delete this.schema.properties['ui:order'];
                        }
                        this.ajv.removeSchema(this.schema);
                        this.validateFormData = this.ajv.compile(this.schema);
                    }
                };
                JsonSchemaFormService.prototype.buildSchemaFromData = function (data, requireAllFields) {
                    if (requireAllFields === void 0) { requireAllFields = false; }
                    if (data) {
                        return buildSchemaFromData(data, requireAllFields);
                    }
                    this.schema = buildSchemaFromData(this.formValues, requireAllFields);
                };
                JsonSchemaFormService.prototype.buildSchemaFromLayout = function (layout) {
                    if (layout) {
                        return buildSchemaFromLayout();
                    }
                    this.schema = buildSchemaFromLayout(this.layout);
                };
                JsonSchemaFormService.prototype.setTpldata = function (newTpldata) {
                    if (newTpldata === void 0) { newTpldata = {}; }
                    this.tpldata = newTpldata;
                };
                JsonSchemaFormService.prototype.parseText = function (text, value, values, key) {
                    var _this_1 = this;
                    if (text === void 0) { text = ''; }
                    if (value === void 0) { value = {}; }
                    if (values === void 0) { values = {}; }
                    if (key === void 0) { key = null; }
                    if (!text || !/{{.+?}}/.test(text)) {
                        return text;
                    }
                    return text.replace(/{{(.+?)}}/g, function () {
                        var a = [];
                        for (var _a = 0; _a < arguments.length; _a++) {
                            a[_a] = arguments[_a];
                        }
                        return _this_1.parseExpression(a[1], value, values, key, _this_1.tpldata);
                    });
                };
                JsonSchemaFormService.prototype.parseExpression = function (expression, value, values, key, tpldata) {
                    var _this_1 = this;
                    if (expression === void 0) { expression = ''; }
                    if (value === void 0) { value = {}; }
                    if (values === void 0) { values = {}; }
                    if (key === void 0) { key = null; }
                    if (tpldata === void 0) { tpldata = null; }
                    if (typeof expression !== 'string') {
                        return '';
                    }
                    var index = typeof key === 'number' ? (key + 1) + '' : (key || '');
                    expression = expression.trim();
                    if ((expression[0] === '\'' || expression[0] === '"') &&
                        expression[0] === expression[expression.length - 1] &&
                        expression.slice(1, expression.length - 1).indexOf(expression[0]) === -1) {
                        return expression.slice(1, expression.length - 1);
                    }
                    if (expression === 'idx' || expression === '$index') {
                        return index;
                    }
                    if (expression === 'value' && !hasOwn(values, 'value')) {
                        return value;
                    }
                    if (['"', '\'', ' ', '||', '&&', '+'].every(function (delim) { return expression.indexOf(delim) === -1; })) {
                        var pointer = JsonPointer.parseObjectPath(expression);
                        return pointer[0] === 'value' && JsonPointer.has(value, pointer.slice(1)) ?
                            JsonPointer.get(value, pointer.slice(1)) :
                            pointer[0] === 'values' && JsonPointer.has(values, pointer.slice(1)) ?
                                JsonPointer.get(values, pointer.slice(1)) :
                                pointer[0] === 'tpldata' && JsonPointer.has(tpldata, pointer.slice(1)) ?
                                    JsonPointer.get(tpldata, pointer.slice(1)) :
                                    JsonPointer.has(values, pointer) ? JsonPointer.get(values, pointer) : '';
                    }
                    if (expression.indexOf('[idx]') > -1) {
                        expression = expression.replace(/\[idx\]/g, index);
                    }
                    if (expression.indexOf('[$index]') > -1) {
                        expression = expression.replace(/\[$index\]/g, index);
                    }
                    // TODO: Improve expression evaluation by parsing quoted strings first
                    // let expressionArray = expression.match(/([^"']+|"[^"]+"|'[^']+')/g);
                    if (expression.indexOf('||') > -1) {
                        return expression.split('||').reduce(function (all, term) { return all || _this_1.parseExpression(term, value, values, key, tpldata); }, '');
                    }
                    if (expression.indexOf('&&') > -1) {
                        return expression.split('&&').reduce(function (all, term) { return all && _this_1.parseExpression(term, value, values, key, tpldata); }, ' ').trim();
                    }
                    if (expression.indexOf('+') > -1) {
                        return expression.split('+')
                            .map(function (term) { return _this_1.parseExpression(term, value, values, key, tpldata); })
                            .join('');
                    }
                    return '';
                };
                JsonSchemaFormService.prototype.setArrayItemTitle = function (parentCtx, childNode, index) {
                    if (parentCtx === void 0) { parentCtx = {}; }
                    if (childNode === void 0) { childNode = null; }
                    if (index === void 0) { index = null; }
                    var parentNode = parentCtx.layoutNode;
                    var parentValues = this.getFormControlValue(parentCtx);
                    var isArrayItem = (parentNode.type || '').slice(-5) === 'array' && isArray(parentValues);
                    var text = JsonPointer.getFirst(isArrayItem && childNode.type !== '$ref' ? [
                        [childNode, '/options/legend'],
                        [childNode, '/options/title'],
                        [parentNode, '/options/title'],
                        [parentNode, '/options/legend'],
                    ] : [
                        [childNode, '/options/title'],
                        [childNode, '/options/legend'],
                        [parentNode, '/options/title'],
                        [parentNode, '/options/legend']
                    ]);
                    if (!text) {
                        return text;
                    }
                    var childValue = isArray(parentValues) && index < parentValues.length ?
                        parentValues[index] : parentValues;
                    return this.parseText(text, childValue, parentValues, index);
                };
                JsonSchemaFormService.prototype.setItemTitle = function (ctx) {
                    return !ctx.options.title && /^(\d+|-)$/.test(ctx.layoutNode.name) ?
                        null :
                        this.parseText(ctx.options.title || toTitleCase(ctx.layoutNode.name), this.getFormControlValue(this), (this.getFormControlGroup(this) || {}).value, ctx.dataIndex[ctx.dataIndex.length - 1]);
                };
                JsonSchemaFormService.prototype.evaluateCondition = function (layoutNode, dataIndex) {
                    var arrayIndex = dataIndex && dataIndex[dataIndex.length - 1];
                    var result = true;
                    if (hasValue((layoutNode.options || {}).condition)) {
                        if (typeof layoutNode.options.condition === 'string') {
                            var pointer = layoutNode.options.condition;
                            if (hasValue(arrayIndex)) {
                                pointer = pointer.replace('[arrayIndex]', "[" + arrayIndex + "]");
                            }
                            pointer = JsonPointer.parseObjectPath(pointer);
                            result = !!JsonPointer.get(this.data, pointer);
                            if (!result && pointer[0] === 'model') {
                                result = !!JsonPointer.get({ model: this.data }, pointer);
                            }
                        }
                        else if (typeof layoutNode.options.condition === 'function') {
                            result = layoutNode.options.condition(this.data);
                        }
                        else if (typeof layoutNode.options.condition.functionBody === 'string') {
                            try {
                                var dynFn = new Function('model', 'arrayIndices', layoutNode.options.condition.functionBody);
                                result = dynFn(this.data, dataIndex);
                            }
                            catch (e) {
                                result = true;
                                console.error('condition functionBody errored out on evaluation: ' + layoutNode.options.condition.functionBody);
                            }
                        }
                    }
                    return result;
                };
                JsonSchemaFormService.prototype.initializeControl = function (ctx, bind) {
                    var _this_1 = this;
                    if (bind === void 0) { bind = true; }
                    if (!isObject(ctx)) {
                        return false;
                    }
                    if (isEmpty(ctx.options)) {
                        ctx.options = !isEmpty((ctx.layoutNode || {}).options) ?
                            ctx.layoutNode.options : Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(this.formOptions);
                    }
                    ctx.formControl = this.getFormControl(ctx);
                    ctx.boundControl = bind && !!ctx.formControl;
                    if (ctx.formControl) {
                        ctx.controlName = this.getFormControlName(ctx);
                        ctx.controlValue = ctx.formControl.value;
                        ctx.controlDisabled = ctx.formControl.disabled;
                        ctx.options.errorMessage = ctx.formControl.status === 'VALID' ? null :
                            this.formatErrors(ctx.formControl.errors, ctx.options.validationMessages);
                        ctx.options.showErrors = this.formOptions.validateOnRender === true ||
                            (this.formOptions.validateOnRender === 'auto' && hasValue(ctx.controlValue));
                        ctx.formControl.statusChanges.subscribe(function (status) { return ctx.options.errorMessage = status === 'VALID' ? null :
                            _this_1.formatErrors(ctx.formControl.errors, ctx.options.validationMessages); });
                        ctx.formControl.valueChanges.subscribe(function (value) {
                            if (!!value) {
                                ctx.controlValue = value;
                            }
                        });
                    }
                    else {
                        ctx.controlName = ctx.layoutNode.name;
                        ctx.controlValue = ctx.layoutNode.value || null;
                        var dataPointer = this.getDataPointer(ctx);
                        if (bind && dataPointer) {
                            console.error("warning: control \"" + dataPointer + "\" is not bound to the Angular FormGroup.");
                        }
                    }
                    return ctx.boundControl;
                };
                JsonSchemaFormService.prototype.formatErrors = function (errors, validationMessages) {
                    if (validationMessages === void 0) { validationMessages = {}; }
                    if (isEmpty(errors)) {
                        return null;
                    }
                    if (!isObject(validationMessages)) {
                        validationMessages = {};
                    }
                    var addSpaces = function (string) { return string[0].toUpperCase() + (string.slice(1) || '')
                        .replace(/([a-z])([A-Z])/g, '$1 $2').replace(/_/g, ' '); };
                    var formatError = function (error) { return typeof error === 'object' ?
                        Object.keys(error).map(function (key) { return error[key] === true ? addSpaces(key) :
                            error[key] === false ? 'Not ' + addSpaces(key) :
                                addSpaces(key) + ': ' + formatError(error[key]); }).join(', ') :
                        addSpaces(error.toString()); };
                    return Object.keys(errors)
                        // Hide 'required' error, unless it is the only one
                        .filter(function (errorKey) { return errorKey !== 'required' || Object.keys(errors).length === 1; })
                        .map(function (errorKey) {
                        // If validationMessages is a string, return it
                        return typeof validationMessages === 'string' ? validationMessages :
                            // If custom error message is a function, return function result
                            typeof validationMessages[errorKey] === 'function' ?
                                validationMessages[errorKey](errors[errorKey]) :
                                // If custom error message is a string, replace placeholders and return
                                typeof validationMessages[errorKey] === 'string' ?
                                    // Does error message have any {{property}} placeholders?
                                    !/{{.+?}}/.test(validationMessages[errorKey]) ?
                                        validationMessages[errorKey] :
                                        // Replace {{property}} placeholders with values
                                        Object.keys(errors[errorKey])
                                            .reduce(function (errorMessage, errorProperty) { return errorMessage.replace(new RegExp('{{' + errorProperty + '}}', 'g'), errors[errorKey][errorProperty]); }, validationMessages[errorKey]) :
                                    // If no custom error message, return formatted error data instead
                                    addSpaces(errorKey) + ' Error: ' + formatError(errors[errorKey]);
                    }).join('<br>');
                };
                JsonSchemaFormService.prototype.updateValue = function (ctx, value) {
                    // Set value of current control
                    ctx.controlValue = value;
                    if (ctx.boundControl) {
                        ctx.formControl.setValue(value);
                        ctx.formControl.markAsDirty();
                    }
                    ctx.layoutNode.value = value;
                    // Set values of any related controls in copyValueTo array
                    if (isArray(ctx.options.copyValueTo)) {
                        for (var _a = 0, _b = ctx.options.copyValueTo; _a < _b.length; _a++) {
                            var item = _b[_a];
                            var targetControl = getControl(this.formGroup, item);
                            if (isObject(targetControl) && typeof targetControl.setValue === 'function') {
                                targetControl.setValue(value);
                                targetControl.markAsDirty();
                            }
                        }
                    }
                };
                JsonSchemaFormService.prototype.updateArrayCheckboxList = function (ctx, checkboxList) {
                    var formArray = this.getFormControl(ctx);
                    // Remove all existing items
                    while (formArray.value.length) {
                        formArray.removeAt(0);
                    }
                    // Re-add an item for each checked box
                    var refPointer = removeRecursiveReferences(ctx.layoutNode.dataPointer + '/-', this.dataRecursiveRefMap, this.arrayMap);
                    for (var _a = 0, checkboxList_1 = checkboxList; _a < checkboxList_1.length; _a++) {
                        var checkboxItem = checkboxList_1[_a];
                        if (checkboxItem.checked) {
                            var newFormControl = buildFormGroup(this.templateRefLibrary[refPointer]);
                            newFormControl.setValue(checkboxItem.value);
                            formArray.push(newFormControl);
                        }
                    }
                    formArray.markAsDirty();
                };
                JsonSchemaFormService.prototype.getFormControl = function (ctx) {
                    if (!ctx.layoutNode || !isDefined(ctx.layoutNode.dataPointer) ||
                        ctx.layoutNode.type === '$ref') {
                        return null;
                    }
                    return getControl(this.formGroup, this.getDataPointer(ctx));
                };
                JsonSchemaFormService.prototype.getFormControlValue = function (ctx) {
                    if (!ctx.layoutNode || !isDefined(ctx.layoutNode.dataPointer) ||
                        ctx.layoutNode.type === '$ref') {
                        return null;
                    }
                    var control = getControl(this.formGroup, this.getDataPointer(ctx));
                    return control ? control.value : null;
                };
                JsonSchemaFormService.prototype.getFormControlGroup = function (ctx) {
                    if (!ctx.layoutNode || !isDefined(ctx.layoutNode.dataPointer)) {
                        return null;
                    }
                    return getControl(this.formGroup, this.getDataPointer(ctx), true);
                };
                JsonSchemaFormService.prototype.getFormControlName = function (ctx) {
                    if (!ctx.layoutNode || !isDefined(ctx.layoutNode.dataPointer) || !hasValue(ctx.dataIndex)) {
                        return null;
                    }
                    return JsonPointer.toKey(this.getDataPointer(ctx));
                };
                JsonSchemaFormService.prototype.getLayoutArray = function (ctx) {
                    return JsonPointer.get(this.layout, this.getLayoutPointer(ctx), 0, -1);
                };
                JsonSchemaFormService.prototype.getParentNode = function (ctx) {
                    return JsonPointer.get(this.layout, this.getLayoutPointer(ctx), 0, -2);
                };
                JsonSchemaFormService.prototype.getDataPointer = function (ctx) {
                    if (!ctx.layoutNode || !isDefined(ctx.layoutNode.dataPointer) || !hasValue(ctx.dataIndex)) {
                        return null;
                    }
                    return JsonPointer.toIndexedPointer(ctx.layoutNode.dataPointer, ctx.dataIndex, this.arrayMap);
                };
                JsonSchemaFormService.prototype.getLayoutPointer = function (ctx) {
                    if (!hasValue(ctx.layoutIndex)) {
                        return null;
                    }
                    return '/' + ctx.layoutIndex.join('/items/');
                };
                JsonSchemaFormService.prototype.isControlBound = function (ctx) {
                    if (!ctx.layoutNode || !isDefined(ctx.layoutNode.dataPointer) || !hasValue(ctx.dataIndex)) {
                        return false;
                    }
                    var controlGroup = this.getFormControlGroup(ctx);
                    var name = this.getFormControlName(ctx);
                    return controlGroup ? hasOwn(controlGroup.controls, name) : false;
                };
                JsonSchemaFormService.prototype.addItem = function (ctx, name) {
                    if (!ctx.layoutNode || !isDefined(ctx.layoutNode.$ref) ||
                        !hasValue(ctx.dataIndex) || !hasValue(ctx.layoutIndex)) {
                        return false;
                    }
                    // Create a new Angular form control from a template in templateRefLibrary
                    var newFormGroup = buildFormGroup(this.templateRefLibrary[ctx.layoutNode.$ref]);
                    // Add the new form control to the parent formArray or formGroup
                    if (ctx.layoutNode.arrayItem) { // Add new array item to formArray
                        this.getFormControlGroup(ctx).push(newFormGroup);
                    }
                    else { // Add new $ref item to formGroup
                        this.getFormControlGroup(ctx)
                            .addControl(name || this.getFormControlName(ctx), newFormGroup);
                    }
                    // Copy a new layoutNode from layoutRefLibrary
                    var newLayoutNode = getLayoutNode(ctx.layoutNode, this);
                    newLayoutNode.arrayItem = ctx.layoutNode.arrayItem;
                    if (ctx.layoutNode.arrayItemType) {
                        newLayoutNode.arrayItemType = ctx.layoutNode.arrayItemType;
                    }
                    else {
                        delete newLayoutNode.arrayItemType;
                    }
                    if (name) {
                        newLayoutNode.name = name;
                        newLayoutNode.dataPointer += '/' + JsonPointer.escape(name);
                        newLayoutNode.options.title = fixTitle(name);
                    }
                    // Add the new layoutNode to the form layout
                    JsonPointer.insert(this.layout, this.getLayoutPointer(ctx), newLayoutNode);
                    return true;
                };
                JsonSchemaFormService.prototype.moveArrayItem = function (ctx, oldIndex, newIndex) {
                    if (!ctx.layoutNode || !isDefined(ctx.layoutNode.dataPointer) ||
                        !hasValue(ctx.dataIndex) || !hasValue(ctx.layoutIndex) ||
                        !isDefined(oldIndex) || !isDefined(newIndex) || oldIndex === newIndex) {
                        return false;
                    }
                    // Move item in the formArray
                    var formArray = this.getFormControlGroup(ctx);
                    var arrayItem = formArray.at(oldIndex);
                    formArray.removeAt(oldIndex);
                    formArray.insert(newIndex, arrayItem);
                    formArray.updateValueAndValidity();
                    // Move layout item
                    var layoutArray = this.getLayoutArray(ctx);
                    layoutArray.splice(newIndex, 0, layoutArray.splice(oldIndex, 1)[0]);
                    return true;
                };
                JsonSchemaFormService.prototype.removeItem = function (ctx) {
                    if (!ctx.layoutNode || !isDefined(ctx.layoutNode.dataPointer) ||
                        !hasValue(ctx.dataIndex) || !hasValue(ctx.layoutIndex)) {
                        return false;
                    }
                    // Remove the Angular form control from the parent formArray or formGroup
                    if (ctx.layoutNode.arrayItem) { // Remove array item from formArray
                        this.getFormControlGroup(ctx)
                            .removeAt(ctx.dataIndex[ctx.dataIndex.length - 1]);
                    }
                    else { // Remove $ref item from formGroup
                        this.getFormControlGroup(ctx)
                            .removeControl(this.getFormControlName(ctx));
                    }
                    // Remove layoutNode from layout
                    JsonPointer.remove(this.layout, this.getLayoutPointer(ctx));
                    return true;
                };
                return JsonSchemaFormService;
            }());
            JsonSchemaFormService = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Injectable"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [])
            ], JsonSchemaFormService);
            function convertSchemaToDraft6(schema, options) {
                if (options === void 0) { options = {}; }
                var draft = options.draft || null;
                var changed = options.changed || false;
                if (typeof schema !== 'object') {
                    return schema;
                }
                if (typeof schema.map === 'function') {
                    return schema.map(function (subSchema) { return convertSchemaToDraft6(subSchema, { changed: changed, draft: draft }); }).slice();
                }
                var newSchema = Object.assign({}, schema);
                var simpleTypes = ['array', 'boolean', 'integer', 'null', 'number', 'object', 'string'];
                if (typeof newSchema.$schema === 'string' &&
                    /http\:\/\/json\-schema\.org\/draft\-0\d\/schema\#/.test(newSchema.$schema)) {
                    draft = newSchema.$schema[30];
                }
                // Convert v1-v2 'contentEncoding' to 'media.binaryEncoding'
                // Note: This is only used in JSON hyper-schema (not regular JSON schema)
                if (newSchema.contentEncoding) {
                    newSchema.media = { binaryEncoding: newSchema.contentEncoding };
                    delete newSchema.contentEncoding;
                    changed = true;
                }
                // Convert v1-v3 'extends' to 'allOf'
                if (typeof newSchema.extends === 'object') {
                    newSchema.allOf = typeof newSchema.extends.map === 'function' ?
                        newSchema.extends.map(function (subSchema) { return convertSchemaToDraft6(subSchema, { changed: changed, draft: draft }); }) :
                        [convertSchemaToDraft6(newSchema.extends, { changed: changed, draft: draft })];
                    delete newSchema.extends;
                    changed = true;
                }
                // Convert v1-v3 'disallow' to 'not'
                if (newSchema.disallow) {
                    if (typeof newSchema.disallow === 'string') {
                        newSchema.not = { type: newSchema.disallow };
                    }
                    else if (typeof newSchema.disallow.map === 'function') {
                        newSchema.not = {
                            anyOf: newSchema.disallow
                                .map(function (type) { return typeof type === 'object' ? type : { type: type }; })
                        };
                    }
                    delete newSchema.disallow;
                    changed = true;
                }
                // Convert v3 string 'dependencies' properties to arrays
                if (typeof newSchema.dependencies === 'object' &&
                    Object.keys(newSchema.dependencies)
                        .some(function (key) { return typeof newSchema.dependencies[key] === 'string'; })) {
                    newSchema.dependencies = Object.assign({}, newSchema.dependencies);
                    Object.keys(newSchema.dependencies)
                        .filter(function (key) { return typeof newSchema.dependencies[key] === 'string'; })
                        .forEach(function (key) { return newSchema.dependencies[key] = [newSchema.dependencies[key]]; });
                    changed = true;
                }
                // Convert v1 'maxDecimal' to 'multipleOf'
                if (typeof newSchema.maxDecimal === 'number') {
                    newSchema.multipleOf = 1 / Math.pow(10, newSchema.maxDecimal);
                    delete newSchema.divisibleBy;
                    changed = true;
                    if (!draft || draft === 2) {
                        draft = 1;
                    }
                }
                // Convert v2-v3 'divisibleBy' to 'multipleOf'
                if (typeof newSchema.divisibleBy === 'number') {
                    newSchema.multipleOf = newSchema.divisibleBy;
                    delete newSchema.divisibleBy;
                    changed = true;
                }
                // Convert v1-v2 boolean 'minimumCanEqual' to 'exclusiveMinimum'
                if (typeof newSchema.minimum === 'number' && newSchema.minimumCanEqual === false) {
                    newSchema.exclusiveMinimum = newSchema.minimum;
                    delete newSchema.minimum;
                    changed = true;
                    if (!draft) {
                        draft = 2;
                    }
                }
                else if (typeof newSchema.minimumCanEqual === 'boolean') {
                    delete newSchema.minimumCanEqual;
                    changed = true;
                    if (!draft) {
                        draft = 2;
                    }
                }
                // Convert v3-v4 boolean 'exclusiveMinimum' to numeric
                if (typeof newSchema.minimum === 'number' && newSchema.exclusiveMinimum === true) {
                    newSchema.exclusiveMinimum = newSchema.minimum;
                    delete newSchema.minimum;
                    changed = true;
                }
                else if (typeof newSchema.exclusiveMinimum === 'boolean') {
                    delete newSchema.exclusiveMinimum;
                    changed = true;
                }
                // Convert v1-v2 boolean 'maximumCanEqual' to 'exclusiveMaximum'
                if (typeof newSchema.maximum === 'number' && newSchema.maximumCanEqual === false) {
                    newSchema.exclusiveMaximum = newSchema.maximum;
                    delete newSchema.maximum;
                    changed = true;
                    if (!draft) {
                        draft = 2;
                    }
                }
                else if (typeof newSchema.maximumCanEqual === 'boolean') {
                    delete newSchema.maximumCanEqual;
                    changed = true;
                    if (!draft) {
                        draft = 2;
                    }
                }
                // Convert v3-v4 boolean 'exclusiveMaximum' to numeric
                if (typeof newSchema.maximum === 'number' && newSchema.exclusiveMaximum === true) {
                    newSchema.exclusiveMaximum = newSchema.maximum;
                    delete newSchema.maximum;
                    changed = true;
                }
                else if (typeof newSchema.exclusiveMaximum === 'boolean') {
                    delete newSchema.exclusiveMaximum;
                    changed = true;
                }
                // Search object 'properties' for 'optional', 'required', and 'requires' items,
                // and convert them into object 'required' arrays and 'dependencies' objects
                if (typeof newSchema.properties === 'object') {
                    var properties_1 = Object.assign({}, newSchema.properties);
                    var requiredKeys_1 = Array.isArray(newSchema.required) ?
                        new Set(newSchema.required) : new Set();
                    // Convert v1-v2 boolean 'optional' properties to 'required' array
                    if (draft === 1 || draft === 2 ||
                        Object.keys(properties_1).some(function (key) { return properties_1[key].optional === true; })) {
                        Object.keys(properties_1)
                            .filter(function (key) { return properties_1[key].optional !== true; })
                            .forEach(function (key) { return requiredKeys_1.add(key); });
                        changed = true;
                        if (!draft) {
                            draft = 2;
                        }
                    }
                    // Convert v3 boolean 'required' properties to 'required' array
                    if (Object.keys(properties_1).some(function (key) { return properties_1[key].required === true; })) {
                        Object.keys(properties_1)
                            .filter(function (key) { return properties_1[key].required === true; })
                            .forEach(function (key) { return requiredKeys_1.add(key); });
                        changed = true;
                    }
                    if (requiredKeys_1.size) {
                        newSchema.required = Array.from(requiredKeys_1);
                    }
                    // Convert v1-v2 array or string 'requires' properties to 'dependencies' object
                    if (Object.keys(properties_1).some(function (key) { return properties_1[key].requires; })) {
                        var dependencies_1 = typeof newSchema.dependencies === 'object' ? Object.assign({}, newSchema.dependencies) : {};
                        Object.keys(properties_1)
                            .filter(function (key) { return properties_1[key].requires; })
                            .forEach(function (key) { return dependencies_1[key] =
                            typeof properties_1[key].requires === 'string' ?
                                [properties_1[key].requires] : properties_1[key].requires; });
                        newSchema.dependencies = dependencies_1;
                        changed = true;
                        if (!draft) {
                            draft = 2;
                        }
                    }
                    newSchema.properties = properties_1;
                }
                // Revove v1-v2 boolean 'optional' key
                if (typeof newSchema.optional === 'boolean') {
                    delete newSchema.optional;
                    changed = true;
                    if (!draft) {
                        draft = 2;
                    }
                }
                // Revove v1-v2 'requires' key
                if (newSchema.requires) {
                    delete newSchema.requires;
                }
                // Revove v3 boolean 'required' key
                if (typeof newSchema.required === 'boolean') {
                    delete newSchema.required;
                }
                // Convert id to $id
                if (typeof newSchema.id === 'string' && !newSchema.$id) {
                    if (newSchema.id.slice(-1) === '#') {
                        newSchema.id = newSchema.id.slice(0, -1);
                    }
                    newSchema.$id = newSchema.id + '-CONVERTED-TO-DRAFT-06#';
                    delete newSchema.id;
                    changed = true;
                }
                // Check if v1-v3 'any' or object types will be converted
                if (newSchema.type && (typeof newSchema.type.every === 'function' ?
                    !newSchema.type.every(function (type) { return simpleTypes.includes(type); }) :
                    !simpleTypes.includes(newSchema.type))) {
                    changed = true;
                }
                // If schema changed, update or remove $schema identifier
                if (typeof newSchema.$schema === 'string' &&
                    /http\:\/\/json\-schema\.org\/draft\-0[1-4]\/schema\#/.test(newSchema.$schema)) {
                    newSchema.$schema = 'http://json-schema.org/draft-06/schema#';
                    changed = true;
                }
                else if (changed && typeof newSchema.$schema === 'string') {
                    var addToDescription = 'Converted to draft 6 from ' + newSchema.$schema;
                    if (typeof newSchema.description === 'string' && newSchema.description.length) {
                        newSchema.description += '\n' + addToDescription;
                    }
                    else {
                        newSchema.description = addToDescription;
                    }
                    delete newSchema.$schema;
                }
                // Convert v1-v3 'any' and object types
                if (newSchema.type && (typeof newSchema.type.every === 'function' ?
                    !newSchema.type.every(function (type) { return simpleTypes.includes(type); }) :
                    !simpleTypes.includes(newSchema.type))) {
                    if (newSchema.type.length === 1) {
                        newSchema.type = newSchema.type[0];
                    }
                    if (typeof newSchema.type === 'string') {
                        // Convert string 'any' type to array of all standard types
                        if (newSchema.type === 'any') {
                            newSchema.type = simpleTypes;
                            // Delete non-standard string type
                        }
                        else {
                            delete newSchema.type;
                        }
                    }
                    else if (typeof newSchema.type === 'object') {
                        if (typeof newSchema.type.every === 'function') {
                            // If array of strings, only allow standard types
                            if (newSchema.type.every(function (type) { return typeof type === 'string'; })) {
                                newSchema.type = newSchema.type.some(function (type) { return type === 'any'; }) ?
                                    newSchema.type = simpleTypes :
                                    newSchema.type.filter(function (type) { return simpleTypes.includes(type); });
                                // If type is an array with objects, convert the current schema to an 'anyOf' array
                            }
                            else if (newSchema.type.length > 1) {
                                var arrayKeys = ['additionalItems', 'items', 'maxItems', 'minItems', 'uniqueItems', 'contains'];
                                var numberKeys = ['multipleOf', 'maximum', 'exclusiveMaximum', 'minimum', 'exclusiveMinimum'];
                                var objectKeys = ['maxProperties', 'minProperties', 'required', 'additionalProperties',
                                    'properties', 'patternProperties', 'dependencies', 'propertyNames'];
                                var stringKeys = ['maxLength', 'minLength', 'pattern', 'format'];
                                var filterKeys_1 = {
                                    'array': numberKeys.concat(objectKeys, stringKeys),
                                    'integer': arrayKeys.concat(objectKeys, stringKeys),
                                    'number': arrayKeys.concat(objectKeys, stringKeys),
                                    'object': arrayKeys.concat(numberKeys, stringKeys),
                                    'string': arrayKeys.concat(numberKeys, objectKeys),
                                    'all': arrayKeys.concat(numberKeys, objectKeys, stringKeys),
                                };
                                var anyOf = [];
                                var _loop_3 = function (type) {
                                    var newType = typeof type === 'string' ? { type: type } : Object.assign({}, type);
                                    Object.keys(newSchema)
                                        .filter(function (key) { return !newType.hasOwnProperty(key) &&
                                        !(filterKeys_1[newType.type] || filterKeys_1.all).concat(['type', 'default']).includes(key); })
                                        .forEach(function (key) { return newType[key] = newSchema[key]; });
                                    anyOf.push(newType);
                                };
                                for (var _a = 0, _b = newSchema.type; _a < _b.length; _a++) {
                                    var type = _b[_a];
                                    _loop_3(type);
                                }
                                newSchema = newSchema.hasOwnProperty('default') ?
                                    { anyOf: anyOf, default: newSchema.default } : { anyOf: anyOf };
                                // If type is an object, merge it with the current schema
                            }
                            else {
                                var typeSchema = newSchema.type;
                                delete newSchema.type;
                                Object.assign(newSchema, typeSchema);
                            }
                        }
                    }
                    else {
                        delete newSchema.type;
                    }
                }
                // Convert sub schemas
                Object.keys(newSchema)
                    .filter(function (key) { return typeof newSchema[key] === 'object'; })
                    .forEach(function (key) {
                    if (['definitions', 'dependencies', 'properties', 'patternProperties']
                        .includes(key) && typeof newSchema[key].map !== 'function') {
                        var newKey_1 = {};
                        Object.keys(newSchema[key]).forEach(function (subKey) { return newKey_1[subKey] =
                            convertSchemaToDraft6(newSchema[key][subKey], { changed: changed, draft: draft }); });
                        newSchema[key] = newKey_1;
                    }
                    else if (['items', 'additionalItems', 'additionalProperties',
                        'allOf', 'anyOf', 'oneOf', 'not'].includes(key)) {
                        newSchema[key] = convertSchemaToDraft6(newSchema[key], { changed: changed, draft: draft });
                    }
                    else {
                        newSchema[key] = Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(newSchema[key]);
                    }
                });
                return newSchema;
            }
            var Framework = /** @class */ (function () {
                function Framework() {
                    this.widgets = {};
                    this.stylesheets = [];
                    this.scripts = [];
                }
                return Framework;
            }());
            Framework = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Injectable"])()
            ], Framework);
            var AddReferenceComponent = /** @class */ (function () {
                function AddReferenceComponent(jsf) {
                    this.jsf = jsf;
                }
                AddReferenceComponent.prototype.ngOnInit = function () {
                    this.options = this.layoutNode.options || {};
                };
                Object.defineProperty(AddReferenceComponent.prototype, "showAddButton", {
                    get: function () {
                        return !this.layoutNode.arrayItem ||
                            this.layoutIndex[this.layoutIndex.length - 1] < this.options.maxItems;
                    },
                    enumerable: true,
                    configurable: true
                });
                AddReferenceComponent.prototype.addItem = function (event) {
                    event.preventDefault();
                    this.jsf.addItem(this);
                };
                Object.defineProperty(AddReferenceComponent.prototype, "buttonText", {
                    get: function () {
                        var parent = {
                            dataIndex: this.dataIndex.slice(0, -1),
                            layoutIndex: this.layoutIndex.slice(0, -1),
                            layoutNode: this.jsf.getParentNode(this)
                        };
                        return parent.layoutNode.add ||
                            this.jsf.setArrayItemTitle(parent, this.layoutNode, this.itemCount);
                    },
                    enumerable: true,
                    configurable: true
                });
                return AddReferenceComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], AddReferenceComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], AddReferenceComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], AddReferenceComponent.prototype, "dataIndex", void 0);
            AddReferenceComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'add-reference-widget',
                    template: "\n    <button *ngIf=\"showAddButton\"\n      [class]=\"options?.fieldHtmlClass || ''\"\n      [disabled]=\"options?.readonly\"\n      (click)=\"addItem($event)\">\n      <span *ngIf=\"options?.icon\" [class]=\"options?.icon\"></span>\n      <span *ngIf=\"options?.title\" [innerHTML]=\"buttonText\"></span>\n    </button>",
                    changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ChangeDetectionStrategy"].Default
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], AddReferenceComponent);
            var ButtonComponent = /** @class */ (function () {
                function ButtonComponent(jsf) {
                    this.jsf = jsf;
                    this.controlDisabled = false;
                    this.boundControl = false;
                }
                ButtonComponent.prototype.ngOnInit = function () {
                    this.options = this.layoutNode.options || {};
                    this.jsf.initializeControl(this);
                };
                ButtonComponent.prototype.updateValue = function (event) {
                    if (typeof this.options.onClick === 'function') {
                        this.options.onClick(event);
                    }
                    else {
                        this.jsf.updateValue(this, event.target.value);
                    }
                };
                return ButtonComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], ButtonComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], ButtonComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], ButtonComponent.prototype, "dataIndex", void 0);
            ButtonComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'button-widget',
                    template: "\n    <div\n      [class]=\"options?.htmlClass || ''\">\n      <button\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [disabled]=\"controlDisabled\"\n        [name]=\"controlName\"\n        [type]=\"layoutNode?.type\"\n        [value]=\"controlValue\"\n        (click)=\"updateValue($event)\">\n        <span *ngIf=\"options?.icon || options?.title\"\n          [class]=\"options?.icon\"\n          [innerHTML]=\"options?.title\"></span>\n      </button>\n    </div>"
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], ButtonComponent);
            var CheckboxComponent = /** @class */ (function () {
                function CheckboxComponent(jsf) {
                    this.jsf = jsf;
                    this.controlDisabled = false;
                    this.boundControl = false;
                    this.trueValue = true;
                    this.falseValue = false;
                }
                CheckboxComponent.prototype.ngOnInit = function () {
                    this.options = this.layoutNode.options || {};
                    this.jsf.initializeControl(this);
                    if (this.controlValue === null || this.controlValue === undefined) {
                        this.controlValue = this.options.title;
                    }
                };
                CheckboxComponent.prototype.updateValue = function (event) {
                    event.preventDefault();
                    this.jsf.updateValue(this, event.target.checked ? this.trueValue : this.falseValue);
                };
                Object.defineProperty(CheckboxComponent.prototype, "isChecked", {
                    get: function () {
                        return this.jsf.getFormControlValue(this) === this.trueValue;
                    },
                    enumerable: true,
                    configurable: true
                });
                return CheckboxComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], CheckboxComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], CheckboxComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], CheckboxComponent.prototype, "dataIndex", void 0);
            CheckboxComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'checkbox-widget',
                    template: "\n    <label\n      [attr.for]=\"'control' + layoutNode?._id\"\n      [class]=\"options?.itemLabelHtmlClass || ''\">\n      <input *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [class]=\"(options?.fieldHtmlClass || '') + (isChecked ?\n          (' ' + (options?.activeClass || '') + ' ' + (options?.style?.selected || '')) :\n          (' ' + (options?.style?.unselected || '')))\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        type=\"checkbox\">\n      <input *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [checked]=\"isChecked ? 'checked' : null\"\n        [class]=\"(options?.fieldHtmlClass || '') + (isChecked ?\n          (' ' + (options?.activeClass || '') + ' ' + (options?.style?.selected || '')) :\n          (' ' + (options?.style?.unselected || '')))\"\n        [disabled]=\"controlDisabled\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [value]=\"controlValue\"\n        type=\"checkbox\"\n        (change)=\"updateValue($event)\">\n      <span *ngIf=\"options?.title\"\n        [style.display]=\"options?.notitle ? 'none' : ''\"\n        [innerHTML]=\"options?.title\"></span>\n    </label>"
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], CheckboxComponent);
            /**
             * 'dateToString' function
             *
             * //  { Date | string } date
             * //   options
             * // { string }
             */
            function dateToString(date, options) {
                if (options === void 0) { options = {}; }
                var dateFormat = options.dateFormat || 'YYYY-MM-DD';
                // TODO: Use options.locale to change default format and names
                // const locale = options.locale || 'en-US';
                if (typeof date === 'string') {
                    date = stringToDate(date);
                }
                if (Object.prototype.toString.call(date) !== '[object Date]') {
                    return null;
                }
                var longMonths = ['January', 'February', 'March', 'April', 'May', 'June',
                    'July', 'August', 'September', 'October', 'November', 'December'];
                var shortMonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                var longDays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                var shortDays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                return dateFormat
                    .replace(/YYYY/ig, date.getFullYear() + '')
                    .replace(/YY/ig, (date.getFullYear() + '').slice(-2))
                    .replace(/MMMM/ig, longMonths[date.getMonth()])
                    .replace(/MMM/ig, shortMonths[date.getMonth()])
                    .replace(/MM/ig, ('0' + (date.getMonth() + 1)).slice(-2))
                    .replace(/M/ig, (date.getMonth() + 1) + '')
                    .replace(/DDDD/ig, longDays[date.getDay()])
                    .replace(/DDD/ig, shortDays[date.getDay()])
                    .replace(/DD/ig, ('0' + date.getDate()).slice(-2))
                    .replace(/D/ig, date.getDate() + '')
                    .replace(/S/ig, ordinal(date.getDate()));
            }
            function ordinal(number) {
                if (typeof number === 'number') {
                    number = number + '';
                }
                var last = number.slice(-1);
                var nextToLast = number.slice(-2, 1);
                return (nextToLast !== '1' && { '1': 'st', '2': 'nd', '3': 'rd' }[last]) || 'th';
            }
            /**
             * 'stringToDate' function
             *
             * //  { string } dateString
             * // { Date }
             */
            function stringToDate(dateString) {
                var getDate = findDate(dateString);
                if (!getDate) {
                    return null;
                }
                var dateParts = [];
                // Split x-y-z to [x, y, z]
                if (/^\d+[^\d]\d+[^\d]\d+$/.test(getDate)) {
                    dateParts = getDate.split(/[^\d]/).map(function (part) { return +part; });
                    // Split xxxxyyzz to [xxxx, yy, zz]
                }
                else if (/^\d{8}$/.test(getDate)) {
                    dateParts = [+getDate.slice(0, 4), +getDate.slice(4, 6), +getDate.slice(6)];
                }
                var thisYear = +(new Date().getFullYear() + '').slice(-2);
                // Check for [YYYY, MM, DD]
                if (dateParts[0] > 1000 && dateParts[0] < 2100 && dateParts[1] <= 12 && dateParts[2] <= 31) {
                    return new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
                    // Check for [MM, DD, YYYY]
                }
                else if (dateParts[0] <= 12 && dateParts[1] <= 31 && dateParts[2] > 1000 && dateParts[2] < 2100) {
                    return new Date(dateParts[2], dateParts[0] - 1, dateParts[1]);
                    // Check for [MM, DD, YY]
                }
                else if (dateParts[0] <= 12 && dateParts[1] <= 31 && dateParts[2] < 100) {
                    var year = (dateParts[2] <= thisYear ? 2000 : 1900) + dateParts[2];
                    return new Date(year, dateParts[0] - 1, dateParts[1]);
                    // Check for [YY, MM, DD]
                }
                else if (dateParts[0] < 100 && dateParts[1] <= 12 && dateParts[2] <= 31) {
                    var year = (dateParts[0] <= thisYear ? 2000 : 1900) + dateParts[0];
                    return new Date(year, dateParts[1] - 1, dateParts[2]);
                }
                return null;
            }
            /**
             * 'findDate' function
             *
             * //  { string } text
             * // { string }
             */
            function findDate(text) {
                if (!text) {
                    return null;
                }
                var foundDate;
                // Match ...YYYY-MM-DD...
                foundDate = text.match(/(?:19|20)\d\d[-_\\\/\. ](?:0?\d|1[012])[-_\\\/\. ](?:[012]?\d|3[01])(?!\d)/);
                if (foundDate) {
                    return foundDate[0];
                }
                // Match ...MM-DD-YYYY...
                foundDate = text.match(/(?:[012]?\d|3[01])[-_\\\/\. ](?:0?\d|1[012])[-_\\\/\. ](?:19|20)\d\d(?!\d)/);
                if (foundDate) {
                    return foundDate[0];
                }
                // Match MM-DD-YY...
                foundDate = text.match(/^(?:[012]?\d|3[01])[-_\\\/\. ](?:0?\d|1[012])[-_\\\/\. ]\d\d(?!\d)/);
                if (foundDate) {
                    return foundDate[0];
                }
                // Match YY-MM-DD...
                foundDate = text.match(/^\d\d[-_\\\/\. ](?:[012]?\d|3[01])[-_\\\/\. ](?:0?\d|1[012])(?!\d)/);
                if (foundDate) {
                    return foundDate[0];
                }
                // Match YYYYMMDD...
                foundDate = text.match(/^(?:19|20)\d\d(?:0\d|1[012])(?:[012]\d|3[01])/);
                if (foundDate) {
                    return foundDate[0];
                }
            }
            var CheckboxesComponent = /** @class */ (function () {
                function CheckboxesComponent(jsf) {
                    this.jsf = jsf;
                    this.controlDisabled = false;
                    this.boundControl = false;
                    this.checkboxList = [];
                }
                CheckboxesComponent.prototype.ngOnInit = function () {
                    this.options = this.layoutNode.options || {};
                    this.layoutOrientation = (this.layoutNode.type === 'checkboxes-inline' ||
                        this.layoutNode.type === 'checkboxbuttons') ? 'horizontal' : 'vertical';
                    this.jsf.initializeControl(this);
                    this.checkboxList = buildTitleMap(this.options.titleMap || this.options.enumNames, this.options.enum, true);
                    if (this.boundControl) {
                        var formArray_1 = this.jsf.getFormControl(this);
                        this.checkboxList.forEach(function (checkboxItem) { return checkboxItem.checked = formArray_1.value.includes(checkboxItem.value); });
                    }
                };
                CheckboxesComponent.prototype.updateValue = function (event) {
                    for (var _a = 0, _b = this.checkboxList; _a < _b.length; _a++) {
                        var checkboxItem = _b[_a];
                        if (event.target.value === checkboxItem.value) {
                            checkboxItem.checked = event.target.checked;
                        }
                    }
                    if (this.boundControl) {
                        this.jsf.updateArrayCheckboxList(this, this.checkboxList);
                    }
                };
                return CheckboxesComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], CheckboxesComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], CheckboxesComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], CheckboxesComponent.prototype, "dataIndex", void 0);
            CheckboxesComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'checkboxes-widget',
                    template: "\n    <label *ngIf=\"options?.title\"\n      [class]=\"options?.labelHtmlClass || ''\"\n      [style.display]=\"options?.notitle ? 'none' : ''\"\n      [innerHTML]=\"options?.title\"></label>\n\n    <!-- 'horizontal' = checkboxes-inline or checkboxbuttons -->\n    <div *ngIf=\"layoutOrientation === 'horizontal'\" [class]=\"options?.htmlClass || ''\">\n      <label *ngFor=\"let checkboxItem of checkboxList\"\n        [attr.for]=\"'control' + layoutNode?._id + '/' + checkboxItem.value\"\n        [class]=\"(options?.itemLabelHtmlClass || '') + (checkboxItem.checked ?\n          (' ' + (options?.activeClass || '') + ' ' + (options?.style?.selected || '')) :\n          (' ' + (options?.style?.unselected || '')))\">\n        <input type=\"checkbox\"\n          [attr.required]=\"options?.required\"\n          [checked]=\"checkboxItem.checked\"\n          [class]=\"options?.fieldHtmlClass || ''\"\n          [disabled]=\"controlDisabled\"\n          [id]=\"'control' + layoutNode?._id + '/' + checkboxItem.value\"\n          [name]=\"checkboxItem?.name\"\n          [readonly]=\"options?.readonly ? 'readonly' : null\"\n          [value]=\"checkboxItem.value\"\n          (change)=\"updateValue($event)\">\n        <span [innerHTML]=\"checkboxItem.name\"></span>\n      </label>\n    </div>\n\n    <!-- 'vertical' = regular checkboxes -->\n    <div *ngIf=\"layoutOrientation === 'vertical'\">\n      <div *ngFor=\"let checkboxItem of checkboxList\" [class]=\"options?.htmlClass || ''\">\n        <label\n          [attr.for]=\"'control' + layoutNode?._id + '/' + checkboxItem.value\"\n          [class]=\"(options?.itemLabelHtmlClass || '') + (checkboxItem.checked ?\n            (' ' + (options?.activeClass || '') + ' ' + (options?.style?.selected || '')) :\n            (' ' + (options?.style?.unselected || '')))\">\n          <input type=\"checkbox\"\n            [attr.required]=\"options?.required\"\n            [checked]=\"checkboxItem.checked\"\n            [class]=\"options?.fieldHtmlClass || ''\"\n            [disabled]=\"controlDisabled\"\n            [id]=\"options?.name + '/' + checkboxItem.value\"\n            [name]=\"checkboxItem?.name\"\n            [readonly]=\"options?.readonly ? 'readonly' : null\"\n            [value]=\"checkboxItem.value\"\n            (change)=\"updateValue($event)\">\n          <span [innerHTML]=\"checkboxItem?.name\"></span>\n        </label>\n      </div>\n    </div>"
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], CheckboxesComponent);
            // TODO: Add this control
            var FileComponent = /** @class */ (function () {
                function FileComponent(jsf) {
                    this.jsf = jsf;
                    this.controlDisabled = false;
                    this.boundControl = false;
                }
                FileComponent.prototype.ngOnInit = function () {
                    this.options = this.layoutNode.options || {};
                    this.jsf.initializeControl(this);
                };
                FileComponent.prototype.updateValue = function (event) {
                    this.jsf.updateValue(this, event.target.value);
                };
                return FileComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], FileComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], FileComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], FileComponent.prototype, "dataIndex", void 0);
            FileComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'file-widget',
                    template: ""
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], FileComponent);
            var InputComponent = /** @class */ (function () {
                function InputComponent(jsf) {
                    this.jsf = jsf;
                    this.controlDisabled = false;
                    this.boundControl = false;
                    this.autoCompleteList = [];
                }
                InputComponent.prototype.ngOnInit = function () {
                    this.options = this.layoutNode.options || {};
                    this.jsf.initializeControl(this);
                };
                InputComponent.prototype.updateValue = function (event) {
                    this.jsf.updateValue(this, event.target.value);
                };
                return InputComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], InputComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], InputComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], InputComponent.prototype, "dataIndex", void 0);
            InputComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'input-widget',
                    template: "\n    <div [class]=\"options?.htmlClass || ''\">\n      <label *ngIf=\"options?.title\"\n        [attr.for]=\"'control' + layoutNode?._id\"\n        [class]=\"options?.labelHtmlClass || ''\"\n        [style.display]=\"options?.notitle ? 'none' : ''\"\n        [innerHTML]=\"options?.title\"></label>\n      <input *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.list]=\"'control' + layoutNode?._id + 'Autocomplete'\"\n        [attr.maxlength]=\"options?.maxLength\"\n        [attr.minlength]=\"options?.minLength\"\n        [attr.pattern]=\"options?.pattern\"\n        [attr.placeholder]=\"options?.placeholder\"\n        [attr.required]=\"options?.required\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [type]=\"layoutNode?.type\">\n      <input *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.list]=\"'control' + layoutNode?._id + 'Autocomplete'\"\n        [attr.maxlength]=\"options?.maxLength\"\n        [attr.minlength]=\"options?.minLength\"\n        [attr.pattern]=\"options?.pattern\"\n        [attr.placeholder]=\"options?.placeholder\"\n        [attr.required]=\"options?.required\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [disabled]=\"controlDisabled\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [type]=\"layoutNode?.type\"\n        [value]=\"controlValue\"\n        (input)=\"updateValue($event)\">\n        <datalist *ngIf=\"options?.typeahead?.source\"\n          [id]=\"'control' + layoutNode?._id + 'Autocomplete'\">\n          <option *ngFor=\"let word of options?.typeahead?.source\" [value]=\"word\">\n        </datalist>\n    </div>"
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], InputComponent);
            var MessageComponent = /** @class */ (function () {
                function MessageComponent(jsf) {
                    this.jsf = jsf;
                    this.message = null;
                }
                MessageComponent.prototype.ngOnInit = function () {
                    this.options = this.layoutNode.options || {};
                    this.message = this.options.help || this.options.helpvalue ||
                        this.options.msg || this.options.message;
                };
                return MessageComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], MessageComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MessageComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MessageComponent.prototype, "dataIndex", void 0);
            MessageComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'message-widget',
                    template: "\n    <span *ngIf=\"message\"\n      [class]=\"options?.labelHtmlClass || ''\"\n      [innerHTML]=\"message\"></span>"
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], MessageComponent);
            var NoneComponent = /** @class */ (function () {
                function NoneComponent() {
                }
                return NoneComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], NoneComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], NoneComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], NoneComponent.prototype, "dataIndex", void 0);
            NoneComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'none-widget',
                    template: ""
                })
            ], NoneComponent);
            var NumberComponent = /** @class */ (function () {
                function NumberComponent(jsf) {
                    this.jsf = jsf;
                    this.controlDisabled = false;
                    this.boundControl = false;
                    this.allowNegative = true;
                    this.allowDecimal = true;
                    this.allowExponents = false;
                    this.lastValidNumber = '';
                }
                NumberComponent.prototype.ngOnInit = function () {
                    this.options = this.layoutNode.options || {};
                    this.jsf.initializeControl(this);
                    if (this.layoutNode.dataType === 'integer') {
                        this.allowDecimal = false;
                    }
                };
                NumberComponent.prototype.updateValue = function (event) {
                    this.jsf.updateValue(this, event.target.value);
                };
                return NumberComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], NumberComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], NumberComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], NumberComponent.prototype, "dataIndex", void 0);
            NumberComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'number-widget',
                    template: "\n    <div [class]=\"options?.htmlClass || ''\">\n      <label *ngIf=\"options?.title\"\n        [attr.for]=\"'control' + layoutNode?._id\"\n        [class]=\"options?.labelHtmlClass || ''\"\n        [style.display]=\"options?.notitle ? 'none' : ''\"\n        [innerHTML]=\"options?.title\"></label>\n      <input *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.max]=\"options?.maximum\"\n        [attr.min]=\"options?.minimum\"\n        [attr.placeholder]=\"options?.placeholder\"\n        [attr.required]=\"options?.required\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.step]=\"options?.multipleOf || options?.step || 'any'\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [title]=\"lastValidNumber\"\n        [type]=\"layoutNode?.type === 'range' ? 'range' : 'number'\">\n      <input *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.max]=\"options?.maximum\"\n        [attr.min]=\"options?.minimum\"\n        [attr.placeholder]=\"options?.placeholder\"\n        [attr.required]=\"options?.required\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.step]=\"options?.multipleOf || options?.step || 'any'\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [disabled]=\"controlDisabled\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [title]=\"lastValidNumber\"\n        [type]=\"layoutNode?.type === 'range' ? 'range' : 'number'\"\n        [value]=\"controlValue\"\n        (input)=\"updateValue($event)\">\n      <span *ngIf=\"layoutNode?.type === 'range'\" [innerHTML]=\"controlValue\"></span>\n    </div>"
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], NumberComponent);
            // TODO: Add this control
            var OneOfComponent = /** @class */ (function () {
                function OneOfComponent(jsf) {
                    this.jsf = jsf;
                    this.controlDisabled = false;
                    this.boundControl = false;
                }
                OneOfComponent.prototype.ngOnInit = function () {
                    this.options = this.layoutNode.options || {};
                    this.jsf.initializeControl(this);
                };
                OneOfComponent.prototype.updateValue = function (event) {
                    this.jsf.updateValue(this, event.target.value);
                };
                return OneOfComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], OneOfComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], OneOfComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], OneOfComponent.prototype, "dataIndex", void 0);
            OneOfComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'one-of-widget',
                    template: ""
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], OneOfComponent);
            var RadiosComponent = /** @class */ (function () {
                function RadiosComponent(jsf) {
                    this.jsf = jsf;
                    this.controlDisabled = false;
                    this.boundControl = false;
                    this.layoutOrientation = 'vertical';
                    this.radiosList = [];
                }
                RadiosComponent.prototype.ngOnInit = function () {
                    this.options = this.layoutNode.options || {};
                    if (this.layoutNode.type === 'radios-inline' ||
                        this.layoutNode.type === 'radiobuttons') {
                        this.layoutOrientation = 'horizontal';
                    }
                    this.radiosList = buildTitleMap(this.options.titleMap || this.options.enumNames, this.options.enum, true);
                    this.jsf.initializeControl(this);
                };
                RadiosComponent.prototype.updateValue = function (event) {
                    this.jsf.updateValue(this, event.target.value);
                };
                return RadiosComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], RadiosComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], RadiosComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], RadiosComponent.prototype, "dataIndex", void 0);
            RadiosComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'radios-widget',
                    template: "\n    <label *ngIf=\"options?.title\"\n      [attr.for]=\"'control' + layoutNode?._id\"\n      [class]=\"options?.labelHtmlClass || ''\"\n      [style.display]=\"options?.notitle ? 'none' : ''\"\n      [innerHTML]=\"options?.title\"></label>\n\n    <!-- 'horizontal' = radios-inline or radiobuttons -->\n    <div *ngIf=\"layoutOrientation === 'horizontal'\"\n      [class]=\"options?.htmlClass || ''\">\n      <label *ngFor=\"let radioItem of radiosList\"\n        [attr.for]=\"'control' + layoutNode?._id + '/' + radioItem?.value\"\n        [class]=\"(options?.itemLabelHtmlClass || '') +\n          ((controlValue + '' === radioItem?.value + '') ?\n          (' ' + (options?.activeClass || '') + ' ' + (options?.style?.selected || '')) :\n          (' ' + (options?.style?.unselected || '')))\">\n        <input type=\"radio\"\n          [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n          [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n          [attr.required]=\"options?.required\"\n          [checked]=\"radioItem?.value === controlValue\"\n          [class]=\"options?.fieldHtmlClass || ''\"\n          [disabled]=\"controlDisabled\"\n          [id]=\"'control' + layoutNode?._id + '/' + radioItem?.value\"\n          [name]=\"controlName\"\n          [value]=\"radioItem?.value\"\n          (change)=\"updateValue($event)\">\n        <span [innerHTML]=\"radioItem?.name\"></span>\n      </label>\n    </div>\n\n    <!-- 'vertical' = regular radios -->\n    <div *ngIf=\"layoutOrientation !== 'horizontal'\">\n      <div *ngFor=\"let radioItem of radiosList\"\n        [class]=\"options?.htmlClass || ''\">\n        <label\n          [attr.for]=\"'control' + layoutNode?._id + '/' + radioItem?.value\"\n          [class]=\"(options?.itemLabelHtmlClass || '') +\n            ((controlValue + '' === radioItem?.value + '') ?\n            (' ' + (options?.activeClass || '') + ' ' + (options?.style?.selected || '')) :\n            (' ' + (options?.style?.unselected || '')))\">\n          <input type=\"radio\"\n            [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n            [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n            [attr.required]=\"options?.required\"\n            [checked]=\"radioItem?.value === controlValue\"\n            [class]=\"options?.fieldHtmlClass || ''\"\n            [disabled]=\"controlDisabled\"\n            [id]=\"'control' + layoutNode?._id + '/' + radioItem?.value\"\n            [name]=\"controlName\"\n            [value]=\"radioItem?.value\"\n            (change)=\"updateValue($event)\">\n          <span [innerHTML]=\"radioItem?.name\"></span>\n        </label>\n      </div>\n    </div>"
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], RadiosComponent);
            var RootComponent = /** @class */ (function () {
                function RootComponent(jsf) {
                    this.jsf = jsf;
                    this.isFlexItem = false;
                }
                RootComponent.prototype.isDraggable = function (node) {
                    return node.arrayItem && node.type !== '$ref' &&
                        node.arrayItemType === 'list' && this.isOrderable !== false;
                };
                // Set attributes for flexbox child
                // (container attributes are set in section.component)
                RootComponent.prototype.getFlexAttribute = function (node, attribute) {
                    var index = ['flex-grow', 'flex-shrink', 'flex-basis'].indexOf(attribute);
                    return ((node.options || {}).flex || '').split(/\s+/)[index] ||
                        (node.options || {})[attribute] || ['1', '1', 'auto'][index];
                };
                RootComponent.prototype.showWidget = function (layoutNode) {
                    return this.jsf.evaluateCondition(layoutNode, this.dataIndex);
                };
                return RootComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], RootComponent.prototype, "dataIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], RootComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], RootComponent.prototype, "layout", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)
            ], RootComponent.prototype, "isOrderable", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], RootComponent.prototype, "isFlexItem", void 0);
            RootComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'root-widget',
                    template: "\n    <div *ngFor=\"let layoutItem of layout; let i = index\"\n      [class.form-flex-item]=\"isFlexItem\"\n      [style.align-self]=\"(layoutItem.options || {})['align-self']\"\n      [style.flex-basis]=\"getFlexAttribute(layoutItem, 'flex-basis')\"\n      [style.flex-grow]=\"getFlexAttribute(layoutItem, 'flex-grow')\"\n      [style.flex-shrink]=\"getFlexAttribute(layoutItem, 'flex-shrink')\"\n      [style.order]=\"(layoutItem.options || {}).order\">\n      <div\n        [dataIndex]=\"layoutItem?.arrayItem ? (dataIndex || []).concat(i) : (dataIndex || [])\"\n        [layoutIndex]=\"(layoutIndex || []).concat(i)\"\n        [layoutNode]=\"layoutItem\"\n        [orderable]=\"isDraggable(layoutItem)\">\n        <select-framework-widget *ngIf=\"showWidget(layoutItem)\"\n          [dataIndex]=\"layoutItem?.arrayItem ? (dataIndex || []).concat(i) : (dataIndex || [])\"\n          [layoutIndex]=\"(layoutIndex || []).concat(i)\"\n          [layoutNode]=\"layoutItem\"></select-framework-widget>\n      </div>\n    </div>",
                    styles: ["\n    [draggable=true] {\n      transition: all 150ms cubic-bezier(.4, 0, .2, 1);\n    }\n    [draggable=true]:hover {\n      cursor: move;\n      box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);\n      position: relative; z-index: 10;\n      margin-top: -1px;\n      margin-left: -1px;\n      margin-right: 1px;\n      margin-bottom: 1px;\n    }\n    [draggable=true].drag-target-top {\n      box-shadow: 0 -2px 0 #000;\n      position: relative; z-index: 20;\n    }\n    [draggable=true].drag-target-bottom {\n      box-shadow: 0 2px 0 #000;\n      position: relative; z-index: 20;\n    }\n  "]
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], RootComponent);
            var SectionComponent = /** @class */ (function () {
                function SectionComponent(jsf) {
                    this.jsf = jsf;
                    this.expanded = true;
                }
                Object.defineProperty(SectionComponent.prototype, "sectionTitle", {
                    get: function () {
                        return this.options.notitle ? null : this.jsf.setItemTitle(this);
                    },
                    enumerable: true,
                    configurable: true
                });
                SectionComponent.prototype.ngOnInit = function () {
                    this.jsf.initializeControl(this);
                    this.options = this.layoutNode.options || {};
                    this.expanded = typeof this.options.expanded === 'boolean' ?
                        this.options.expanded : !this.options.expandable;
                    switch (this.layoutNode.type) {
                        case 'fieldset':
                        case 'array':
                        case 'tab':
                        case 'advancedfieldset':
                        case 'authfieldset':
                        case 'optionfieldset':
                        case 'selectfieldset':
                            this.containerType = 'fieldset';
                            break;
                        default: // 'div', 'flex', 'section', 'conditional', 'actions', 'tagsinput'
                            this.containerType = 'div';
                            break;
                    }
                };
                SectionComponent.prototype.toggleExpanded = function () {
                    if (this.options.expandable) {
                        this.expanded = !this.expanded;
                    }
                };
                // Set attributes for flexbox container
                // (child attributes are set in root.component)
                SectionComponent.prototype.getFlexAttribute = function (attribute) {
                    var flexActive = this.layoutNode.type === 'flex' ||
                        !!this.options.displayFlex ||
                        this.options.display === 'flex';
                    if (attribute !== 'flex' && !flexActive) {
                        return null;
                    }
                    switch (attribute) {
                        case 'is-flex':
                            return flexActive;
                        case 'display':
                            return flexActive ? 'flex' : 'initial';
                        case 'flex-direction':
                        case 'flex-wrap':
                            var index = ['flex-direction', 'flex-wrap'].indexOf(attribute);
                            return (this.options['flex-flow'] || '').split(/\s+/)[index] ||
                                this.options[attribute] || ['column', 'nowrap'][index];
                        case 'justify-content':
                        case 'align-items':
                        case 'align-content':
                            return this.options[attribute];
                    }
                };
                return SectionComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], SectionComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], SectionComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], SectionComponent.prototype, "dataIndex", void 0);
            SectionComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'section-widget',
                    template: "\n    <div *ngIf=\"containerType === 'div'\"\n      [class]=\"options?.htmlClass || ''\"\n      [class.expandable]=\"options?.expandable && !expanded\"\n      [class.expanded]=\"options?.expandable && expanded\">\n      <label *ngIf=\"sectionTitle\"\n        class=\"legend\"\n        [class]=\"options?.labelHtmlClass || ''\"\n        [innerHTML]=\"sectionTitle\"\n        (click)=\"toggleExpanded()\"></label>\n      <root-widget *ngIf=\"expanded\"\n        [dataIndex]=\"dataIndex\"\n        [layout]=\"layoutNode.items\"\n        [layoutIndex]=\"layoutIndex\"\n        [isFlexItem]=\"getFlexAttribute('is-flex')\"\n        [isOrderable]=\"options?.orderable\"\n        [class.form-flex-column]=\"getFlexAttribute('flex-direction') === 'column'\"\n        [class.form-flex-row]=\"getFlexAttribute('flex-direction') === 'row'\"\n        [style.align-content]=\"getFlexAttribute('align-content')\"\n        [style.align-items]=\"getFlexAttribute('align-items')\"\n        [style.display]=\"getFlexAttribute('display')\"\n        [style.flex-direction]=\"getFlexAttribute('flex-direction')\"\n        [style.flex-wrap]=\"getFlexAttribute('flex-wrap')\"\n        [style.justify-content]=\"getFlexAttribute('justify-content')\"></root-widget>\n    </div>\n    <fieldset *ngIf=\"containerType === 'fieldset'\"\n      [class]=\"options?.htmlClass || ''\"\n      [class.expandable]=\"options?.expandable && !expanded\"\n      [class.expanded]=\"options?.expandable && expanded\"\n      [disabled]=\"options?.readonly\">\n      <legend *ngIf=\"sectionTitle\"\n        class=\"legend\"\n        [class]=\"options?.labelHtmlClass || ''\"\n        [innerHTML]=\"sectionTitle\"\n        (click)=\"toggleExpanded()\"></legend>\n      <div *ngIf=\"options?.messageLocation !== 'bottom'\">\n        <p *ngIf=\"options?.description\"\n        class=\"help-block\"\n        [class]=\"options?.labelHelpBlockClass || ''\"\n        [innerHTML]=\"options?.description\"></p>\n      </div>\n      <root-widget *ngIf=\"expanded\"\n        [dataIndex]=\"dataIndex\"\n        [layout]=\"layoutNode.items\"\n        [layoutIndex]=\"layoutIndex\"\n        [isFlexItem]=\"getFlexAttribute('is-flex')\"\n        [isOrderable]=\"options?.orderable\"\n        [class.form-flex-column]=\"getFlexAttribute('flex-direction') === 'column'\"\n        [class.form-flex-row]=\"getFlexAttribute('flex-direction') === 'row'\"\n        [style.align-content]=\"getFlexAttribute('align-content')\"\n        [style.align-items]=\"getFlexAttribute('align-items')\"\n        [style.display]=\"getFlexAttribute('display')\"\n        [style.flex-direction]=\"getFlexAttribute('flex-direction')\"\n        [style.flex-wrap]=\"getFlexAttribute('flex-wrap')\"\n        [style.justify-content]=\"getFlexAttribute('justify-content')\"></root-widget>\n      <div *ngIf=\"options?.messageLocation === 'bottom'\">\n        <p *ngIf=\"options?.description\"\n        class=\"help-block\"\n        [class]=\"options?.labelHelpBlockClass || ''\"\n        [innerHTML]=\"options?.description\"></p>\n      </div>\n    </fieldset>",
                    styles: ["\n    .legend { font-weight: bold; }\n    .expandable > legend:before, .expandable > label:before  { content: '\u25B6'; padding-right: .3em; }\n    .expanded > legend:before, .expanded > label:before  { content: '\u25BC'; padding-right: .2em; }\n  "]
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], SectionComponent);
            var SelectComponent = /** @class */ (function () {
                function SelectComponent(jsf) {
                    this.jsf = jsf;
                    this.controlDisabled = false;
                    this.boundControl = false;
                    this.selectList = [];
                    this.isArray = isArray;
                }
                SelectComponent.prototype.ngOnInit = function () {
                    this.options = this.layoutNode.options || {};
                    this.selectList = buildTitleMap(this.options.titleMap || this.options.enumNames, this.options.enum, !!this.options.required, !!this.options.flatList);
                    this.jsf.initializeControl(this);
                };
                SelectComponent.prototype.updateValue = function (event) {
                    this.jsf.updateValue(this, event.target.value);
                };
                return SelectComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], SelectComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], SelectComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], SelectComponent.prototype, "dataIndex", void 0);
            SelectComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'select-widget',
                    template: "\n    <div\n      [class]=\"options?.htmlClass || ''\">\n      <label *ngIf=\"options?.title\"\n        [attr.for]=\"'control' + layoutNode?._id\"\n        [class]=\"options?.labelHtmlClass || ''\"\n        [style.display]=\"options?.notitle ? 'none' : ''\"\n        [innerHTML]=\"options?.title\"></label>\n      <select *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.required]=\"options?.required\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\">\n        <ng-template ngFor let-selectItem [ngForOf]=\"selectList\">\n          <option *ngIf=\"!isArray(selectItem?.items)\"\n            [value]=\"selectItem?.value\">\n            <span [innerHTML]=\"selectItem?.name\"></span>\n          </option>\n          <optgroup *ngIf=\"isArray(selectItem?.items)\"\n            [label]=\"selectItem?.group\">\n            <option *ngFor=\"let subItem of selectItem.items\"\n              [value]=\"subItem?.value\">\n              <span [innerHTML]=\"subItem?.name\"></span>\n            </option>\n          </optgroup>\n        </ng-template>\n      </select>\n      <select *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.required]=\"options?.required\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [disabled]=\"controlDisabled\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        (change)=\"updateValue($event)\">\n        <ng-template ngFor let-selectItem [ngForOf]=\"selectList\">\n          <option *ngIf=\"!isArray(selectItem?.items)\"\n            [selected]=\"selectItem?.value === controlValue\"\n            [value]=\"selectItem?.value\">\n            <span [innerHTML]=\"selectItem?.name\"></span>\n          </option>\n          <optgroup *ngIf=\"isArray(selectItem?.items)\"\n            [label]=\"selectItem?.group\">\n            <option *ngFor=\"let subItem of selectItem.items\"\n              [attr.selected]=\"subItem?.value === controlValue\"\n              [value]=\"subItem?.value\">\n              <span [innerHTML]=\"subItem?.name\"></span>\n            </option>\n          </optgroup>\n        </ng-template>\n      </select>\n    </div>"
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], SelectComponent);
            var SelectFrameworkComponent = /** @class */ (function () {
                function SelectFrameworkComponent(componentFactory, jsf) {
                    this.componentFactory = componentFactory;
                    this.jsf = jsf;
                    this.newComponent = null;
                }
                SelectFrameworkComponent.prototype.ngOnInit = function () {
                    this.updateComponent();
                };
                SelectFrameworkComponent.prototype.ngOnChanges = function () {
                    this.updateComponent();
                };
                SelectFrameworkComponent.prototype.updateComponent = function () {
                    if (this.widgetContainer && !this.newComponent && this.jsf.framework) {
                        this.newComponent = this.widgetContainer.createComponent(this.componentFactory.resolveComponentFactory(this.jsf.framework));
                    }
                    if (this.newComponent) {
                        for (var _a = 0, _b = ['layoutNode', 'layoutIndex', 'dataIndex']; _a < _b.length; _a++) {
                            var input = _b[_a];
                            this.newComponent.instance[input] = this[input];
                        }
                    }
                };
                return SelectFrameworkComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], SelectFrameworkComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], SelectFrameworkComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], SelectFrameworkComponent.prototype, "dataIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["ViewChild"])('widgetContainer', {
                    read: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ViewContainerRef"],
                    static: true
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_8__["ViewContainerRef"])
            ], SelectFrameworkComponent.prototype, "widgetContainer", void 0);
            SelectFrameworkComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'select-framework-widget',
                    template: "<div #widgetContainer></div>"
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_8__["ComponentFactoryResolver"],
                    JsonSchemaFormService])
            ], SelectFrameworkComponent);
            var SelectWidgetComponent = /** @class */ (function () {
                function SelectWidgetComponent(componentFactory, jsf) {
                    this.componentFactory = componentFactory;
                    this.jsf = jsf;
                    this.newComponent = null;
                }
                SelectWidgetComponent.prototype.ngOnInit = function () {
                    this.updateComponent();
                };
                SelectWidgetComponent.prototype.ngOnChanges = function () {
                    this.updateComponent();
                };
                SelectWidgetComponent.prototype.updateComponent = function () {
                    if (this.widgetContainer && !this.newComponent && (this.layoutNode || {}).widget) {
                        this.newComponent = this.widgetContainer.createComponent(this.componentFactory.resolveComponentFactory(this.layoutNode.widget));
                    }
                    if (this.newComponent) {
                        for (var _a = 0, _b = ['layoutNode', 'layoutIndex', 'dataIndex']; _a < _b.length; _a++) {
                            var input = _b[_a];
                            this.newComponent.instance[input] = this[input];
                        }
                    }
                };
                return SelectWidgetComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], SelectWidgetComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], SelectWidgetComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], SelectWidgetComponent.prototype, "dataIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["ViewChild"])('widgetContainer', { read: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ViewContainerRef"], static: true }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_8__["ViewContainerRef"])
            ], SelectWidgetComponent.prototype, "widgetContainer", void 0);
            SelectWidgetComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'select-widget-widget',
                    template: "<div #widgetContainer></div>"
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_8__["ComponentFactoryResolver"],
                    JsonSchemaFormService])
            ], SelectWidgetComponent);
            var SubmitComponent = /** @class */ (function () {
                function SubmitComponent(jsf) {
                    this.jsf = jsf;
                    this.controlDisabled = false;
                    this.boundControl = false;
                }
                SubmitComponent.prototype.ngOnInit = function () {
                    var _this_1 = this;
                    this.options = this.layoutNode.options || {};
                    this.jsf.initializeControl(this);
                    if (hasOwn(this.options, 'disabled')) {
                        this.controlDisabled = this.options.disabled;
                    }
                    else if (this.jsf.formOptions.disableInvalidSubmit) {
                        this.controlDisabled = !this.jsf.isValid;
                        this.jsf.isValidChanges.subscribe(function (isValid) { return _this_1.controlDisabled = !isValid; });
                    }
                    if (this.controlValue === null || this.controlValue === undefined) {
                        this.controlValue = this.options.title;
                    }
                };
                SubmitComponent.prototype.updateValue = function (event) {
                    if (typeof this.options.onClick === 'function') {
                        this.options.onClick(event);
                    }
                    else {
                        this.jsf.updateValue(this, event.target.value);
                    }
                };
                return SubmitComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], SubmitComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], SubmitComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], SubmitComponent.prototype, "dataIndex", void 0);
            SubmitComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'submit-widget',
                    template: "\n    <div\n      [class]=\"options?.htmlClass || ''\">\n      <input\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.required]=\"options?.required\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [disabled]=\"controlDisabled\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [type]=\"layoutNode?.type\"\n        [value]=\"controlValue\"\n        (click)=\"updateValue($event)\">\n    </div>"
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], SubmitComponent);
            var TabsComponent = /** @class */ (function () {
                function TabsComponent(jsf) {
                    this.jsf = jsf;
                    this.selectedItem = 0;
                    this.showAddTab = true;
                }
                TabsComponent.prototype.ngOnInit = function () {
                    this.options = this.layoutNode.options || {};
                    this.itemCount = this.layoutNode.items.length - 1;
                    this.updateControl();
                };
                TabsComponent.prototype.select = function (index) {
                    if (this.layoutNode.items[index].type === '$ref') {
                        this.itemCount = this.layoutNode.items.length;
                        this.jsf.addItem({
                            layoutNode: this.layoutNode.items[index],
                            layoutIndex: this.layoutIndex.concat(index),
                            dataIndex: this.dataIndex.concat(index)
                        });
                        this.updateControl();
                    }
                    this.selectedItem = index;
                };
                TabsComponent.prototype.updateControl = function () {
                    var lastItem = this.layoutNode.items[this.layoutNode.items.length - 1];
                    if (lastItem.type === '$ref' &&
                        this.itemCount >= (lastItem.options.maxItems || 1000)) {
                        this.showAddTab = false;
                    }
                };
                TabsComponent.prototype.setTabTitle = function (item, index) {
                    return this.jsf.setArrayItemTitle(this, item, index);
                };
                return TabsComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], TabsComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], TabsComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], TabsComponent.prototype, "dataIndex", void 0);
            TabsComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'tabs-widget',
                    template: "\n    <ul\n      [class]=\"options?.labelHtmlClass || ''\">\n      <li *ngFor=\"let item of layoutNode?.items; let i = index\"\n        [class]=\"(options?.itemLabelHtmlClass || '') + (selectedItem === i ?\n          (' ' + (options?.activeClass || '') + ' ' + (options?.style?.selected || '')) :\n          (' ' + options?.style?.unselected))\"\n        role=\"presentation\"\n        data-tabs>\n        <a *ngIf=\"showAddTab || item.type !== '$ref'\"\n           [class]=\"'nav-link' + (selectedItem === i ? (' ' + options?.activeClass + ' ' + options?.style?.selected) :\n            (' ' + options?.style?.unselected))\"\n          [innerHTML]=\"setTabTitle(item, i)\"\n          (click)=\"select(i)\"></a>\n      </li>\n    </ul>\n\n    <div *ngFor=\"let layoutItem of layoutNode?.items; let i = index\"\n      [class]=\"options?.htmlClass || ''\">\n\n      <select-framework-widget *ngIf=\"selectedItem === i\"\n        [class]=\"(options?.fieldHtmlClass || '') +\n          ' ' + (options?.activeClass || '') +\n          ' ' + (options?.style?.selected || '')\"\n        [dataIndex]=\"layoutNode?.dataType === 'array' ? (dataIndex || []).concat(i) : dataIndex\"\n        [layoutIndex]=\"(layoutIndex || []).concat(i)\"\n        [layoutNode]=\"layoutItem\"></select-framework-widget>\n\n    </div>",
                    styles: [" a { cursor: pointer; } "]
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], TabsComponent);
            var TemplateComponent = /** @class */ (function () {
                function TemplateComponent(componentFactory, jsf) {
                    this.componentFactory = componentFactory;
                    this.jsf = jsf;
                    this.newComponent = null;
                }
                TemplateComponent.prototype.ngOnInit = function () {
                    this.updateComponent();
                };
                TemplateComponent.prototype.ngOnChanges = function () {
                    this.updateComponent();
                };
                TemplateComponent.prototype.updateComponent = function () {
                    if (this.widgetContainer && !this.newComponent && this.layoutNode.options.template) {
                        this.newComponent = this.widgetContainer.createComponent(this.componentFactory.resolveComponentFactory(this.layoutNode.options.template));
                    }
                    if (this.newComponent) {
                        for (var _a = 0, _b = ['layoutNode', 'layoutIndex', 'dataIndex']; _a < _b.length; _a++) {
                            var input = _b[_a];
                            this.newComponent.instance[input] = this[input];
                        }
                    }
                };
                return TemplateComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], TemplateComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], TemplateComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], TemplateComponent.prototype, "dataIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["ViewChild"])('widgetContainer', { read: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ViewContainerRef"], static: true }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_8__["ViewContainerRef"])
            ], TemplateComponent.prototype, "widgetContainer", void 0);
            TemplateComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'template-widget',
                    template: "<div #widgetContainer></div>"
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_8__["ComponentFactoryResolver"],
                    JsonSchemaFormService])
            ], TemplateComponent);
            var TextareaComponent = /** @class */ (function () {
                function TextareaComponent(jsf) {
                    this.jsf = jsf;
                    this.controlDisabled = false;
                    this.boundControl = false;
                }
                TextareaComponent.prototype.ngOnInit = function () {
                    this.options = this.layoutNode.options || {};
                    this.jsf.initializeControl(this);
                };
                TextareaComponent.prototype.updateValue = function (event) {
                    this.jsf.updateValue(this, event.target.value);
                };
                return TextareaComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], TextareaComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], TextareaComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], TextareaComponent.prototype, "dataIndex", void 0);
            TextareaComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'textarea-widget',
                    template: "\n    <div\n      [class]=\"options?.htmlClass || ''\">\n      <label *ngIf=\"options?.title\"\n        [attr.for]=\"'control' + layoutNode?._id\"\n        [class]=\"options?.labelHtmlClass || ''\"\n        [style.display]=\"options?.notitle ? 'none' : ''\"\n        [innerHTML]=\"options?.title\"></label>\n      <textarea *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.maxlength]=\"options?.maxLength\"\n        [attr.minlength]=\"options?.minLength\"\n        [attr.pattern]=\"options?.pattern\"\n        [attr.placeholder]=\"options?.placeholder\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.required]=\"options?.required\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"></textarea>\n      <textarea *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.maxlength]=\"options?.maxLength\"\n        [attr.minlength]=\"options?.minLength\"\n        [attr.pattern]=\"options?.pattern\"\n        [attr.placeholder]=\"options?.placeholder\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.required]=\"options?.required\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [disabled]=\"controlDisabled\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [value]=\"controlValue\"\n        (input)=\"updateValue($event)\">{{controlValue}}</textarea>\n    </div>"
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], TextareaComponent);
            var WidgetLibraryService = /** @class */ (function () {
                function WidgetLibraryService() {
                    this.defaultWidget = 'text';
                    this.widgetLibrary = {
                        // Angular JSON Schema Form administrative widgets
                        'none': NoneComponent,
                        'root': RootComponent,
                        'select-framework': SelectFrameworkComponent,
                        'select-widget': SelectWidgetComponent,
                        '$ref': AddReferenceComponent,
                        // Free-form text HTML 'input' form control widgets <input type="...">
                        'email': 'text',
                        'integer': 'number',
                        'number': NumberComponent,
                        'password': 'text',
                        'search': 'text',
                        'tel': 'text',
                        'text': InputComponent,
                        'url': 'text',
                        // Controlled text HTML 'input' form control widgets <input type="...">
                        'color': 'text',
                        'date': 'text',
                        'datetime': 'text',
                        'datetime-local': 'text',
                        'month': 'text',
                        'range': 'number',
                        'time': 'text',
                        'week': 'text',
                        // Non-text HTML 'input' form control widgets <input type="...">
                        // 'button': <input type="button"> not used, use <button> instead
                        'checkbox': CheckboxComponent,
                        'file': FileComponent,
                        'hidden': 'text',
                        'image': 'text',
                        'radio': 'radios',
                        'reset': 'submit',
                        'submit': SubmitComponent,
                        // Other (non-'input') HTML form control widgets
                        'button': ButtonComponent,
                        'select': SelectComponent,
                        // 'option': automatically generated by select widgets
                        // 'optgroup': automatically generated by select widgets
                        'textarea': TextareaComponent,
                        // HTML form control widget sets
                        'checkboxes': CheckboxesComponent,
                        'checkboxes-inline': 'checkboxes',
                        'checkboxbuttons': 'checkboxes',
                        'radios': RadiosComponent,
                        'radios-inline': 'radios',
                        'radiobuttons': 'radios',
                        // HTML Layout widgets
                        // 'label': automatically added to data widgets
                        // 'legend': automatically added to fieldsets
                        'section': SectionComponent,
                        'div': 'section',
                        'fieldset': 'section',
                        'flex': 'section',
                        // Non-HTML layout widgets
                        'one-of': OneOfComponent,
                        // TODO: Finish 'one-of' widget
                        'array': 'section',
                        'tabarray': 'tabs',
                        'tab': 'section',
                        'tabs': TabsComponent,
                        'message': MessageComponent,
                        'help': 'message',
                        'msg': 'message',
                        'html': 'message',
                        'template': TemplateComponent,
                        // Widgets included for compatibility with JSON Form API
                        'advancedfieldset': 'section',
                        'authfieldset': 'section',
                        'optionfieldset': 'one-of',
                        'selectfieldset': 'one-of',
                        'conditional': 'section',
                        'actions': 'section',
                        'tagsinput': 'section',
                        // See: http://ulion.github.io/jsonform/playground/?example=fields-checkboxbuttons
                        // Widgets included for compatibility with React JSON Schema Form API
                        'updown': 'number',
                        'date-time': 'datetime-local',
                        'alt-datetime': 'datetime-local',
                        'alt-date': 'date',
                        // Widgets included for compatibility with Angular Schema Form API
                        'wizard': 'section',
                        // Widgets included for compatibility with other libraries
                        'textline': 'text',
                    };
                    this.registeredWidgets = {};
                    this.frameworkWidgets = {};
                    this.activeWidgets = {};
                    this.setActiveWidgets();
                }
                WidgetLibraryService.prototype.setActiveWidgets = function () {
                    this.activeWidgets = Object.assign({}, this.widgetLibrary, this.frameworkWidgets, this.registeredWidgets);
                    for (var _a = 0, _b = Object.keys(this.activeWidgets); _a < _b.length; _a++) {
                        var widgetName = _b[_a];
                        var widget = this.activeWidgets[widgetName];
                        // Resolve aliases
                        if (typeof widget === 'string') {
                            var usedAliases = [];
                            while (typeof widget === 'string' && !usedAliases.includes(widget)) {
                                usedAliases.push(widget);
                                widget = this.activeWidgets[widget];
                            }
                            if (typeof widget !== 'string') {
                                this.activeWidgets[widgetName] = widget;
                            }
                        }
                    }
                    return true;
                };
                WidgetLibraryService.prototype.setDefaultWidget = function (type) {
                    if (!this.hasWidget(type)) {
                        return false;
                    }
                    this.defaultWidget = type;
                    return true;
                };
                WidgetLibraryService.prototype.hasWidget = function (type, widgetSet) {
                    if (widgetSet === void 0) { widgetSet = 'activeWidgets'; }
                    if (!type || typeof type !== 'string') {
                        return false;
                    }
                    return hasOwn(this[widgetSet], type);
                };
                WidgetLibraryService.prototype.hasDefaultWidget = function (type) {
                    return this.hasWidget(type, 'widgetLibrary');
                };
                WidgetLibraryService.prototype.registerWidget = function (type, widget) {
                    if (!type || !widget || typeof type !== 'string') {
                        return false;
                    }
                    this.registeredWidgets[type] = widget;
                    return this.setActiveWidgets();
                };
                WidgetLibraryService.prototype.unRegisterWidget = function (type) {
                    if (!hasOwn(this.registeredWidgets, type)) {
                        return false;
                    }
                    delete this.registeredWidgets[type];
                    return this.setActiveWidgets();
                };
                WidgetLibraryService.prototype.unRegisterAllWidgets = function (unRegisterFrameworkWidgets) {
                    if (unRegisterFrameworkWidgets === void 0) { unRegisterFrameworkWidgets = true; }
                    this.registeredWidgets = {};
                    if (unRegisterFrameworkWidgets) {
                        this.frameworkWidgets = {};
                    }
                    return this.setActiveWidgets();
                };
                WidgetLibraryService.prototype.registerFrameworkWidgets = function (widgets) {
                    if (widgets === null || typeof widgets !== 'object') {
                        widgets = {};
                    }
                    this.frameworkWidgets = widgets;
                    return this.setActiveWidgets();
                };
                WidgetLibraryService.prototype.unRegisterFrameworkWidgets = function () {
                    if (Object.keys(this.frameworkWidgets).length) {
                        this.frameworkWidgets = {};
                        return this.setActiveWidgets();
                    }
                    return false;
                };
                WidgetLibraryService.prototype.getWidget = function (type, widgetSet) {
                    if (widgetSet === void 0) { widgetSet = 'activeWidgets'; }
                    if (this.hasWidget(type, widgetSet)) {
                        return this[widgetSet][type];
                    }
                    else if (this.hasWidget(this.defaultWidget, widgetSet)) {
                        return this[widgetSet][this.defaultWidget];
                    }
                    else {
                        return null;
                    }
                };
                WidgetLibraryService.prototype.getAllWidgets = function () {
                    return {
                        widgetLibrary: this.widgetLibrary,
                        registeredWidgets: this.registeredWidgets,
                        frameworkWidgets: this.frameworkWidgets,
                        activeWidgets: this.activeWidgets,
                    };
                };
                return WidgetLibraryService;
            }());
            WidgetLibraryService = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Injectable"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [])
            ], WidgetLibraryService);
            // Possible future frameworks:
            // - Foundation 6:
            //   http://justindavis.co/2017/06/15/using-foundation-6-in-angular-4/
            //   https://github.com/zurb/foundation-sites
            // - Semantic UI:
            //   https://github.com/edcarroll/ng2-semantic-ui
            //   https://github.com/vladotesanovic/ngSemantic
            var FrameworkLibraryService = /** @class */ (function () {
                function FrameworkLibraryService(frameworks, widgetLibrary) {
                    var _this_1 = this;
                    this.frameworks = frameworks;
                    this.widgetLibrary = widgetLibrary;
                    this.activeFramework = null;
                    this.loadExternalAssets = false;
                    this.frameworkLibrary = {};
                    this.frameworks.forEach(function (framework) { return _this_1.frameworkLibrary[framework.name] = framework; });
                    this.defaultFramework = this.frameworks[0].name;
                    this.setFramework(this.defaultFramework);
                }
                FrameworkLibraryService.prototype.setLoadExternalAssets = function (loadExternalAssets) {
                    if (loadExternalAssets === void 0) { loadExternalAssets = true; }
                    this.loadExternalAssets = !!loadExternalAssets;
                };
                FrameworkLibraryService.prototype.setFramework = function (framework, loadExternalAssets) {
                    if (framework === void 0) { framework = this.defaultFramework; }
                    if (loadExternalAssets === void 0) { loadExternalAssets = this.loadExternalAssets; }
                    this.activeFramework =
                        typeof framework === 'string' && this.hasFramework(framework) ?
                            this.frameworkLibrary[framework] :
                            typeof framework === 'object' && hasOwn(framework, 'framework') ?
                                framework :
                                this.frameworkLibrary[this.defaultFramework];
                    return this.registerFrameworkWidgets(this.activeFramework);
                };
                FrameworkLibraryService.prototype.registerFrameworkWidgets = function (framework) {
                    return hasOwn(framework, 'widgets') ?
                        this.widgetLibrary.registerFrameworkWidgets(framework.widgets) :
                        this.widgetLibrary.unRegisterFrameworkWidgets();
                };
                FrameworkLibraryService.prototype.hasFramework = function (type) {
                    return hasOwn(this.frameworkLibrary, type);
                };
                FrameworkLibraryService.prototype.getFramework = function () {
                    if (!this.activeFramework) {
                        this.setFramework('default', true);
                    }
                    return this.activeFramework.framework;
                };
                FrameworkLibraryService.prototype.getFrameworkWidgets = function () {
                    return this.activeFramework.widgets || {};
                };
                FrameworkLibraryService.prototype.getFrameworkStylesheets = function (load) {
                    if (load === void 0) { load = this.loadExternalAssets; }
                    return (load && this.activeFramework.stylesheets) || [];
                };
                FrameworkLibraryService.prototype.getFrameworkScripts = function (load) {
                    if (load === void 0) { load = this.loadExternalAssets; }
                    return (load && this.activeFramework.scripts) || [];
                };
                return FrameworkLibraryService;
            }());
            FrameworkLibraryService = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Injectable"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__param"])(0, Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Inject"])(Framework)),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__param"])(1, Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Inject"])(WidgetLibraryService)),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [Array, WidgetLibraryService])
            ], FrameworkLibraryService);
            var JSON_SCHEMA_FORM_VALUE_ACCESSOR = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_6__["NG_VALUE_ACCESSOR"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["forwardRef"])(function () { return JsonSchemaFormComponent; }),
                multi: true,
            };
            /**
             * @module 'JsonSchemaFormComponent' - Angular JSON Schema Form
             *
             * Root module of the Angular JSON Schema Form client-side library,
             * an Angular library which generates an HTML form from a JSON schema
             * structured data model and/or a JSON Schema Form layout description.
             *
             * This library also validates input data by the user, using both validators on
             * individual controls to provide real-time feedback while the user is filling
             * out the form, and then validating the entire input against the schema when
             * the form is submitted to make sure the returned JSON data object is valid.
             *
             * This library is similar to, and mostly API compatible with:
             *
             * - JSON Schema Form's Angular Schema Form library for AngularJs
             *   http://schemaform.io
             *   http://schemaform.io/examples/bootstrap-example.html (examples)
             *
             * - Mozilla's react-jsonschema-form library for React
             *   https://github.com/mozilla-services/react-jsonschema-form
             *   https://mozilla-services.github.io/react-jsonschema-form (examples)
             *
             * - Joshfire's JSON Form library for jQuery
             *   https://github.com/joshfire/jsonform
             *   http://ulion.github.io/jsonform/playground (examples)
             *
             * This library depends on:
             *  - Angular (obviously)                  https://angular.io
             *  - lodash, JavaScript utility library   https://github.com/lodash/lodash
             *  - ajv, Another JSON Schema validator   https://github.com/epoberezkin/ajv
             *
             * In addition, the Example Playground also depends on:
             *  - brace, Browserified Ace editor       http://thlorenz.github.io/brace
             */
            var JsonSchemaFormComponent = /** @class */ (function () {
                function JsonSchemaFormComponent(changeDetector, frameworkLibrary, widgetLibrary, jsf, sanitizer) {
                    this.changeDetector = changeDetector;
                    this.frameworkLibrary = frameworkLibrary;
                    this.widgetLibrary = widgetLibrary;
                    this.jsf = jsf;
                    this.sanitizer = sanitizer;
                    this.formValueSubscription = null;
                    this.formInitialized = false;
                    this.objectWrap = false; // Is non-object input schema wrapped in an object?
                    this.previousInputs = {
                        schema: null, layout: null, data: null, options: null, framework: null,
                        widgets: null, form: null, model: null, JSONSchema: null, UISchema: null,
                        formData: null, loadExternalAssets: null, debug: null,
                    };
                    // Outputs
                    // tslint:disable-next-line:no-output-on-prefix
                    this.onChanges = new _angular_core__WEBPACK_IMPORTED_MODULE_8__["EventEmitter"](); // Live unvalidated internal form data
                    // tslint:disable-next-line:no-output-on-prefix
                    this.onSubmit = new _angular_core__WEBPACK_IMPORTED_MODULE_8__["EventEmitter"](); // Complete validated form data
                    this.isValid = new _angular_core__WEBPACK_IMPORTED_MODULE_8__["EventEmitter"](); // Is current data valid?
                    this.validationErrors = new _angular_core__WEBPACK_IMPORTED_MODULE_8__["EventEmitter"](); // Validation errors (if any)
                    this.formSchema = new _angular_core__WEBPACK_IMPORTED_MODULE_8__["EventEmitter"](); // Final schema used to create form
                    this.formLayout = new _angular_core__WEBPACK_IMPORTED_MODULE_8__["EventEmitter"](); // Final layout used to create form
                    // Outputs for possible 2-way data binding
                    // Only the one input providing the initial form data will be bound.
                    // If there is no inital data, input '{}' to activate 2-way data binding.
                    // There is no 2-way binding if inital data is combined inside the 'form' input.
                    this.dataChange = new _angular_core__WEBPACK_IMPORTED_MODULE_8__["EventEmitter"]();
                    this.modelChange = new _angular_core__WEBPACK_IMPORTED_MODULE_8__["EventEmitter"]();
                    this.formDataChange = new _angular_core__WEBPACK_IMPORTED_MODULE_8__["EventEmitter"]();
                    this.ngModelChange = new _angular_core__WEBPACK_IMPORTED_MODULE_8__["EventEmitter"]();
                }
                Object.defineProperty(JsonSchemaFormComponent.prototype, "value", {
                    get: function () {
                        return this.objectWrap ? this.jsf.data['1'] : this.jsf.data;
                    },
                    set: function (value) {
                        this.setFormValues(value, false);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(JsonSchemaFormComponent.prototype, "stylesheets", {
                    get: function () {
                        var stylesheets = this.frameworkLibrary.getFrameworkStylesheets();
                        var load = this.sanitizer.bypassSecurityTrustResourceUrl;
                        return stylesheets.map(function (stylesheet) { return load(stylesheet); });
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(JsonSchemaFormComponent.prototype, "scripts", {
                    get: function () {
                        var scripts = this.frameworkLibrary.getFrameworkScripts();
                        var load = this.sanitizer.bypassSecurityTrustResourceUrl;
                        return scripts.map(function (script) { return load(script); });
                    },
                    enumerable: true,
                    configurable: true
                });
                JsonSchemaFormComponent.prototype.ngOnInit = function () {
                    this.updateForm();
                };
                JsonSchemaFormComponent.prototype.ngOnChanges = function () {
                    this.updateForm();
                };
                JsonSchemaFormComponent.prototype.writeValue = function (value) {
                    this.setFormValues(value, false);
                    if (!this.formValuesInput) {
                        this.formValuesInput = 'ngModel';
                    }
                };
                JsonSchemaFormComponent.prototype.registerOnChange = function (fn) {
                    this.onChange = fn;
                };
                JsonSchemaFormComponent.prototype.registerOnTouched = function (fn) {
                    this.onTouched = fn;
                };
                JsonSchemaFormComponent.prototype.setDisabledState = function (isDisabled) {
                    if (this.jsf.formOptions.formDisabled !== !!isDisabled) {
                        this.jsf.formOptions.formDisabled = !!isDisabled;
                        this.initializeForm();
                    }
                };
                JsonSchemaFormComponent.prototype.updateForm = function () {
                    var _this_1 = this;
                    if (!this.formInitialized || !this.formValuesInput ||
                        (this.language && this.language !== this.jsf.language)) {
                        this.initializeForm();
                    }
                    else {
                        if (this.language && this.language !== this.jsf.language) {
                            this.jsf.setLanguage(this.language);
                        }
                        // Get names of changed inputs
                        var changedInput = Object.keys(this.previousInputs)
                            .filter(function (input) { return _this_1.previousInputs[input] !== _this_1[input]; });
                        var resetFirst = true;
                        if (changedInput.length === 1 && changedInput[0] === 'form' &&
                            this.formValuesInput.startsWith('form.')) {
                            // If only 'form' input changed, get names of changed keys
                            changedInput = Object.keys(this.previousInputs.form || {})
                                .filter(function (key) { return !Object(lodash_es_isEqual__WEBPACK_IMPORTED_MODULE_9__["default"])(_this_1.previousInputs.form[key], _this_1.form[key]); })
                                .map(function (key) { return "form." + key; });
                            resetFirst = false;
                        }
                        // If only input values have changed, update the form values
                        if (changedInput.length === 1 && changedInput[0] === this.formValuesInput) {
                            if (this.formValuesInput.indexOf('.') === -1) {
                                this.setFormValues(this[this.formValuesInput], resetFirst);
                            }
                            else {
                                var _a = this.formValuesInput.split('.'), input = _a[0], key = _a[1];
                                this.setFormValues(this[input][key], resetFirst);
                            }
                            // If anything else has changed, re-render the entire form
                        }
                        else if (changedInput.length) {
                            this.initializeForm();
                            if (this.onChange) {
                                this.onChange(this.jsf.formValues);
                            }
                            if (this.onTouched) {
                                this.onTouched(this.jsf.formValues);
                            }
                        }
                        // Update previous inputs
                        Object.keys(this.previousInputs)
                            .filter(function (input) { return _this_1.previousInputs[input] !== _this_1[input]; })
                            .forEach(function (input) { return _this_1.previousInputs[input] = _this_1[input]; });
                    }
                };
                JsonSchemaFormComponent.prototype.setFormValues = function (formValues, resetFirst) {
                    if (resetFirst === void 0) { resetFirst = true; }
                    if (formValues) {
                        var newFormValues = this.objectWrap ? formValues['1'] : formValues;
                        if (!this.jsf.formGroup) {
                            this.jsf.formValues = formValues;
                            this.activateForm();
                        }
                        else if (resetFirst) {
                            this.jsf.formGroup.reset();
                        }
                        if (this.jsf.formGroup) {
                            this.jsf.formGroup.patchValue(newFormValues);
                        }
                        if (this.onChange) {
                            this.onChange(newFormValues);
                        }
                        if (this.onTouched) {
                            this.onTouched(newFormValues);
                        }
                    }
                    else {
                        this.jsf.formGroup.reset();
                    }
                };
                JsonSchemaFormComponent.prototype.submitForm = function () {
                    var validData = this.jsf.validData;
                    this.onSubmit.emit(this.objectWrap ? validData['1'] : validData);
                };
                /**
                 * 'initializeForm' function
                 *
                 * - Update 'schema', 'layout', and 'formValues', from inputs.
                 *
                 * - Create 'schemaRefLibrary' and 'schemaRecursiveRefMap'
                 *   to resolve schema $ref links, including recursive $ref links.
                 *
                 * - Create 'dataRecursiveRefMap' to resolve recursive links in data
                 *   and corectly set output formats for recursively nested values.
                 *
                 * - Create 'layoutRefLibrary' and 'templateRefLibrary' to store
                 *   new layout nodes and formGroup elements to use when dynamically
                 *   adding form components to arrays and recursive $ref points.
                 *
                 * - Create 'dataMap' to map the data to the schema and template.
                 *
                 * - Create the master 'formGroupTemplate' then from it 'formGroup'
                 *   the Angular formGroup used to control the reactive form.
                 */
                JsonSchemaFormComponent.prototype.initializeForm = function () {
                    if (this.schema || this.layout || this.data || this.form || this.model ||
                        this.JSONSchema || this.UISchema || this.formData || this.ngModel ||
                        this.jsf.data) {
                        this.jsf.resetAllValues(); // Reset all form values to defaults
                        this.initializeOptions(); // Update options
                        this.initializeSchema(); // Update schema, schemaRefLibrary,
                        // schemaRecursiveRefMap, & dataRecursiveRefMap
                        this.initializeLayout(); // Update layout, layoutRefLibrary,
                        this.initializeData(); // Update formValues
                        this.activateForm(); // Update dataMap, templateRefLibrary,
                        // formGroupTemplate, formGroup
                        // Uncomment individual lines to output debugging information to console:
                        // (These always work.)
                        // console.log('loading form...');
                        // console.log('schema', this.jsf.schema);
                        // console.log('layout', this.jsf.layout);
                        // console.log('options', this.options);
                        // console.log('formValues', this.jsf.formValues);
                        // console.log('formGroupTemplate', this.jsf.formGroupTemplate);
                        // console.log('formGroup', this.jsf.formGroup);
                        // console.log('formGroup.value', this.jsf.formGroup.value);
                        // console.log('schemaRefLibrary', this.jsf.schemaRefLibrary);
                        // console.log('layoutRefLibrary', this.jsf.layoutRefLibrary);
                        // console.log('templateRefLibrary', this.jsf.templateRefLibrary);
                        // console.log('dataMap', this.jsf.dataMap);
                        // console.log('arrayMap', this.jsf.arrayMap);
                        // console.log('schemaRecursiveRefMap', this.jsf.schemaRecursiveRefMap);
                        // console.log('dataRecursiveRefMap', this.jsf.dataRecursiveRefMap);
                        // Uncomment individual lines to output debugging information to browser:
                        // (These only work if the 'debug' option has also been set to 'true'.)
                        if (this.debug || this.jsf.formOptions.debug) {
                            var vars = [];
                            // vars.push(this.jsf.schema);
                            // vars.push(this.jsf.layout);
                            // vars.push(this.options);
                            // vars.push(this.jsf.formValues);
                            // vars.push(this.jsf.formGroup.value);
                            // vars.push(this.jsf.formGroupTemplate);
                            // vars.push(this.jsf.formGroup);
                            // vars.push(this.jsf.schemaRefLibrary);
                            // vars.push(this.jsf.layoutRefLibrary);
                            // vars.push(this.jsf.templateRefLibrary);
                            // vars.push(this.jsf.dataMap);
                            // vars.push(this.jsf.arrayMap);
                            // vars.push(this.jsf.schemaRecursiveRefMap);
                            // vars.push(this.jsf.dataRecursiveRefMap);
                            this.debugOutput = vars.map(function (v) { return JSON.stringify(v, null, 2); }).join('\n');
                        }
                        this.formInitialized = true;
                    }
                };
                /**
                 * 'initializeOptions' function
                 *
                 * Initialize 'options' (global form options) and set framework
                 * Combine available inputs:
                 * 1. options - recommended
                 * 2. form.options - Single input style
                 */
                JsonSchemaFormComponent.prototype.initializeOptions = function () {
                    if (this.language && this.language !== this.jsf.language) {
                        this.jsf.setLanguage(this.language);
                    }
                    this.jsf.setOptions({ debug: !!this.debug });
                    var loadExternalAssets = this.loadExternalAssets || false;
                    var framework = this.framework || 'default';
                    if (isObject(this.options)) {
                        this.jsf.setOptions(this.options);
                        loadExternalAssets = this.options.loadExternalAssets || loadExternalAssets;
                        framework = this.options.framework || framework;
                    }
                    if (isObject(this.form) && isObject(this.form.options)) {
                        this.jsf.setOptions(this.form.options);
                        loadExternalAssets = this.form.options.loadExternalAssets || loadExternalAssets;
                        framework = this.form.options.framework || framework;
                    }
                    if (isObject(this.widgets)) {
                        this.jsf.setOptions({ widgets: this.widgets });
                    }
                    this.frameworkLibrary.setLoadExternalAssets(loadExternalAssets);
                    this.frameworkLibrary.setFramework(framework);
                    this.jsf.framework = this.frameworkLibrary.getFramework();
                    if (isObject(this.jsf.formOptions.widgets)) {
                        for (var _a = 0, _b = Object.keys(this.jsf.formOptions.widgets); _a < _b.length; _a++) {
                            var widget = _b[_a];
                            this.widgetLibrary.registerWidget(widget, this.jsf.formOptions.widgets[widget]);
                        }
                    }
                    if (isObject(this.form) && isObject(this.form.tpldata)) {
                        this.jsf.setTpldata(this.form.tpldata);
                    }
                };
                /**
                 * 'initializeSchema' function
                 *
                 * Initialize 'schema'
                 * Use first available input:
                 * 1. schema - recommended / Angular Schema Form style
                 * 2. form.schema - Single input / JSON Form style
                 * 3. JSONSchema - React JSON Schema Form style
                 * 4. form.JSONSchema - For testing single input React JSON Schema Forms
                 * 5. form - For testing single schema-only inputs
                 *
                 * ... if no schema input found, the 'activateForm' function, below,
                 *     will make two additional attempts to build a schema
                 * 6. If layout input - build schema from layout
                 * 7. If data input - build schema from data
                 */
                JsonSchemaFormComponent.prototype.initializeSchema = function () {
                    // TODO: update to allow non-object schemas
                    if (isObject(this.schema)) {
                        this.jsf.AngularSchemaFormCompatibility = true;
                        this.jsf.schema = Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(this.schema);
                    }
                    else if (hasOwn(this.form, 'schema') && isObject(this.form.schema)) {
                        this.jsf.schema = Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(this.form.schema);
                    }
                    else if (isObject(this.JSONSchema)) {
                        this.jsf.ReactJsonSchemaFormCompatibility = true;
                        this.jsf.schema = Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(this.JSONSchema);
                    }
                    else if (hasOwn(this.form, 'JSONSchema') && isObject(this.form.JSONSchema)) {
                        this.jsf.ReactJsonSchemaFormCompatibility = true;
                        this.jsf.schema = Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(this.form.JSONSchema);
                    }
                    else if (hasOwn(this.form, 'properties') && isObject(this.form.properties)) {
                        this.jsf.schema = Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(this.form);
                    }
                    else if (isObject(this.form))
                        ;
                    if (!isEmpty(this.jsf.schema)) {
                        // If other types also allowed, render schema as an object
                        if (inArray('object', this.jsf.schema.type)) {
                            this.jsf.schema.type = 'object';
                        }
                        // Wrap non-object schemas in object.
                        if (hasOwn(this.jsf.schema, 'type') && this.jsf.schema.type !== 'object') {
                            this.jsf.schema = {
                                'type': 'object',
                                'properties': { 1: this.jsf.schema }
                            };
                            this.objectWrap = true;
                        }
                        else if (!hasOwn(this.jsf.schema, 'type')) {
                            // Add type = 'object' if missing
                            if (isObject(this.jsf.schema.properties) ||
                                isObject(this.jsf.schema.patternProperties) ||
                                isObject(this.jsf.schema.additionalProperties)) {
                                this.jsf.schema.type = 'object';
                                // Fix JSON schema shorthand (JSON Form style)
                            }
                            else {
                                this.jsf.JsonFormCompatibility = true;
                                this.jsf.schema = {
                                    'type': 'object',
                                    'properties': this.jsf.schema
                                };
                            }
                        }
                        // If needed, update JSON Schema to draft 6 format, including
                        // draft 3 (JSON Form style) and draft 4 (Angular Schema Form style)
                        this.jsf.schema = convertSchemaToDraft6(this.jsf.schema);
                        // Initialize ajv and compile schema
                        this.jsf.compileAjvSchema();
                        // Create schemaRefLibrary, schemaRecursiveRefMap, dataRecursiveRefMap, & arrayMap
                        this.jsf.schema = resolveSchemaReferences(this.jsf.schema, this.jsf.schemaRefLibrary, this.jsf.schemaRecursiveRefMap, this.jsf.dataRecursiveRefMap, this.jsf.arrayMap);
                        if (hasOwn(this.jsf.schemaRefLibrary, '')) {
                            this.jsf.hasRootReference = true;
                        }
                        // TODO: (?) Resolve external $ref links
                        // // Create schemaRefLibrary & schemaRecursiveRefMap
                        // this.parser.bundle(this.schema)
                        //   .then(schema => this.schema = resolveSchemaReferences(
                        //     schema, this.jsf.schemaRefLibrary,
                        //     this.jsf.schemaRecursiveRefMap, this.jsf.dataRecursiveRefMap
                        //   ));
                    }
                };
                /**
                 * 'initializeData' function
                 *
                 * Initialize 'formValues'
                 * defulat or previously submitted values used to populate form
                 * Use first available input:
                 * 1. data - recommended
                 * 2. model - Angular Schema Form style
                 * 3. form.value - JSON Form style
                 * 4. form.data - Single input style
                 * 5. formData - React JSON Schema Form style
                 * 6. form.formData - For easier testing of React JSON Schema Forms
                 * 7. (none) no data - initialize data from schema and layout defaults only
                 */
                JsonSchemaFormComponent.prototype.initializeData = function () {
                    if (hasValue(this.data)) {
                        this.jsf.formValues = Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(this.data);
                        this.formValuesInput = 'data';
                    }
                    else if (hasValue(this.model)) {
                        this.jsf.AngularSchemaFormCompatibility = true;
                        this.jsf.formValues = Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(this.model);
                        this.formValuesInput = 'model';
                    }
                    else if (hasValue(this.ngModel)) {
                        this.jsf.AngularSchemaFormCompatibility = true;
                        this.jsf.formValues = Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(this.ngModel);
                        this.formValuesInput = 'ngModel';
                    }
                    else if (isObject(this.form) && hasValue(this.form.value)) {
                        this.jsf.JsonFormCompatibility = true;
                        this.jsf.formValues = Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(this.form.value);
                        this.formValuesInput = 'form.value';
                    }
                    else if (isObject(this.form) && hasValue(this.form.data)) {
                        this.jsf.formValues = Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(this.form.data);
                        this.formValuesInput = 'form.data';
                    }
                    else if (hasValue(this.formData)) {
                        this.jsf.ReactJsonSchemaFormCompatibility = true;
                        this.formValuesInput = 'formData';
                    }
                    else if (hasOwn(this.form, 'formData') && hasValue(this.form.formData)) {
                        this.jsf.ReactJsonSchemaFormCompatibility = true;
                        this.jsf.formValues = Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(this.form.formData);
                        this.formValuesInput = 'form.formData';
                    }
                    else {
                        this.formValuesInput = null;
                    }
                };
                /**
                 * 'initializeLayout' function
                 *
                 * Initialize 'layout'
                 * Use first available array input:
                 * 1. layout - recommended
                 * 2. form - Angular Schema Form style
                 * 3. form.form - JSON Form style
                 * 4. form.layout - Single input style
                 * 5. (none) no layout - set default layout instead
                 *    (full layout will be built later from the schema)
                 *
                 * Also, if alternate layout formats are available,
                 * import from 'UISchema' or 'customFormItems'
                 * used for React JSON Schema Form and JSON Form API compatibility
                 * Use first available input:
                 * 1. UISchema - React JSON Schema Form style
                 * 2. form.UISchema - For testing single input React JSON Schema Forms
                 * 2. form.customFormItems - JSON Form style
                 * 3. (none) no input - don't import
                 */
                JsonSchemaFormComponent.prototype.initializeLayout = function () {
                    var _this_1 = this;
                    // Rename JSON Form-style 'options' lists to
                    // Angular Schema Form-style 'titleMap' lists.
                    var fixJsonFormOptions = function (layout) {
                        if (isObject(layout) || isArray(layout)) {
                            forEach(layout, function (value, key) {
                                if (hasOwn(value, 'options') && isObject(value.options)) {
                                    value.titleMap = value.options;
                                    delete value.options;
                                }
                            }, 'top-down');
                        }
                        return layout;
                    };
                    // Check for layout inputs and, if found, initialize form layout
                    if (isArray(this.layout)) {
                        this.jsf.layout = Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(this.layout);
                    }
                    else if (isArray(this.form)) {
                        this.jsf.AngularSchemaFormCompatibility = true;
                        this.jsf.layout = Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(this.form);
                    }
                    else if (this.form && isArray(this.form.form)) {
                        this.jsf.JsonFormCompatibility = true;
                        this.jsf.layout = fixJsonFormOptions(Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(this.form.form));
                    }
                    else if (this.form && isArray(this.form.layout)) {
                        this.jsf.layout = Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(this.form.layout);
                    }
                    else {
                        this.jsf.layout = ['*'];
                    }
                    // Check for alternate layout inputs
                    var alternateLayout = null;
                    if (isObject(this.UISchema)) {
                        this.jsf.ReactJsonSchemaFormCompatibility = true;
                        alternateLayout = Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(this.UISchema);
                    }
                    else if (hasOwn(this.form, 'UISchema')) {
                        this.jsf.ReactJsonSchemaFormCompatibility = true;
                        alternateLayout = Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(this.form.UISchema);
                    }
                    else if (hasOwn(this.form, 'uiSchema')) {
                        this.jsf.ReactJsonSchemaFormCompatibility = true;
                        alternateLayout = Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(this.form.uiSchema);
                    }
                    else if (hasOwn(this.form, 'customFormItems')) {
                        this.jsf.JsonFormCompatibility = true;
                        alternateLayout = fixJsonFormOptions(Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(this.form.customFormItems));
                    }
                    // if alternate layout found, copy alternate layout options into schema
                    if (alternateLayout) {
                        JsonPointer.forEachDeep(alternateLayout, function (value, pointer) {
                            var schemaPointer = pointer
                                .replace(/\//g, '/properties/')
                                .replace(/\/properties\/items\/properties\//g, '/items/properties/')
                                .replace(/\/properties\/titleMap\/properties\//g, '/titleMap/properties/');
                            if (hasValue(value) && hasValue(pointer)) {
                                var key = JsonPointer.toKey(pointer);
                                var groupPointer = (JsonPointer.parse(schemaPointer) || []).slice(0, -2);
                                var itemPointer = void 0;
                                // If 'ui:order' object found, copy into object schema root
                                if (key.toLowerCase() === 'ui:order') {
                                    itemPointer = groupPointer.concat(['ui:order']);
                                    // Copy other alternate layout options to schema 'x-schema-form',
                                    // (like Angular Schema Form options) and remove any 'ui:' prefixes
                                }
                                else {
                                    if (key.slice(0, 3).toLowerCase() === 'ui:') {
                                        key = key.slice(3);
                                    }
                                    itemPointer = groupPointer.concat(['x-schema-form', key]);
                                }
                                if (JsonPointer.has(_this_1.jsf.schema, groupPointer) &&
                                    !JsonPointer.has(_this_1.jsf.schema, itemPointer)) {
                                    JsonPointer.set(_this_1.jsf.schema, itemPointer, value);
                                }
                            }
                        });
                    }
                };
                /**
                 * 'activateForm' function
                 *
                 * ...continued from 'initializeSchema' function, above
                 * If 'schema' has not been initialized (i.e. no schema input found)
                 * 6. If layout input - build schema from layout input
                 * 7. If data input - build schema from data input
                 *
                 * Create final layout,
                 * build the FormGroup template and the Angular FormGroup,
                 * subscribe to changes,
                 * and activate the form.
                 */
                JsonSchemaFormComponent.prototype.activateForm = function () {
                    var _this_1 = this;
                    // If 'schema' not initialized
                    if (isEmpty(this.jsf.schema)) {
                        // TODO: If full layout input (with no '*'), build schema from layout
                        // if (!this.jsf.layout.includes('*')) {
                        //   this.jsf.buildSchemaFromLayout();
                        // } else
                        // If data input, build schema from data
                        if (!isEmpty(this.jsf.formValues)) {
                            this.jsf.buildSchemaFromData();
                        }
                    }
                    if (!isEmpty(this.jsf.schema)) {
                        // If not already initialized, initialize ajv and compile schema
                        this.jsf.compileAjvSchema();
                        // Update all layout elements, add values, widgets, and validators,
                        // replace any '*' with a layout built from all schema elements,
                        // and update the FormGroup template with any new validators
                        this.jsf.buildLayout(this.widgetLibrary);
                        // Build the Angular FormGroup template from the schema
                        this.jsf.buildFormGroupTemplate(this.jsf.formValues);
                        // Build the real Angular FormGroup from the FormGroup template
                        this.jsf.buildFormGroup();
                    }
                    if (this.jsf.formGroup) {
                        // Reset initial form values
                        if (!isEmpty(this.jsf.formValues) &&
                            this.jsf.formOptions.setSchemaDefaults !== true &&
                            this.jsf.formOptions.setLayoutDefaults !== true) {
                            this.setFormValues(this.jsf.formValues);
                        }
                        // TODO: Figure out how to display calculated values without changing object data
                        // See http://ulion.github.io/jsonform/playground/?example=templating-values
                        // Calculate references to other fields
                        // if (!isEmpty(this.jsf.formGroup.value)) {
                        //   forEach(this.jsf.formGroup.value, (value, key, object, rootObject) => {
                        //     if (typeof value === 'string') {
                        //       object[key] = this.jsf.parseText(value, value, rootObject, key);
                        //     }
                        //   }, 'top-down');
                        // }
                        // Subscribe to form changes to output live data, validation, and errors
                        this.jsf.dataChanges.subscribe(function (data) {
                            _this_1.onChanges.emit(_this_1.objectWrap ? data['1'] : data);
                            if (_this_1.formValuesInput && _this_1.formValuesInput.indexOf('.') === -1) {
                                _this_1[_this_1.formValuesInput + "Change"].emit(_this_1.objectWrap ? data['1'] : data);
                            }
                        });
                        // Trigger change detection on statusChanges to show updated errors
                        this.jsf.formGroup.statusChanges.subscribe(function () { return _this_1.changeDetector.markForCheck(); });
                        this.jsf.isValidChanges.subscribe(function (isValid) { return _this_1.isValid.emit(isValid); });
                        this.jsf.validationErrorChanges.subscribe(function (err) { return _this_1.validationErrors.emit(err); });
                        // Output final schema, final layout, and initial data
                        this.formSchema.emit(this.jsf.schema);
                        this.formLayout.emit(this.jsf.layout);
                        this.onChanges.emit(this.objectWrap ? this.jsf.data['1'] : this.jsf.data);
                        // If validateOnRender, output initial validation and any errors
                        var validateOnRender_1 = JsonPointer.get(this.jsf, '/formOptions/validateOnRender');
                        if (validateOnRender_1) { // validateOnRender === 'auto' || true
                            var touchAll_1 = function (control) {
                                if (validateOnRender_1 === true || hasValue(control.value)) {
                                    control.markAsTouched();
                                }
                                Object.keys(control.controls || {})
                                    .forEach(function (key) { return touchAll_1(control.controls[key]); });
                            };
                            touchAll_1(this.jsf.formGroup);
                            this.isValid.emit(this.jsf.isValid);
                            this.validationErrors.emit(this.jsf.ajvErrors);
                        }
                    }
                };
                return JsonSchemaFormComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], JsonSchemaFormComponent.prototype, "schema", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], JsonSchemaFormComponent.prototype, "layout", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], JsonSchemaFormComponent.prototype, "data", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], JsonSchemaFormComponent.prototype, "options", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], JsonSchemaFormComponent.prototype, "framework", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], JsonSchemaFormComponent.prototype, "widgets", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], JsonSchemaFormComponent.prototype, "form", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], JsonSchemaFormComponent.prototype, "model", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], JsonSchemaFormComponent.prototype, "JSONSchema", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], JsonSchemaFormComponent.prototype, "UISchema", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], JsonSchemaFormComponent.prototype, "formData", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], JsonSchemaFormComponent.prototype, "ngModel", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)
            ], JsonSchemaFormComponent.prototype, "language", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)
            ], JsonSchemaFormComponent.prototype, "loadExternalAssets", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)
            ], JsonSchemaFormComponent.prototype, "debug", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [Object])
            ], JsonSchemaFormComponent.prototype, "value", null);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Output"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], JsonSchemaFormComponent.prototype, "onChanges", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Output"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], JsonSchemaFormComponent.prototype, "onSubmit", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Output"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], JsonSchemaFormComponent.prototype, "isValid", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Output"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], JsonSchemaFormComponent.prototype, "validationErrors", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Output"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], JsonSchemaFormComponent.prototype, "formSchema", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Output"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], JsonSchemaFormComponent.prototype, "formLayout", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Output"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], JsonSchemaFormComponent.prototype, "dataChange", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Output"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], JsonSchemaFormComponent.prototype, "modelChange", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Output"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], JsonSchemaFormComponent.prototype, "formDataChange", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Output"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], JsonSchemaFormComponent.prototype, "ngModelChange", void 0);
            JsonSchemaFormComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'json-schema-form',
                    template: "\n    <div *ngFor=\"let stylesheet of stylesheets\">\n      <link rel=\"stylesheet\" [href]=\"stylesheet\">\n    </div>\n    <div *ngFor=\"let script of scripts\">\n      <script type=\"text/javascript\" [src]=\"script\"></script>\n    </div>\n    <form [autocomplete]=\"jsf?.formOptions?.autocomplete ? 'on' : 'off'\" class=\"json-schema-form\" (ngSubmit)=\"submitForm()\">\n      <root-widget [layout]=\"jsf?.layout\"></root-widget>\n    </form>\n    <div *ngIf=\"debug || jsf?.formOptions?.debug\">\n      Debug output: <pre>{{debugOutput}}</pre>\n    </div>",
                    changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ChangeDetectionStrategy"].OnPush,
                    // Adding 'JsonSchemaFormService' here, instead of in the module,
                    // creates a separate instance of the service for each component
                    providers: [JsonSchemaFormService, JSON_SCHEMA_FORM_VALUE_ACCESSOR]
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_8__["ChangeDetectorRef"],
                    FrameworkLibraryService,
                    WidgetLibraryService,
                    JsonSchemaFormService,
                    _angular_platform_browser__WEBPACK_IMPORTED_MODULE_12__["DomSanitizer"]])
            ], JsonSchemaFormComponent);
            var NoFrameworkComponent = /** @class */ (function () {
                function NoFrameworkComponent() {
                }
                return NoFrameworkComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], NoFrameworkComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], NoFrameworkComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], NoFrameworkComponent.prototype, "dataIndex", void 0);
            NoFrameworkComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'no-framework',
                    template: "\n    <select-widget-widget\n      [dataIndex]=\"dataIndex\"\n      [layoutIndex]=\"layoutIndex\"\n      [layoutNode]=\"layoutNode\"></select-widget-widget>"
                })
            ], NoFrameworkComponent);
            // No framework - plain HTML controls (styles from form layout only)
            var NoFramework = /** @class */ (function (_super) {
                __extends(NoFramework, _super);
                // No framework - plain HTML controls (styles from form layout only)
                function NoFramework() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.name = 'no-framework';
                    _this_1.framework = NoFrameworkComponent;
                    return _this_1;
                }
                return NoFramework;
            }(Framework));
            NoFramework = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Injectable"])()
            ], NoFramework);
            var HiddenComponent = /** @class */ (function () {
                function HiddenComponent(jsf) {
                    this.jsf = jsf;
                    this.controlDisabled = false;
                    this.boundControl = false;
                }
                HiddenComponent.prototype.ngOnInit = function () {
                    this.jsf.initializeControl(this);
                };
                return HiddenComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], HiddenComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], HiddenComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], HiddenComponent.prototype, "dataIndex", void 0);
            HiddenComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'hidden-widget',
                    template: "\n    <input *ngIf=\"boundControl\"\n      [formControl]=\"formControl\"\n      [id]=\"'control' + layoutNode?._id\"\n      [name]=\"controlName\"\n      type=\"hidden\">\n    <input *ngIf=\"!boundControl\"\n      [disabled]=\"controlDisabled\"\n      [name]=\"controlName\"\n      [id]=\"'control' + layoutNode?._id\"\n      type=\"hidden\"\n      [value]=\"controlValue\">"
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], HiddenComponent);
            var TabComponent = /** @class */ (function () {
                function TabComponent(jsf) {
                    this.jsf = jsf;
                }
                TabComponent.prototype.ngOnInit = function () {
                    this.options = this.layoutNode.options || {};
                };
                return TabComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], TabComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], TabComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], TabComponent.prototype, "dataIndex", void 0);
            TabComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'tab-widget',
                    template: "\n    <div [class]=\"options?.htmlClass || ''\">\n      <root-widget\n        [dataIndex]=\"dataIndex\"\n        [layoutIndex]=\"layoutIndex\"\n        [layout]=\"layoutNode.items\"></root-widget>\n    </div>"
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], TabComponent);
            /**
             * OrderableDirective
             *
             * Enables array elements to be reordered by dragging and dropping.
             *
             * Only works for arrays that have at least two elements.
             *
             * Also detects arrays-within-arrays, and correctly moves either
             * the child array element or the parent array element,
             * depending on the drop targert.
             *
             * Listeners for movable element being dragged:
             * - dragstart: add 'dragging' class to element, set effectAllowed = 'move'
             * - dragover: set dropEffect = 'move'
             * - dragend: remove 'dragging' class from element
             *
             * Listeners for stationary items being dragged over:
             * - dragenter: add 'drag-target-...' classes to element
             * - dragleave: remove 'drag-target-...' classes from element
             * - drop: remove 'drag-target-...' classes from element, move dropped array item
             */
            var OrderableDirective = /** @class */ (function () {
                function OrderableDirective(elementRef, jsf, ngZone) {
                    this.elementRef = elementRef;
                    this.jsf = jsf;
                    this.ngZone = ngZone;
                    this.overParentElement = false;
                    this.overChildElement = false;
                }
                OrderableDirective.prototype.ngOnInit = function () {
                    var _this_1 = this;
                    if (this.orderable && this.layoutNode && this.layoutIndex && this.dataIndex) {
                        this.element = this.elementRef.nativeElement;
                        this.element.draggable = true;
                        this.arrayLayoutIndex = 'move:' + this.layoutIndex.slice(0, -1).toString();
                        this.ngZone.runOutsideAngular(function () {
                            // Listeners for movable element being dragged:
                            _this_1.element.addEventListener('dragstart', function (event) {
                                event.dataTransfer.effectAllowed = 'move';
                                event.dataTransfer.setData('text', '');
                                // Hack to bypass stupid HTML drag-and-drop dataTransfer protection
                                // so drag source info will be available on dragenter
                                var sourceArrayIndex = _this_1.dataIndex[_this_1.dataIndex.length - 1];
                                sessionStorage.setItem(_this_1.arrayLayoutIndex, sourceArrayIndex + '');
                            });
                            _this_1.element.addEventListener('dragover', function (event) {
                                if (event.preventDefault) {
                                    event.preventDefault();
                                }
                                event.dataTransfer.dropEffect = 'move';
                                return false;
                            });
                            // Listeners for stationary items being dragged over:
                            _this_1.element.addEventListener('dragenter', function (event) {
                                // Part 1 of a hack, inspired by Dragster, to simulate mouseover and mouseout
                                // behavior while dragging items - http://bensmithett.github.io/dragster/
                                if (_this_1.overParentElement) {
                                    return _this_1.overChildElement = true;
                                }
                                else {
                                    _this_1.overParentElement = true;
                                }
                                var sourceArrayIndex = sessionStorage.getItem(_this_1.arrayLayoutIndex);
                                if (sourceArrayIndex !== null) {
                                    if (_this_1.dataIndex[_this_1.dataIndex.length - 1] < +sourceArrayIndex) {
                                        _this_1.element.classList.add('drag-target-top');
                                    }
                                    else if (_this_1.dataIndex[_this_1.dataIndex.length - 1] > +sourceArrayIndex) {
                                        _this_1.element.classList.add('drag-target-bottom');
                                    }
                                }
                            });
                            _this_1.element.addEventListener('dragleave', function (event) {
                                // Part 2 of the Dragster hack
                                if (_this_1.overChildElement) {
                                    _this_1.overChildElement = false;
                                }
                                else if (_this_1.overParentElement) {
                                    _this_1.overParentElement = false;
                                }
                                var sourceArrayIndex = sessionStorage.getItem(_this_1.arrayLayoutIndex);
                                if (!_this_1.overParentElement && !_this_1.overChildElement && sourceArrayIndex !== null) {
                                    _this_1.element.classList.remove('drag-target-top');
                                    _this_1.element.classList.remove('drag-target-bottom');
                                }
                            });
                            _this_1.element.addEventListener('drop', function (event) {
                                _this_1.element.classList.remove('drag-target-top');
                                _this_1.element.classList.remove('drag-target-bottom');
                                // Confirm that drop target is another item in the same array as source item
                                var sourceArrayIndex = sessionStorage.getItem(_this_1.arrayLayoutIndex);
                                var destArrayIndex = _this_1.dataIndex[_this_1.dataIndex.length - 1];
                                if (sourceArrayIndex !== null && +sourceArrayIndex !== destArrayIndex) {
                                    // Move array item
                                    _this_1.jsf.moveArrayItem(_this_1, +sourceArrayIndex, destArrayIndex);
                                }
                                sessionStorage.removeItem(_this_1.arrayLayoutIndex);
                                return false;
                            });
                        });
                    }
                };
                return OrderableDirective;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)
            ], OrderableDirective.prototype, "orderable", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], OrderableDirective.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], OrderableDirective.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], OrderableDirective.prototype, "dataIndex", void 0);
            OrderableDirective = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Directive"])({
                    // tslint:disable-next-line:directive-selector
                    selector: '[orderable]',
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_8__["ElementRef"],
                    JsonSchemaFormService,
                    _angular_core__WEBPACK_IMPORTED_MODULE_8__["NgZone"]])
            ], OrderableDirective);
            var BASIC_WIDGETS = [
                AddReferenceComponent, OneOfComponent, ButtonComponent, CheckboxComponent,
                CheckboxesComponent, FileComponent, HiddenComponent, InputComponent,
                MessageComponent, NoneComponent, NumberComponent, RadiosComponent,
                RootComponent, SectionComponent, SelectComponent, SelectFrameworkComponent,
                SelectWidgetComponent, SubmitComponent, TabComponent, TabsComponent,
                TemplateComponent, TextareaComponent
            ];
            var WidgetLibraryModule_1;
            var WidgetLibraryModule = WidgetLibraryModule_1 = /** @class */ (function () {
                function WidgetLibraryModule() {
                }
                WidgetLibraryModule.forRoot = function () {
                    return {
                        ngModule: WidgetLibraryModule_1,
                        providers: [JsonSchemaFormService]
                    };
                };
                return WidgetLibraryModule;
            }());
            WidgetLibraryModule = WidgetLibraryModule_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["NgModule"])({
                    imports: [_angular_common__WEBPACK_IMPORTED_MODULE_13__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_6__["FormsModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_6__["ReactiveFormsModule"]],
                    declarations: BASIC_WIDGETS.concat([OrderableDirective]),
                    exports: BASIC_WIDGETS.concat([OrderableDirective]),
                    entryComponents: BASIC_WIDGETS.slice(),
                    providers: [JsonSchemaFormService]
                })
            ], WidgetLibraryModule);
            // No framework - plain HTML controls (styles from form layout only)
            var NoFrameworkModule = /** @class */ (function () {
                function NoFrameworkModule() {
                }
                return NoFrameworkModule;
            }());
            NoFrameworkModule = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["NgModule"])({
                    imports: [_angular_common__WEBPACK_IMPORTED_MODULE_13__["CommonModule"], WidgetLibraryModule],
                    declarations: [NoFrameworkComponent],
                    exports: [NoFrameworkComponent],
                    providers: [JsonSchemaFormService, FrameworkLibraryService, WidgetLibraryService,
                        { provide: Framework, useClass: NoFramework, multi: true }
                    ],
                    entryComponents: [NoFrameworkComponent]
                })
            ], NoFrameworkModule);
            var FlexLayoutRootComponent = /** @class */ (function () {
                function FlexLayoutRootComponent(jsf) {
                    this.jsf = jsf;
                    this.isFlexItem = false;
                }
                FlexLayoutRootComponent.prototype.removeItem = function (item) {
                    this.jsf.removeItem(item);
                };
                // Set attributes for flexbox child
                // (container attributes are set in flex-layout-section.component)
                FlexLayoutRootComponent.prototype.getFlexAttribute = function (node, attribute) {
                    var index = ['flex-grow', 'flex-shrink', 'flex-basis'].indexOf(attribute);
                    return ((node.options || {}).flex || '').split(/\s+/)[index] ||
                        (node.options || {})[attribute] || ['1', '1', 'auto'][index];
                };
                FlexLayoutRootComponent.prototype.showWidget = function (layoutNode) {
                    return this.jsf.evaluateCondition(layoutNode, this.dataIndex);
                };
                return FlexLayoutRootComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], FlexLayoutRootComponent.prototype, "dataIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], FlexLayoutRootComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], FlexLayoutRootComponent.prototype, "layout", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], FlexLayoutRootComponent.prototype, "isFlexItem", void 0);
            FlexLayoutRootComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'flex-layout-root-widget',
                    template: "\n    <div *ngFor=\"let layoutNode of layout; let i = index\"\n      [class.form-flex-item]=\"isFlexItem\"\n      [style.flex-grow]=\"getFlexAttribute(layoutNode, 'flex-grow')\"\n      [style.flex-shrink]=\"getFlexAttribute(layoutNode, 'flex-shrink')\"\n      [style.flex-basis]=\"getFlexAttribute(layoutNode, 'flex-basis')\"\n      [style.align-self]=\"(layoutNode?.options || {})['align-self']\"\n      [style.order]=\"layoutNode?.options?.order\"\n      [fxFlex]=\"layoutNode?.options?.fxFlex\"\n      [fxFlexOrder]=\"layoutNode?.options?.fxFlexOrder\"\n      [fxFlexOffset]=\"layoutNode?.options?.fxFlexOffset\"\n      [fxFlexAlign]=\"layoutNode?.options?.fxFlexAlign\">\n      <select-framework-widget *ngIf=\"showWidget(layoutNode)\"\n        [dataIndex]=\"layoutNode?.arrayItem ? (dataIndex || []).concat(i) : (dataIndex || [])\"\n        [layoutIndex]=\"(layoutIndex || []).concat(i)\"\n        [layoutNode]=\"layoutNode\"></select-framework-widget>\n    <div>",
                    changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ChangeDetectionStrategy"].Default
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], FlexLayoutRootComponent);
            var FlexLayoutSectionComponent = /** @class */ (function () {
                function FlexLayoutSectionComponent(jsf) {
                    this.jsf = jsf;
                    this.controlDisabled = false;
                    this.boundControl = false;
                    this.expanded = true;
                    this.containerType = 'div';
                }
                Object.defineProperty(FlexLayoutSectionComponent.prototype, "sectionTitle", {
                    get: function () {
                        return this.options.notitle ? null : this.jsf.setItemTitle(this);
                    },
                    enumerable: true,
                    configurable: true
                });
                FlexLayoutSectionComponent.prototype.ngOnInit = function () {
                    this.jsf.initializeControl(this);
                    this.options = this.layoutNode.options || {};
                    this.expanded = typeof this.options.expanded === 'boolean' ?
                        this.options.expanded : !this.options.expandable;
                    switch (this.layoutNode.type) {
                        case 'section':
                        case 'array':
                        case 'fieldset':
                        case 'advancedfieldset':
                        case 'authfieldset':
                        case 'optionfieldset':
                        case 'selectfieldset':
                            this.containerType = 'fieldset';
                            break;
                        case 'card':
                            this.containerType = 'card';
                            break;
                        case 'expansion-panel':
                            this.containerType = 'expansion-panel';
                            break;
                        default: // 'div', 'flex', 'tab', 'conditional', 'actions'
                            this.containerType = 'div';
                    }
                };
                FlexLayoutSectionComponent.prototype.toggleExpanded = function () {
                    if (this.options.expandable) {
                        this.expanded = !this.expanded;
                    }
                };
                // Set attributes for flexbox container
                // (child attributes are set in flex-layout-root.component)
                FlexLayoutSectionComponent.prototype.getFlexAttribute = function (attribute) {
                    var flexActive = this.layoutNode.type === 'flex' ||
                        !!this.options.displayFlex ||
                        this.options.display === 'flex';
                    // if (attribute !== 'flex' && !flexActive) { return null; }
                    switch (attribute) {
                        case 'is-flex':
                            return flexActive;
                        case 'display':
                            return flexActive ? 'flex' : 'initial';
                        case 'flex-direction':
                        case 'flex-wrap':
                            var index = ['flex-direction', 'flex-wrap'].indexOf(attribute);
                            return (this.options['flex-flow'] || '').split(/\s+/)[index] ||
                                this.options[attribute] || ['column', 'nowrap'][index];
                        case 'justify-content':
                        case 'align-items':
                        case 'align-content':
                            return this.options[attribute];
                        case 'layout':
                            return (this.options.fxLayout || 'row') +
                                this.options.fxLayoutWrap ? ' ' + this.options.fxLayoutWrap : '';
                    }
                };
                return FlexLayoutSectionComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], FlexLayoutSectionComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], FlexLayoutSectionComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], FlexLayoutSectionComponent.prototype, "dataIndex", void 0);
            FlexLayoutSectionComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'flex-layout-section-widget',
                    template: "\n    <div *ngIf=\"containerType === 'div'\"\n      [class]=\"options?.htmlClass || ''\"\n      [class.expandable]=\"options?.expandable && !expanded\"\n      [class.expanded]=\"options?.expandable && expanded\">\n      <label *ngIf=\"sectionTitle\"\n        [class]=\"'legend ' + (options?.labelHtmlClass || '')\"\n        [innerHTML]=\"sectionTitle\"\n        (click)=\"toggleExpanded()\"></label>\n      <flex-layout-root-widget *ngIf=\"expanded\"\n        [layout]=\"layoutNode.items\"\n        [dataIndex]=\"dataIndex\"\n        [layoutIndex]=\"layoutIndex\"\n        [isFlexItem]=\"getFlexAttribute('is-flex')\"\n        [class.form-flex-column]=\"getFlexAttribute('flex-direction') === 'column'\"\n        [class.form-flex-row]=\"getFlexAttribute('flex-direction') === 'row'\"\n        [style.display]=\"getFlexAttribute('display')\"\n        [style.flex-direction]=\"getFlexAttribute('flex-direction')\"\n        [style.flex-wrap]=\"getFlexAttribute('flex-wrap')\"\n        [style.justify-content]=\"getFlexAttribute('justify-content')\"\n        [style.align-items]=\"getFlexAttribute('align-items')\"\n        [style.align-content]=\"getFlexAttribute('align-content')\"\n        [fxLayout]=\"getFlexAttribute('layout')\"\n        [fxLayoutGap]=\"options?.fxLayoutGap\"\n        [fxLayoutAlign]=\"options?.fxLayoutAlign\"\n        [attr.fxFlexFill]=\"options?.fxLayoutAlign\"></flex-layout-root-widget>\n      <mat-error *ngIf=\"options?.showErrors && options?.errorMessage\"\n        [innerHTML]=\"options?.errorMessage\"></mat-error>\n    </div>\n\n    <fieldset *ngIf=\"containerType === 'fieldset'\"\n      [class]=\"options?.htmlClass || ''\"\n      [class.expandable]=\"options?.expandable && !expanded\"\n      [class.expanded]=\"options?.expandable && expanded\"\n      [disabled]=\"options?.readonly\">\n      <legend *ngIf=\"sectionTitle\"\n        [class]=\"'legend ' + (options?.labelHtmlClass || '')\"\n        [innerHTML]=\"sectionTitle\"\n        (click)=\"toggleExpanded()\"></legend>\n      <flex-layout-root-widget *ngIf=\"expanded\"\n        [layout]=\"layoutNode.items\"\n        [dataIndex]=\"dataIndex\"\n        [layoutIndex]=\"layoutIndex\"\n        [isFlexItem]=\"getFlexAttribute('is-flex')\"\n        [class.form-flex-column]=\"getFlexAttribute('flex-direction') === 'column'\"\n        [class.form-flex-row]=\"getFlexAttribute('flex-direction') === 'row'\"\n        [style.display]=\"getFlexAttribute('display')\"\n        [style.flex-direction]=\"getFlexAttribute('flex-direction')\"\n        [style.flex-wrap]=\"getFlexAttribute('flex-wrap')\"\n        [style.justify-content]=\"getFlexAttribute('justify-content')\"\n        [style.align-items]=\"getFlexAttribute('align-items')\"\n        [style.align-content]=\"getFlexAttribute('align-content')\"\n        [fxLayout]=\"getFlexAttribute('layout')\"\n        [fxLayoutGap]=\"options?.fxLayoutGap\"\n        [fxLayoutAlign]=\"options?.fxLayoutAlign\"\n        [attr.fxFlexFill]=\"options?.fxLayoutAlign\"></flex-layout-root-widget>\n      <mat-error *ngIf=\"options?.showErrors && options?.errorMessage\"\n        [innerHTML]=\"options?.errorMessage\"></mat-error>\n    </fieldset>\n\n    <mat-card *ngIf=\"containerType === 'card'\"\n      [ngClass]=\"options?.htmlClass || ''\"\n      [class.expandable]=\"options?.expandable && !expanded\"\n      [class.expanded]=\"options?.expandable && expanded\">\n      <mat-card-header *ngIf=\"sectionTitle\">\n        <legend\n          [class]=\"'legend ' + (options?.labelHtmlClass || '')\"\n          [innerHTML]=\"sectionTitle\"\n          (click)=\"toggleExpanded()\"></legend>\n      </mat-card-header>\n      <mat-card-content *ngIf=\"expanded\">\n        <fieldset [disabled]=\"options?.readonly\">\n          <flex-layout-root-widget *ngIf=\"expanded\"\n            [layout]=\"layoutNode.items\"\n            [dataIndex]=\"dataIndex\"\n            [layoutIndex]=\"layoutIndex\"\n            [isFlexItem]=\"getFlexAttribute('is-flex')\"\n            [class.form-flex-column]=\"getFlexAttribute('flex-direction') === 'column'\"\n            [class.form-flex-row]=\"getFlexAttribute('flex-direction') === 'row'\"\n            [style.display]=\"getFlexAttribute('display')\"\n            [style.flex-direction]=\"getFlexAttribute('flex-direction')\"\n            [style.flex-wrap]=\"getFlexAttribute('flex-wrap')\"\n            [style.justify-content]=\"getFlexAttribute('justify-content')\"\n            [style.align-items]=\"getFlexAttribute('align-items')\"\n            [style.align-content]=\"getFlexAttribute('align-content')\"\n            [fxLayout]=\"getFlexAttribute('layout')\"\n            [fxLayoutGap]=\"options?.fxLayoutGap\"\n            [fxLayoutAlign]=\"options?.fxLayoutAlign\"\n            [attr.fxFlexFill]=\"options?.fxLayoutAlign\"></flex-layout-root-widget>\n          </fieldset>\n      </mat-card-content>\n      <mat-card-footer>\n        <mat-error *ngIf=\"options?.showErrors && options?.errorMessage\"\n          [innerHTML]=\"options?.errorMessage\"></mat-error>\n      </mat-card-footer>\n    </mat-card>\n\n    <mat-expansion-panel *ngIf=\"containerType === 'expansion-panel'\"\n      [expanded]=\"expanded\"\n      [hideToggle]=\"!options?.expandable\">\n      <mat-expansion-panel-header>\n        <mat-panel-title>\n          <legend *ngIf=\"sectionTitle\"\n            [class]=\"options?.labelHtmlClass\"\n            [innerHTML]=\"sectionTitle\"\n            (click)=\"toggleExpanded()\"></legend>\n        </mat-panel-title>\n      </mat-expansion-panel-header>\n      <fieldset [disabled]=\"options?.readonly\">\n        <flex-layout-root-widget *ngIf=\"expanded\"\n          [layout]=\"layoutNode.items\"\n          [dataIndex]=\"dataIndex\"\n          [layoutIndex]=\"layoutIndex\"\n          [isFlexItem]=\"getFlexAttribute('is-flex')\"\n          [class.form-flex-column]=\"getFlexAttribute('flex-direction') === 'column'\"\n          [class.form-flex-row]=\"getFlexAttribute('flex-direction') === 'row'\"\n          [style.display]=\"getFlexAttribute('display')\"\n          [style.flex-direction]=\"getFlexAttribute('flex-direction')\"\n          [style.flex-wrap]=\"getFlexAttribute('flex-wrap')\"\n          [style.justify-content]=\"getFlexAttribute('justify-content')\"\n          [style.align-items]=\"getFlexAttribute('align-items')\"\n          [style.align-content]=\"getFlexAttribute('align-content')\"\n          [fxLayout]=\"getFlexAttribute('layout')\"\n          [fxLayoutGap]=\"options?.fxLayoutGap\"\n          [fxLayoutAlign]=\"options?.fxLayoutAlign\"\n          [attr.fxFlexFill]=\"options?.fxLayoutAlign\"></flex-layout-root-widget>\n      </fieldset>\n      <mat-error *ngIf=\"options?.showErrors && options?.errorMessage\"\n        [innerHTML]=\"options?.errorMessage\"></mat-error>\n    </mat-expansion-panel>",
                    styles: ["\n    fieldset { border: 0; margin: 0; padding: 0; }\n    .legend { font-weight: bold; }\n    .expandable > .legend:before { content: '\u25B6'; padding-right: .3em; }\n    .expanded > .legend:before { content: '\u25BC'; padding-right: .2em; }\n  "]
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], FlexLayoutSectionComponent);
            var MaterialAddReferenceComponent = /** @class */ (function () {
                function MaterialAddReferenceComponent(jsf) {
                    this.jsf = jsf;
                }
                MaterialAddReferenceComponent.prototype.ngOnInit = function () {
                    this.options = this.layoutNode.options || {};
                };
                Object.defineProperty(MaterialAddReferenceComponent.prototype, "showAddButton", {
                    get: function () {
                        return !this.layoutNode.arrayItem ||
                            this.layoutIndex[this.layoutIndex.length - 1] < this.options.maxItems;
                    },
                    enumerable: true,
                    configurable: true
                });
                MaterialAddReferenceComponent.prototype.addItem = function (event) {
                    event.preventDefault();
                    this.jsf.addItem(this);
                };
                Object.defineProperty(MaterialAddReferenceComponent.prototype, "buttonText", {
                    get: function () {
                        var parent = {
                            dataIndex: this.dataIndex.slice(0, -1),
                            layoutIndex: this.layoutIndex.slice(0, -1),
                            layoutNode: this.jsf.getParentNode(this),
                        };
                        return parent.layoutNode.add ||
                            this.jsf.setArrayItemTitle(parent, this.layoutNode, this.itemCount);
                    },
                    enumerable: true,
                    configurable: true
                });
                return MaterialAddReferenceComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], MaterialAddReferenceComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialAddReferenceComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialAddReferenceComponent.prototype, "dataIndex", void 0);
            MaterialAddReferenceComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'material-add-reference-widget',
                    template: "\n    <section [class]=\"options?.htmlClass || ''\" align=\"end\">\n      <button mat-raised-button *ngIf=\"showAddButton\"\n        [color]=\"options?.color || 'accent'\"\n        [disabled]=\"options?.readonly\"\n        (click)=\"addItem($event)\">\n        <span *ngIf=\"options?.icon\" [class]=\"options?.icon\"></span>\n        <span *ngIf=\"options?.title\" [innerHTML]=\"buttonText\"></span>\n      </button>\n    </section>",
                    changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ChangeDetectionStrategy"].Default
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], MaterialAddReferenceComponent);
            var MaterialButtonComponent = /** @class */ (function () {
                function MaterialButtonComponent(jsf) {
                    this.jsf = jsf;
                    this.controlDisabled = false;
                    this.boundControl = false;
                }
                MaterialButtonComponent.prototype.ngOnInit = function () {
                    var _this_1 = this;
                    this.options = this.layoutNode.options || {};
                    this.jsf.initializeControl(this);
                    if (hasOwn(this.options, 'disabled')) {
                        this.controlDisabled = this.options.disabled;
                    }
                    else if (this.jsf.formOptions.disableInvalidSubmit) {
                        this.controlDisabled = !this.jsf.isValid;
                        this.jsf.isValidChanges.subscribe(function (isValid) { return _this_1.controlDisabled = !isValid; });
                    }
                };
                MaterialButtonComponent.prototype.updateValue = function (event) {
                    if (typeof this.options.onClick === 'function') {
                        this.options.onClick(event);
                    }
                    else {
                        this.jsf.updateValue(this, event.target.value);
                    }
                };
                return MaterialButtonComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], MaterialButtonComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialButtonComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialButtonComponent.prototype, "dataIndex", void 0);
            MaterialButtonComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'material-button-widget',
                    template: "\n    <div class=\"button-row\" [class]=\"options?.htmlClass || ''\">\n      <button mat-raised-button\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [color]=\"options?.color || 'primary'\"\n        [disabled]=\"controlDisabled || options?.readonly\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [type]=\"layoutNode?.type\"\n        [value]=\"controlValue\"\n        (click)=\"updateValue($event)\">\n        <mat-icon *ngIf=\"options?.icon\" class=\"mat-24\">{{options?.icon}}</mat-icon>\n        <span *ngIf=\"options?.title\" [innerHTML]=\"options?.title\"></span>\n      </button>\n    </div>",
                    styles: [" button { margin-top: 10px; } "]
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], MaterialButtonComponent);
            var MaterialButtonGroupComponent = /** @class */ (function () {
                function MaterialButtonGroupComponent(jsf) {
                    this.jsf = jsf;
                    this.controlDisabled = false;
                    this.boundControl = false;
                    this.radiosList = [];
                    this.vertical = false;
                }
                MaterialButtonGroupComponent.prototype.ngOnInit = function () {
                    this.options = this.layoutNode.options || {};
                    this.radiosList = buildTitleMap(this.options.titleMap || this.options.enumNames, this.options.enum, true);
                    this.jsf.initializeControl(this);
                };
                MaterialButtonGroupComponent.prototype.updateValue = function (value) {
                    this.options.showErrors = true;
                    this.jsf.updateValue(this, value);
                };
                return MaterialButtonGroupComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], MaterialButtonGroupComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialButtonGroupComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialButtonGroupComponent.prototype, "dataIndex", void 0);
            MaterialButtonGroupComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'material-button-group-widget',
                    template: "\n    <div>\n      <div *ngIf=\"options?.title\">\n        <label\n          [attr.for]=\"'control' + layoutNode?._id\"\n          [class]=\"options?.labelHtmlClass || ''\"\n          [style.display]=\"options?.notitle ? 'none' : ''\"\n          [innerHTML]=\"options?.title\"></label>\n      </div>\n      <mat-button-toggle-group\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.required]=\"options?.required\"\n        [disabled]=\"controlDisabled || options?.readonly\"\n        [name]=\"controlName\"\n        [value]=\"controlValue\"\n        [vertical]=\"!!options.vertical\">\n        <mat-button-toggle *ngFor=\"let radioItem of radiosList\"\n          [id]=\"'control' + layoutNode?._id + '/' + radioItem?.name\"\n          [value]=\"radioItem?.value\"\n          (click)=\"updateValue(radioItem?.value)\">\n          <span [innerHTML]=\"radioItem?.name\"></span>\n        </mat-button-toggle>\n      </mat-button-toggle-group>\n      <mat-error *ngIf=\"options?.showErrors && options?.errorMessage\"\n        [innerHTML]=\"options?.errorMessage\"></mat-error>\n    </div>",
                    styles: [" mat-error { font-size: 75%; } "]
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], MaterialButtonGroupComponent);
            var MaterialCheckboxComponent = /** @class */ (function () {
                function MaterialCheckboxComponent(jsf) {
                    this.jsf = jsf;
                    this.controlDisabled = false;
                    this.boundControl = false;
                    this.trueValue = true;
                    this.falseValue = false;
                    this.showSlideToggle = false;
                }
                MaterialCheckboxComponent.prototype.ngOnInit = function () {
                    this.options = this.layoutNode.options || {};
                    this.jsf.initializeControl(this, !this.options.readonly);
                    if (this.controlValue === null || this.controlValue === undefined) {
                        this.controlValue = false;
                        this.jsf.updateValue(this, this.falseValue);
                    }
                    if (this.layoutNode.type === 'slide-toggle' ||
                        this.layoutNode.format === 'slide-toggle') {
                        this.showSlideToggle = true;
                    }
                };
                MaterialCheckboxComponent.prototype.updateValue = function (event) {
                    this.options.showErrors = true;
                    this.jsf.updateValue(this, event.checked ? this.trueValue : this.falseValue);
                };
                Object.defineProperty(MaterialCheckboxComponent.prototype, "isChecked", {
                    get: function () {
                        return this.jsf.getFormControlValue(this) === this.trueValue;
                    },
                    enumerable: true,
                    configurable: true
                });
                return MaterialCheckboxComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], MaterialCheckboxComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialCheckboxComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialCheckboxComponent.prototype, "dataIndex", void 0);
            MaterialCheckboxComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'material-checkbox-widget',
                    template: "\n    <mat-checkbox *ngIf=\"boundControl && !showSlideToggle\"\n      [formControl]=\"formControl\"\n      align=\"left\"\n      [color]=\"options?.color || 'primary'\"\n      [id]=\"'control' + layoutNode?._id\"\n      labelPosition=\"after\"\n      [name]=\"controlName\"\n      (blur)=\"options.showErrors = true\">\n      <span *ngIf=\"options?.title\"\n        class=\"checkbox-name\"\n        [style.display]=\"options?.notitle ? 'none' : ''\"\n        [innerHTML]=\"options?.title\"></span>\n    </mat-checkbox>\n    <mat-checkbox *ngIf=\"!boundControl && !showSlideToggle\"\n      align=\"left\"\n      [color]=\"options?.color || 'primary'\"\n      [disabled]=\"controlDisabled || options?.readonly\"\n      [id]=\"'control' + layoutNode?._id\"\n      labelPosition=\"after\"\n      [name]=\"controlName\"\n      [checked]=\"isChecked\"\n      (blur)=\"options.showErrors = true\"\n      (change)=\"updateValue($event)\">\n      <span *ngIf=\"options?.title\"\n        class=\"checkbox-name\"\n        [style.display]=\"options?.notitle ? 'none' : ''\"\n        [innerHTML]=\"options?.title\"></span>\n    </mat-checkbox>\n    <mat-slide-toggle *ngIf=\"boundControl && showSlideToggle\"\n      [formControl]=\"formControl\"\n      align=\"left\"\n      [color]=\"options?.color || 'primary'\"\n      [id]=\"'control' + layoutNode?._id\"\n      labelPosition=\"after\"\n      [name]=\"controlName\"\n      (blur)=\"options.showErrors = true\">\n      <span *ngIf=\"options?.title\"\n        class=\"checkbox-name\"\n        [style.display]=\"options?.notitle ? 'none' : ''\"\n        [innerHTML]=\"options?.title\"></span>\n    </mat-slide-toggle>\n    <mat-slide-toggle *ngIf=\"!boundControl && showSlideToggle\"\n      align=\"left\"\n      [color]=\"options?.color || 'primary'\"\n      [disabled]=\"controlDisabled || options?.readonly\"\n      [id]=\"'control' + layoutNode?._id\"\n      labelPosition=\"after\"\n      [name]=\"controlName\"\n      [checked]=\"isChecked\"\n      (blur)=\"options.showErrors = true\"\n      (change)=\"updateValue($event)\">\n      <span *ngIf=\"options?.title\"\n        class=\"checkbox-name\"\n        [style.display]=\"options?.notitle ? 'none' : ''\"\n        [innerHTML]=\"options?.title\"></span>\n    </mat-slide-toggle>\n    <mat-error *ngIf=\"options?.showErrors && options?.errorMessage\"\n      [innerHTML]=\"options?.errorMessage\"></mat-error>",
                    styles: ["\n    .checkbox-name { white-space: nowrap; }\n    mat-error { font-size: 75%; }\n  "]
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], MaterialCheckboxComponent);
            // TODO: Change this to use a Selection List instead?
            // https://material.angular.io/components/list/overview
            var MaterialCheckboxesComponent = /** @class */ (function () {
                function MaterialCheckboxesComponent(jsf) {
                    this.jsf = jsf;
                    this.controlDisabled = false;
                    this.boundControl = false;
                    this.horizontalList = false;
                    this.checkboxList = [];
                }
                MaterialCheckboxesComponent.prototype.ngOnInit = function () {
                    this.options = this.layoutNode.options || {};
                    this.horizontalList = this.layoutNode.type === 'checkboxes-inline' ||
                        this.layoutNode.type === 'checkboxbuttons';
                    this.jsf.initializeControl(this);
                    this.checkboxList = buildTitleMap(this.options.titleMap || this.options.enumNames, this.options.enum, true);
                    if (this.boundControl) {
                        var formArray = this.jsf.getFormControl(this);
                        for (var _a = 0, _b = this.checkboxList; _a < _b.length; _a++) {
                            var checkboxItem = _b[_a];
                            checkboxItem.checked = formArray.value.includes(checkboxItem.value);
                        }
                    }
                };
                Object.defineProperty(MaterialCheckboxesComponent.prototype, "allChecked", {
                    get: function () {
                        return this.checkboxList.filter(function (t) { return t.checked; }).length === this.checkboxList.length;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MaterialCheckboxesComponent.prototype, "someChecked", {
                    get: function () {
                        var checkedItems = this.checkboxList.filter(function (t) { return t.checked; }).length;
                        return checkedItems > 0 && checkedItems < this.checkboxList.length;
                    },
                    enumerable: true,
                    configurable: true
                });
                MaterialCheckboxesComponent.prototype.updateValue = function () {
                    this.options.showErrors = true;
                    if (this.boundControl) {
                        this.jsf.updateArrayCheckboxList(this, this.checkboxList);
                    }
                };
                MaterialCheckboxesComponent.prototype.updateAllValues = function (event) {
                    this.options.showErrors = true;
                    this.checkboxList.forEach(function (t) { return t.checked = event.checked; });
                    this.updateValue();
                };
                return MaterialCheckboxesComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], MaterialCheckboxesComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialCheckboxesComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialCheckboxesComponent.prototype, "dataIndex", void 0);
            MaterialCheckboxesComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'material-checkboxes-widget',
                    template: "\n    <div>\n      <mat-checkbox type=\"checkbox\"\n        [checked]=\"allChecked\"\n        [color]=\"options?.color || 'primary'\"\n        [disabled]=\"controlDisabled || options?.readonly\"\n        [indeterminate]=\"someChecked\"\n        [name]=\"options?.name\"\n        (blur)=\"options.showErrors = true\"\n        (change)=\"updateAllValues($event)\">\n        <span class=\"checkbox-name\" [innerHTML]=\"options?.name\"></span>\n      </mat-checkbox>\n      <label *ngIf=\"options?.title\"\n        class=\"title\"\n        [class]=\"options?.labelHtmlClass || ''\"\n        [style.display]=\"options?.notitle ? 'none' : ''\"\n        [innerHTML]=\"options?.title\"></label>\n      <ul class=\"checkbox-list\" [class.horizontal-list]=\"horizontalList\">\n        <li *ngFor=\"let checkboxItem of checkboxList\"\n          [class]=\"options?.htmlClass || ''\">\n          <mat-checkbox type=\"checkbox\"\n            [(ngModel)]=\"checkboxItem.checked\"\n            [color]=\"options?.color || 'primary'\"\n            [disabled]=\"controlDisabled || options?.readonly\"\n            [name]=\"checkboxItem?.name\"\n            (blur)=\"options.showErrors = true\"\n            (change)=\"updateValue()\">\n            <span class=\"checkbox-name\" [innerHTML]=\"checkboxItem?.name\"></span>\n          </mat-checkbox>\n        </li>\n      </ul>\n      <mat-error *ngIf=\"options?.showErrors && options?.errorMessage\"\n        [innerHTML]=\"options?.errorMessage\"></mat-error>\n    </div>",
                    styles: ["\n    .title { font-weight: bold; }\n    .checkbox-list { list-style-type: none; }\n    .horizontal-list > li { display: inline-block; margin-right: 10px; zoom: 1; }\n    .checkbox-name { white-space: nowrap; }\n    mat-error { font-size: 75%; }\n  "]
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], MaterialCheckboxesComponent);
            // TODO: Add this control
            var MaterialChipListComponent = /** @class */ (function () {
                function MaterialChipListComponent(jsf) {
                    this.jsf = jsf;
                    this.controlDisabled = false;
                    this.boundControl = false;
                }
                MaterialChipListComponent.prototype.ngOnInit = function () {
                    this.options = this.layoutNode.options || {};
                    this.jsf.initializeControl(this);
                };
                MaterialChipListComponent.prototype.updateValue = function (event) {
                    this.jsf.updateValue(this, event.target.value);
                };
                return MaterialChipListComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], MaterialChipListComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialChipListComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialChipListComponent.prototype, "dataIndex", void 0);
            MaterialChipListComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'material-chip-list-widget',
                    template: ""
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], MaterialChipListComponent);
            var MaterialDatepickerComponent = /** @class */ (function () {
                function MaterialDatepickerComponent(matFormFieldDefaultOptions, matLabelGlobalOptions, jsf) {
                    this.matFormFieldDefaultOptions = matFormFieldDefaultOptions;
                    this.matLabelGlobalOptions = matLabelGlobalOptions;
                    this.jsf = jsf;
                    this.controlDisabled = false;
                    this.boundControl = false;
                    this.autoCompleteList = [];
                }
                MaterialDatepickerComponent.prototype.ngOnInit = function () {
                    this.options = this.layoutNode.options || {};
                    this.jsf.initializeControl(this, !this.options.readonly);
                    if (this.controlValue) {
                        this.setDate(dateToString(new Date(this.controlValue)));
                    }
                    if (!this.options.notitle && !this.options.description && this.options.placeholder) {
                        this.options.description = this.options.placeholder;
                    }
                };
                MaterialDatepickerComponent.prototype.updateValue = function (event) {
                    this.options.showErrors = true;
                    if (event.value) {
                        this.setDate(dateToString(event.value));
                    }
                };
                MaterialDatepickerComponent.prototype.setDate = function (date) {
                    this.formControl.setValue(date, this.options);
                };
                return MaterialDatepickerComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], MaterialDatepickerComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialDatepickerComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialDatepickerComponent.prototype, "dataIndex", void 0);
            MaterialDatepickerComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'material-datepicker-widget',
                    template: "\n    <mat-form-field [appearance]=\"options?.appearance || matFormFieldDefaultOptions?.appearance || 'standard'\"\n                    [class]=\"options?.htmlClass || ''\"\n                    [floatLabel]=\"options?.floatLabel || matLabelGlobalOptions?.float || (options?.notitle ? 'never' : 'auto')\"\n                    [hideRequiredMarker]=\"options?.hideRequired ? 'true' : 'false'\"\n                    [style.width]=\"'100%'\">\n      <mat-label *ngIf=\"!options?.notitle\">{{options?.title}}</mat-label>\n      <span matPrefix *ngIf=\"options?.prefix || options?.fieldAddonLeft\"\n        [innerHTML]=\"options?.prefix || options?.fieldAddonLeft\"></span>\n        <input matInput *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.list]=\"'control' + layoutNode?._id + 'Autocomplete'\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [id]=\"'control' + layoutNode?._id\"\n        [max]=\"options?.maximum\"\n        [matDatepicker]=\"picker\"\n        [min]=\"options?.minimum\"\n        [name]=\"controlName\"\n        [placeholder]=\"options?.title\"\n        [readonly]=\"options?.readonly\"\n        [required]=\"options?.required\"\n        [style.width]=\"'100%'\"\n        (blur)=\"options.showErrors = true\"\n        (dateChange)=\"updateValue($event)\"\n        (dateInput)=\"updateValue($event)\">\n      <input matInput *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.list]=\"'control' + layoutNode?._id + 'Autocomplete'\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [disabled]=\"controlDisabled || options?.readonly\"\n        [id]=\"'control' + layoutNode?._id\"\n        [max]=\"options?.maximum\"\n        [matDatepicker]=\"picker\"\n        [min]=\"options?.minimum\"\n        [name]=\"controlName\"\n        [placeholder]=\"options?.title\"\n        [required]=\"options?.required\"\n        [style.width]=\"'100%'\"\n        [readonly]=\"options?.readonly\"\n        (blur)=\"options.showErrors = true\"\n        (dateChange)=\"updateValue($event)\"\n        (dateInput)=\"updateValue($event)\">\n      <span matSuffix *ngIf=\"options?.suffix || options?.fieldAddonRight\"\n        [innerHTML]=\"options?.suffix || options?.fieldAddonRight\"></span>\n      <mat-hint *ngIf=\"options?.description && (!options?.showErrors || !options?.errorMessage)\"\n        align=\"end\" [innerHTML]=\"options?.description\"></mat-hint>\n      <mat-datepicker-toggle matSuffix [for]=\"picker\"></mat-datepicker-toggle>\n    </mat-form-field>\n    <mat-datepicker #picker ></mat-datepicker>\n    <mat-error *ngIf=\"options?.showErrors && options?.errorMessage\"\n      [innerHTML]=\"options?.errorMessage\"></mat-error>",
                    styles: ["\n    mat-error { font-size: 75%; margin-top: -1rem; margin-bottom: 0.5rem; }\n    ::ng-deep json-schema-form mat-form-field .mat-form-field-wrapper .mat-form-field-flex\n      .mat-form-field-infix { width: initial; }\n  "]
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__param"])(0, Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Inject"])(_angular_material_form_field__WEBPACK_IMPORTED_MODULE_15__["MAT_FORM_FIELD_DEFAULT_OPTIONS"])), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__param"])(0, Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Optional"])()),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__param"])(1, Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Inject"])(_angular_material_core__WEBPACK_IMPORTED_MODULE_14__["MAT_LABEL_GLOBAL_OPTIONS"])), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__param"])(1, Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Optional"])()),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [Object, Object, JsonSchemaFormService])
            ], MaterialDatepickerComponent);
            var MaterialDesignFrameworkComponent = /** @class */ (function () {
                function MaterialDesignFrameworkComponent(changeDetector, jsf) {
                    this.changeDetector = changeDetector;
                    this.jsf = jsf;
                    this.frameworkInitialized = false;
                    this.formControl = null;
                    this.parentArray = null;
                    this.isOrderable = false;
                    this.dynamicTitle = null;
                }
                Object.defineProperty(MaterialDesignFrameworkComponent.prototype, "showRemoveButton", {
                    get: function () {
                        if (!this.layoutNode || !this.widgetOptions.removable ||
                            this.widgetOptions.readonly || this.layoutNode.type === '$ref') {
                            return false;
                        }
                        if (this.layoutNode.recursiveReference) {
                            return true;
                        }
                        if (!this.layoutNode.arrayItem || !this.parentArray) {
                            return false;
                        }
                        // If array length <= minItems, don't allow removing any items
                        return this.parentArray.items.length - 1 <= this.parentArray.options.minItems ? false :
                            // For removable list items, allow removing any item
                            this.layoutNode.arrayItemType === 'list' ? true :
                                // For removable tuple items, only allow removing last item in list
                                this.layoutIndex[this.layoutIndex.length - 1] === this.parentArray.items.length - 2;
                    },
                    enumerable: true,
                    configurable: true
                });
                MaterialDesignFrameworkComponent.prototype.ngOnInit = function () {
                    this.initializeFramework();
                };
                MaterialDesignFrameworkComponent.prototype.ngOnChanges = function () {
                    if (!this.frameworkInitialized) {
                        this.initializeFramework();
                    }
                    if (this.dynamicTitle) {
                        this.updateTitle();
                    }
                };
                MaterialDesignFrameworkComponent.prototype.initializeFramework = function () {
                    if (this.layoutNode) {
                        this.options = Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(this.layoutNode.options || {});
                        this.widgetLayoutNode = Object.assign({}, this.layoutNode, { options: Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(this.layoutNode.options || {}) });
                        this.widgetOptions = this.widgetLayoutNode.options;
                        this.formControl = this.jsf.getFormControl(this);
                        if (isDefined(this.widgetOptions.minimum) &&
                            isDefined(this.widgetOptions.maximum) &&
                            this.widgetOptions.multipleOf >= 1) {
                            this.layoutNode.type = 'range';
                        }
                        if (!['$ref', 'advancedfieldset', 'authfieldset', 'button', 'card',
                            'checkbox', 'expansion-panel', 'help', 'message', 'msg', 'section',
                            'submit', 'tabarray', 'tabs'].includes(this.layoutNode.type) &&
                            /{{.+?}}/.test(this.widgetOptions.title || '')) {
                            this.dynamicTitle = this.widgetOptions.title;
                            this.updateTitle();
                        }
                        if (this.layoutNode.arrayItem && this.layoutNode.type !== '$ref') {
                            this.parentArray = this.jsf.getParentNode(this);
                            if (this.parentArray) {
                                this.isOrderable =
                                    this.parentArray.type.slice(0, 3) !== 'tab' &&
                                        this.layoutNode.arrayItemType === 'list' &&
                                        !this.widgetOptions.readonly &&
                                        this.parentArray.options.orderable;
                            }
                        }
                        this.frameworkInitialized = true;
                    }
                    else {
                        this.options = {};
                    }
                };
                MaterialDesignFrameworkComponent.prototype.updateTitle = function () {
                    this.widgetLayoutNode.options.title = this.jsf.parseText(this.dynamicTitle, this.jsf.getFormControlValue(this), this.jsf.getFormControlGroup(this).value, this.dataIndex[this.dataIndex.length - 1]);
                };
                MaterialDesignFrameworkComponent.prototype.removeItem = function () {
                    this.jsf.removeItem(this);
                };
                return MaterialDesignFrameworkComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], MaterialDesignFrameworkComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialDesignFrameworkComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialDesignFrameworkComponent.prototype, "dataIndex", void 0);
            MaterialDesignFrameworkComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'material-design-framework',
                    template: "\n    <div\n      [class.array-item]=\"widgetLayoutNode?.arrayItem && widgetLayoutNode?.type !== '$ref'\"\n      [orderable]=\"isOrderable\"\n      [dataIndex]=\"dataIndex\"\n      [layoutIndex]=\"layoutIndex\"\n      [layoutNode]=\"widgetLayoutNode\">\n      <svg *ngIf=\"showRemoveButton\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        height=\"18\" width=\"18\" viewBox=\"0 0 24 24\"\n        class=\"close-button\"\n        (click)=\"removeItem()\">\n        <path d=\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z\"/>\n      </svg>\n      <select-widget-widget\n        [dataIndex]=\"dataIndex\"\n        [layoutIndex]=\"layoutIndex\"\n        [layoutNode]=\"widgetLayoutNode\"></select-widget-widget>\n    </div>\n    <div class=\"spacer\" *ngIf=\"widgetLayoutNode?.arrayItem && widgetLayoutNode?.type !== '$ref'\"></div>",
                    styles: ["\n    .array-item {\n      border-radius: 2px;\n      box-shadow: 0 3px 1px -2px rgba(0,0,0,.2),\n                  0 2px 2px  0   rgba(0,0,0,.14),\n                  0 1px 5px  0   rgba(0,0,0,.12);\n      padding: 6px;\n      position: relative;\n      transition: all 280ms cubic-bezier(.4, 0, .2, 1);\n    }\n    .close-button {\n      cursor: pointer;\n      position: absolute;\n      top: 6px;\n      right: 6px;\n      fill: rgba(0,0,0,.4);\n      visibility: hidden;\n      z-index: 500;\n    }\n    .close-button:hover { fill: rgba(0,0,0,.8); }\n    .array-item:hover > .close-button { visibility: visible; }\n    .spacer { margin: 6px 0; }\n    [draggable=true]:hover {\n      box-shadow: 0 5px 5px -3px rgba(0,0,0,.2),\n                  0 8px 10px 1px rgba(0,0,0,.14),\n                  0 3px 14px 2px rgba(0,0,0,.12);\n      cursor: move;\n      z-index: 10;\n    }\n    [draggable=true].drag-target-top {\n      box-shadow: 0 -2px 0 #000;\n      position: relative; z-index: 20;\n    }\n    [draggable=true].drag-target-bottom {\n      box-shadow: 0 2px 0 #000;\n      position: relative; z-index: 20;\n    }\n  "]
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_8__["ChangeDetectorRef"],
                    JsonSchemaFormService])
            ], MaterialDesignFrameworkComponent);
            // TODO: Add this control
            var MaterialFileComponent = /** @class */ (function () {
                function MaterialFileComponent(jsf) {
                    this.jsf = jsf;
                    this.controlDisabled = false;
                    this.boundControl = false;
                }
                MaterialFileComponent.prototype.ngOnInit = function () {
                    this.options = this.layoutNode.options || {};
                    this.jsf.initializeControl(this);
                };
                MaterialFileComponent.prototype.updateValue = function (event) {
                    this.jsf.updateValue(this, event.target.value);
                };
                return MaterialFileComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], MaterialFileComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialFileComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialFileComponent.prototype, "dataIndex", void 0);
            MaterialFileComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'material-file-widget',
                    template: ""
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], MaterialFileComponent);
            var MaterialInputComponent = /** @class */ (function () {
                function MaterialInputComponent(matFormFieldDefaultOptions, matLabelGlobalOptions, jsf) {
                    this.matFormFieldDefaultOptions = matFormFieldDefaultOptions;
                    this.matLabelGlobalOptions = matLabelGlobalOptions;
                    this.jsf = jsf;
                    this.controlDisabled = false;
                    this.boundControl = false;
                    this.autoCompleteList = [];
                }
                MaterialInputComponent.prototype.ngOnInit = function () {
                    this.options = this.layoutNode.options || {};
                    this.jsf.initializeControl(this);
                    if (!this.options.notitle && !this.options.description && this.options.placeholder) {
                        this.options.description = this.options.placeholder;
                    }
                };
                MaterialInputComponent.prototype.updateValue = function (event) {
                    this.jsf.updateValue(this, event.target.value);
                };
                return MaterialInputComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], MaterialInputComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialInputComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialInputComponent.prototype, "dataIndex", void 0);
            MaterialInputComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'material-input-widget',
                    template: "\n    <mat-form-field [appearance]=\"options?.appearance || matFormFieldDefaultOptions?.appearance || 'standard'\"\n      [class]=\"options?.htmlClass || ''\"\n      [floatLabel]=\"options?.floatLabel || matLabelGlobalOptions?.float || (options?.notitle ? 'never' : 'auto')\"\n      [hideRequiredMarker]=\"options?.hideRequired ? 'true' : 'false'\"\n      [style.width]=\"'100%'\">\n      <mat-label *ngIf=\"!options?.notitle\">{{options?.title}}</mat-label>\n      <span matPrefix *ngIf=\"options?.prefix || options?.fieldAddonLeft\"\n        [innerHTML]=\"options?.prefix || options?.fieldAddonLeft\"></span>\n      <input matInput *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.list]=\"'control' + layoutNode?._id + 'Autocomplete'\"\n        [attr.maxlength]=\"options?.maxLength\"\n        [attr.minlength]=\"options?.minLength\"\n        [attr.pattern]=\"options?.pattern\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [placeholder]=\"options?.notitle ? options?.placeholder : options?.title\"\n        [required]=\"options?.required\"\n        [style.width]=\"'100%'\"\n        [type]=\"layoutNode?.type\"\n        (blur)=\"options.showErrors = true\">\n      <input matInput *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.list]=\"'control' + layoutNode?._id + 'Autocomplete'\"\n        [attr.maxlength]=\"options?.maxLength\"\n        [attr.minlength]=\"options?.minLength\"\n        [attr.pattern]=\"options?.pattern\"\n        [disabled]=\"controlDisabled\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [placeholder]=\"options?.notitle ? options?.placeholder : options?.title\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [required]=\"options?.required\"\n        [style.width]=\"'100%'\"\n        [type]=\"layoutNode?.type\"\n        [value]=\"controlValue\"\n        (input)=\"updateValue($event)\"\n        (blur)=\"options.showErrors = true\">\n      <span matSuffix *ngIf=\"options?.suffix || options?.fieldAddonRight\"\n        [innerHTML]=\"options?.suffix || options?.fieldAddonRight\"></span>\n      <mat-hint *ngIf=\"options?.description && (!options?.showErrors || !options?.errorMessage)\"\n        align=\"end\" [innerHTML]=\"options?.description\"></mat-hint>\n      <mat-autocomplete *ngIf=\"options?.typeahead?.source\">\n        <mat-option *ngFor=\"let word of options?.typeahead?.source\"\n          [value]=\"word\">{{word}}</mat-option>\n      </mat-autocomplete>\n    </mat-form-field>\n    <mat-error *ngIf=\"options?.showErrors && options?.errorMessage\"\n      [innerHTML]=\"options?.errorMessage\"></mat-error>",
                    styles: ["\n    mat-error { font-size: 75%; margin-top: -1rem; margin-bottom: 0.5rem; }\n    ::ng-deep json-schema-form mat-form-field .mat-form-field-wrapper .mat-form-field-flex\n      .mat-form-field-infix { width: initial; }\n  "]
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__param"])(0, Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Inject"])(_angular_material_form_field__WEBPACK_IMPORTED_MODULE_15__["MAT_FORM_FIELD_DEFAULT_OPTIONS"])), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__param"])(0, Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Optional"])()),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__param"])(1, Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Inject"])(_angular_material_core__WEBPACK_IMPORTED_MODULE_14__["MAT_LABEL_GLOBAL_OPTIONS"])), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__param"])(1, Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Optional"])()),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [Object, Object, JsonSchemaFormService])
            ], MaterialInputComponent);
            var MaterialNumberComponent = /** @class */ (function () {
                function MaterialNumberComponent(matFormFieldDefaultOptions, matLabelGlobalOptions, jsf) {
                    this.matFormFieldDefaultOptions = matFormFieldDefaultOptions;
                    this.matLabelGlobalOptions = matLabelGlobalOptions;
                    this.jsf = jsf;
                    this.controlDisabled = false;
                    this.boundControl = false;
                    this.allowNegative = true;
                    this.allowDecimal = true;
                    this.allowExponents = false;
                    this.lastValidNumber = '';
                }
                MaterialNumberComponent.prototype.ngOnInit = function () {
                    this.options = this.layoutNode.options || {};
                    this.jsf.initializeControl(this);
                    if (this.layoutNode.dataType === 'integer') {
                        this.allowDecimal = false;
                    }
                    if (!this.options.notitle && !this.options.description && this.options.placeholder) {
                        this.options.description = this.options.placeholder;
                    }
                };
                MaterialNumberComponent.prototype.updateValue = function (event) {
                    this.jsf.updateValue(this, event.target.value);
                };
                return MaterialNumberComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], MaterialNumberComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialNumberComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialNumberComponent.prototype, "dataIndex", void 0);
            MaterialNumberComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'material-number-widget',
                    template: "\n    <mat-form-field [appearance]=\"options?.appearance || matFormFieldDefaultOptions?.appearance || 'standard'\"\n    [class]=\"options?.htmlClass || ''\"\n    [floatLabel]=\"options?.floatLabel || matLabelGlobalOptions?.float || (options?.notitle ? 'never' : 'auto')\"\n    [hideRequiredMarker]=\"options?.hideRequired ? 'true' : 'false'\"\n    [style.width]=\"'100%'\">\n    <mat-label *ngIf=\"!options?.notitle\">{{options?.title}}</mat-label>\n      <span matPrefix *ngIf=\"options?.prefix || options?.fieldAddonLeft\"\n        [innerHTML]=\"options?.prefix || options?.fieldAddonLeft\"></span>\n      <input matInput *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.max]=\"options?.maximum\"\n        [attr.min]=\"options?.minimum\"\n        [attr.step]=\"options?.multipleOf || options?.step || 'any'\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [placeholder]=\"options?.notitle ? options?.placeholder : options?.title\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [required]=\"options?.required\"\n        [style.width]=\"'100%'\"\n        [type]=\"'number'\"\n        (blur)=\"options.showErrors = true\">\n      <input matInput *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.max]=\"options?.maximum\"\n        [attr.min]=\"options?.minimum\"\n        [attr.step]=\"options?.multipleOf || options?.step || 'any'\"\n        [disabled]=\"controlDisabled\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [placeholder]=\"options?.notitle ? options?.placeholder : options?.title\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [required]=\"options?.required\"\n        [style.width]=\"'100%'\"\n        [type]=\"'number'\"\n        [value]=\"controlValue\"\n        (input)=\"updateValue($event)\"\n        (blur)=\"options.showErrors = true\">\n      <span matSuffix *ngIf=\"options?.suffix || options?.fieldAddonRight\"\n        [innerHTML]=\"options?.suffix || options?.fieldAddonRight\"></span>\n      <mat-hint *ngIf=\"layoutNode?.type === 'range'\" align=\"start\"\n        [innerHTML]=\"controlValue\"></mat-hint>\n      <mat-hint *ngIf=\"options?.description && (!options?.showErrors || !options?.errorMessage)\"\n        align=\"end\" [innerHTML]=\"options?.description\"></mat-hint>\n    </mat-form-field>\n    <mat-error *ngIf=\"options?.showErrors && options?.errorMessage\"\n      [innerHTML]=\"options?.errorMessage\"></mat-error>",
                    styles: ["\n    mat-error { font-size: 75%; margin-top: -1rem; margin-bottom: 0.5rem; }\n    ::ng-deep json-schema-form mat-form-field .mat-form-field-wrapper .mat-form-field-flex\n      .mat-form-field-infix { width: initial; }\n  "]
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__param"])(0, Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Inject"])(_angular_material_form_field__WEBPACK_IMPORTED_MODULE_15__["MAT_FORM_FIELD_DEFAULT_OPTIONS"])), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__param"])(0, Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Optional"])()),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__param"])(1, Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Inject"])(_angular_material_core__WEBPACK_IMPORTED_MODULE_14__["MAT_LABEL_GLOBAL_OPTIONS"])), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__param"])(1, Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Optional"])()),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [Object, Object, JsonSchemaFormService])
            ], MaterialNumberComponent);
            // TODO: Add this control
            var MaterialOneOfComponent = /** @class */ (function () {
                function MaterialOneOfComponent(jsf) {
                    this.jsf = jsf;
                    this.controlDisabled = false;
                    this.boundControl = false;
                }
                MaterialOneOfComponent.prototype.ngOnInit = function () {
                    this.options = this.layoutNode.options || {};
                    this.jsf.initializeControl(this);
                };
                MaterialOneOfComponent.prototype.updateValue = function (event) {
                    this.jsf.updateValue(this, event.target.value);
                };
                return MaterialOneOfComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], MaterialOneOfComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialOneOfComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialOneOfComponent.prototype, "dataIndex", void 0);
            MaterialOneOfComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'material-one-of-widget',
                    template: ""
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], MaterialOneOfComponent);
            var MaterialRadiosComponent = /** @class */ (function () {
                function MaterialRadiosComponent(jsf) {
                    this.jsf = jsf;
                    this.controlDisabled = false;
                    this.boundControl = false;
                    this.flexDirection = 'column';
                    this.radiosList = [];
                }
                MaterialRadiosComponent.prototype.ngOnInit = function () {
                    this.options = this.layoutNode.options || {};
                    if (this.layoutNode.type === 'radios-inline') {
                        this.flexDirection = 'row';
                    }
                    this.radiosList = buildTitleMap(this.options.titleMap || this.options.enumNames, this.options.enum, true);
                    this.jsf.initializeControl(this, !this.options.readonly);
                };
                MaterialRadiosComponent.prototype.updateValue = function (value) {
                    this.options.showErrors = true;
                    this.jsf.updateValue(this, value);
                };
                return MaterialRadiosComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], MaterialRadiosComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialRadiosComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialRadiosComponent.prototype, "dataIndex", void 0);
            MaterialRadiosComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'material-radios-widget',
                    template: "\n    <div>\n      <div *ngIf=\"options?.title\">\n        <label\n          [attr.for]=\"'control' + layoutNode?._id\"\n          [class]=\"options?.labelHtmlClass || ''\"\n          [style.display]=\"options?.notitle ? 'none' : ''\"\n          [innerHTML]=\"options?.title\"></label>\n      </div>\n      <mat-radio-group *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.required]=\"options?.required\"\n        [style.flex-direction]=\"flexDirection\"\n        [name]=\"controlName\"\n        (blur)=\"options.showErrors = true\">\n        <mat-radio-button *ngFor=\"let radioItem of radiosList\"\n          [id]=\"'control' + layoutNode?._id + '/' + radioItem?.name\"\n          [value]=\"radioItem?.value\">\n          <span [innerHTML]=\"radioItem?.name\"></span>\n        </mat-radio-button>\n      </mat-radio-group>\n      <mat-radio-group *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.required]=\"options?.required\"\n        [style.flex-direction]=\"flexDirection\"\n        [disabled]=\"controlDisabled || options?.readonly\"\n        [name]=\"controlName\"\n        [value]=\"controlValue\">\n        <mat-radio-button *ngFor=\"let radioItem of radiosList\"\n          [id]=\"'control' + layoutNode?._id + '/' + radioItem?.name\"\n          [value]=\"radioItem?.value\"\n          (click)=\"updateValue(radioItem?.value)\">\n          <span [innerHTML]=\"radioItem?.name\"></span>\n        </mat-radio-button>\n      </mat-radio-group>\n      <mat-error *ngIf=\"options?.showErrors && options?.errorMessage\"\n        [innerHTML]=\"options?.errorMessage\"></mat-error>\n    </div>",
                    styles: ["\n    mat-radio-group { display: inline-flex; }\n    mat-radio-button { margin: 2px; }\n    mat-error { font-size: 75%; }\n  "]
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], MaterialRadiosComponent);
            var MaterialSelectComponent = /** @class */ (function () {
                function MaterialSelectComponent(matFormFieldDefaultOptions, matLabelGlobalOptions, jsf) {
                    this.matFormFieldDefaultOptions = matFormFieldDefaultOptions;
                    this.matLabelGlobalOptions = matLabelGlobalOptions;
                    this.jsf = jsf;
                    this.controlDisabled = false;
                    this.boundControl = false;
                    this.selectList = [];
                    this.isArray = isArray;
                }
                MaterialSelectComponent.prototype.ngOnInit = function () {
                    this.options = this.layoutNode.options || {};
                    this.selectList = buildTitleMap(this.options.titleMap || this.options.enumNames, this.options.enum, !!this.options.required, !!this.options.flatList);
                    this.jsf.initializeControl(this, !this.options.readonly);
                    if (!this.options.notitle && !this.options.description && this.options.placeholder) {
                        this.options.description = this.options.placeholder;
                    }
                };
                MaterialSelectComponent.prototype.updateValue = function (event) {
                    this.options.showErrors = true;
                    this.jsf.updateValue(this, event.value);
                };
                return MaterialSelectComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], MaterialSelectComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialSelectComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialSelectComponent.prototype, "dataIndex", void 0);
            MaterialSelectComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'material-select-widget',
                    template: "\n    <mat-form-field\n      [appearance]=\"options?.appearance || matFormFieldDefaultOptions?.appearance || 'standard'\"\n      [class]=\"options?.htmlClass || ''\"\n      [floatLabel]=\"options?.floatLabel || matLabelGlobalOptions?.float || (options?.notitle ? 'never' : 'auto')\"\n      [hideRequiredMarker]=\"options?.hideRequired ? 'true' : 'false'\"\n      [style.width]=\"'100%'\">\n      <mat-label *ngIf=\"!options?.notitle\">{{options?.title}}</mat-label>\n      <span matPrefix *ngIf=\"options?.prefix || options?.fieldAddonLeft\"\n        [innerHTML]=\"options?.prefix || options?.fieldAddonLeft\"></span>\n      <mat-select *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.name]=\"controlName\"\n        [id]=\"'control' + layoutNode?._id\"\n        [multiple]=\"options?.multiple\"\n        [placeholder]=\"options?.notitle ? options?.placeholder : options?.title\"\n        [required]=\"options?.required\"\n        [style.width]=\"'100%'\"\n        (blur)=\"options.showErrors = true\">\n        <ng-template ngFor let-selectItem [ngForOf]=\"selectList\">\n          <mat-option *ngIf=\"!isArray(selectItem?.items)\"\n            [value]=\"selectItem?.value\">\n            <span [innerHTML]=\"selectItem?.name\"></span>\n          </mat-option>\n          <mat-optgroup *ngIf=\"isArray(selectItem?.items)\"\n            [label]=\"selectItem?.group\">\n            <mat-option *ngFor=\"let subItem of selectItem.items\"\n              [value]=\"subItem?.value\">\n              <span [innerHTML]=\"subItem?.name\"></span>\n            </mat-option>\n          </mat-optgroup>\n        </ng-template>\n      </mat-select>\n      <mat-select *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.name]=\"controlName\"\n        [disabled]=\"controlDisabled || options?.readonly\"\n        [id]=\"'control' + layoutNode?._id\"\n        [multiple]=\"options?.multiple\"\n        [placeholder]=\"options?.notitle ? options?.placeholder : options?.title\"\n        [required]=\"options?.required\"\n        [style.width]=\"'100%'\"\n        [value]=\"controlValue\"\n        (blur)=\"options.showErrors = true\"\n        (change)=\"updateValue($event)\">\n        <ng-template ngFor let-selectItem [ngForOf]=\"selectList\">\n          <mat-option *ngIf=\"!isArray(selectItem?.items)\"\n            [attr.selected]=\"selectItem?.value === controlValue\"\n            [value]=\"selectItem?.value\">\n            <span [innerHTML]=\"selectItem?.name\"></span>\n          </mat-option>\n          <mat-optgroup *ngIf=\"isArray(selectItem?.items)\"\n            [label]=\"selectItem?.group\">\n            <mat-option *ngFor=\"let subItem of selectItem.items\"\n              [attr.selected]=\"subItem?.value === controlValue\"\n              [value]=\"subItem?.value\">\n              <span [innerHTML]=\"subItem?.name\"></span>\n            </mat-option>\n          </mat-optgroup>\n        </ng-template>\n      </mat-select>\n      <span matSuffix *ngIf=\"options?.suffix || options?.fieldAddonRight\"\n        [innerHTML]=\"options?.suffix || options?.fieldAddonRight\"></span>\n      <mat-hint *ngIf=\"options?.description && (!options?.showErrors || !options?.errorMessage)\"\n        align=\"end\" [innerHTML]=\"options?.description\"></mat-hint>\n    </mat-form-field>\n    <mat-error *ngIf=\"options?.showErrors && options?.errorMessage\"\n      [innerHTML]=\"options?.errorMessage\"></mat-error>",
                    styles: ["\n    mat-error { font-size: 75%; margin-top: -1rem; margin-bottom: 0.5rem; }\n    ::ng-deep json-schema-form mat-form-field .mat-form-field-wrapper .mat-form-field-flex\n      .mat-form-field-infix { width: initial; }\n  "]
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__param"])(0, Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Inject"])(_angular_material_form_field__WEBPACK_IMPORTED_MODULE_15__["MAT_FORM_FIELD_DEFAULT_OPTIONS"])), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__param"])(0, Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Optional"])()),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__param"])(1, Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Inject"])(_angular_material_core__WEBPACK_IMPORTED_MODULE_14__["MAT_LABEL_GLOBAL_OPTIONS"])), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__param"])(1, Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Optional"])()),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [Object, Object, JsonSchemaFormService])
            ], MaterialSelectComponent);
            var MaterialSliderComponent = /** @class */ (function () {
                function MaterialSliderComponent(jsf) {
                    this.jsf = jsf;
                    this.controlDisabled = false;
                    this.boundControl = false;
                    this.allowNegative = true;
                    this.allowDecimal = true;
                    this.allowExponents = false;
                    this.lastValidNumber = '';
                }
                MaterialSliderComponent.prototype.ngOnInit = function () {
                    this.options = this.layoutNode.options || {};
                    this.jsf.initializeControl(this, !this.options.readonly);
                };
                MaterialSliderComponent.prototype.updateValue = function (event) {
                    this.options.showErrors = true;
                    this.jsf.updateValue(this, event.value);
                };
                return MaterialSliderComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], MaterialSliderComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialSliderComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialSliderComponent.prototype, "dataIndex", void 0);
            MaterialSliderComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'material-slider-widget',
                    template: "\n    <mat-slider thumbLabel *ngIf=\"boundControl\"\n      [formControl]=\"formControl\"\n      [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n      [id]=\"'control' + layoutNode?._id\"\n      [max]=\"options?.maximum\"\n      [min]=\"options?.minimum\"\n      [step]=\"options?.multipleOf || options?.step || 'any'\"\n      [style.width]=\"'100%'\"\n      (blur)=\"options.showErrors = true\"></mat-slider>\n    <mat-slider thumbLabel *ngIf=\"!boundControl\"\n      [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n      [disabled]=\"controlDisabled || options?.readonly\"\n      [id]=\"'control' + layoutNode?._id\"\n      [max]=\"options?.maximum\"\n      [min]=\"options?.minimum\"\n      [step]=\"options?.multipleOf || options?.step || 'any'\"\n      [style.width]=\"'100%'\"\n      [value]=\"controlValue\"\n      (blur)=\"options.showErrors = true\"\n      (change)=\"updateValue($event)\"></mat-slider>\n    <mat-error *ngIf=\"options?.showErrors && options?.errorMessage\"\n      [innerHTML]=\"options?.errorMessage\"></mat-error>",
                    styles: [" mat-error { font-size: 75%; } "]
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], MaterialSliderComponent);
            // TODO: Add this control
            var MaterialStepperComponent = /** @class */ (function () {
                function MaterialStepperComponent(jsf) {
                    this.jsf = jsf;
                    this.controlDisabled = false;
                    this.boundControl = false;
                }
                MaterialStepperComponent.prototype.ngOnInit = function () {
                    this.options = this.layoutNode.options || {};
                    this.jsf.initializeControl(this);
                };
                MaterialStepperComponent.prototype.updateValue = function (event) {
                    this.jsf.updateValue(this, event.target.value);
                };
                return MaterialStepperComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], MaterialStepperComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialStepperComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialStepperComponent.prototype, "dataIndex", void 0);
            MaterialStepperComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'material-stepper-widget',
                    template: ""
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], MaterialStepperComponent);
            var MaterialTabsComponent = /** @class */ (function () {
                function MaterialTabsComponent(jsf) {
                    this.jsf = jsf;
                    this.selectedItem = 0;
                    this.showAddTab = true;
                }
                MaterialTabsComponent.prototype.ngOnInit = function () {
                    this.options = this.layoutNode.options || {};
                    this.itemCount = this.layoutNode.items.length - 1;
                    this.updateControl();
                };
                MaterialTabsComponent.prototype.select = function (index) {
                    if (this.layoutNode.items[index].type === '$ref') {
                        this.jsf.addItem({
                            layoutNode: this.layoutNode.items[index],
                            layoutIndex: this.layoutIndex.concat(index),
                            dataIndex: this.dataIndex.concat(index)
                        });
                        this.updateControl();
                    }
                    this.selectedItem = index;
                };
                MaterialTabsComponent.prototype.updateControl = function () {
                    this.itemCount = this.layoutNode.items.length - 1;
                    var lastItem = this.layoutNode.items[this.layoutNode.items.length - 1];
                    this.showAddTab = lastItem.type === '$ref' &&
                        this.itemCount < (lastItem.options.maxItems || 1000);
                };
                MaterialTabsComponent.prototype.setTabTitle = function (item, index) {
                    return this.jsf.setArrayItemTitle(this, item, index);
                };
                return MaterialTabsComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], MaterialTabsComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialTabsComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialTabsComponent.prototype, "dataIndex", void 0);
            MaterialTabsComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'material-tabs-widget',
                    template: "\n    <nav mat-tab-nav-bar\n      [attr.aria-label]=\"options?.label || options?.title || ''\"\n      [style.width]=\"'100%'\">\n        <a mat-tab-link *ngFor=\"let item of layoutNode?.items; let i = index\"\n          [active]=\"selectedItem === i\"\n          (click)=\"select(i)\">\n          <span *ngIf=\"showAddTab || item.type !== '$ref'\"\n            [innerHTML]=\"setTabTitle(item, i)\"></span>\n        </a>\n    </nav>\n    <div *ngFor=\"let layoutItem of layoutNode?.items; let i = index\"\n      [class]=\"options?.htmlClass || ''\">\n      <select-framework-widget *ngIf=\"selectedItem === i\"\n        [class]=\"(options?.fieldHtmlClass || '') + ' ' + (options?.activeClass || '') + ' ' + (options?.style?.selected || '')\"\n        [dataIndex]=\"layoutNode?.dataType === 'array' ? (dataIndex || []).concat(i) : dataIndex\"\n        [layoutIndex]=\"(layoutIndex || []).concat(i)\"\n        [layoutNode]=\"layoutItem\"></select-framework-widget>\n    </div>",
                    styles: [" a { cursor: pointer; } "]
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [JsonSchemaFormService])
            ], MaterialTabsComponent);
            var MaterialTextareaComponent = /** @class */ (function () {
                function MaterialTextareaComponent(matFormFieldDefaultOptions, matLabelGlobalOptions, jsf) {
                    this.matFormFieldDefaultOptions = matFormFieldDefaultOptions;
                    this.matLabelGlobalOptions = matLabelGlobalOptions;
                    this.jsf = jsf;
                    this.controlDisabled = false;
                    this.boundControl = false;
                }
                MaterialTextareaComponent.prototype.ngOnInit = function () {
                    this.options = this.layoutNode.options || {};
                    this.jsf.initializeControl(this);
                    if (!this.options.notitle && !this.options.description && this.options.placeholder) {
                        this.options.description = this.options.placeholder;
                    }
                };
                MaterialTextareaComponent.prototype.updateValue = function (event) {
                    this.jsf.updateValue(this, event.target.value);
                };
                return MaterialTextareaComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], MaterialTextareaComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialTextareaComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], MaterialTextareaComponent.prototype, "dataIndex", void 0);
            MaterialTextareaComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'material-textarea-widget',
                    template: "\n    <mat-form-field [appearance]=\"options?.appearance || matFormFieldDefaultOptions?.appearance || 'standard'\"\n      [class]=\"options?.htmlClass || ''\"\n      [floatLabel]=\"options?.floatLabel || matLabelGlobalOptions?.float || (options?.notitle ? 'never' : 'auto')\"\n      [hideRequiredMarker]=\"options?.hideRequired ? 'true' : 'false'\"\n      [style.width]=\"'100%'\">\n      <mat-label *ngIf=\"!options?.notitle\">{{options?.title}}</mat-label>\n      <span matPrefix *ngIf=\"options?.prefix || options?.fieldAddonLeft\"\n        [innerHTML]=\"options?.prefix || options?.fieldAddonLeft\"></span>\n      <textarea matInput *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.list]=\"'control' + layoutNode?._id + 'Autocomplete'\"\n        [attr.maxlength]=\"options?.maxLength\"\n        [attr.minlength]=\"options?.minLength\"\n        [attr.pattern]=\"options?.pattern\"\n        [required]=\"options?.required\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [placeholder]=\"options?.notitle ? options?.placeholder : options?.title\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [style.width]=\"'100%'\"\n        (blur)=\"options.showErrors = true\"></textarea>\n      <textarea matInput *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.list]=\"'control' + layoutNode?._id + 'Autocomplete'\"\n        [attr.maxlength]=\"options?.maxLength\"\n        [attr.minlength]=\"options?.minLength\"\n        [attr.pattern]=\"options?.pattern\"\n        [required]=\"options?.required\"\n        [disabled]=\"controlDisabled\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [placeholder]=\"options?.notitle ? options?.placeholder : options?.title\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [style.width]=\"'100%'\"\n        [value]=\"controlValue\"\n        (input)=\"updateValue($event)\"\n        (blur)=\"options.showErrors = true\"></textarea>\n      <span matSuffix *ngIf=\"options?.suffix || options?.fieldAddonRight\"\n        [innerHTML]=\"options?.suffix || options?.fieldAddonRight\"></span>\n      <mat-hint *ngIf=\"options?.description && (!options?.showErrors || !options?.errorMessage)\"\n        align=\"end\" [innerHTML]=\"options?.description\"></mat-hint>\n    </mat-form-field>\n    <mat-error *ngIf=\"options?.showErrors && options?.errorMessage\"\n      [innerHTML]=\"options?.errorMessage\"></mat-error>",
                    styles: ["\n    mat-error { font-size: 75%; margin-top: -1rem; margin-bottom: 0.5rem; }\n    ::ng-deep json-schema-form mat-form-field .mat-form-field-wrapper .mat-form-field-flex\n      .mat-form-field-infix { width: initial; }\n  "]
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__param"])(0, Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Inject"])(_angular_material_form_field__WEBPACK_IMPORTED_MODULE_15__["MAT_FORM_FIELD_DEFAULT_OPTIONS"])), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__param"])(0, Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Optional"])()),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__param"])(1, Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Inject"])(_angular_material_core__WEBPACK_IMPORTED_MODULE_14__["MAT_LABEL_GLOBAL_OPTIONS"])), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__param"])(1, Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Optional"])()),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [Object, Object, JsonSchemaFormService])
            ], MaterialTextareaComponent);
            // Material Design Framework
            // https://github.com/angular/material2
            var MaterialDesignFramework = /** @class */ (function (_super) {
                __extends(MaterialDesignFramework, _super);
                // Material Design Framework
                // https://github.com/angular/material2
                function MaterialDesignFramework() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.name = 'material-design';
                    _this_1.framework = MaterialDesignFrameworkComponent;
                    _this_1.stylesheets = [
                        '//fonts.googleapis.com/icon?family=Material+Icons',
                        '//fonts.googleapis.com/css?family=Roboto:300,400,500,700',
                    ];
                    _this_1.widgets = {
                        'root': FlexLayoutRootComponent,
                        'section': FlexLayoutSectionComponent,
                        '$ref': MaterialAddReferenceComponent,
                        'button': MaterialButtonComponent,
                        'button-group': MaterialButtonGroupComponent,
                        'checkbox': MaterialCheckboxComponent,
                        'checkboxes': MaterialCheckboxesComponent,
                        'chip-list': MaterialChipListComponent,
                        'date': MaterialDatepickerComponent,
                        'file': MaterialFileComponent,
                        'number': MaterialNumberComponent,
                        'one-of': MaterialOneOfComponent,
                        'radios': MaterialRadiosComponent,
                        'select': MaterialSelectComponent,
                        'slider': MaterialSliderComponent,
                        'stepper': MaterialStepperComponent,
                        'tabs': MaterialTabsComponent,
                        'text': MaterialInputComponent,
                        'textarea': MaterialTextareaComponent,
                        'alt-date': 'date',
                        'any-of': 'one-of',
                        'card': 'section',
                        'color': 'text',
                        'expansion-panel': 'section',
                        'hidden': 'none',
                        'image': 'none',
                        'integer': 'number',
                        'radiobuttons': 'button-group',
                        'range': 'slider',
                        'submit': 'button',
                        'tagsinput': 'chip-list',
                        'wizard': 'stepper',
                    };
                    return _this_1;
                }
                return MaterialDesignFramework;
            }(Framework));
            MaterialDesignFramework = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Injectable"])()
            ], MaterialDesignFramework);
            function fixAngularFlex() {
                // monkey patch based on errors in console  - https://github.com/angular/flex-layout/issues/1011
                var MediaMarshallerUpdateElement = _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_17__["MediaMarshaller"].prototype.updateElement;
                _angular_flex_layout_core__WEBPACK_IMPORTED_MODULE_17__["MediaMarshaller"].prototype.updateElement = function (element, key, value) {
                    if (key === 'layout-gap' && (value === null || value === undefined)) {
                        value = '0px';
                    }
                    MediaMarshallerUpdateElement.apply(this, [element, key, value]);
                };
            }
            var JsonSchemaFormModule = /** @class */ (function () {
                function JsonSchemaFormModule() {
                    fixAngularFlex();
                }
                return JsonSchemaFormModule;
            }());
            JsonSchemaFormModule = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["NgModule"])({
                    imports: [
                        _angular_common__WEBPACK_IMPORTED_MODULE_13__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_6__["FormsModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_6__["ReactiveFormsModule"],
                        WidgetLibraryModule, NoFrameworkModule
                    ],
                    declarations: [JsonSchemaFormComponent],
                    exports: [JsonSchemaFormComponent, WidgetLibraryModule]
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [])
            ], JsonSchemaFormModule);
            var MATERIAL_FRAMEWORK_COMPONENTS = [
                FlexLayoutRootComponent, FlexLayoutSectionComponent,
                MaterialAddReferenceComponent, MaterialOneOfComponent,
                MaterialButtonComponent, MaterialButtonGroupComponent,
                MaterialCheckboxComponent, MaterialCheckboxesComponent,
                MaterialChipListComponent, MaterialDatepickerComponent,
                MaterialFileComponent, MaterialInputComponent, MaterialNumberComponent,
                MaterialRadiosComponent, MaterialSelectComponent, MaterialSliderComponent,
                MaterialStepperComponent, MaterialTabsComponent, MaterialTextareaComponent,
                MaterialDesignFrameworkComponent
            ];
            /**
             * unused @angular/material modules:
             * MatDialogModule, MatGridListModule, MatListModule, MatMenuModule,
             * MatPaginatorModule, MatProgressBarModule, MatProgressSpinnerModule,
             * MatSidenavModule, MatSnackBarModule, MatSortModule, MatTableModule,
             * MatToolbarModule,
             */
            var ANGULAR_MATERIAL_MODULES = [
                _angular_material_autocomplete__WEBPACK_IMPORTED_MODULE_18__["MatAutocompleteModule"], _angular_material_button__WEBPACK_IMPORTED_MODULE_19__["MatButtonModule"], _angular_material_button_toggle__WEBPACK_IMPORTED_MODULE_20__["MatButtonToggleModule"], _angular_material_card__WEBPACK_IMPORTED_MODULE_21__["MatCardModule"],
                _angular_material_checkbox__WEBPACK_IMPORTED_MODULE_22__["MatCheckboxModule"], _angular_material_chips__WEBPACK_IMPORTED_MODULE_23__["MatChipsModule"], _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_24__["MatDatepickerModule"], _angular_material_expansion__WEBPACK_IMPORTED_MODULE_25__["MatExpansionModule"],
                _angular_material_form_field__WEBPACK_IMPORTED_MODULE_15__["MatFormFieldModule"], _angular_material_icon__WEBPACK_IMPORTED_MODULE_26__["MatIconModule"], _angular_material_input__WEBPACK_IMPORTED_MODULE_27__["MatInputModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_14__["MatNativeDateModule"],
                _angular_material_radio__WEBPACK_IMPORTED_MODULE_28__["MatRadioModule"], _angular_material_select__WEBPACK_IMPORTED_MODULE_29__["MatSelectModule"], _angular_material_slider__WEBPACK_IMPORTED_MODULE_31__["MatSliderModule"], _angular_material_slide_toggle__WEBPACK_IMPORTED_MODULE_30__["MatSlideToggleModule"],
                _angular_material_stepper__WEBPACK_IMPORTED_MODULE_32__["MatStepperModule"], _angular_material_tabs__WEBPACK_IMPORTED_MODULE_33__["MatTabsModule"], _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_34__["MatTooltipModule"],
            ];
            var MaterialDesignFrameworkModule = /** @class */ (function () {
                function MaterialDesignFrameworkModule() {
                }
                return MaterialDesignFrameworkModule;
            }());
            MaterialDesignFrameworkModule = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["NgModule"])({
                    imports: [
                        _angular_common__WEBPACK_IMPORTED_MODULE_13__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_6__["FormsModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_6__["ReactiveFormsModule"], _angular_flex_layout__WEBPACK_IMPORTED_MODULE_16__["FlexLayoutModule"]
                    ].concat(ANGULAR_MATERIAL_MODULES, [
                        WidgetLibraryModule, JsonSchemaFormModule
                    ]),
                    declarations: MATERIAL_FRAMEWORK_COMPONENTS.slice(),
                    exports: [JsonSchemaFormModule].concat(MATERIAL_FRAMEWORK_COMPONENTS),
                    providers: [JsonSchemaFormService, FrameworkLibraryService, WidgetLibraryService,
                        { provide: Framework, useClass: MaterialDesignFramework, multi: true }
                    ],
                    entryComponents: MATERIAL_FRAMEWORK_COMPONENTS.slice()
                })
            ], MaterialDesignFrameworkModule);
            /**
             * Bootstrap 3 framework for Angular JSON Schema Form.
             *
             */
            var Bootstrap3FrameworkComponent = /** @class */ (function () {
                function Bootstrap3FrameworkComponent(changeDetector, jsf) {
                    this.changeDetector = changeDetector;
                    this.jsf = jsf;
                    this.frameworkInitialized = false;
                    this.formControl = null;
                    this.debugOutput = '';
                    this.debug = '';
                    this.parentArray = null;
                    this.isOrderable = false;
                }
                Object.defineProperty(Bootstrap3FrameworkComponent.prototype, "showRemoveButton", {
                    get: function () {
                        if (!this.options.removable || this.options.readonly ||
                            this.layoutNode.type === '$ref') {
                            return false;
                        }
                        if (this.layoutNode.recursiveReference) {
                            return true;
                        }
                        if (!this.layoutNode.arrayItem || !this.parentArray) {
                            return false;
                        }
                        // If array length <= minItems, don't allow removing any items
                        return this.parentArray.items.length - 1 <= this.parentArray.options.minItems ? false :
                            // For removable list items, allow removing any item
                            this.layoutNode.arrayItemType === 'list' ? true :
                                // For removable tuple items, only allow removing last item in list
                                this.layoutIndex[this.layoutIndex.length - 1] === this.parentArray.items.length - 2;
                    },
                    enumerable: true,
                    configurable: true
                });
                Bootstrap3FrameworkComponent.prototype.ngOnInit = function () {
                    this.initializeFramework();
                    if (this.layoutNode.arrayItem && this.layoutNode.type !== '$ref') {
                        this.parentArray = this.jsf.getParentNode(this);
                        if (this.parentArray) {
                            this.isOrderable = this.layoutNode.arrayItemType === 'list' &&
                                !this.options.readonly && this.parentArray.options.orderable;
                        }
                    }
                };
                Bootstrap3FrameworkComponent.prototype.ngOnChanges = function () {
                    if (!this.frameworkInitialized) {
                        this.initializeFramework();
                    }
                };
                Bootstrap3FrameworkComponent.prototype.initializeFramework = function () {
                    var _this_1 = this;
                    if (this.layoutNode) {
                        this.options = Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(this.layoutNode.options);
                        this.widgetLayoutNode = Object.assign({}, this.layoutNode, { options: Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(this.layoutNode.options) });
                        this.widgetOptions = this.widgetLayoutNode.options;
                        this.formControl = this.jsf.getFormControl(this);
                        this.options.isInputWidget = inArray(this.layoutNode.type, [
                            'button', 'checkbox', 'checkboxes-inline', 'checkboxes', 'color',
                            'date', 'datetime-local', 'datetime', 'email', 'file', 'hidden',
                            'image', 'integer', 'month', 'number', 'password', 'radio',
                            'radiobuttons', 'radios-inline', 'radios', 'range', 'reset', 'search',
                            'select', 'submit', 'tel', 'text', 'textarea', 'time', 'url', 'week'
                        ]);
                        this.options.title = this.setTitle();
                        this.options.htmlClass =
                            addClasses(this.options.htmlClass, 'schema-form-' + this.layoutNode.type);
                        if (this.layoutNode.type !== 'flex') {
                            this.options.htmlClass =
                                this.layoutNode.type === 'array' ?
                                    addClasses(this.options.htmlClass, 'list-group') :
                                    this.layoutNode.arrayItem && this.layoutNode.type !== '$ref' ?
                                        addClasses(this.options.htmlClass, 'list-group-item') :
                                        addClasses(this.options.htmlClass, 'form-group');
                        }
                        this.widgetOptions.htmlClass = '';
                        this.options.labelHtmlClass =
                            addClasses(this.options.labelHtmlClass, 'control-label');
                        this.widgetOptions.activeClass =
                            addClasses(this.widgetOptions.activeClass, 'active');
                        this.options.fieldAddonLeft =
                            this.options.fieldAddonLeft || this.options.prepend;
                        this.options.fieldAddonRight =
                            this.options.fieldAddonRight || this.options.append;
                        // Add asterisk to titles if required
                        if (this.options.title && this.layoutNode.type !== 'tab' &&
                            !this.options.notitle && this.options.required &&
                            !this.options.title.includes('*')) {
                            this.options.title += ' <strong class="text-danger">*</strong>';
                        }
                        // Set miscelaneous styles and settings for each control type
                        switch (this.layoutNode.type) {
                            // Checkbox controls
                            case 'checkbox':
                            case 'checkboxes':
                                this.widgetOptions.htmlClass = addClasses(this.widgetOptions.htmlClass, 'checkbox');
                                break;
                            case 'checkboxes-inline':
                                this.widgetOptions.htmlClass = addClasses(this.widgetOptions.htmlClass, 'checkbox');
                                this.widgetOptions.itemLabelHtmlClass = addClasses(this.widgetOptions.itemLabelHtmlClass, 'checkbox-inline');
                                break;
                            // Radio controls
                            case 'radio':
                            case 'radios':
                                this.widgetOptions.htmlClass = addClasses(this.widgetOptions.htmlClass, 'radio');
                                break;
                            case 'radios-inline':
                                this.widgetOptions.htmlClass = addClasses(this.widgetOptions.htmlClass, 'radio');
                                this.widgetOptions.itemLabelHtmlClass = addClasses(this.widgetOptions.itemLabelHtmlClass, 'radio-inline');
                                break;
                            // Button sets - checkboxbuttons and radiobuttons
                            case 'checkboxbuttons':
                            case 'radiobuttons':
                                this.widgetOptions.htmlClass = addClasses(this.widgetOptions.htmlClass, 'btn-group');
                                this.widgetOptions.itemLabelHtmlClass = addClasses(this.widgetOptions.itemLabelHtmlClass, 'btn');
                                this.widgetOptions.itemLabelHtmlClass = addClasses(this.widgetOptions.itemLabelHtmlClass, this.options.style || 'btn-default');
                                this.widgetOptions.fieldHtmlClass = addClasses(this.widgetOptions.fieldHtmlClass, 'sr-only');
                                break;
                            // Single button controls
                            case 'button':
                            case 'submit':
                                this.widgetOptions.fieldHtmlClass = addClasses(this.widgetOptions.fieldHtmlClass, 'btn');
                                this.widgetOptions.fieldHtmlClass = addClasses(this.widgetOptions.fieldHtmlClass, this.options.style || 'btn-info');
                                break;
                            // Containers - arrays and fieldsets
                            case 'array':
                            case 'fieldset':
                            case 'section':
                            case 'conditional':
                            case 'advancedfieldset':
                            case 'authfieldset':
                            case 'selectfieldset':
                            case 'optionfieldset':
                                this.options.messageLocation = 'top';
                                break;
                            case 'tabarray':
                            case 'tabs':
                                this.widgetOptions.htmlClass = addClasses(this.widgetOptions.htmlClass, 'tab-content');
                                this.widgetOptions.fieldHtmlClass = addClasses(this.widgetOptions.fieldHtmlClass, 'tab-pane');
                                this.widgetOptions.labelHtmlClass = addClasses(this.widgetOptions.labelHtmlClass, 'nav nav-tabs');
                                break;
                            // 'Add' buttons - references
                            case '$ref':
                                this.widgetOptions.fieldHtmlClass = addClasses(this.widgetOptions.fieldHtmlClass, 'btn pull-right');
                                this.widgetOptions.fieldHtmlClass = addClasses(this.widgetOptions.fieldHtmlClass, this.options.style || 'btn-default');
                                this.options.icon = 'glyphicon glyphicon-plus';
                                break;
                            // Default - including regular inputs
                            default:
                                this.widgetOptions.fieldHtmlClass = addClasses(this.widgetOptions.fieldHtmlClass, 'form-control');
                        }
                        if (this.formControl) {
                            this.updateHelpBlock(this.formControl.status);
                            this.formControl.statusChanges.subscribe(function (status) { return _this_1.updateHelpBlock(status); });
                            if (this.options.debug) {
                                var vars = [];
                                this.debugOutput = Object(lodash_es_map__WEBPACK_IMPORTED_MODULE_5__["default"])(vars, function (thisVar) { return JSON.stringify(thisVar, null, 2); }).join('\n');
                            }
                        }
                        this.frameworkInitialized = true;
                    }
                };
                Bootstrap3FrameworkComponent.prototype.updateHelpBlock = function (status) {
                    this.options.helpBlock = status === 'INVALID' &&
                        this.options.enableErrorState && this.formControl.errors &&
                        (this.formControl.dirty || this.options.feedbackOnRender) ?
                        this.jsf.formatErrors(this.formControl.errors, this.options.validationMessages) :
                        this.options.description || this.options.help || null;
                };
                Bootstrap3FrameworkComponent.prototype.setTitle = function () {
                    switch (this.layoutNode.type) {
                        case 'button':
                        case 'checkbox':
                        case 'section':
                        case 'help':
                        case 'msg':
                        case 'submit':
                        case 'message':
                        case 'tabarray':
                        case 'tabs':
                        case '$ref':
                            return null;
                        case 'advancedfieldset':
                            this.widgetOptions.expandable = true;
                            this.widgetOptions.title = 'Advanced options';
                            return null;
                        case 'authfieldset':
                            this.widgetOptions.expandable = true;
                            this.widgetOptions.title = 'Authentication settings';
                            return null;
                        case 'fieldset':
                            this.widgetOptions.title = this.options.title;
                            return null;
                        default:
                            this.widgetOptions.title = null;
                            return this.jsf.setItemTitle(this);
                    }
                };
                Bootstrap3FrameworkComponent.prototype.removeItem = function () {
                    this.jsf.removeItem(this);
                };
                return Bootstrap3FrameworkComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], Bootstrap3FrameworkComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], Bootstrap3FrameworkComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], Bootstrap3FrameworkComponent.prototype, "dataIndex", void 0);
            Bootstrap3FrameworkComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'bootstrap-3-framework',
                    template: "\n    <div\n      [class]=\"options?.htmlClass || ''\"\n      [class.has-feedback]=\"options?.feedback && options?.isInputWidget &&\n        (formControl?.dirty || options?.feedbackOnRender)\"\n      [class.has-error]=\"options?.enableErrorState && formControl?.errors &&\n        (formControl?.dirty || options?.feedbackOnRender)\"\n      [class.has-success]=\"options?.enableSuccessState && !formControl?.errors &&\n        (formControl?.dirty || options?.feedbackOnRender)\">\n\n      <button *ngIf=\"showRemoveButton\"\n        class=\"close pull-right\"\n        type=\"button\"\n        (click)=\"removeItem()\">\n        <span aria-hidden=\"true\">&times;</span>\n        <span class=\"sr-only\">Close</span>\n      </button>\n      <div *ngIf=\"options?.messageLocation === 'top'\">\n          <p *ngIf=\"options?.helpBlock\"\n          class=\"help-block\"\n          [innerHTML]=\"options?.helpBlock\"></p>\n      </div>\n\n      <label *ngIf=\"options?.title && layoutNode?.type !== 'tab'\"\n        [attr.for]=\"'control' + layoutNode?._id\"\n        [class]=\"options?.labelHtmlClass || ''\"\n        [class.sr-only]=\"options?.notitle\"\n        [innerHTML]=\"options?.title\"></label>\n      <p *ngIf=\"layoutNode?.type === 'submit' && jsf?.formOptions?.fieldsRequired\">\n        <strong class=\"text-danger\">*</strong> = required fields\n      </p>\n      <div [class.input-group]=\"options?.fieldAddonLeft || options?.fieldAddonRight\">\n        <span *ngIf=\"options?.fieldAddonLeft\"\n          class=\"input-group-addon\"\n          [innerHTML]=\"options?.fieldAddonLeft\"></span>\n\n        <select-widget-widget\n          [layoutNode]=\"widgetLayoutNode\"\n          [dataIndex]=\"dataIndex\"\n          [layoutIndex]=\"layoutIndex\"></select-widget-widget>\n\n        <span *ngIf=\"options?.fieldAddonRight\"\n          class=\"input-group-addon\"\n          [innerHTML]=\"options?.fieldAddonRight\"></span>\n      </div>\n\n      <span *ngIf=\"options?.feedback && options?.isInputWidget &&\n          !options?.fieldAddonRight && !layoutNode.arrayItem &&\n          (formControl?.dirty || options?.feedbackOnRender)\"\n        [class.glyphicon-ok]=\"options?.enableSuccessState && !formControl?.errors\"\n        [class.glyphicon-remove]=\"options?.enableErrorState && formControl?.errors\"\n        aria-hidden=\"true\"\n        class=\"form-control-feedback glyphicon\"></span>\n      <div *ngIf=\"options?.messageLocation !== 'top'\">\n        <p *ngIf=\"options?.helpBlock\"\n          class=\"help-block\"\n          [innerHTML]=\"options?.helpBlock\"></p>\n      </div>\n    </div>\n\n    <div *ngIf=\"debug && debugOutput\">debug: <pre>{{debugOutput}}</pre></div>\n  ",
                    styles: ["\n    :host /deep/ .list-group-item .form-control-feedback { top: 40; }\n    :host /deep/ .checkbox,\n    :host /deep/ .radio { margin-top: 0; margin-bottom: 0; }\n    :host /deep/ .checkbox-inline,\n    :host /deep/ .checkbox-inline + .checkbox-inline,\n    :host /deep/ .checkbox-inline + .radio-inline,\n    :host /deep/ .radio-inline,\n    :host /deep/ .radio-inline + .radio-inline,\n    :host /deep/ .radio-inline + .checkbox-inline { margin-left: 0; margin-right: 10px; }\n    :host /deep/ .checkbox-inline:last-child,\n    :host /deep/ .radio-inline:last-child { margin-right: 0; }\n    :host /deep/ .ng-invalid.ng-touched { border: 1px solid #f44336; }\n  "]
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_8__["ChangeDetectorRef"],
                    JsonSchemaFormService])
            ], Bootstrap3FrameworkComponent);
            // Bootstrap 3 Framework
            // https://github.com/valor-software/ng2-bootstrap
            var Bootstrap3Framework = /** @class */ (function (_super) {
                __extends(Bootstrap3Framework, _super);
                // Bootstrap 3 Framework
                // https://github.com/valor-software/ng2-bootstrap
                function Bootstrap3Framework() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.name = 'bootstrap-3';
                    _this_1.framework = Bootstrap3FrameworkComponent;
                    _this_1.stylesheets = [
                        '//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css',
                        '//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css',
                    ];
                    _this_1.scripts = [
                        '//ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js',
                        '//ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js',
                        '//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js',
                    ];
                    return _this_1;
                }
                return Bootstrap3Framework;
            }(Framework));
            Bootstrap3Framework = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Injectable"])()
            ], Bootstrap3Framework);
            var Bootstrap3FrameworkModule = /** @class */ (function () {
                function Bootstrap3FrameworkModule() {
                }
                return Bootstrap3FrameworkModule;
            }());
            Bootstrap3FrameworkModule = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["NgModule"])({
                    imports: [JsonSchemaFormModule, _angular_common__WEBPACK_IMPORTED_MODULE_13__["CommonModule"], WidgetLibraryModule],
                    declarations: [Bootstrap3FrameworkComponent],
                    exports: [JsonSchemaFormModule, Bootstrap3FrameworkComponent],
                    providers: [JsonSchemaFormService, FrameworkLibraryService, WidgetLibraryService,
                        { provide: Framework, useClass: Bootstrap3Framework, multi: true }
                    ],
                    entryComponents: [Bootstrap3FrameworkComponent]
                })
            ], Bootstrap3FrameworkModule);
            /**
             * Bootstrap 4 framework for Angular JSON Schema Form.
             *
             */
            var Bootstrap4FrameworkComponent = /** @class */ (function () {
                function Bootstrap4FrameworkComponent(changeDetector, jsf) {
                    this.changeDetector = changeDetector;
                    this.jsf = jsf;
                    this.frameworkInitialized = false;
                    this.formControl = null;
                    this.debugOutput = '';
                    this.debug = '';
                    this.parentArray = null;
                    this.isOrderable = false;
                }
                Object.defineProperty(Bootstrap4FrameworkComponent.prototype, "showRemoveButton", {
                    get: function () {
                        if (!this.options.removable || this.options.readonly ||
                            this.layoutNode.type === '$ref') {
                            return false;
                        }
                        if (this.layoutNode.recursiveReference) {
                            return true;
                        }
                        if (!this.layoutNode.arrayItem || !this.parentArray) {
                            return false;
                        }
                        // If array length <= minItems, don't allow removing any items
                        return this.parentArray.items.length - 1 <= this.parentArray.options.minItems ? false :
                            // For removable list items, allow removing any item
                            this.layoutNode.arrayItemType === 'list' ? true :
                                // For removable tuple items, only allow removing last item in list
                                this.layoutIndex[this.layoutIndex.length - 1] === this.parentArray.items.length - 2;
                    },
                    enumerable: true,
                    configurable: true
                });
                Bootstrap4FrameworkComponent.prototype.ngOnInit = function () {
                    this.initializeFramework();
                    if (this.layoutNode.arrayItem && this.layoutNode.type !== '$ref') {
                        this.parentArray = this.jsf.getParentNode(this);
                        if (this.parentArray) {
                            this.isOrderable = this.layoutNode.arrayItemType === 'list' &&
                                !this.options.readonly && this.parentArray.options.orderable;
                        }
                    }
                };
                Bootstrap4FrameworkComponent.prototype.ngOnChanges = function () {
                    if (!this.frameworkInitialized) {
                        this.initializeFramework();
                    }
                };
                Bootstrap4FrameworkComponent.prototype.initializeFramework = function () {
                    var _this_1 = this;
                    if (this.layoutNode) {
                        this.options = Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(this.layoutNode.options);
                        this.widgetLayoutNode = Object.assign({}, this.layoutNode, { options: Object(lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_1__["default"])(this.layoutNode.options) });
                        this.widgetOptions = this.widgetLayoutNode.options;
                        this.formControl = this.jsf.getFormControl(this);
                        this.options.isInputWidget = inArray(this.layoutNode.type, [
                            'button', 'checkbox', 'checkboxes-inline', 'checkboxes', 'color',
                            'date', 'datetime-local', 'datetime', 'email', 'file', 'hidden',
                            'image', 'integer', 'month', 'number', 'password', 'radio',
                            'radiobuttons', 'radios-inline', 'radios', 'range', 'reset', 'search',
                            'select', 'submit', 'tel', 'text', 'textarea', 'time', 'url', 'week'
                        ]);
                        this.options.title = this.setTitle();
                        this.options.htmlClass =
                            addClasses(this.options.htmlClass, 'schema-form-' + this.layoutNode.type);
                        this.options.htmlClass =
                            this.layoutNode.type === 'array' ?
                                addClasses(this.options.htmlClass, 'list-group') :
                                this.layoutNode.arrayItem && this.layoutNode.type !== '$ref' ?
                                    addClasses(this.options.htmlClass, 'list-group-item') :
                                    addClasses(this.options.htmlClass, 'form-group');
                        this.widgetOptions.htmlClass = '';
                        this.options.labelHtmlClass =
                            addClasses(this.options.labelHtmlClass, 'control-label');
                        this.widgetOptions.activeClass =
                            addClasses(this.widgetOptions.activeClass, 'active');
                        this.options.fieldAddonLeft =
                            this.options.fieldAddonLeft || this.options.prepend;
                        this.options.fieldAddonRight =
                            this.options.fieldAddonRight || this.options.append;
                        // Add asterisk to titles if required
                        if (this.options.title && this.layoutNode.type !== 'tab' &&
                            !this.options.notitle && this.options.required &&
                            !this.options.title.includes('*')) {
                            this.options.title += ' <strong class="text-danger">*</strong>';
                        }
                        // Set miscelaneous styles and settings for each control type
                        switch (this.layoutNode.type) {
                            // Checkbox controls
                            case 'checkbox':
                            case 'checkboxes':
                                this.widgetOptions.htmlClass = addClasses(this.widgetOptions.htmlClass, 'checkbox');
                                break;
                            case 'checkboxes-inline':
                                this.widgetOptions.htmlClass = addClasses(this.widgetOptions.htmlClass, 'checkbox');
                                this.widgetOptions.itemLabelHtmlClass = addClasses(this.widgetOptions.itemLabelHtmlClass, 'checkbox-inline');
                                break;
                            // Radio controls
                            case 'radio':
                            case 'radios':
                                this.widgetOptions.htmlClass = addClasses(this.widgetOptions.htmlClass, 'radio');
                                break;
                            case 'radios-inline':
                                this.widgetOptions.htmlClass = addClasses(this.widgetOptions.htmlClass, 'radio');
                                this.widgetOptions.itemLabelHtmlClass = addClasses(this.widgetOptions.itemLabelHtmlClass, 'radio-inline');
                                break;
                            // Button sets - checkboxbuttons and radiobuttons
                            case 'checkboxbuttons':
                            case 'radiobuttons':
                                this.widgetOptions.htmlClass = addClasses(this.widgetOptions.htmlClass, 'btn-group');
                                this.widgetOptions.itemLabelHtmlClass = addClasses(this.widgetOptions.itemLabelHtmlClass, 'btn');
                                this.widgetOptions.itemLabelHtmlClass = addClasses(this.widgetOptions.itemLabelHtmlClass, this.options.style || 'btn-default');
                                this.widgetOptions.fieldHtmlClass = addClasses(this.widgetOptions.fieldHtmlClass, 'sr-only');
                                break;
                            // Single button controls
                            case 'button':
                            case 'submit':
                                this.widgetOptions.fieldHtmlClass = addClasses(this.widgetOptions.fieldHtmlClass, 'btn');
                                this.widgetOptions.fieldHtmlClass = addClasses(this.widgetOptions.fieldHtmlClass, this.options.style || 'btn-info');
                                break;
                            // Containers - arrays and fieldsets
                            case 'array':
                            case 'fieldset':
                            case 'section':
                            case 'conditional':
                            case 'advancedfieldset':
                            case 'authfieldset':
                            case 'selectfieldset':
                            case 'optionfieldset':
                                this.options.messageLocation = 'top';
                                break;
                            case 'tabarray':
                            case 'tabs':
                                this.widgetOptions.htmlClass = addClasses(this.widgetOptions.htmlClass, 'tab-content');
                                this.widgetOptions.fieldHtmlClass = addClasses(this.widgetOptions.fieldHtmlClass, 'tab-pane');
                                this.widgetOptions.labelHtmlClass = addClasses(this.widgetOptions.labelHtmlClass, 'nav nav-tabs');
                                break;
                            // 'Add' buttons - references
                            case '$ref':
                                this.widgetOptions.fieldHtmlClass = addClasses(this.widgetOptions.fieldHtmlClass, 'btn pull-right');
                                this.widgetOptions.fieldHtmlClass = addClasses(this.widgetOptions.fieldHtmlClass, this.options.style || 'btn-default');
                                this.options.icon = 'glyphicon glyphicon-plus';
                                break;
                            // Default - including regular inputs
                            default:
                                this.widgetOptions.fieldHtmlClass = addClasses(this.widgetOptions.fieldHtmlClass, 'form-control');
                        }
                        if (this.formControl) {
                            this.updateHelpBlock(this.formControl.status);
                            this.formControl.statusChanges.subscribe(function (status) { return _this_1.updateHelpBlock(status); });
                            if (this.options.debug) {
                                var vars = [];
                                this.debugOutput = Object(lodash_es_map__WEBPACK_IMPORTED_MODULE_5__["default"])(vars, function (thisVar) { return JSON.stringify(thisVar, null, 2); }).join('\n');
                            }
                        }
                        this.frameworkInitialized = true;
                    }
                };
                Bootstrap4FrameworkComponent.prototype.updateHelpBlock = function (status) {
                    this.options.helpBlock = status === 'INVALID' &&
                        this.options.enableErrorState && this.formControl.errors &&
                        (this.formControl.dirty || this.options.feedbackOnRender) ?
                        this.jsf.formatErrors(this.formControl.errors, this.options.validationMessages) :
                        this.options.description || this.options.help || null;
                };
                Bootstrap4FrameworkComponent.prototype.setTitle = function () {
                    switch (this.layoutNode.type) {
                        case 'button':
                        case 'checkbox':
                        case 'section':
                        case 'help':
                        case 'msg':
                        case 'submit':
                        case 'message':
                        case 'tabarray':
                        case 'tabs':
                        case '$ref':
                            return null;
                        case 'advancedfieldset':
                            this.widgetOptions.expandable = true;
                            this.widgetOptions.title = 'Advanced options';
                            return null;
                        case 'authfieldset':
                            this.widgetOptions.expandable = true;
                            this.widgetOptions.title = 'Authentication settings';
                            return null;
                        case 'fieldset':
                            this.widgetOptions.title = this.options.title;
                            return null;
                        default:
                            this.widgetOptions.title = null;
                            return this.jsf.setItemTitle(this);
                    }
                };
                Bootstrap4FrameworkComponent.prototype.removeItem = function () {
                    this.jsf.removeItem(this);
                };
                return Bootstrap4FrameworkComponent;
            }());
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)
            ], Bootstrap4FrameworkComponent.prototype, "layoutNode", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], Bootstrap4FrameworkComponent.prototype, "layoutIndex", void 0);
            Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"])(),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)
            ], Bootstrap4FrameworkComponent.prototype, "dataIndex", void 0);
            Bootstrap4FrameworkComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"])({
                    // tslint:disable-next-line:component-selector
                    selector: 'bootstrap-4-framework',
                    template: "\n    <div\n      [class]=\"options?.htmlClass || ''\"\n      [class.has-feedback]=\"options?.feedback && options?.isInputWidget &&\n        (formControl?.dirty || options?.feedbackOnRender)\"\n      [class.has-error]=\"options?.enableErrorState && formControl?.errors &&\n        (formControl?.dirty || options?.feedbackOnRender)\"\n      [class.has-success]=\"options?.enableSuccessState && !formControl?.errors &&\n        (formControl?.dirty || options?.feedbackOnRender)\">\n\n      <button *ngIf=\"showRemoveButton\"\n        class=\"close pull-right\"\n        type=\"button\"\n        (click)=\"removeItem()\">\n        <span aria-hidden=\"true\">&times;</span>\n        <span class=\"sr-only\">Close</span>\n      </button>\n      <div *ngIf=\"options?.messageLocation === 'top'\">\n        <p *ngIf=\"options?.helpBlock\"\n          class=\"help-block\"\n          [innerHTML]=\"options?.helpBlock\"></p>\n      </div>\n\n      <label *ngIf=\"options?.title && layoutNode?.type !== 'tab'\"\n        [attr.for]=\"'control' + layoutNode?._id\"\n        [class]=\"options?.labelHtmlClass || ''\"\n        [class.sr-only]=\"options?.notitle\"\n        [innerHTML]=\"options?.title\"></label>\n      <p *ngIf=\"layoutNode?.type === 'submit' && jsf?.formOptions?.fieldsRequired\">\n        <strong class=\"text-danger\">*</strong> = required fields\n      </p>\n      <div [class.input-group]=\"options?.fieldAddonLeft || options?.fieldAddonRight\">\n        <span *ngIf=\"options?.fieldAddonLeft\"\n          class=\"input-group-addon\"\n          [innerHTML]=\"options?.fieldAddonLeft\"></span>\n\n        <select-widget-widget\n          [layoutNode]=\"widgetLayoutNode\"\n          [dataIndex]=\"dataIndex\"\n          [layoutIndex]=\"layoutIndex\"></select-widget-widget>\n\n        <span *ngIf=\"options?.fieldAddonRight\"\n          class=\"input-group-addon\"\n          [innerHTML]=\"options?.fieldAddonRight\"></span>\n      </div>\n\n      <span *ngIf=\"options?.feedback && options?.isInputWidget &&\n          !options?.fieldAddonRight && !layoutNode.arrayItem &&\n          (formControl?.dirty || options?.feedbackOnRender)\"\n        [class.glyphicon-ok]=\"options?.enableSuccessState && !formControl?.errors\"\n        [class.glyphicon-remove]=\"options?.enableErrorState && formControl?.errors\"\n        aria-hidden=\"true\"\n        class=\"form-control-feedback glyphicon\"></span>\n      <div *ngIf=\"options?.messageLocation !== 'top'\">\n        <p *ngIf=\"options?.helpBlock\"\n          class=\"help-block\"\n          [innerHTML]=\"options?.helpBlock\"></p>\n      </div>\n    </div>\n\n    <div *ngIf=\"debug && debugOutput\">debug: <pre>{{debugOutput}}</pre></div>\n  ",
                    styles: ["\n    :host /deep/ .list-group-item .form-control-feedback { top: 40px; }\n    :host /deep/ .checkbox,\n    :host /deep/ .radio { margin-top: 0; margin-bottom: 0; }\n    :host /deep/ .checkbox-inline,\n    :host /deep/ .checkbox-inline + .checkbox-inline,\n    :host /deep/ .checkbox-inline + .radio-inline,\n    :host /deep/ .radio-inline,\n    :host /deep/ .radio-inline + .radio-inline,\n    :host /deep/ .radio-inline + .checkbox-inline { margin-left: 0; margin-right: 10px; }\n    :host /deep/ .checkbox-inline:last-child,\n    :host /deep/ .radio-inline:last-child { margin-right: 0; }\n    :host /deep/ .ng-invalid.ng-touched { border: 1px solid #f44336; }\n  "]
                }),
                Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_8__["ChangeDetectorRef"],
                    JsonSchemaFormService])
            ], Bootstrap4FrameworkComponent);
            // Bootstrap 4 Framework
            // https://github.com/ng-bootstrap/ng-bootstrap
            var Bootstrap4Framework = /** @class */ (function (_super) {
                __extends(Bootstrap4Framework, _super);
                // Bootstrap 4 Framework
                // https://github.com/ng-bootstrap/ng-bootstrap
                function Bootstrap4Framework() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.name = 'bootstrap-4';
                    _this_1.framework = Bootstrap4FrameworkComponent;
                    _this_1.stylesheets = [
                        '//stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css'
                    ];
                    _this_1.scripts = [
                        '//code.jquery.com/jquery-3.3.1.slim.min.js',
                        '//cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js',
                        '//stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js',
                    ];
                    return _this_1;
                }
                return Bootstrap4Framework;
            }(Framework));
            Bootstrap4Framework = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["Injectable"])()
            ], Bootstrap4Framework);
            var Bootstrap4FrameworkModule = /** @class */ (function () {
                function Bootstrap4FrameworkModule() {
                }
                return Bootstrap4FrameworkModule;
            }());
            Bootstrap4FrameworkModule = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["NgModule"])({
                    imports: [JsonSchemaFormModule, _angular_common__WEBPACK_IMPORTED_MODULE_13__["CommonModule"], WidgetLibraryModule],
                    declarations: [Bootstrap4FrameworkComponent],
                    exports: [JsonSchemaFormModule, Bootstrap4FrameworkComponent],
                    providers: [JsonSchemaFormService, FrameworkLibraryService, WidgetLibraryService,
                        { provide: Framework, useClass: Bootstrap4Framework, multi: true }
                    ],
                    entryComponents: [Bootstrap4FrameworkComponent]
                })
            ], Bootstrap4FrameworkModule);
            //# sourceMappingURL=angular6-json-schema-form.js.map
            /***/ 
        }),
        /***/ "./node_modules/fast-deep-equal/index.js": 
        /*!***********************************************!*\
          !*** ./node_modules/fast-deep-equal/index.js ***!
          \***********************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var isArray = Array.isArray;
            var keyList = Object.keys;
            var hasProp = Object.prototype.hasOwnProperty;
            module.exports = function equal(a, b) {
                if (a === b)
                    return true;
                if (a && b && typeof a == 'object' && typeof b == 'object') {
                    var arrA = isArray(a), arrB = isArray(b), i, length, key;
                    if (arrA && arrB) {
                        length = a.length;
                        if (length != b.length)
                            return false;
                        for (i = length; i-- !== 0;)
                            if (!equal(a[i], b[i]))
                                return false;
                        return true;
                    }
                    if (arrA != arrB)
                        return false;
                    var dateA = a instanceof Date, dateB = b instanceof Date;
                    if (dateA != dateB)
                        return false;
                    if (dateA && dateB)
                        return a.getTime() == b.getTime();
                    var regexpA = a instanceof RegExp, regexpB = b instanceof RegExp;
                    if (regexpA != regexpB)
                        return false;
                    if (regexpA && regexpB)
                        return a.toString() == b.toString();
                    var keys = keyList(a);
                    length = keys.length;
                    if (length !== keyList(b).length)
                        return false;
                    for (i = length; i-- !== 0;)
                        if (!hasProp.call(b, keys[i]))
                            return false;
                    for (i = length; i-- !== 0;) {
                        key = keys[i];
                        if (!equal(a[key], b[key]))
                            return false;
                    }
                    return true;
                }
                return a !== a && b !== b;
            };
            /***/ 
        }),
        /***/ "./node_modules/fast-json-stable-stringify/index.js": 
        /*!**********************************************************!*\
          !*** ./node_modules/fast-json-stable-stringify/index.js ***!
          \**********************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            module.exports = function (data, opts) {
                if (!opts)
                    opts = {};
                if (typeof opts === 'function')
                    opts = { cmp: opts };
                var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
                var cmp = opts.cmp && (function (f) {
                    return function (node) {
                        return function (a, b) {
                            var aobj = { key: a, value: node[a] };
                            var bobj = { key: b, value: node[b] };
                            return f(aobj, bobj);
                        };
                    };
                })(opts.cmp);
                var seen = [];
                return (function stringify(node) {
                    if (node && node.toJSON && typeof node.toJSON === 'function') {
                        node = node.toJSON();
                    }
                    if (node === undefined)
                        return;
                    if (typeof node == 'number')
                        return isFinite(node) ? '' + node : 'null';
                    if (typeof node !== 'object')
                        return JSON.stringify(node);
                    var i, out;
                    if (Array.isArray(node)) {
                        out = '[';
                        for (i = 0; i < node.length; i++) {
                            if (i)
                                out += ',';
                            out += stringify(node[i]) || 'null';
                        }
                        return out + ']';
                    }
                    if (node === null)
                        return 'null';
                    if (seen.indexOf(node) !== -1) {
                        if (cycles)
                            return JSON.stringify('__cycle__');
                        throw new TypeError('Converting circular structure to JSON');
                    }
                    var seenIndex = seen.push(node) - 1;
                    var keys = Object.keys(node).sort(cmp && cmp(node));
                    out = '';
                    for (i = 0; i < keys.length; i++) {
                        var key = keys[i];
                        var value = stringify(node[key]);
                        if (!value)
                            continue;
                        if (out)
                            out += ',';
                        out += JSON.stringify(key) + ':' + value;
                    }
                    seen.splice(seenIndex, 1);
                    return '{' + out + '}';
                })(data);
            };
            /***/ 
        }),
        /***/ "./node_modules/generate-schema/src/index.js": 
        /*!***************************************************!*\
          !*** ./node_modules/generate-schema/src/index.js ***!
          \***************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            exports.generic = __webpack_require__(/*! ./schemas/generic */ "./node_modules/generate-schema/src/schemas/generic.js");
            exports.mongoose = __webpack_require__(/*! ./schemas/mongoose */ "./node_modules/generate-schema/src/schemas/mongoose.js");
            exports.bigquery = __webpack_require__(/*! ./schemas/bigquery */ "./node_modules/generate-schema/src/schemas/bigquery.js");
            exports.mysql = __webpack_require__(/*! ./schemas/mysql */ "./node_modules/generate-schema/src/schemas/mysql.js");
            exports.json = __webpack_require__(/*! ./schemas/json */ "./node_modules/generate-schema/src/schemas/json.js");
            exports.clickhouse = __webpack_require__(/*! ./schemas/clickhouse */ "./node_modules/generate-schema/src/schemas/clickhouse.js");
            /***/ 
        }),
        /***/ "./node_modules/generate-schema/src/schemas/bigquery.js": 
        /*!**************************************************************!*\
          !*** ./node_modules/generate-schema/src/schemas/bigquery.js ***!
          \**************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            var utils = __webpack_require__(/*! ../utils */ "./node_modules/generate-schema/src/utils.js");
            function getPropertyMode(value) {
                return Array.isArray(value) ? 'REPEATED' : 'NULLABLE';
            }
            function getPropertyType(value) {
                if (Array.isArray(value)) {
                    return getPropertyType(value[0]);
                }
                if (value instanceof Date)
                    return 'TIMESTAMP';
                if (typeof value === 'object')
                    return 'RECORD';
                if (typeof value === 'boolean')
                    return 'BOOLEAN';
                if (typeof value === 'string') {
                    if (utils.isDateString(value))
                        return 'DATE';
                    if (utils.isTimestamp(value))
                        return 'TIMESTAMP';
                }
                if (!isNaN(value)) {
                    return Number.isInteger(parseFloat(value)) ? 'INTEGER' : 'FLOAT';
                }
                return 'STRING';
            }
            function processFields(data) {
                return Object.keys(data).map(function (key) {
                    var value = data[key];
                    var entry = {
                        name: key,
                        type: getPropertyType(data[key]),
                        mode: getPropertyMode(data[key])
                    };
                    if (entry.type === 'RECORD') {
                        entry.fields = processFields((entry.mode === 'REPEATED') ? value[0] : value);
                    }
                    return entry;
                });
            }
            module.exports = function Process(data) {
                return processFields(data);
            };
            /***/ 
        }),
        /***/ "./node_modules/generate-schema/src/schemas/clickhouse.js": 
        /*!****************************************************************!*\
          !*** ./node_modules/generate-schema/src/schemas/clickhouse.js ***!
          \****************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            // Modules
            var Type = __webpack_require__(/*! type-of-is */ "./node_modules/type-of-is/index.js");
            var Utils = __webpack_require__(/*! ../utils */ "./node_modules/generate-schema/src/utils.js");
            // Type Mapping for Clickhouse
            var types = {
                boolean: 'String',
                string: 'String',
                number: 'Int32',
                date: 'Date',
                timestamp: 'DateTime',
                object: 'Nested',
                'regexp': 'String',
                'undefined': 'String',
                'null': 'String'
            };
            var lang = {
                create: function (name) {
                    return ['CREATE TABLE ', name, ' ('].join('');
                },
                close: function (id, dateField) {
                    if (!dateField)
                        return [') ENGINE = Memory;'].join('');
                    else
                        return [') ENGINE = MergeTree(', dateField, ', (', id, ', ', dateField, '), 8192);'].join('');
                },
                id: function (name, value) {
                    return ['  ', name, '_id ', value, ','].join('');
                },
                property: function (name, value) {
                    return ['  ', name, ' ', value, ','].join('');
                },
            };
            function processObject(obj, options, dateField) {
                var name = options.tableName;
                var parent = options.parentTableName;
                var parentId = options.parentTableId;
                var parentIdType = options.parentTableIdType;
                // In-memory storage
                var keys = Object.keys(obj);
                var output = [];
                var tables = [];
                // Table variables
                var id = null;
                var idType = 'string';
                // Initialize Table
                output.push(lang.create(name));
                if (parent) {
                    output.push(lang.property(parent + '_' + parentId, types[parentIdType]));
                }
                // Obtain ID
                var nkey;
                for (var i = 0; i < keys.length; i++) {
                    if (keys[i].toLowerCase() === 'id' || keys[i].toLowerCase().indexOf('_id') > -1) {
                        nkey = keys[i];
                        obj[nkey] = obj[keys[i]];
                        keys[i] = nkey;
                        id = keys[i];
                        idType = typeof obj[keys[i]];
                    }
                }
                if (!id) {
                    id = 'id';
                    idType = parentIdType || idType;
                    output.push(lang.property(id, types[idType]));
                }
                // Create table properties
                var key, value, type;
                for (var i = 0; i < keys.length; i++) {
                    key = keys[i];
                    value = obj[key];
                    type = value instanceof Date
                        ? 'date'
                        : Type.string(value).toLowerCase();
                    if (type == 'date' && !dateField) {
                        var dateField = key;
                    }
                    if (type !== 'undefined') {
                        type = Utils.isTimestamp(value) ? 'timestamp' : type;
                    }
                    if (type === 'function') {
                        continue;
                    }
                    // pojo
                    if (type === 'object' && !value.length) {
                        tables.push('');
                        tables.push(processObject(value, {
                            parentTableName: name,
                            parentTableId: id,
                            parentTableIdType: idType,
                            tableName: name + '_' + key
                        }).join(''));
                        continue;
                    }
                    // array
                    if (type === 'object' || type === 'array') {
                        if (typeof value[0] === 'object') {
                            tables.push('');
                            tables.push(processObject(value[0], {
                                parentTableName: name,
                                parentTableId: id,
                                parentTableIdType: idType,
                                tableName: name + '_' + key
                            }).join(''));
                            continue;
                        }
                        tables.push('');
                        tables.push(processObject({
                            value: typeof value[0]
                        }, {
                            parentTableName: name,
                            parentTableId: id,
                            parentTableIdType: idType,
                            tableName: name + '_' + key
                        }).join(''));
                        continue;
                    }
                    output.push(lang.property(key, types[type]));
                }
                output[output.length - 1] = Utils.arrayLastItem(output)
                    .substr(0, Utils.arrayLastItem(output).length - 1);
                output.push(lang.close(id, dateField));
                return output.concat(tables);
            }
            module.exports = function Process(tableName, object, dateField) {
                if (typeof tableName !== 'string') {
                    object = tableName;
                    tableName = 'generic';
                }
                if (!dateField)
                    dateField = null;
                return processObject(object, {
                    tableName: tableName
                }, dateField).join('');
            };
            /***/ 
        }),
        /***/ "./node_modules/generate-schema/src/schemas/generic.js": 
        /*!*************************************************************!*\
          !*** ./node_modules/generate-schema/src/schemas/generic.js ***!
          \*************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            // Modules
            var Type = __webpack_require__(/*! type-of-is */ "./node_modules/type-of-is/index.js");
            var Utils = __webpack_require__(/*! ../utils */ "./node_modules/generate-schema/src/utils.js");
            module.exports = function Process(object, output) {
                output = output || {};
                for (var key in object) {
                    var value = object[key];
                    var type = Type.string(value).toLowerCase();
                    if (type === 'undefined') {
                        type = 'null';
                    }
                    if (type === 'string' && Utils.isDate(value)) {
                        type = 'date';
                    }
                    if (type !== 'object') {
                        output[key] = {
                            type: type
                        };
                    }
                    else {
                        output[key] = Process(object[key]);
                        output[key].type = type;
                    }
                }
                return output;
            };
            /***/ 
        }),
        /***/ "./node_modules/generate-schema/src/schemas/json.js": 
        /*!**********************************************************!*\
          !*** ./node_modules/generate-schema/src/schemas/json.js ***!
          \**********************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            // Modules
            var Type = __webpack_require__(/*! type-of-is */ "./node_modules/type-of-is/index.js");
            // Constants
            var DRAFT = 'http://json-schema.org/draft-04/schema#';
            function getPropertyFormat(value) {
                var type = Type.string(value).toLowerCase();
                if (type === 'date')
                    return 'date-time';
                return null;
            }
            function getPropertyType(value) {
                var type = Type.string(value).toLowerCase();
                if (type === 'date')
                    return 'string';
                if (type === 'regexp')
                    return 'string';
                if (type === 'function')
                    return 'string';
                return type;
            }
            function getUniqueKeys(a, b, c) {
                a = Object.keys(a);
                b = Object.keys(b);
                c = c || [];
                var value;
                var cIndex;
                var aIndex;
                for (var keyIndex = 0, keyLength = b.length; keyIndex < keyLength; keyIndex++) {
                    value = b[keyIndex];
                    aIndex = a.indexOf(value);
                    cIndex = c.indexOf(value);
                    if (aIndex === -1) {
                        if (cIndex !== -1) {
                            // Value is optional, it doesn't exist in A but exists in B(n)
                            c.splice(cIndex, 1);
                        }
                    }
                    else if (cIndex === -1) {
                        // Value is required, it exists in both B and A, and is not yet present in C
                        c.push(value);
                    }
                }
                return c;
            }
            function processArray(array, output, nested) {
                var format;
                var oneOf;
                var type;
                if (nested && output) {
                    output = { items: output };
                }
                else {
                    output = output || {};
                    output.type = getPropertyType(array);
                    output.items = output.items || {};
                    type = output.items.type || null;
                }
                // Determine whether each item is different
                for (var arrIndex = 0, arrLength = array.length; arrIndex < arrLength; arrIndex++) {
                    var elementType = getPropertyType(array[arrIndex]);
                    var elementFormat = getPropertyFormat(array[arrIndex]);
                    if (type && elementType !== type) {
                        output.items.oneOf = [];
                        oneOf = true;
                        break;
                    }
                    else {
                        type = elementType;
                        format = elementFormat;
                    }
                }
                // Setup type otherwise
                if (!oneOf && type) {
                    output.items.type = type;
                    if (format) {
                        output.items.format = format;
                    }
                }
                else if (oneOf && type !== 'object') {
                    output.items = {
                        oneOf: [{ type: type }],
                        required: output.items.required
                    };
                }
                // Process each item depending
                if (typeof output.items.oneOf !== 'undefined' || type === 'object') {
                    for (var itemIndex = 0, itemLength = array.length; itemIndex < itemLength; itemIndex++) {
                        var value = array[itemIndex];
                        var itemType = getPropertyType(value);
                        var itemFormat = getPropertyFormat(value);
                        var arrayItem;
                        if (itemType === 'object') {
                            if (output.items.properties) {
                                output.items.required = getUniqueKeys(output.items.properties, value, output.items.required);
                            }
                            arrayItem = processObject(value, oneOf ? {} : output.items.properties, true);
                        }
                        else if (itemType === 'array') {
                            arrayItem = processArray(value, oneOf ? {} : output.items.properties, true);
                        }
                        else {
                            arrayItem = {};
                            arrayItem.type = itemType;
                            if (itemFormat) {
                                arrayItem.format = itemFormat;
                            }
                        }
                        if (oneOf) {
                            var childType = Type.string(value).toLowerCase();
                            var tempObj = {};
                            if (!arrayItem.type && childType === 'object') {
                                tempObj.properties = arrayItem;
                                tempObj.type = 'object';
                                arrayItem = tempObj;
                            }
                            output.items.oneOf.push(arrayItem);
                        }
                        else {
                            if (output.items.type !== 'object') {
                                continue;
                            }
                            output.items.properties = arrayItem;
                        }
                    }
                }
                return nested ? output.items : output;
            }
            function processObject(object, output, nested) {
                if (nested && output) {
                    output = { properties: output };
                }
                else {
                    output = output || {};
                    output.type = getPropertyType(object);
                    output.properties = output.properties || {};
                }
                for (var key in object) {
                    var value = object[key];
                    var type = getPropertyType(value);
                    var format = getPropertyFormat(value);
                    type = type === 'undefined' ? 'null' : type;
                    if (type === 'object') {
                        output.properties[key] = processObject(value, output.properties[key]);
                        continue;
                    }
                    if (type === 'array') {
                        output.properties[key] = processArray(value, output.properties[key]);
                        continue;
                    }
                    if (output.properties[key]) {
                        var entry = output.properties[key];
                        var hasTypeArray = Array.isArray(entry.type);
                        // When an array already exists, we check the existing
                        // type array to see if it contains our current property
                        // type, if not, we add it to the array and continue
                        if (hasTypeArray && entry.type.indexOf(type) < 0) {
                            entry.type.push(type);
                        }
                        // When multiple fields of differing types occur,
                        // json schema states that the field must specify the
                        // primitive types the field allows in array format.
                        if (!hasTypeArray && entry.type !== type) {
                            entry.type = [entry.type, type];
                        }
                        continue;
                    }
                    output.properties[key] = {};
                    output.properties[key].type = type;
                    if (format) {
                        output.properties[key].format = format;
                    }
                }
                return nested ? output.properties : output;
            }
            module.exports = function Process(title, object) {
                var processOutput;
                var output = {
                    $schema: DRAFT
                };
                // Determine title exists
                if (typeof title !== 'string') {
                    object = title;
                    title = undefined;
                }
                else {
                    output.title = title;
                }
                // Set initial object type
                output.type = Type.string(object).toLowerCase();
                // Process object
                if (output.type === 'object') {
                    processOutput = processObject(object);
                    output.type = processOutput.type;
                    output.properties = processOutput.properties;
                }
                if (output.type === 'array') {
                    processOutput = processArray(object);
                    output.type = processOutput.type;
                    output.items = processOutput.items;
                    if (output.title) {
                        output.items.title = output.title;
                        output.title += ' Set';
                    }
                }
                // Output
                return output;
            };
            /***/ 
        }),
        /***/ "./node_modules/generate-schema/src/schemas/mongoose.js": 
        /*!**************************************************************!*\
          !*** ./node_modules/generate-schema/src/schemas/mongoose.js ***!
          \**************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            // Modules
            var Type = __webpack_require__(/*! type-of-is */ "./node_modules/type-of-is/index.js");
            var Utils = __webpack_require__(/*! ../utils */ "./node_modules/generate-schema/src/utils.js");
            function getNativeType(string) {
                switch (string) {
                    case "array":
                        return 'Array';
                    case "buffer":
                        return 'Buffer';
                    case "boolean":
                        return 'Boolean';
                    case "date":
                        return 'Date';
                    case "number":
                        return 'Number';
                    case "string":
                        return 'String';
                    case "objectid":
                        return 'ObjectId';
                    case "null":
                    case "undefined":
                    case "regexp":
                    default:
                        return 'Mixed';
                }
            }
            module.exports = function Process(object, output) {
                var output = output || {};
                for (var key in object) {
                    var value = object[key];
                    var originalType = null;
                    var elementType = null;
                    var type = null;
                    if (value instanceof Buffer) {
                        type = 'buffer';
                    }
                    if (value != null && typeof value.toString !== 'undefined' && value.toString().match(/^[0-9a-fA-F]{24}$/)) {
                        type = 'objectid';
                    }
                    if (!type) {
                        type = Type.string(value).toLowerCase();
                    }
                    if (type === 'string' && Utils.isDate(value)) {
                        type = 'date';
                    }
                    if (type === 'object') {
                        output[key] = Process(object[key]);
                    }
                    else {
                        if (type === 'undefined') {
                            type = 'null';
                        }
                        if (type === 'array' && value.length) {
                            originalType = type;
                            type = undefined;
                            for (var index = 0, length = value.length; index < length; index++) {
                                elementType = Type.string(value[index]).toLowerCase();
                                if (type && elementType !== type) {
                                    type = 'mixed';
                                    break;
                                }
                                else {
                                    type = elementType;
                                }
                            }
                        }
                        if (originalType && originalType === 'array') {
                            output[key] = { type: [getNativeType(type)] };
                        }
                        else {
                            output[key] = { type: getNativeType(type) };
                        }
                    }
                }
                return output;
            };
            /***/ 
        }),
        /***/ "./node_modules/generate-schema/src/schemas/mysql.js": 
        /*!***********************************************************!*\
          !*** ./node_modules/generate-schema/src/schemas/mysql.js ***!
          \***********************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            // Modules
            var Type = __webpack_require__(/*! type-of-is */ "./node_modules/type-of-is/index.js");
            var Utils = __webpack_require__(/*! ../utils */ "./node_modules/generate-schema/src/utils.js");
            // Type Mapping
            var types = {
                boolean: 'BOOLEAN',
                string: 'TEXT',
                number: 'INT',
                date: 'DATE',
                timestamp: 'TIMESTAMP',
                'regexp': 'TEXT',
                'undefined': 'TEXT',
                'null': 'TEXT'
            };
            var lang = {
                create: function (name) {
                    return ['CREATE TABLE ', name, ' ('].join('');
                },
                close: function () {
                    return ');';
                },
                id: function (name, value) {
                    return ['  ', name, '_id ', value, ','].join('');
                },
                property: function (name, value) {
                    return ['  ', name, ' ', value, ','].join('');
                },
                primary: function (id) {
                    return ['  PRIMARY KEY (', id, '),'].join('');
                },
                foreign: function (key1, table, key2) {
                    return ['  FOREIGN KEY (', key1, ') REFERENCES ', table, '(', key2, '),'].join('');
                },
            };
            function processObject(obj, options) {
                var name = options.tableName;
                var parent = options.parentTableName;
                var parentId = options.parentTableId;
                var parentIdType = options.parentTableIdType;
                // In-memory storage
                var keys = Object.keys(obj);
                var output = [];
                var tables = [];
                // Table variables
                var id = null;
                var idType = 'string';
                // Initialize Table
                output.push(lang.create(name));
                if (parent) {
                    output.push(lang.property(parent + '_' + parentId, types[parentIdType]));
                }
                // Obtain ID
                var nkey;
                for (var i = 0; i < keys.length; i++) {
                    if (keys[i].toLowerCase() === 'id' || keys[i].toLowerCase().indexOf('_id') > -1) {
                        nkey = keys[i];
                        obj[nkey] = obj[keys[i]];
                        keys[i] = nkey;
                        id = keys[i];
                        idType = typeof obj[keys[i]];
                    }
                }
                if (!id) {
                    id = 'id';
                    idType = parentIdType || idType;
                    output.push(lang.property(id, types[idType]));
                }
                // Create table properties
                var key, value, type;
                for (var i = 0; i < keys.length; i++) {
                    key = keys[i];
                    value = obj[key];
                    type = value instanceof Date
                        ? 'date'
                        : Type.string(value).toLowerCase();
                    if (type !== 'undefined') {
                        type = Utils.isTimestamp(value) ? 'timestamp' : type;
                    }
                    if (type === 'function') {
                        continue;
                    }
                    // pojo
                    if (type === 'object' && !value.length) {
                        tables.push('');
                        tables.push(processObject(value, {
                            parentTableName: name,
                            parentTableId: id,
                            parentTableIdType: idType,
                            tableName: name + '_' + key
                        }).join('\n'));
                        continue;
                    }
                    // array
                    if (type === 'object' || type === 'array') {
                        if (typeof value[0] === 'object') {
                            tables.push('');
                            tables.push(processObject(value[0], {
                                parentTableName: name,
                                parentTableId: id,
                                parentTableIdType: idType,
                                tableName: name + '_' + key
                            }).join('\n'));
                            continue;
                        }
                        tables.push('');
                        tables.push(processObject({
                            value: typeof value[0]
                        }, {
                            parentTableName: name,
                            parentTableId: id,
                            parentTableIdType: idType,
                            tableName: name + '_' + key
                        }).join('\n'));
                        continue;
                    }
                    output.push(lang.property(key, types[type]));
                }
                // Handle table keys
                output.push(lang.primary(id));
                if (parent) {
                    output.push(lang.foreign(parent + '_id', parent, parentId));
                }
                output[output.length - 1] = Utils.arrayLastItem(output)
                    .substr(0, Utils.arrayLastItem(output).length - 1);
                output.push(lang.close());
                return output.concat(tables);
            }
            module.exports = function Process(tableName, object) {
                if (typeof tableName !== 'string') {
                    object = tableName;
                    tableName = 'generic';
                }
                return processObject(object, {
                    tableName: tableName
                }).join('\n');
            };
            /***/ 
        }),
        /***/ "./node_modules/generate-schema/src/utils.js": 
        /*!***************************************************!*\
          !*** ./node_modules/generate-schema/src/utils.js ***!
          \***************************************************/
        /*! no static exports found */
        /***/ (function (module, exports) {
            var DATE_REGEXP = /\d{4}-\d{2}-\d{2}/;
            exports.isNumber = function (value) {
                return (typeof value === 'number' || Object.prototype.toString.call(value) === '[object Number]');
            };
            exports.isDate = function (date) {
                return ((new Date(date).toString() !== 'Invalid Date' && !isNaN(new Date(date))));
            };
            exports.isTimestamp = function (string) {
                return string.length > 18 && !isNaN((new Date(string)).getTime());
            };
            exports.isDateString = function (string) {
                return string.match(DATE_REGEXP);
            };
            exports.arrayLastItem = function (arr) {
                return arr[arr.length - 1];
            };
            /***/ 
        }),
        /***/ "./node_modules/json-schema-traverse/index.js": 
        /*!****************************************************!*\
          !*** ./node_modules/json-schema-traverse/index.js ***!
          \****************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var traverse = module.exports = function (schema, opts, cb) {
                // Legacy support for v0.3.1 and earlier.
                if (typeof opts == 'function') {
                    cb = opts;
                    opts = {};
                }
                cb = opts.cb || cb;
                var pre = (typeof cb == 'function') ? cb : cb.pre || function () { };
                var post = cb.post || function () { };
                _traverse(opts, pre, post, schema, '', schema);
            };
            traverse.keywords = {
                additionalItems: true,
                items: true,
                contains: true,
                additionalProperties: true,
                propertyNames: true,
                not: true
            };
            traverse.arrayKeywords = {
                items: true,
                allOf: true,
                anyOf: true,
                oneOf: true
            };
            traverse.propsKeywords = {
                definitions: true,
                properties: true,
                patternProperties: true,
                dependencies: true
            };
            traverse.skipKeywords = {
                default: true,
                enum: true,
                const: true,
                required: true,
                maximum: true,
                minimum: true,
                exclusiveMaximum: true,
                exclusiveMinimum: true,
                multipleOf: true,
                maxLength: true,
                minLength: true,
                pattern: true,
                format: true,
                maxItems: true,
                minItems: true,
                uniqueItems: true,
                maxProperties: true,
                minProperties: true
            };
            function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
                if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
                    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
                    for (var key in schema) {
                        var sch = schema[key];
                        if (Array.isArray(sch)) {
                            if (key in traverse.arrayKeywords) {
                                for (var i = 0; i < sch.length; i++)
                                    _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
                            }
                        }
                        else if (key in traverse.propsKeywords) {
                            if (sch && typeof sch == 'object') {
                                for (var prop in sch)
                                    _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
                            }
                        }
                        else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {
                            _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
                        }
                    }
                    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
                }
            }
            function escapeJsonPtr(str) {
                return str.replace(/~/g, '~0').replace(/\//g, '~1');
            }
            /***/ 
        }),
        /***/ "./node_modules/jsontoxml/jsontoxml.js": 
        /*!*********************************************!*\
          !*** ./node_modules/jsontoxml/jsontoxml.js ***!
          \*********************************************/
        /*! no static exports found */
        /***/ (function (module, exports) {
            //copyright Ryan Day 2010 <http://ryanday.org>, Joscha Feth 2013 <http://www.feth.com> [MIT Licensed]
            var element_start_char = "a-zA-Z_\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FFF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD";
            var element_non_start_char = "\-.0-9\u00B7\u0300-\u036F\u203F\u2040";
            var element_replace = new RegExp("^([^" + element_start_char + "])|^((x|X)(m|M)(l|L))|([^" + element_start_char + element_non_start_char + "])", "g");
            var not_safe_in_xml = /[^\x09\x0A\x0D\x20-\xFF\x85\xA0-\uD7FF\uE000-\uFDCF\uFDE0-\uFFFD]/gm;
            var process_to_xml = function (node_data, options) {
                var makeNode = function (name, content, attributes, level, hasSubNodes) {
                    var indent_value = options.indent !== undefined ? options.indent : "\t";
                    var indent = options.prettyPrint ? '\n' + new Array(level).join(indent_value) : '';
                    if (options.removeIllegalNameCharacters) {
                        name = name.replace(element_replace, '_');
                    }
                    var node = [indent, '<', name, (attributes || '')];
                    if (content && content.length > 0 || options.html) {
                        node.push('>');
                        node.push(content);
                        hasSubNodes && node.push(indent);
                        node.push('</');
                        node.push(name);
                        node.push('>');
                    }
                    else {
                        node.push('/>');
                    }
                    return node.join('');
                };
                return (function fn(node_data, node_descriptor, level) {
                    var type = typeof node_data;
                    if ((Array.isArray) ? Array.isArray(node_data) : node_data instanceof Array) {
                        type = 'array';
                    }
                    else if (node_data instanceof Date) {
                        type = 'date';
                    }
                    switch (type) {
                        //if value is an array create child nodes from values
                        case 'array':
                            var ret = [];
                            node_data.map(function (v) {
                                ret.push(fn(v, 1, level + 1));
                                //entries that are values of an array are the only ones that can be special node descriptors
                            });
                            options.prettyPrint && ret.push('\n');
                            return ret.join('');
                            break;
                        case 'date':
                            // cast dates to ISO 8601 date (soap likes it)
                            return node_data.toJSON ? node_data.toJSON() : node_data + '';
                            break;
                        case 'object':
                            if (node_descriptor == 1 && node_data.name) {
                                var content = [], attributes = [];
                                if (node_data.attrs) {
                                    if (typeof node_data.attrs != 'object') {
                                        // attrs is a string, etc. - just use it as an attribute
                                        attributes.push(' ');
                                        attributes.push(node_data.attrs);
                                    }
                                    else {
                                        for (var key in node_data.attrs) {
                                            var value = node_data.attrs[key];
                                            attributes.push(' ');
                                            attributes.push(key);
                                            attributes.push('="');
                                            attributes.push(options.escape ? esc(value) : value);
                                            attributes.push('"');
                                        }
                                    }
                                }
                                //later attributes can be added here
                                if (typeof node_data.value != 'undefined') {
                                    var c = '' + node_data.value;
                                    content.push(options.escape && !node_data.noescape ? esc(c) : c);
                                }
                                else if (typeof node_data.text != 'undefined') {
                                    var c = '' + node_data.text;
                                    content.push(options.escape && !node_data.noescape ? esc(c) : c);
                                }
                                if (node_data.children) {
                                    content.push(fn(node_data.children, 0, level + 1));
                                }
                                return makeNode(node_data.name, content.join(''), attributes.join(''), level, !!node_data.children);
                            }
                            else {
                                var nodes = [];
                                for (var name in node_data) {
                                    nodes.push(makeNode(name, fn(node_data[name], 0, level + 1), null, level + 1));
                                }
                                options.prettyPrint && nodes.length > 0 && nodes.push('\n');
                                return nodes.join('');
                            }
                            break;
                        case 'function':
                            return node_data();
                            break;
                        default:
                            return options.escape ? esc(node_data) : '' + node_data;
                    }
                }(node_data, 0, 0));
            };
            var xml_header = function (standalone) {
                var ret = ['<?xml version="1.0" encoding="utf-8"'];
                if (standalone) {
                    ret.push(' standalone="yes"');
                }
                ret.push('?>');
                return ret.join('');
            };
            module.exports = function (obj, options) {
                var Buf = typeof Buffer !== 'undefined' ? Buffer : function Buffer() { };
                if (typeof obj == 'string' || obj instanceof Buf) {
                    try {
                        obj = JSON.parse(obj.toString());
                    }
                    catch (e) {
                        return false;
                    }
                }
                var xmlheader = '';
                var docType = '';
                if (options) {
                    if (typeof options == 'object') {
                        // our config is an object
                        if (options.xmlHeader) {
                            // the user wants an xml header
                            xmlheader = xml_header(!!options.xmlHeader.standalone);
                        }
                        if (typeof options.docType != 'undefined') {
                            docType = '<!DOCTYPE ' + options.docType + '>';
                        }
                    }
                    else {
                        // our config is a boolean value, so just add xml header
                        xmlheader = xml_header();
                    }
                }
                options = options || {};
                var ret = [
                    xmlheader,
                    (options.prettyPrint && docType ? '\n' : ''),
                    docType,
                    process_to_xml(obj, options)
                ];
                return ret.join('');
            };
            module.exports.json_to_xml =
                module.exports.obj_to_xml = module.exports;
            module.exports.escape = esc;
            function esc(str) {
                return ('' + str).replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/'/g, '&apos;')
                    .replace(/"/g, '&quot;')
                    .replace(not_safe_in_xml, '');
            }
            module.exports.cdata = cdata;
            function cdata(str) {
                if (str)
                    return "<![CDATA[" + str.replace(/]]>/g, '') + ']]>';
                return "<![CDATA[]]>";
            }
            ;
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_DataView.js": 
        /*!*********************************************!*\
          !*** ./node_modules/lodash-es/_DataView.js ***!
          \*********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _getNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getNative.js */ "./node_modules/lodash-es/_getNative.js");
            /* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");
            /* Built-in method references that are verified to be native. */
            var DataView = Object(_getNative_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_root_js__WEBPACK_IMPORTED_MODULE_1__["default"], 'DataView');
            /* harmony default export */ __webpack_exports__["default"] = (DataView);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_Hash.js": 
        /*!*****************************************!*\
          !*** ./node_modules/lodash-es/_Hash.js ***!
          \*****************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _hashClear_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_hashClear.js */ "./node_modules/lodash-es/_hashClear.js");
            /* harmony import */ var _hashDelete_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_hashDelete.js */ "./node_modules/lodash-es/_hashDelete.js");
            /* harmony import */ var _hashGet_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_hashGet.js */ "./node_modules/lodash-es/_hashGet.js");
            /* harmony import */ var _hashHas_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_hashHas.js */ "./node_modules/lodash-es/_hashHas.js");
            /* harmony import */ var _hashSet_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_hashSet.js */ "./node_modules/lodash-es/_hashSet.js");
            /**
             * Creates a hash object.
             *
             * @private
             * @constructor
             * @param {Array} [entries] The key-value pairs to cache.
             */
            function Hash(entries) {
                var index = -1, length = entries == null ? 0 : entries.length;
                this.clear();
                while (++index < length) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                }
            }
            // Add methods to `Hash`.
            Hash.prototype.clear = _hashClear_js__WEBPACK_IMPORTED_MODULE_0__["default"];
            Hash.prototype['delete'] = _hashDelete_js__WEBPACK_IMPORTED_MODULE_1__["default"];
            Hash.prototype.get = _hashGet_js__WEBPACK_IMPORTED_MODULE_2__["default"];
            Hash.prototype.has = _hashHas_js__WEBPACK_IMPORTED_MODULE_3__["default"];
            Hash.prototype.set = _hashSet_js__WEBPACK_IMPORTED_MODULE_4__["default"];
            /* harmony default export */ __webpack_exports__["default"] = (Hash);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_ListCache.js": 
        /*!**********************************************!*\
          !*** ./node_modules/lodash-es/_ListCache.js ***!
          \**********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _listCacheClear_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_listCacheClear.js */ "./node_modules/lodash-es/_listCacheClear.js");
            /* harmony import */ var _listCacheDelete_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_listCacheDelete.js */ "./node_modules/lodash-es/_listCacheDelete.js");
            /* harmony import */ var _listCacheGet_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_listCacheGet.js */ "./node_modules/lodash-es/_listCacheGet.js");
            /* harmony import */ var _listCacheHas_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_listCacheHas.js */ "./node_modules/lodash-es/_listCacheHas.js");
            /* harmony import */ var _listCacheSet_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_listCacheSet.js */ "./node_modules/lodash-es/_listCacheSet.js");
            /**
             * Creates an list cache object.
             *
             * @private
             * @constructor
             * @param {Array} [entries] The key-value pairs to cache.
             */
            function ListCache(entries) {
                var index = -1, length = entries == null ? 0 : entries.length;
                this.clear();
                while (++index < length) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                }
            }
            // Add methods to `ListCache`.
            ListCache.prototype.clear = _listCacheClear_js__WEBPACK_IMPORTED_MODULE_0__["default"];
            ListCache.prototype['delete'] = _listCacheDelete_js__WEBPACK_IMPORTED_MODULE_1__["default"];
            ListCache.prototype.get = _listCacheGet_js__WEBPACK_IMPORTED_MODULE_2__["default"];
            ListCache.prototype.has = _listCacheHas_js__WEBPACK_IMPORTED_MODULE_3__["default"];
            ListCache.prototype.set = _listCacheSet_js__WEBPACK_IMPORTED_MODULE_4__["default"];
            /* harmony default export */ __webpack_exports__["default"] = (ListCache);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_Map.js": 
        /*!****************************************!*\
          !*** ./node_modules/lodash-es/_Map.js ***!
          \****************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _getNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getNative.js */ "./node_modules/lodash-es/_getNative.js");
            /* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");
            /* Built-in method references that are verified to be native. */
            var Map = Object(_getNative_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_root_js__WEBPACK_IMPORTED_MODULE_1__["default"], 'Map');
            /* harmony default export */ __webpack_exports__["default"] = (Map);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_MapCache.js": 
        /*!*********************************************!*\
          !*** ./node_modules/lodash-es/_MapCache.js ***!
          \*********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _mapCacheClear_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_mapCacheClear.js */ "./node_modules/lodash-es/_mapCacheClear.js");
            /* harmony import */ var _mapCacheDelete_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_mapCacheDelete.js */ "./node_modules/lodash-es/_mapCacheDelete.js");
            /* harmony import */ var _mapCacheGet_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_mapCacheGet.js */ "./node_modules/lodash-es/_mapCacheGet.js");
            /* harmony import */ var _mapCacheHas_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_mapCacheHas.js */ "./node_modules/lodash-es/_mapCacheHas.js");
            /* harmony import */ var _mapCacheSet_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_mapCacheSet.js */ "./node_modules/lodash-es/_mapCacheSet.js");
            /**
             * Creates a map cache object to store key-value pairs.
             *
             * @private
             * @constructor
             * @param {Array} [entries] The key-value pairs to cache.
             */
            function MapCache(entries) {
                var index = -1, length = entries == null ? 0 : entries.length;
                this.clear();
                while (++index < length) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                }
            }
            // Add methods to `MapCache`.
            MapCache.prototype.clear = _mapCacheClear_js__WEBPACK_IMPORTED_MODULE_0__["default"];
            MapCache.prototype['delete'] = _mapCacheDelete_js__WEBPACK_IMPORTED_MODULE_1__["default"];
            MapCache.prototype.get = _mapCacheGet_js__WEBPACK_IMPORTED_MODULE_2__["default"];
            MapCache.prototype.has = _mapCacheHas_js__WEBPACK_IMPORTED_MODULE_3__["default"];
            MapCache.prototype.set = _mapCacheSet_js__WEBPACK_IMPORTED_MODULE_4__["default"];
            /* harmony default export */ __webpack_exports__["default"] = (MapCache);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_Promise.js": 
        /*!********************************************!*\
          !*** ./node_modules/lodash-es/_Promise.js ***!
          \********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _getNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getNative.js */ "./node_modules/lodash-es/_getNative.js");
            /* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");
            /* Built-in method references that are verified to be native. */
            var Promise = Object(_getNative_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_root_js__WEBPACK_IMPORTED_MODULE_1__["default"], 'Promise');
            /* harmony default export */ __webpack_exports__["default"] = (Promise);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_Set.js": 
        /*!****************************************!*\
          !*** ./node_modules/lodash-es/_Set.js ***!
          \****************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _getNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getNative.js */ "./node_modules/lodash-es/_getNative.js");
            /* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");
            /* Built-in method references that are verified to be native. */
            var Set = Object(_getNative_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_root_js__WEBPACK_IMPORTED_MODULE_1__["default"], 'Set');
            /* harmony default export */ __webpack_exports__["default"] = (Set);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_SetCache.js": 
        /*!*********************************************!*\
          !*** ./node_modules/lodash-es/_SetCache.js ***!
          \*********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _MapCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_MapCache.js */ "./node_modules/lodash-es/_MapCache.js");
            /* harmony import */ var _setCacheAdd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_setCacheAdd.js */ "./node_modules/lodash-es/_setCacheAdd.js");
            /* harmony import */ var _setCacheHas_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_setCacheHas.js */ "./node_modules/lodash-es/_setCacheHas.js");
            /**
             *
             * Creates an array cache object to store unique values.
             *
             * @private
             * @constructor
             * @param {Array} [values] The values to cache.
             */
            function SetCache(values) {
                var index = -1, length = values == null ? 0 : values.length;
                this.__data__ = new _MapCache_js__WEBPACK_IMPORTED_MODULE_0__["default"];
                while (++index < length) {
                    this.add(values[index]);
                }
            }
            // Add methods to `SetCache`.
            SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd_js__WEBPACK_IMPORTED_MODULE_1__["default"];
            SetCache.prototype.has = _setCacheHas_js__WEBPACK_IMPORTED_MODULE_2__["default"];
            /* harmony default export */ __webpack_exports__["default"] = (SetCache);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_Stack.js": 
        /*!******************************************!*\
          !*** ./node_modules/lodash-es/_Stack.js ***!
          \******************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _ListCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_ListCache.js */ "./node_modules/lodash-es/_ListCache.js");
            /* harmony import */ var _stackClear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_stackClear.js */ "./node_modules/lodash-es/_stackClear.js");
            /* harmony import */ var _stackDelete_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_stackDelete.js */ "./node_modules/lodash-es/_stackDelete.js");
            /* harmony import */ var _stackGet_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_stackGet.js */ "./node_modules/lodash-es/_stackGet.js");
            /* harmony import */ var _stackHas_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_stackHas.js */ "./node_modules/lodash-es/_stackHas.js");
            /* harmony import */ var _stackSet_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_stackSet.js */ "./node_modules/lodash-es/_stackSet.js");
            /**
             * Creates a stack cache object to store key-value pairs.
             *
             * @private
             * @constructor
             * @param {Array} [entries] The key-value pairs to cache.
             */
            function Stack(entries) {
                var data = this.__data__ = new _ListCache_js__WEBPACK_IMPORTED_MODULE_0__["default"](entries);
                this.size = data.size;
            }
            // Add methods to `Stack`.
            Stack.prototype.clear = _stackClear_js__WEBPACK_IMPORTED_MODULE_1__["default"];
            Stack.prototype['delete'] = _stackDelete_js__WEBPACK_IMPORTED_MODULE_2__["default"];
            Stack.prototype.get = _stackGet_js__WEBPACK_IMPORTED_MODULE_3__["default"];
            Stack.prototype.has = _stackHas_js__WEBPACK_IMPORTED_MODULE_4__["default"];
            Stack.prototype.set = _stackSet_js__WEBPACK_IMPORTED_MODULE_5__["default"];
            /* harmony default export */ __webpack_exports__["default"] = (Stack);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_Symbol.js": 
        /*!*******************************************!*\
          !*** ./node_modules/lodash-es/_Symbol.js ***!
          \*******************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");
            /** Built-in value references. */
            var Symbol = _root_js__WEBPACK_IMPORTED_MODULE_0__["default"].Symbol;
            /* harmony default export */ __webpack_exports__["default"] = (Symbol);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_Uint8Array.js": 
        /*!***********************************************!*\
          !*** ./node_modules/lodash-es/_Uint8Array.js ***!
          \***********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");
            /** Built-in value references. */
            var Uint8Array = _root_js__WEBPACK_IMPORTED_MODULE_0__["default"].Uint8Array;
            /* harmony default export */ __webpack_exports__["default"] = (Uint8Array);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_WeakMap.js": 
        /*!********************************************!*\
          !*** ./node_modules/lodash-es/_WeakMap.js ***!
          \********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _getNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getNative.js */ "./node_modules/lodash-es/_getNative.js");
            /* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");
            /* Built-in method references that are verified to be native. */
            var WeakMap = Object(_getNative_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_root_js__WEBPACK_IMPORTED_MODULE_1__["default"], 'WeakMap');
            /* harmony default export */ __webpack_exports__["default"] = (WeakMap);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_arrayEach.js": 
        /*!**********************************************!*\
          !*** ./node_modules/lodash-es/_arrayEach.js ***!
          \**********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * A specialized version of `_.forEach` for arrays without support for
             * iteratee shorthands.
             *
             * @private
             * @param {Array} [array] The array to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @returns {Array} Returns `array`.
             */
            function arrayEach(array, iteratee) {
                var index = -1, length = array == null ? 0 : array.length;
                while (++index < length) {
                    if (iteratee(array[index], index, array) === false) {
                        break;
                    }
                }
                return array;
            }
            /* harmony default export */ __webpack_exports__["default"] = (arrayEach);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_arrayFilter.js": 
        /*!************************************************!*\
          !*** ./node_modules/lodash-es/_arrayFilter.js ***!
          \************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * A specialized version of `_.filter` for arrays without support for
             * iteratee shorthands.
             *
             * @private
             * @param {Array} [array] The array to iterate over.
             * @param {Function} predicate The function invoked per iteration.
             * @returns {Array} Returns the new filtered array.
             */
            function arrayFilter(array, predicate) {
                var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
                while (++index < length) {
                    var value = array[index];
                    if (predicate(value, index, array)) {
                        result[resIndex++] = value;
                    }
                }
                return result;
            }
            /* harmony default export */ __webpack_exports__["default"] = (arrayFilter);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_arrayLikeKeys.js": 
        /*!**************************************************!*\
          !*** ./node_modules/lodash-es/_arrayLikeKeys.js ***!
          \**************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _baseTimes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseTimes.js */ "./node_modules/lodash-es/_baseTimes.js");
            /* harmony import */ var _isArguments_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArguments.js */ "./node_modules/lodash-es/isArguments.js");
            /* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js");
            /* harmony import */ var _isBuffer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isBuffer.js */ "./node_modules/lodash-es/isBuffer.js");
            /* harmony import */ var _isIndex_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_isIndex.js */ "./node_modules/lodash-es/_isIndex.js");
            /* harmony import */ var _isTypedArray_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isTypedArray.js */ "./node_modules/lodash-es/isTypedArray.js");
            /** Used for built-in method references. */
            var objectProto = Object.prototype;
            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty;
            /**
             * Creates an array of the enumerable property names of the array-like `value`.
             *
             * @private
             * @param {*} value The value to query.
             * @param {boolean} inherited Specify returning inherited property names.
             * @returns {Array} Returns the array of property names.
             */
            function arrayLikeKeys(value, inherited) {
                var isArr = Object(_isArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value), isArg = !isArr && Object(_isArguments_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value), isBuff = !isArr && !isArg && Object(_isBuffer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value), isType = !isArr && !isArg && !isBuff && Object(_isTypedArray_js__WEBPACK_IMPORTED_MODULE_5__["default"])(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? Object(_baseTimes_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value.length, String) : [], length = result.length;
                for (var key in value) {
                    if ((inherited || hasOwnProperty.call(value, key)) &&
                        !(skipIndexes && (
                        // Safari 9 has enumerable `arguments.length` in strict mode.
                        key == 'length' ||
                            // Node.js 0.10 has enumerable non-index properties on buffers.
                            (isBuff && (key == 'offset' || key == 'parent')) ||
                            // PhantomJS 2 has enumerable non-index properties on typed arrays.
                            (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
                            // Skip index properties.
                            Object(_isIndex_js__WEBPACK_IMPORTED_MODULE_4__["default"])(key, length)))) {
                        result.push(key);
                    }
                }
                return result;
            }
            /* harmony default export */ __webpack_exports__["default"] = (arrayLikeKeys);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_arrayMap.js": 
        /*!*********************************************!*\
          !*** ./node_modules/lodash-es/_arrayMap.js ***!
          \*********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * A specialized version of `_.map` for arrays without support for iteratee
             * shorthands.
             *
             * @private
             * @param {Array} [array] The array to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @returns {Array} Returns the new mapped array.
             */
            function arrayMap(array, iteratee) {
                var index = -1, length = array == null ? 0 : array.length, result = Array(length);
                while (++index < length) {
                    result[index] = iteratee(array[index], index, array);
                }
                return result;
            }
            /* harmony default export */ __webpack_exports__["default"] = (arrayMap);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_arrayPush.js": 
        /*!**********************************************!*\
          !*** ./node_modules/lodash-es/_arrayPush.js ***!
          \**********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * Appends the elements of `values` to `array`.
             *
             * @private
             * @param {Array} array The array to modify.
             * @param {Array} values The values to append.
             * @returns {Array} Returns `array`.
             */
            function arrayPush(array, values) {
                var index = -1, length = values.length, offset = array.length;
                while (++index < length) {
                    array[offset + index] = values[index];
                }
                return array;
            }
            /* harmony default export */ __webpack_exports__["default"] = (arrayPush);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_arraySome.js": 
        /*!**********************************************!*\
          !*** ./node_modules/lodash-es/_arraySome.js ***!
          \**********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * A specialized version of `_.some` for arrays without support for iteratee
             * shorthands.
             *
             * @private
             * @param {Array} [array] The array to iterate over.
             * @param {Function} predicate The function invoked per iteration.
             * @returns {boolean} Returns `true` if any element passes the predicate check,
             *  else `false`.
             */
            function arraySome(array, predicate) {
                var index = -1, length = array == null ? 0 : array.length;
                while (++index < length) {
                    if (predicate(array[index], index, array)) {
                        return true;
                    }
                }
                return false;
            }
            /* harmony default export */ __webpack_exports__["default"] = (arraySome);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_assignValue.js": 
        /*!************************************************!*\
          !*** ./node_modules/lodash-es/_assignValue.js ***!
          \************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _baseAssignValue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseAssignValue.js */ "./node_modules/lodash-es/_baseAssignValue.js");
            /* harmony import */ var _eq_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./eq.js */ "./node_modules/lodash-es/eq.js");
            /** Used for built-in method references. */
            var objectProto = Object.prototype;
            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty;
            /**
             * Assigns `value` to `key` of `object` if the existing value is not equivalent
             * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
             * for equality comparisons.
             *
             * @private
             * @param {Object} object The object to modify.
             * @param {string} key The key of the property to assign.
             * @param {*} value The value to assign.
             */
            function assignValue(object, key, value) {
                var objValue = object[key];
                if (!(hasOwnProperty.call(object, key) && Object(_eq_js__WEBPACK_IMPORTED_MODULE_1__["default"])(objValue, value)) ||
                    (value === undefined && !(key in object))) {
                    Object(_baseAssignValue_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, key, value);
                }
            }
            /* harmony default export */ __webpack_exports__["default"] = (assignValue);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_assocIndexOf.js": 
        /*!*************************************************!*\
          !*** ./node_modules/lodash-es/_assocIndexOf.js ***!
          \*************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _eq_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eq.js */ "./node_modules/lodash-es/eq.js");
            /**
             * Gets the index at which the `key` is found in `array` of key-value pairs.
             *
             * @private
             * @param {Array} array The array to inspect.
             * @param {*} key The key to search for.
             * @returns {number} Returns the index of the matched value, else `-1`.
             */
            function assocIndexOf(array, key) {
                var length = array.length;
                while (length--) {
                    if (Object(_eq_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array[length][0], key)) {
                        return length;
                    }
                }
                return -1;
            }
            /* harmony default export */ __webpack_exports__["default"] = (assocIndexOf);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseAssign.js": 
        /*!***********************************************!*\
          !*** ./node_modules/lodash-es/_baseAssign.js ***!
          \***********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _copyObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_copyObject.js */ "./node_modules/lodash-es/_copyObject.js");
            /* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ "./node_modules/lodash-es/keys.js");
            /**
             * The base implementation of `_.assign` without support for multiple sources
             * or `customizer` functions.
             *
             * @private
             * @param {Object} object The destination object.
             * @param {Object} source The source object.
             * @returns {Object} Returns `object`.
             */
            function baseAssign(object, source) {
                return object && Object(_copyObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(source, Object(_keys_js__WEBPACK_IMPORTED_MODULE_1__["default"])(source), object);
            }
            /* harmony default export */ __webpack_exports__["default"] = (baseAssign);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseAssignIn.js": 
        /*!*************************************************!*\
          !*** ./node_modules/lodash-es/_baseAssignIn.js ***!
          \*************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _copyObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_copyObject.js */ "./node_modules/lodash-es/_copyObject.js");
            /* harmony import */ var _keysIn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keysIn.js */ "./node_modules/lodash-es/keysIn.js");
            /**
             * The base implementation of `_.assignIn` without support for multiple sources
             * or `customizer` functions.
             *
             * @private
             * @param {Object} object The destination object.
             * @param {Object} source The source object.
             * @returns {Object} Returns `object`.
             */
            function baseAssignIn(object, source) {
                return object && Object(_copyObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(source, Object(_keysIn_js__WEBPACK_IMPORTED_MODULE_1__["default"])(source), object);
            }
            /* harmony default export */ __webpack_exports__["default"] = (baseAssignIn);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseAssignValue.js": 
        /*!****************************************************!*\
          !*** ./node_modules/lodash-es/_baseAssignValue.js ***!
          \****************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _defineProperty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_defineProperty.js */ "./node_modules/lodash-es/_defineProperty.js");
            /**
             * The base implementation of `assignValue` and `assignMergeValue` without
             * value checks.
             *
             * @private
             * @param {Object} object The object to modify.
             * @param {string} key The key of the property to assign.
             * @param {*} value The value to assign.
             */
            function baseAssignValue(object, key, value) {
                if (key == '__proto__' && _defineProperty_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
                    Object(_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, key, {
                        'configurable': true,
                        'enumerable': true,
                        'value': value,
                        'writable': true
                    });
                }
                else {
                    object[key] = value;
                }
            }
            /* harmony default export */ __webpack_exports__["default"] = (baseAssignValue);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseClone.js": 
        /*!**********************************************!*\
          !*** ./node_modules/lodash-es/_baseClone.js ***!
          \**********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _Stack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Stack.js */ "./node_modules/lodash-es/_Stack.js");
            /* harmony import */ var _arrayEach_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_arrayEach.js */ "./node_modules/lodash-es/_arrayEach.js");
            /* harmony import */ var _assignValue_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_assignValue.js */ "./node_modules/lodash-es/_assignValue.js");
            /* harmony import */ var _baseAssign_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_baseAssign.js */ "./node_modules/lodash-es/_baseAssign.js");
            /* harmony import */ var _baseAssignIn_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_baseAssignIn.js */ "./node_modules/lodash-es/_baseAssignIn.js");
            /* harmony import */ var _cloneBuffer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_cloneBuffer.js */ "./node_modules/lodash-es/_cloneBuffer.js");
            /* harmony import */ var _copyArray_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_copyArray.js */ "./node_modules/lodash-es/_copyArray.js");
            /* harmony import */ var _copySymbols_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./_copySymbols.js */ "./node_modules/lodash-es/_copySymbols.js");
            /* harmony import */ var _copySymbolsIn_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./_copySymbolsIn.js */ "./node_modules/lodash-es/_copySymbolsIn.js");
            /* harmony import */ var _getAllKeys_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./_getAllKeys.js */ "./node_modules/lodash-es/_getAllKeys.js");
            /* harmony import */ var _getAllKeysIn_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./_getAllKeysIn.js */ "./node_modules/lodash-es/_getAllKeysIn.js");
            /* harmony import */ var _getTag_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./_getTag.js */ "./node_modules/lodash-es/_getTag.js");
            /* harmony import */ var _initCloneArray_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./_initCloneArray.js */ "./node_modules/lodash-es/_initCloneArray.js");
            /* harmony import */ var _initCloneByTag_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./_initCloneByTag.js */ "./node_modules/lodash-es/_initCloneByTag.js");
            /* harmony import */ var _initCloneObject_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./_initCloneObject.js */ "./node_modules/lodash-es/_initCloneObject.js");
            /* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js");
            /* harmony import */ var _isBuffer_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./isBuffer.js */ "./node_modules/lodash-es/isBuffer.js");
            /* harmony import */ var _isMap_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./isMap.js */ "./node_modules/lodash-es/isMap.js");
            /* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js");
            /* harmony import */ var _isSet_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./isSet.js */ "./node_modules/lodash-es/isSet.js");
            /* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./keys.js */ "./node_modules/lodash-es/keys.js");
            /** Used to compose bitmasks for cloning. */
            var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
            /** `Object#toString` result references. */
            var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', weakMapTag = '[object WeakMap]';
            var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
            /** Used to identify `toStringTag` values supported by `_.clone`. */
            var cloneableTags = {};
            cloneableTags[argsTag] = cloneableTags[arrayTag] =
                cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
                    cloneableTags[boolTag] = cloneableTags[dateTag] =
                        cloneableTags[float32Tag] = cloneableTags[float64Tag] =
                            cloneableTags[int8Tag] = cloneableTags[int16Tag] =
                                cloneableTags[int32Tag] = cloneableTags[mapTag] =
                                    cloneableTags[numberTag] = cloneableTags[objectTag] =
                                        cloneableTags[regexpTag] = cloneableTags[setTag] =
                                            cloneableTags[stringTag] = cloneableTags[symbolTag] =
                                                cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
                                                    cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
            cloneableTags[errorTag] = cloneableTags[funcTag] =
                cloneableTags[weakMapTag] = false;
            /**
             * The base implementation of `_.clone` and `_.cloneDeep` which tracks
             * traversed objects.
             *
             * @private
             * @param {*} value The value to clone.
             * @param {boolean} bitmask The bitmask flags.
             *  1 - Deep clone
             *  2 - Flatten inherited properties
             *  4 - Clone symbols
             * @param {Function} [customizer] The function to customize cloning.
             * @param {string} [key] The key of `value`.
             * @param {Object} [object] The parent object of `value`.
             * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
             * @returns {*} Returns the cloned value.
             */
            function baseClone(value, bitmask, customizer, key, object, stack) {
                var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
                if (customizer) {
                    result = object ? customizer(value, key, object, stack) : customizer(value);
                }
                if (result !== undefined) {
                    return result;
                }
                if (!Object(_isObject_js__WEBPACK_IMPORTED_MODULE_18__["default"])(value)) {
                    return value;
                }
                var isArr = Object(_isArray_js__WEBPACK_IMPORTED_MODULE_15__["default"])(value);
                if (isArr) {
                    result = Object(_initCloneArray_js__WEBPACK_IMPORTED_MODULE_12__["default"])(value);
                    if (!isDeep) {
                        return Object(_copyArray_js__WEBPACK_IMPORTED_MODULE_6__["default"])(value, result);
                    }
                }
                else {
                    var tag = Object(_getTag_js__WEBPACK_IMPORTED_MODULE_11__["default"])(value), isFunc = tag == funcTag || tag == genTag;
                    if (Object(_isBuffer_js__WEBPACK_IMPORTED_MODULE_16__["default"])(value)) {
                        return Object(_cloneBuffer_js__WEBPACK_IMPORTED_MODULE_5__["default"])(value, isDeep);
                    }
                    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
                        result = (isFlat || isFunc) ? {} : Object(_initCloneObject_js__WEBPACK_IMPORTED_MODULE_14__["default"])(value);
                        if (!isDeep) {
                            return isFlat
                                ? Object(_copySymbolsIn_js__WEBPACK_IMPORTED_MODULE_8__["default"])(value, Object(_baseAssignIn_js__WEBPACK_IMPORTED_MODULE_4__["default"])(result, value))
                                : Object(_copySymbols_js__WEBPACK_IMPORTED_MODULE_7__["default"])(value, Object(_baseAssign_js__WEBPACK_IMPORTED_MODULE_3__["default"])(result, value));
                        }
                    }
                    else {
                        if (!cloneableTags[tag]) {
                            return object ? value : {};
                        }
                        result = Object(_initCloneByTag_js__WEBPACK_IMPORTED_MODULE_13__["default"])(value, tag, isDeep);
                    }
                }
                // Check for circular references and return its corresponding clone.
                stack || (stack = new _Stack_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
                var stacked = stack.get(value);
                if (stacked) {
                    return stacked;
                }
                stack.set(value, result);
                if (Object(_isSet_js__WEBPACK_IMPORTED_MODULE_19__["default"])(value)) {
                    value.forEach(function (subValue) {
                        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
                    });
                }
                else if (Object(_isMap_js__WEBPACK_IMPORTED_MODULE_17__["default"])(value)) {
                    value.forEach(function (subValue, key) {
                        result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
                    });
                }
                var keysFunc = isFull
                    ? (isFlat ? _getAllKeysIn_js__WEBPACK_IMPORTED_MODULE_10__["default"] : _getAllKeys_js__WEBPACK_IMPORTED_MODULE_9__["default"])
                    : (isFlat ? keysIn : _keys_js__WEBPACK_IMPORTED_MODULE_20__["default"]);
                var props = isArr ? undefined : keysFunc(value);
                Object(_arrayEach_js__WEBPACK_IMPORTED_MODULE_1__["default"])(props || value, function (subValue, key) {
                    if (props) {
                        key = subValue;
                        subValue = value[key];
                    }
                    // Recursively populate clone (susceptible to call stack limits).
                    Object(_assignValue_js__WEBPACK_IMPORTED_MODULE_2__["default"])(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
                });
                return result;
            }
            /* harmony default export */ __webpack_exports__["default"] = (baseClone);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseCreate.js": 
        /*!***********************************************!*\
          !*** ./node_modules/lodash-es/_baseCreate.js ***!
          \***********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js");
            /** Built-in value references. */
            var objectCreate = Object.create;
            /**
             * The base implementation of `_.create` without support for assigning
             * properties to the created object.
             *
             * @private
             * @param {Object} proto The object to inherit from.
             * @returns {Object} Returns the new object.
             */
            var baseCreate = (function () {
                function object() { }
                return function (proto) {
                    if (!Object(_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(proto)) {
                        return {};
                    }
                    if (objectCreate) {
                        return objectCreate(proto);
                    }
                    object.prototype = proto;
                    var result = new object;
                    object.prototype = undefined;
                    return result;
                };
            }());
            /* harmony default export */ __webpack_exports__["default"] = (baseCreate);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseEach.js": 
        /*!*********************************************!*\
          !*** ./node_modules/lodash-es/_baseEach.js ***!
          \*********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _baseForOwn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseForOwn.js */ "./node_modules/lodash-es/_baseForOwn.js");
            /* harmony import */ var _createBaseEach_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_createBaseEach.js */ "./node_modules/lodash-es/_createBaseEach.js");
            /**
             * The base implementation of `_.forEach` without support for iteratee shorthands.
             *
             * @private
             * @param {Array|Object} collection The collection to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @returns {Array|Object} Returns `collection`.
             */
            var baseEach = Object(_createBaseEach_js__WEBPACK_IMPORTED_MODULE_1__["default"])(_baseForOwn_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
            /* harmony default export */ __webpack_exports__["default"] = (baseEach);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseFilter.js": 
        /*!***********************************************!*\
          !*** ./node_modules/lodash-es/_baseFilter.js ***!
          \***********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _baseEach_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseEach.js */ "./node_modules/lodash-es/_baseEach.js");
            /**
             * The base implementation of `_.filter` without support for iteratee shorthands.
             *
             * @private
             * @param {Array|Object} collection The collection to iterate over.
             * @param {Function} predicate The function invoked per iteration.
             * @returns {Array} Returns the new filtered array.
             */
            function baseFilter(collection, predicate) {
                var result = [];
                Object(_baseEach_js__WEBPACK_IMPORTED_MODULE_0__["default"])(collection, function (value, index, collection) {
                    if (predicate(value, index, collection)) {
                        result.push(value);
                    }
                });
                return result;
            }
            /* harmony default export */ __webpack_exports__["default"] = (baseFilter);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseFor.js": 
        /*!********************************************!*\
          !*** ./node_modules/lodash-es/_baseFor.js ***!
          \********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _createBaseFor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createBaseFor.js */ "./node_modules/lodash-es/_createBaseFor.js");
            /**
             * The base implementation of `baseForOwn` which iterates over `object`
             * properties returned by `keysFunc` and invokes `iteratee` for each property.
             * Iteratee functions may exit iteration early by explicitly returning `false`.
             *
             * @private
             * @param {Object} object The object to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @param {Function} keysFunc The function to get the keys of `object`.
             * @returns {Object} Returns `object`.
             */
            var baseFor = Object(_createBaseFor_js__WEBPACK_IMPORTED_MODULE_0__["default"])();
            /* harmony default export */ __webpack_exports__["default"] = (baseFor);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseForOwn.js": 
        /*!***********************************************!*\
          !*** ./node_modules/lodash-es/_baseForOwn.js ***!
          \***********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _baseFor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseFor.js */ "./node_modules/lodash-es/_baseFor.js");
            /* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ "./node_modules/lodash-es/keys.js");
            /**
             * The base implementation of `_.forOwn` without support for iteratee shorthands.
             *
             * @private
             * @param {Object} object The object to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @returns {Object} Returns `object`.
             */
            function baseForOwn(object, iteratee) {
                return object && Object(_baseFor_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, iteratee, _keys_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
            }
            /* harmony default export */ __webpack_exports__["default"] = (baseForOwn);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseGet.js": 
        /*!********************************************!*\
          !*** ./node_modules/lodash-es/_baseGet.js ***!
          \********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _castPath_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_castPath.js */ "./node_modules/lodash-es/_castPath.js");
            /* harmony import */ var _toKey_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_toKey.js */ "./node_modules/lodash-es/_toKey.js");
            /**
             * The base implementation of `_.get` without support for default values.
             *
             * @private
             * @param {Object} object The object to query.
             * @param {Array|string} path The path of the property to get.
             * @returns {*} Returns the resolved value.
             */
            function baseGet(object, path) {
                path = Object(_castPath_js__WEBPACK_IMPORTED_MODULE_0__["default"])(path, object);
                var index = 0, length = path.length;
                while (object != null && index < length) {
                    object = object[Object(_toKey_js__WEBPACK_IMPORTED_MODULE_1__["default"])(path[index++])];
                }
                return (index && index == length) ? object : undefined;
            }
            /* harmony default export */ __webpack_exports__["default"] = (baseGet);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseGetAllKeys.js": 
        /*!***************************************************!*\
          !*** ./node_modules/lodash-es/_baseGetAllKeys.js ***!
          \***************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _arrayPush_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_arrayPush.js */ "./node_modules/lodash-es/_arrayPush.js");
            /* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js");
            /**
             * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
             * `keysFunc` and `symbolsFunc` to get the enumerable property names and
             * symbols of `object`.
             *
             * @private
             * @param {Object} object The object to query.
             * @param {Function} keysFunc The function to get the keys of `object`.
             * @param {Function} symbolsFunc The function to get the symbols of `object`.
             * @returns {Array} Returns the array of property names and symbols.
             */
            function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                var result = keysFunc(object);
                return Object(_isArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object) ? result : Object(_arrayPush_js__WEBPACK_IMPORTED_MODULE_0__["default"])(result, symbolsFunc(object));
            }
            /* harmony default export */ __webpack_exports__["default"] = (baseGetAllKeys);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseGetTag.js": 
        /*!***********************************************!*\
          !*** ./node_modules/lodash-es/_baseGetTag.js ***!
          \***********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _Symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Symbol.js */ "./node_modules/lodash-es/_Symbol.js");
            /* harmony import */ var _getRawTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getRawTag.js */ "./node_modules/lodash-es/_getRawTag.js");
            /* harmony import */ var _objectToString_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_objectToString.js */ "./node_modules/lodash-es/_objectToString.js");
            /** `Object#toString` result references. */
            var nullTag = '[object Null]', undefinedTag = '[object Undefined]';
            /** Built-in value references. */
            var symToStringTag = _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].toStringTag : undefined;
            /**
             * The base implementation of `getTag` without fallbacks for buggy environments.
             *
             * @private
             * @param {*} value The value to query.
             * @returns {string} Returns the `toStringTag`.
             */
            function baseGetTag(value) {
                if (value == null) {
                    return value === undefined ? undefinedTag : nullTag;
                }
                return (symToStringTag && symToStringTag in Object(value))
                    ? Object(_getRawTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value)
                    : Object(_objectToString_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value);
            }
            /* harmony default export */ __webpack_exports__["default"] = (baseGetTag);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseHasIn.js": 
        /*!**********************************************!*\
          !*** ./node_modules/lodash-es/_baseHasIn.js ***!
          \**********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * The base implementation of `_.hasIn` without support for deep paths.
             *
             * @private
             * @param {Object} [object] The object to query.
             * @param {Array|string} key The key to check.
             * @returns {boolean} Returns `true` if `key` exists, else `false`.
             */
            function baseHasIn(object, key) {
                return object != null && key in Object(object);
            }
            /* harmony default export */ __webpack_exports__["default"] = (baseHasIn);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseIsArguments.js": 
        /*!****************************************************!*\
          !*** ./node_modules/lodash-es/_baseIsArguments.js ***!
          \****************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseGetTag.js */ "./node_modules/lodash-es/_baseGetTag.js");
            /* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isObjectLike.js */ "./node_modules/lodash-es/isObjectLike.js");
            /** `Object#toString` result references. */
            var argsTag = '[object Arguments]';
            /**
             * The base implementation of `_.isArguments`.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is an `arguments` object,
             */
            function baseIsArguments(value) {
                return Object(_isObjectLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) && Object(_baseGetTag_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) == argsTag;
            }
            /* harmony default export */ __webpack_exports__["default"] = (baseIsArguments);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseIsEqual.js": 
        /*!************************************************!*\
          !*** ./node_modules/lodash-es/_baseIsEqual.js ***!
          \************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _baseIsEqualDeep_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseIsEqualDeep.js */ "./node_modules/lodash-es/_baseIsEqualDeep.js");
            /* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isObjectLike.js */ "./node_modules/lodash-es/isObjectLike.js");
            /**
             * The base implementation of `_.isEqual` which supports partial comparisons
             * and tracks traversed objects.
             *
             * @private
             * @param {*} value The value to compare.
             * @param {*} other The other value to compare.
             * @param {boolean} bitmask The bitmask flags.
             *  1 - Unordered comparison
             *  2 - Partial comparison
             * @param {Function} [customizer] The function to customize comparisons.
             * @param {Object} [stack] Tracks traversed `value` and `other` objects.
             * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
             */
            function baseIsEqual(value, other, bitmask, customizer, stack) {
                if (value === other) {
                    return true;
                }
                if (value == null || other == null || (!Object(_isObjectLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) && !Object(_isObjectLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(other))) {
                    return value !== value && other !== other;
                }
                return Object(_baseIsEqualDeep_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value, other, bitmask, customizer, baseIsEqual, stack);
            }
            /* harmony default export */ __webpack_exports__["default"] = (baseIsEqual);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseIsEqualDeep.js": 
        /*!****************************************************!*\
          !*** ./node_modules/lodash-es/_baseIsEqualDeep.js ***!
          \****************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _Stack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Stack.js */ "./node_modules/lodash-es/_Stack.js");
            /* harmony import */ var _equalArrays_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_equalArrays.js */ "./node_modules/lodash-es/_equalArrays.js");
            /* harmony import */ var _equalByTag_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_equalByTag.js */ "./node_modules/lodash-es/_equalByTag.js");
            /* harmony import */ var _equalObjects_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_equalObjects.js */ "./node_modules/lodash-es/_equalObjects.js");
            /* harmony import */ var _getTag_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_getTag.js */ "./node_modules/lodash-es/_getTag.js");
            /* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js");
            /* harmony import */ var _isBuffer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./isBuffer.js */ "./node_modules/lodash-es/isBuffer.js");
            /* harmony import */ var _isTypedArray_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./isTypedArray.js */ "./node_modules/lodash-es/isTypedArray.js");
            /** Used to compose bitmasks for value comparisons. */
            var COMPARE_PARTIAL_FLAG = 1;
            /** `Object#toString` result references. */
            var argsTag = '[object Arguments]', arrayTag = '[object Array]', objectTag = '[object Object]';
            /** Used for built-in method references. */
            var objectProto = Object.prototype;
            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty;
            /**
             * A specialized version of `baseIsEqual` for arrays and objects which performs
             * deep comparisons and tracks traversed objects enabling objects with circular
             * references to be compared.
             *
             * @private
             * @param {Object} object The object to compare.
             * @param {Object} other The other object to compare.
             * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
             * @param {Function} customizer The function to customize comparisons.
             * @param {Function} equalFunc The function to determine equivalents of values.
             * @param {Object} [stack] Tracks traversed `object` and `other` objects.
             * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
             */
            function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
                var objIsArr = Object(_isArray_js__WEBPACK_IMPORTED_MODULE_5__["default"])(object), othIsArr = Object(_isArray_js__WEBPACK_IMPORTED_MODULE_5__["default"])(other), objTag = objIsArr ? arrayTag : Object(_getTag_js__WEBPACK_IMPORTED_MODULE_4__["default"])(object), othTag = othIsArr ? arrayTag : Object(_getTag_js__WEBPACK_IMPORTED_MODULE_4__["default"])(other);
                objTag = objTag == argsTag ? objectTag : objTag;
                othTag = othTag == argsTag ? objectTag : othTag;
                var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
                if (isSameTag && Object(_isBuffer_js__WEBPACK_IMPORTED_MODULE_6__["default"])(object)) {
                    if (!Object(_isBuffer_js__WEBPACK_IMPORTED_MODULE_6__["default"])(other)) {
                        return false;
                    }
                    objIsArr = true;
                    objIsObj = false;
                }
                if (isSameTag && !objIsObj) {
                    stack || (stack = new _Stack_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
                    return (objIsArr || Object(_isTypedArray_js__WEBPACK_IMPORTED_MODULE_7__["default"])(object))
                        ? Object(_equalArrays_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, other, bitmask, customizer, equalFunc, stack)
                        : Object(_equalByTag_js__WEBPACK_IMPORTED_MODULE_2__["default"])(object, other, objTag, bitmask, customizer, equalFunc, stack);
                }
                if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'), othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
                    if (objIsWrapped || othIsWrapped) {
                        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                        stack || (stack = new _Stack_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
                        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
                    }
                }
                if (!isSameTag) {
                    return false;
                }
                stack || (stack = new _Stack_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
                return Object(_equalObjects_js__WEBPACK_IMPORTED_MODULE_3__["default"])(object, other, bitmask, customizer, equalFunc, stack);
            }
            /* harmony default export */ __webpack_exports__["default"] = (baseIsEqualDeep);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseIsMap.js": 
        /*!**********************************************!*\
          !*** ./node_modules/lodash-es/_baseIsMap.js ***!
          \**********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _getTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getTag.js */ "./node_modules/lodash-es/_getTag.js");
            /* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isObjectLike.js */ "./node_modules/lodash-es/isObjectLike.js");
            /** `Object#toString` result references. */
            var mapTag = '[object Map]';
            /**
             * The base implementation of `_.isMap` without Node.js optimizations.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a map, else `false`.
             */
            function baseIsMap(value) {
                return Object(_isObjectLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) && Object(_getTag_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) == mapTag;
            }
            /* harmony default export */ __webpack_exports__["default"] = (baseIsMap);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseIsMatch.js": 
        /*!************************************************!*\
          !*** ./node_modules/lodash-es/_baseIsMatch.js ***!
          \************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _Stack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Stack.js */ "./node_modules/lodash-es/_Stack.js");
            /* harmony import */ var _baseIsEqual_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseIsEqual.js */ "./node_modules/lodash-es/_baseIsEqual.js");
            /** Used to compose bitmasks for value comparisons. */
            var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
            /**
             * The base implementation of `_.isMatch` without support for iteratee shorthands.
             *
             * @private
             * @param {Object} object The object to inspect.
             * @param {Object} source The object of property values to match.
             * @param {Array} matchData The property names, values, and compare flags to match.
             * @param {Function} [customizer] The function to customize comparisons.
             * @returns {boolean} Returns `true` if `object` is a match, else `false`.
             */
            function baseIsMatch(object, source, matchData, customizer) {
                var index = matchData.length, length = index, noCustomizer = !customizer;
                if (object == null) {
                    return !length;
                }
                object = Object(object);
                while (index--) {
                    var data = matchData[index];
                    if ((noCustomizer && data[2])
                        ? data[1] !== object[data[0]]
                        : !(data[0] in object)) {
                        return false;
                    }
                }
                while (++index < length) {
                    data = matchData[index];
                    var key = data[0], objValue = object[key], srcValue = data[1];
                    if (noCustomizer && data[2]) {
                        if (objValue === undefined && !(key in object)) {
                            return false;
                        }
                    }
                    else {
                        var stack = new _Stack_js__WEBPACK_IMPORTED_MODULE_0__["default"];
                        if (customizer) {
                            var result = customizer(objValue, srcValue, key, object, source, stack);
                        }
                        if (!(result === undefined
                            ? Object(_baseIsEqual_js__WEBPACK_IMPORTED_MODULE_1__["default"])(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                            : result)) {
                            return false;
                        }
                    }
                }
                return true;
            }
            /* harmony default export */ __webpack_exports__["default"] = (baseIsMatch);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseIsNative.js": 
        /*!*************************************************!*\
          !*** ./node_modules/lodash-es/_baseIsNative.js ***!
          \*************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/lodash-es/isFunction.js");
            /* harmony import */ var _isMasked_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isMasked.js */ "./node_modules/lodash-es/_isMasked.js");
            /* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js");
            /* harmony import */ var _toSource_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_toSource.js */ "./node_modules/lodash-es/_toSource.js");
            /**
             * Used to match `RegExp`
             * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
             */
            var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
            /** Used to detect host constructors (Safari). */
            var reIsHostCtor = /^\[object .+?Constructor\]$/;
            /** Used for built-in method references. */
            var funcProto = Function.prototype, objectProto = Object.prototype;
            /** Used to resolve the decompiled source of functions. */
            var funcToString = funcProto.toString;
            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty;
            /** Used to detect if a method is native. */
            var reIsNative = RegExp('^' +
                funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
                    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
            /**
             * The base implementation of `_.isNative` without bad shim checks.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a native function,
             *  else `false`.
             */
            function baseIsNative(value) {
                if (!Object(_isObject_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value) || Object(_isMasked_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value)) {
                    return false;
                }
                var pattern = Object(_isFunction_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) ? reIsNative : reIsHostCtor;
                return pattern.test(Object(_toSource_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value));
            }
            /* harmony default export */ __webpack_exports__["default"] = (baseIsNative);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseIsSet.js": 
        /*!**********************************************!*\
          !*** ./node_modules/lodash-es/_baseIsSet.js ***!
          \**********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _getTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getTag.js */ "./node_modules/lodash-es/_getTag.js");
            /* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isObjectLike.js */ "./node_modules/lodash-es/isObjectLike.js");
            /** `Object#toString` result references. */
            var setTag = '[object Set]';
            /**
             * The base implementation of `_.isSet` without Node.js optimizations.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a set, else `false`.
             */
            function baseIsSet(value) {
                return Object(_isObjectLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) && Object(_getTag_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) == setTag;
            }
            /* harmony default export */ __webpack_exports__["default"] = (baseIsSet);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseIsTypedArray.js": 
        /*!*****************************************************!*\
          !*** ./node_modules/lodash-es/_baseIsTypedArray.js ***!
          \*****************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseGetTag.js */ "./node_modules/lodash-es/_baseGetTag.js");
            /* harmony import */ var _isLength_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isLength.js */ "./node_modules/lodash-es/isLength.js");
            /* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isObjectLike.js */ "./node_modules/lodash-es/isObjectLike.js");
            /** `Object#toString` result references. */
            var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', weakMapTag = '[object WeakMap]';
            var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
            /** Used to identify `toStringTag` values of typed arrays. */
            var typedArrayTags = {};
            typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
                typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
                    typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
                        typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
                            typedArrayTags[uint32Tag] = true;
            typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
                typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
                    typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
                        typedArrayTags[errorTag] = typedArrayTags[funcTag] =
                            typedArrayTags[mapTag] = typedArrayTags[numberTag] =
                                typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
                                    typedArrayTags[setTag] = typedArrayTags[stringTag] =
                                        typedArrayTags[weakMapTag] = false;
            /**
             * The base implementation of `_.isTypedArray` without Node.js optimizations.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
             */
            function baseIsTypedArray(value) {
                return Object(_isObjectLike_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value) &&
                    Object(_isLength_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value.length) && !!typedArrayTags[Object(_baseGetTag_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value)];
            }
            /* harmony default export */ __webpack_exports__["default"] = (baseIsTypedArray);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseIteratee.js": 
        /*!*************************************************!*\
          !*** ./node_modules/lodash-es/_baseIteratee.js ***!
          \*************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _baseMatches_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseMatches.js */ "./node_modules/lodash-es/_baseMatches.js");
            /* harmony import */ var _baseMatchesProperty_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseMatchesProperty.js */ "./node_modules/lodash-es/_baseMatchesProperty.js");
            /* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./identity.js */ "./node_modules/lodash-es/identity.js");
            /* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js");
            /* harmony import */ var _property_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./property.js */ "./node_modules/lodash-es/property.js");
            /**
             * The base implementation of `_.iteratee`.
             *
             * @private
             * @param {*} [value=_.identity] The value to convert to an iteratee.
             * @returns {Function} Returns the iteratee.
             */
            function baseIteratee(value) {
                // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
                // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
                if (typeof value == 'function') {
                    return value;
                }
                if (value == null) {
                    return _identity_js__WEBPACK_IMPORTED_MODULE_2__["default"];
                }
                if (typeof value == 'object') {
                    return Object(_isArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value)
                        ? Object(_baseMatchesProperty_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value[0], value[1])
                        : Object(_baseMatches_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value);
                }
                return Object(_property_js__WEBPACK_IMPORTED_MODULE_4__["default"])(value);
            }
            /* harmony default export */ __webpack_exports__["default"] = (baseIteratee);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseKeys.js": 
        /*!*********************************************!*\
          !*** ./node_modules/lodash-es/_baseKeys.js ***!
          \*********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _isPrototype_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isPrototype.js */ "./node_modules/lodash-es/_isPrototype.js");
            /* harmony import */ var _nativeKeys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_nativeKeys.js */ "./node_modules/lodash-es/_nativeKeys.js");
            /** Used for built-in method references. */
            var objectProto = Object.prototype;
            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty;
            /**
             * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
             *
             * @private
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of property names.
             */
            function baseKeys(object) {
                if (!Object(_isPrototype_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object)) {
                    return Object(_nativeKeys_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object);
                }
                var result = [];
                for (var key in Object(object)) {
                    if (hasOwnProperty.call(object, key) && key != 'constructor') {
                        result.push(key);
                    }
                }
                return result;
            }
            /* harmony default export */ __webpack_exports__["default"] = (baseKeys);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseKeysIn.js": 
        /*!***********************************************!*\
          !*** ./node_modules/lodash-es/_baseKeysIn.js ***!
          \***********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js");
            /* harmony import */ var _isPrototype_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isPrototype.js */ "./node_modules/lodash-es/_isPrototype.js");
            /* harmony import */ var _nativeKeysIn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_nativeKeysIn.js */ "./node_modules/lodash-es/_nativeKeysIn.js");
            /** Used for built-in method references. */
            var objectProto = Object.prototype;
            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty;
            /**
             * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
             *
             * @private
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of property names.
             */
            function baseKeysIn(object) {
                if (!Object(_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object)) {
                    return Object(_nativeKeysIn_js__WEBPACK_IMPORTED_MODULE_2__["default"])(object);
                }
                var isProto = Object(_isPrototype_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object), result = [];
                for (var key in object) {
                    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                        result.push(key);
                    }
                }
                return result;
            }
            /* harmony default export */ __webpack_exports__["default"] = (baseKeysIn);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseMap.js": 
        /*!********************************************!*\
          !*** ./node_modules/lodash-es/_baseMap.js ***!
          \********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _baseEach_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseEach.js */ "./node_modules/lodash-es/_baseEach.js");
            /* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArrayLike.js */ "./node_modules/lodash-es/isArrayLike.js");
            /**
             * The base implementation of `_.map` without support for iteratee shorthands.
             *
             * @private
             * @param {Array|Object} collection The collection to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @returns {Array} Returns the new mapped array.
             */
            function baseMap(collection, iteratee) {
                var index = -1, result = Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(collection) ? Array(collection.length) : [];
                Object(_baseEach_js__WEBPACK_IMPORTED_MODULE_0__["default"])(collection, function (value, key, collection) {
                    result[++index] = iteratee(value, key, collection);
                });
                return result;
            }
            /* harmony default export */ __webpack_exports__["default"] = (baseMap);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseMatches.js": 
        /*!************************************************!*\
          !*** ./node_modules/lodash-es/_baseMatches.js ***!
          \************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _baseIsMatch_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseIsMatch.js */ "./node_modules/lodash-es/_baseIsMatch.js");
            /* harmony import */ var _getMatchData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getMatchData.js */ "./node_modules/lodash-es/_getMatchData.js");
            /* harmony import */ var _matchesStrictComparable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_matchesStrictComparable.js */ "./node_modules/lodash-es/_matchesStrictComparable.js");
            /**
             * The base implementation of `_.matches` which doesn't clone `source`.
             *
             * @private
             * @param {Object} source The object of property values to match.
             * @returns {Function} Returns the new spec function.
             */
            function baseMatches(source) {
                var matchData = Object(_getMatchData_js__WEBPACK_IMPORTED_MODULE_1__["default"])(source);
                if (matchData.length == 1 && matchData[0][2]) {
                    return Object(_matchesStrictComparable_js__WEBPACK_IMPORTED_MODULE_2__["default"])(matchData[0][0], matchData[0][1]);
                }
                return function (object) {
                    return object === source || Object(_baseIsMatch_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, source, matchData);
                };
            }
            /* harmony default export */ __webpack_exports__["default"] = (baseMatches);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseMatchesProperty.js": 
        /*!********************************************************!*\
          !*** ./node_modules/lodash-es/_baseMatchesProperty.js ***!
          \********************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _baseIsEqual_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseIsEqual.js */ "./node_modules/lodash-es/_baseIsEqual.js");
            /* harmony import */ var _get_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get.js */ "./node_modules/lodash-es/get.js");
            /* harmony import */ var _hasIn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hasIn.js */ "./node_modules/lodash-es/hasIn.js");
            /* harmony import */ var _isKey_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_isKey.js */ "./node_modules/lodash-es/_isKey.js");
            /* harmony import */ var _isStrictComparable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_isStrictComparable.js */ "./node_modules/lodash-es/_isStrictComparable.js");
            /* harmony import */ var _matchesStrictComparable_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_matchesStrictComparable.js */ "./node_modules/lodash-es/_matchesStrictComparable.js");
            /* harmony import */ var _toKey_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_toKey.js */ "./node_modules/lodash-es/_toKey.js");
            /** Used to compose bitmasks for value comparisons. */
            var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
            /**
             * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
             *
             * @private
             * @param {string} path The path of the property to get.
             * @param {*} srcValue The value to match.
             * @returns {Function} Returns the new spec function.
             */
            function baseMatchesProperty(path, srcValue) {
                if (Object(_isKey_js__WEBPACK_IMPORTED_MODULE_3__["default"])(path) && Object(_isStrictComparable_js__WEBPACK_IMPORTED_MODULE_4__["default"])(srcValue)) {
                    return Object(_matchesStrictComparable_js__WEBPACK_IMPORTED_MODULE_5__["default"])(Object(_toKey_js__WEBPACK_IMPORTED_MODULE_6__["default"])(path), srcValue);
                }
                return function (object) {
                    var objValue = Object(_get_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, path);
                    return (objValue === undefined && objValue === srcValue)
                        ? Object(_hasIn_js__WEBPACK_IMPORTED_MODULE_2__["default"])(object, path)
                        : Object(_baseIsEqual_js__WEBPACK_IMPORTED_MODULE_0__["default"])(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
                };
            }
            /* harmony default export */ __webpack_exports__["default"] = (baseMatchesProperty);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseProperty.js": 
        /*!*************************************************!*\
          !*** ./node_modules/lodash-es/_baseProperty.js ***!
          \*************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * The base implementation of `_.property` without support for deep paths.
             *
             * @private
             * @param {string} key The key of the property to get.
             * @returns {Function} Returns the new accessor function.
             */
            function baseProperty(key) {
                return function (object) {
                    return object == null ? undefined : object[key];
                };
            }
            /* harmony default export */ __webpack_exports__["default"] = (baseProperty);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_basePropertyDeep.js": 
        /*!*****************************************************!*\
          !*** ./node_modules/lodash-es/_basePropertyDeep.js ***!
          \*****************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _baseGet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseGet.js */ "./node_modules/lodash-es/_baseGet.js");
            /**
             * A specialized version of `baseProperty` which supports deep paths.
             *
             * @private
             * @param {Array|string} path The path of the property to get.
             * @returns {Function} Returns the new accessor function.
             */
            function basePropertyDeep(path) {
                return function (object) {
                    return Object(_baseGet_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, path);
                };
            }
            /* harmony default export */ __webpack_exports__["default"] = (basePropertyDeep);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseTimes.js": 
        /*!**********************************************!*\
          !*** ./node_modules/lodash-es/_baseTimes.js ***!
          \**********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * The base implementation of `_.times` without support for iteratee shorthands
             * or max array length checks.
             *
             * @private
             * @param {number} n The number of times to invoke `iteratee`.
             * @param {Function} iteratee The function invoked per iteration.
             * @returns {Array} Returns the array of results.
             */
            function baseTimes(n, iteratee) {
                var index = -1, result = Array(n);
                while (++index < n) {
                    result[index] = iteratee(index);
                }
                return result;
            }
            /* harmony default export */ __webpack_exports__["default"] = (baseTimes);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseToString.js": 
        /*!*************************************************!*\
          !*** ./node_modules/lodash-es/_baseToString.js ***!
          \*************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _Symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Symbol.js */ "./node_modules/lodash-es/_Symbol.js");
            /* harmony import */ var _arrayMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_arrayMap.js */ "./node_modules/lodash-es/_arrayMap.js");
            /* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js");
            /* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isSymbol.js */ "./node_modules/lodash-es/isSymbol.js");
            /** Used as references for various `Number` constants. */
            var INFINITY = 1 / 0;
            /** Used to convert symbols to primitives and strings. */
            var symbolProto = _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
            /**
             * The base implementation of `_.toString` which doesn't convert nullish
             * values to empty strings.
             *
             * @private
             * @param {*} value The value to process.
             * @returns {string} Returns the string.
             */
            function baseToString(value) {
                // Exit early for strings to avoid a performance hit in some environments.
                if (typeof value == 'string') {
                    return value;
                }
                if (Object(_isArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value)) {
                    // Recursively convert values (susceptible to call stack limits).
                    return Object(_arrayMap_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value, baseToString) + '';
                }
                if (Object(_isSymbol_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value)) {
                    return symbolToString ? symbolToString.call(value) : '';
                }
                var result = (value + '');
                return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
            }
            /* harmony default export */ __webpack_exports__["default"] = (baseToString);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_baseUnary.js": 
        /*!**********************************************!*\
          !*** ./node_modules/lodash-es/_baseUnary.js ***!
          \**********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * The base implementation of `_.unary` without support for storing metadata.
             *
             * @private
             * @param {Function} func The function to cap arguments for.
             * @returns {Function} Returns the new capped function.
             */
            function baseUnary(func) {
                return function (value) {
                    return func(value);
                };
            }
            /* harmony default export */ __webpack_exports__["default"] = (baseUnary);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_cacheHas.js": 
        /*!*********************************************!*\
          !*** ./node_modules/lodash-es/_cacheHas.js ***!
          \*********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * Checks if a `cache` value for `key` exists.
             *
             * @private
             * @param {Object} cache The cache to query.
             * @param {string} key The key of the entry to check.
             * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
             */
            function cacheHas(cache, key) {
                return cache.has(key);
            }
            /* harmony default export */ __webpack_exports__["default"] = (cacheHas);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_castPath.js": 
        /*!*********************************************!*\
          !*** ./node_modules/lodash-es/_castPath.js ***!
          \*********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js");
            /* harmony import */ var _isKey_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isKey.js */ "./node_modules/lodash-es/_isKey.js");
            /* harmony import */ var _stringToPath_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_stringToPath.js */ "./node_modules/lodash-es/_stringToPath.js");
            /* harmony import */ var _toString_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./toString.js */ "./node_modules/lodash-es/toString.js");
            /**
             * Casts `value` to a path array if it's not one.
             *
             * @private
             * @param {*} value The value to inspect.
             * @param {Object} [object] The object to query keys on.
             * @returns {Array} Returns the cast property path array.
             */
            function castPath(value, object) {
                if (Object(_isArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value)) {
                    return value;
                }
                return Object(_isKey_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value, object) ? [value] : Object(_stringToPath_js__WEBPACK_IMPORTED_MODULE_2__["default"])(Object(_toString_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value));
            }
            /* harmony default export */ __webpack_exports__["default"] = (castPath);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_cloneArrayBuffer.js": 
        /*!*****************************************************!*\
          !*** ./node_modules/lodash-es/_cloneArrayBuffer.js ***!
          \*****************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _Uint8Array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Uint8Array.js */ "./node_modules/lodash-es/_Uint8Array.js");
            /**
             * Creates a clone of `arrayBuffer`.
             *
             * @private
             * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
             * @returns {ArrayBuffer} Returns the cloned array buffer.
             */
            function cloneArrayBuffer(arrayBuffer) {
                var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
                new _Uint8Array_js__WEBPACK_IMPORTED_MODULE_0__["default"](result).set(new _Uint8Array_js__WEBPACK_IMPORTED_MODULE_0__["default"](arrayBuffer));
                return result;
            }
            /* harmony default export */ __webpack_exports__["default"] = (cloneArrayBuffer);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_cloneBuffer.js": 
        /*!************************************************!*\
          !*** ./node_modules/lodash-es/_cloneBuffer.js ***!
          \************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* WEBPACK VAR INJECTION */ (function (module) {
                var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");
                /** Detect free variable `exports`. */
                var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
                /** Detect free variable `module`. */
                var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
                /** Detect the popular CommonJS extension `module.exports`. */
                var moduleExports = freeModule && freeModule.exports === freeExports;
                /** Built-in value references. */
                var Buffer = moduleExports ? _root_js__WEBPACK_IMPORTED_MODULE_0__["default"].Buffer : undefined, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
                /**
                 * Creates a clone of  `buffer`.
                 *
                 * @private
                 * @param {Buffer} buffer The buffer to clone.
                 * @param {boolean} [isDeep] Specify a deep clone.
                 * @returns {Buffer} Returns the cloned buffer.
                 */
                function cloneBuffer(buffer, isDeep) {
                    if (isDeep) {
                        return buffer.slice();
                    }
                    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
                    buffer.copy(result);
                    return result;
                }
                /* harmony default export */ __webpack_exports__["default"] = (cloneBuffer);
                /* WEBPACK VAR INJECTION */ 
            }.call(this, __webpack_require__(/*! ./../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)));
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_cloneDataView.js": 
        /*!**************************************************!*\
          !*** ./node_modules/lodash-es/_cloneDataView.js ***!
          \**************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _cloneArrayBuffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cloneArrayBuffer.js */ "./node_modules/lodash-es/_cloneArrayBuffer.js");
            /**
             * Creates a clone of `dataView`.
             *
             * @private
             * @param {Object} dataView The data view to clone.
             * @param {boolean} [isDeep] Specify a deep clone.
             * @returns {Object} Returns the cloned data view.
             */
            function cloneDataView(dataView, isDeep) {
                var buffer = isDeep ? Object(_cloneArrayBuffer_js__WEBPACK_IMPORTED_MODULE_0__["default"])(dataView.buffer) : dataView.buffer;
                return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
            }
            /* harmony default export */ __webpack_exports__["default"] = (cloneDataView);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_cloneRegExp.js": 
        /*!************************************************!*\
          !*** ./node_modules/lodash-es/_cloneRegExp.js ***!
          \************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /** Used to match `RegExp` flags from their coerced string values. */
            var reFlags = /\w*$/;
            /**
             * Creates a clone of `regexp`.
             *
             * @private
             * @param {Object} regexp The regexp to clone.
             * @returns {Object} Returns the cloned regexp.
             */
            function cloneRegExp(regexp) {
                var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
                result.lastIndex = regexp.lastIndex;
                return result;
            }
            /* harmony default export */ __webpack_exports__["default"] = (cloneRegExp);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_cloneSymbol.js": 
        /*!************************************************!*\
          !*** ./node_modules/lodash-es/_cloneSymbol.js ***!
          \************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _Symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Symbol.js */ "./node_modules/lodash-es/_Symbol.js");
            /** Used to convert symbols to primitives and strings. */
            var symbolProto = _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
            /**
             * Creates a clone of the `symbol` object.
             *
             * @private
             * @param {Object} symbol The symbol object to clone.
             * @returns {Object} Returns the cloned symbol object.
             */
            function cloneSymbol(symbol) {
                return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
            }
            /* harmony default export */ __webpack_exports__["default"] = (cloneSymbol);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_cloneTypedArray.js": 
        /*!****************************************************!*\
          !*** ./node_modules/lodash-es/_cloneTypedArray.js ***!
          \****************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _cloneArrayBuffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cloneArrayBuffer.js */ "./node_modules/lodash-es/_cloneArrayBuffer.js");
            /**
             * Creates a clone of `typedArray`.
             *
             * @private
             * @param {Object} typedArray The typed array to clone.
             * @param {boolean} [isDeep] Specify a deep clone.
             * @returns {Object} Returns the cloned typed array.
             */
            function cloneTypedArray(typedArray, isDeep) {
                var buffer = isDeep ? Object(_cloneArrayBuffer_js__WEBPACK_IMPORTED_MODULE_0__["default"])(typedArray.buffer) : typedArray.buffer;
                return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
            }
            /* harmony default export */ __webpack_exports__["default"] = (cloneTypedArray);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_copyArray.js": 
        /*!**********************************************!*\
          !*** ./node_modules/lodash-es/_copyArray.js ***!
          \**********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * Copies the values of `source` to `array`.
             *
             * @private
             * @param {Array} source The array to copy values from.
             * @param {Array} [array=[]] The array to copy values to.
             * @returns {Array} Returns `array`.
             */
            function copyArray(source, array) {
                var index = -1, length = source.length;
                array || (array = Array(length));
                while (++index < length) {
                    array[index] = source[index];
                }
                return array;
            }
            /* harmony default export */ __webpack_exports__["default"] = (copyArray);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_copyObject.js": 
        /*!***********************************************!*\
          !*** ./node_modules/lodash-es/_copyObject.js ***!
          \***********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _assignValue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assignValue.js */ "./node_modules/lodash-es/_assignValue.js");
            /* harmony import */ var _baseAssignValue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseAssignValue.js */ "./node_modules/lodash-es/_baseAssignValue.js");
            /**
             * Copies properties of `source` to `object`.
             *
             * @private
             * @param {Object} source The object to copy properties from.
             * @param {Array} props The property identifiers to copy.
             * @param {Object} [object={}] The object to copy properties to.
             * @param {Function} [customizer] The function to customize copied values.
             * @returns {Object} Returns `object`.
             */
            function copyObject(source, props, object, customizer) {
                var isNew = !object;
                object || (object = {});
                var index = -1, length = props.length;
                while (++index < length) {
                    var key = props[index];
                    var newValue = customizer
                        ? customizer(object[key], source[key], key, object, source)
                        : undefined;
                    if (newValue === undefined) {
                        newValue = source[key];
                    }
                    if (isNew) {
                        Object(_baseAssignValue_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, key, newValue);
                    }
                    else {
                        Object(_assignValue_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, key, newValue);
                    }
                }
                return object;
            }
            /* harmony default export */ __webpack_exports__["default"] = (copyObject);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_copySymbols.js": 
        /*!************************************************!*\
          !*** ./node_modules/lodash-es/_copySymbols.js ***!
          \************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _copyObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_copyObject.js */ "./node_modules/lodash-es/_copyObject.js");
            /* harmony import */ var _getSymbols_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getSymbols.js */ "./node_modules/lodash-es/_getSymbols.js");
            /**
             * Copies own symbols of `source` to `object`.
             *
             * @private
             * @param {Object} source The object to copy symbols from.
             * @param {Object} [object={}] The object to copy symbols to.
             * @returns {Object} Returns `object`.
             */
            function copySymbols(source, object) {
                return Object(_copyObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(source, Object(_getSymbols_js__WEBPACK_IMPORTED_MODULE_1__["default"])(source), object);
            }
            /* harmony default export */ __webpack_exports__["default"] = (copySymbols);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_copySymbolsIn.js": 
        /*!**************************************************!*\
          !*** ./node_modules/lodash-es/_copySymbolsIn.js ***!
          \**************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _copyObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_copyObject.js */ "./node_modules/lodash-es/_copyObject.js");
            /* harmony import */ var _getSymbolsIn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getSymbolsIn.js */ "./node_modules/lodash-es/_getSymbolsIn.js");
            /**
             * Copies own and inherited symbols of `source` to `object`.
             *
             * @private
             * @param {Object} source The object to copy symbols from.
             * @param {Object} [object={}] The object to copy symbols to.
             * @returns {Object} Returns `object`.
             */
            function copySymbolsIn(source, object) {
                return Object(_copyObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(source, Object(_getSymbolsIn_js__WEBPACK_IMPORTED_MODULE_1__["default"])(source), object);
            }
            /* harmony default export */ __webpack_exports__["default"] = (copySymbolsIn);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_coreJsData.js": 
        /*!***********************************************!*\
          !*** ./node_modules/lodash-es/_coreJsData.js ***!
          \***********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");
            /** Used to detect overreaching core-js shims. */
            var coreJsData = _root_js__WEBPACK_IMPORTED_MODULE_0__["default"]['__core-js_shared__'];
            /* harmony default export */ __webpack_exports__["default"] = (coreJsData);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_createBaseEach.js": 
        /*!***************************************************!*\
          !*** ./node_modules/lodash-es/_createBaseEach.js ***!
          \***************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArrayLike.js */ "./node_modules/lodash-es/isArrayLike.js");
            /**
             * Creates a `baseEach` or `baseEachRight` function.
             *
             * @private
             * @param {Function} eachFunc The function to iterate over a collection.
             * @param {boolean} [fromRight] Specify iterating from right to left.
             * @returns {Function} Returns the new base function.
             */
            function createBaseEach(eachFunc, fromRight) {
                return function (collection, iteratee) {
                    if (collection == null) {
                        return collection;
                    }
                    if (!Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(collection)) {
                        return eachFunc(collection, iteratee);
                    }
                    var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
                    while ((fromRight ? index-- : ++index < length)) {
                        if (iteratee(iterable[index], index, iterable) === false) {
                            break;
                        }
                    }
                    return collection;
                };
            }
            /* harmony default export */ __webpack_exports__["default"] = (createBaseEach);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_createBaseFor.js": 
        /*!**************************************************!*\
          !*** ./node_modules/lodash-es/_createBaseFor.js ***!
          \**************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * Creates a base function for methods like `_.forIn` and `_.forOwn`.
             *
             * @private
             * @param {boolean} [fromRight] Specify iterating from right to left.
             * @returns {Function} Returns the new base function.
             */
            function createBaseFor(fromRight) {
                return function (object, iteratee, keysFunc) {
                    var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
                    while (length--) {
                        var key = props[fromRight ? length : ++index];
                        if (iteratee(iterable[key], key, iterable) === false) {
                            break;
                        }
                    }
                    return object;
                };
            }
            /* harmony default export */ __webpack_exports__["default"] = (createBaseFor);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_defineProperty.js": 
        /*!***************************************************!*\
          !*** ./node_modules/lodash-es/_defineProperty.js ***!
          \***************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _getNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getNative.js */ "./node_modules/lodash-es/_getNative.js");
            var defineProperty = (function () {
                try {
                    var func = Object(_getNative_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Object, 'defineProperty');
                    func({}, '', {});
                    return func;
                }
                catch (e) { }
            }());
            /* harmony default export */ __webpack_exports__["default"] = (defineProperty);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_equalArrays.js": 
        /*!************************************************!*\
          !*** ./node_modules/lodash-es/_equalArrays.js ***!
          \************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _SetCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_SetCache.js */ "./node_modules/lodash-es/_SetCache.js");
            /* harmony import */ var _arraySome_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_arraySome.js */ "./node_modules/lodash-es/_arraySome.js");
            /* harmony import */ var _cacheHas_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_cacheHas.js */ "./node_modules/lodash-es/_cacheHas.js");
            /** Used to compose bitmasks for value comparisons. */
            var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
            /**
             * A specialized version of `baseIsEqualDeep` for arrays with support for
             * partial deep comparisons.
             *
             * @private
             * @param {Array} array The array to compare.
             * @param {Array} other The other array to compare.
             * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
             * @param {Function} customizer The function to customize comparisons.
             * @param {Function} equalFunc The function to determine equivalents of values.
             * @param {Object} stack Tracks traversed `array` and `other` objects.
             * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
             */
            function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
                if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
                    return false;
                }
                // Assume cyclic values are equal.
                var stacked = stack.get(array);
                if (stacked && stack.get(other)) {
                    return stacked == other;
                }
                var index = -1, result = true, seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new _SetCache_js__WEBPACK_IMPORTED_MODULE_0__["default"] : undefined;
                stack.set(array, other);
                stack.set(other, array);
                // Ignore non-index properties.
                while (++index < arrLength) {
                    var arrValue = array[index], othValue = other[index];
                    if (customizer) {
                        var compared = isPartial
                            ? customizer(othValue, arrValue, index, other, array, stack)
                            : customizer(arrValue, othValue, index, array, other, stack);
                    }
                    if (compared !== undefined) {
                        if (compared) {
                            continue;
                        }
                        result = false;
                        break;
                    }
                    // Recursively compare arrays (susceptible to call stack limits).
                    if (seen) {
                        if (!Object(_arraySome_js__WEBPACK_IMPORTED_MODULE_1__["default"])(other, function (othValue, othIndex) {
                            if (!Object(_cacheHas_js__WEBPACK_IMPORTED_MODULE_2__["default"])(seen, othIndex) &&
                                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                                return seen.push(othIndex);
                            }
                        })) {
                            result = false;
                            break;
                        }
                    }
                    else if (!(arrValue === othValue ||
                        equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                        result = false;
                        break;
                    }
                }
                stack['delete'](array);
                stack['delete'](other);
                return result;
            }
            /* harmony default export */ __webpack_exports__["default"] = (equalArrays);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_equalByTag.js": 
        /*!***********************************************!*\
          !*** ./node_modules/lodash-es/_equalByTag.js ***!
          \***********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _Symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Symbol.js */ "./node_modules/lodash-es/_Symbol.js");
            /* harmony import */ var _Uint8Array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_Uint8Array.js */ "./node_modules/lodash-es/_Uint8Array.js");
            /* harmony import */ var _eq_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./eq.js */ "./node_modules/lodash-es/eq.js");
            /* harmony import */ var _equalArrays_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_equalArrays.js */ "./node_modules/lodash-es/_equalArrays.js");
            /* harmony import */ var _mapToArray_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_mapToArray.js */ "./node_modules/lodash-es/_mapToArray.js");
            /* harmony import */ var _setToArray_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_setToArray.js */ "./node_modules/lodash-es/_setToArray.js");
            /** Used to compose bitmasks for value comparisons. */
            var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
            /** `Object#toString` result references. */
            var boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', mapTag = '[object Map]', numberTag = '[object Number]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]';
            var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]';
            /** Used to convert symbols to primitives and strings. */
            var symbolProto = _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
            /**
             * A specialized version of `baseIsEqualDeep` for comparing objects of
             * the same `toStringTag`.
             *
             * **Note:** This function only supports comparing values with tags of
             * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
             *
             * @private
             * @param {Object} object The object to compare.
             * @param {Object} other The other object to compare.
             * @param {string} tag The `toStringTag` of the objects to compare.
             * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
             * @param {Function} customizer The function to customize comparisons.
             * @param {Function} equalFunc The function to determine equivalents of values.
             * @param {Object} stack Tracks traversed `object` and `other` objects.
             * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
             */
            function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
                switch (tag) {
                    case dataViewTag:
                        if ((object.byteLength != other.byteLength) ||
                            (object.byteOffset != other.byteOffset)) {
                            return false;
                        }
                        object = object.buffer;
                        other = other.buffer;
                    case arrayBufferTag:
                        if ((object.byteLength != other.byteLength) ||
                            !equalFunc(new _Uint8Array_js__WEBPACK_IMPORTED_MODULE_1__["default"](object), new _Uint8Array_js__WEBPACK_IMPORTED_MODULE_1__["default"](other))) {
                            return false;
                        }
                        return true;
                    case boolTag:
                    case dateTag:
                    case numberTag:
                        // Coerce booleans to `1` or `0` and dates to milliseconds.
                        // Invalid dates are coerced to `NaN`.
                        return Object(_eq_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+object, +other);
                    case errorTag:
                        return object.name == other.name && object.message == other.message;
                    case regexpTag:
                    case stringTag:
                        // Coerce regexes to strings and treat strings, primitives and objects,
                        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
                        // for more details.
                        return object == (other + '');
                    case mapTag:
                        var convert = _mapToArray_js__WEBPACK_IMPORTED_MODULE_4__["default"];
                    case setTag:
                        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                        convert || (convert = _setToArray_js__WEBPACK_IMPORTED_MODULE_5__["default"]);
                        if (object.size != other.size && !isPartial) {
                            return false;
                        }
                        // Assume cyclic values are equal.
                        var stacked = stack.get(object);
                        if (stacked) {
                            return stacked == other;
                        }
                        bitmask |= COMPARE_UNORDERED_FLAG;
                        // Recursively compare objects (susceptible to call stack limits).
                        stack.set(object, other);
                        var result = Object(_equalArrays_js__WEBPACK_IMPORTED_MODULE_3__["default"])(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                        stack['delete'](object);
                        return result;
                    case symbolTag:
                        if (symbolValueOf) {
                            return symbolValueOf.call(object) == symbolValueOf.call(other);
                        }
                }
                return false;
            }
            /* harmony default export */ __webpack_exports__["default"] = (equalByTag);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_equalObjects.js": 
        /*!*************************************************!*\
          !*** ./node_modules/lodash-es/_equalObjects.js ***!
          \*************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _getAllKeys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getAllKeys.js */ "./node_modules/lodash-es/_getAllKeys.js");
            /** Used to compose bitmasks for value comparisons. */
            var COMPARE_PARTIAL_FLAG = 1;
            /** Used for built-in method references. */
            var objectProto = Object.prototype;
            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty;
            /**
             * A specialized version of `baseIsEqualDeep` for objects with support for
             * partial deep comparisons.
             *
             * @private
             * @param {Object} object The object to compare.
             * @param {Object} other The other object to compare.
             * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
             * @param {Function} customizer The function to customize comparisons.
             * @param {Function} equalFunc The function to determine equivalents of values.
             * @param {Object} stack Tracks traversed `object` and `other` objects.
             * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
             */
            function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = Object(_getAllKeys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object), objLength = objProps.length, othProps = Object(_getAllKeys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(other), othLength = othProps.length;
                if (objLength != othLength && !isPartial) {
                    return false;
                }
                var index = objLength;
                while (index--) {
                    var key = objProps[index];
                    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                        return false;
                    }
                }
                // Assume cyclic values are equal.
                var stacked = stack.get(object);
                if (stacked && stack.get(other)) {
                    return stacked == other;
                }
                var result = true;
                stack.set(object, other);
                stack.set(other, object);
                var skipCtor = isPartial;
                while (++index < objLength) {
                    key = objProps[index];
                    var objValue = object[key], othValue = other[key];
                    if (customizer) {
                        var compared = isPartial
                            ? customizer(othValue, objValue, key, other, object, stack)
                            : customizer(objValue, othValue, key, object, other, stack);
                    }
                    // Recursively compare objects (susceptible to call stack limits).
                    if (!(compared === undefined
                        ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
                        : compared)) {
                        result = false;
                        break;
                    }
                    skipCtor || (skipCtor = key == 'constructor');
                }
                if (result && !skipCtor) {
                    var objCtor = object.constructor, othCtor = other.constructor;
                    // Non `Object` object instances with different constructors are not equal.
                    if (objCtor != othCtor &&
                        ('constructor' in object && 'constructor' in other) &&
                        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                            typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                        result = false;
                    }
                }
                stack['delete'](object);
                stack['delete'](other);
                return result;
            }
            /* harmony default export */ __webpack_exports__["default"] = (equalObjects);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_freeGlobal.js": 
        /*!***********************************************!*\
          !*** ./node_modules/lodash-es/_freeGlobal.js ***!
          \***********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /** Detect free variable `global` from Node.js. */
            var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
            /* harmony default export */ __webpack_exports__["default"] = (freeGlobal);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_getAllKeys.js": 
        /*!***********************************************!*\
          !*** ./node_modules/lodash-es/_getAllKeys.js ***!
          \***********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _baseGetAllKeys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseGetAllKeys.js */ "./node_modules/lodash-es/_baseGetAllKeys.js");
            /* harmony import */ var _getSymbols_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getSymbols.js */ "./node_modules/lodash-es/_getSymbols.js");
            /* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keys.js */ "./node_modules/lodash-es/keys.js");
            /**
             * Creates an array of own enumerable property names and symbols of `object`.
             *
             * @private
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of property names and symbols.
             */
            function getAllKeys(object) {
                return Object(_baseGetAllKeys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, _keys_js__WEBPACK_IMPORTED_MODULE_2__["default"], _getSymbols_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
            }
            /* harmony default export */ __webpack_exports__["default"] = (getAllKeys);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_getAllKeysIn.js": 
        /*!*************************************************!*\
          !*** ./node_modules/lodash-es/_getAllKeysIn.js ***!
          \*************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _baseGetAllKeys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseGetAllKeys.js */ "./node_modules/lodash-es/_baseGetAllKeys.js");
            /* harmony import */ var _getSymbolsIn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getSymbolsIn.js */ "./node_modules/lodash-es/_getSymbolsIn.js");
            /* harmony import */ var _keysIn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keysIn.js */ "./node_modules/lodash-es/keysIn.js");
            /**
             * Creates an array of own and inherited enumerable property names and
             * symbols of `object`.
             *
             * @private
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of property names and symbols.
             */
            function getAllKeysIn(object) {
                return Object(_baseGetAllKeys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, _keysIn_js__WEBPACK_IMPORTED_MODULE_2__["default"], _getSymbolsIn_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
            }
            /* harmony default export */ __webpack_exports__["default"] = (getAllKeysIn);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_getMapData.js": 
        /*!***********************************************!*\
          !*** ./node_modules/lodash-es/_getMapData.js ***!
          \***********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _isKeyable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isKeyable.js */ "./node_modules/lodash-es/_isKeyable.js");
            /**
             * Gets the data for `map`.
             *
             * @private
             * @param {Object} map The map to query.
             * @param {string} key The reference key.
             * @returns {*} Returns the map data.
             */
            function getMapData(map, key) {
                var data = map.__data__;
                return Object(_isKeyable_js__WEBPACK_IMPORTED_MODULE_0__["default"])(key)
                    ? data[typeof key == 'string' ? 'string' : 'hash']
                    : data.map;
            }
            /* harmony default export */ __webpack_exports__["default"] = (getMapData);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_getMatchData.js": 
        /*!*************************************************!*\
          !*** ./node_modules/lodash-es/_getMatchData.js ***!
          \*************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _isStrictComparable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isStrictComparable.js */ "./node_modules/lodash-es/_isStrictComparable.js");
            /* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ "./node_modules/lodash-es/keys.js");
            /**
             * Gets the property names, values, and compare flags of `object`.
             *
             * @private
             * @param {Object} object The object to query.
             * @returns {Array} Returns the match data of `object`.
             */
            function getMatchData(object) {
                var result = Object(_keys_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object), length = result.length;
                while (length--) {
                    var key = result[length], value = object[key];
                    result[length] = [key, value, Object(_isStrictComparable_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value)];
                }
                return result;
            }
            /* harmony default export */ __webpack_exports__["default"] = (getMatchData);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_getNative.js": 
        /*!**********************************************!*\
          !*** ./node_modules/lodash-es/_getNative.js ***!
          \**********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _baseIsNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseIsNative.js */ "./node_modules/lodash-es/_baseIsNative.js");
            /* harmony import */ var _getValue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getValue.js */ "./node_modules/lodash-es/_getValue.js");
            /**
             * Gets the native function at `key` of `object`.
             *
             * @private
             * @param {Object} object The object to query.
             * @param {string} key The key of the method to get.
             * @returns {*} Returns the function if it's native, else `undefined`.
             */
            function getNative(object, key) {
                var value = Object(_getValue_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, key);
                return Object(_baseIsNative_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) ? value : undefined;
            }
            /* harmony default export */ __webpack_exports__["default"] = (getNative);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_getPrototype.js": 
        /*!*************************************************!*\
          !*** ./node_modules/lodash-es/_getPrototype.js ***!
          \*************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _overArg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_overArg.js */ "./node_modules/lodash-es/_overArg.js");
            /** Built-in value references. */
            var getPrototype = Object(_overArg_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Object.getPrototypeOf, Object);
            /* harmony default export */ __webpack_exports__["default"] = (getPrototype);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_getRawTag.js": 
        /*!**********************************************!*\
          !*** ./node_modules/lodash-es/_getRawTag.js ***!
          \**********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _Symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Symbol.js */ "./node_modules/lodash-es/_Symbol.js");
            /** Used for built-in method references. */
            var objectProto = Object.prototype;
            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty;
            /**
             * Used to resolve the
             * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
             * of values.
             */
            var nativeObjectToString = objectProto.toString;
            /** Built-in value references. */
            var symToStringTag = _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].toStringTag : undefined;
            /**
             * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
             *
             * @private
             * @param {*} value The value to query.
             * @returns {string} Returns the raw `toStringTag`.
             */
            function getRawTag(value) {
                var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
                try {
                    value[symToStringTag] = undefined;
                    var unmasked = true;
                }
                catch (e) { }
                var result = nativeObjectToString.call(value);
                if (unmasked) {
                    if (isOwn) {
                        value[symToStringTag] = tag;
                    }
                    else {
                        delete value[symToStringTag];
                    }
                }
                return result;
            }
            /* harmony default export */ __webpack_exports__["default"] = (getRawTag);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_getSymbols.js": 
        /*!***********************************************!*\
          !*** ./node_modules/lodash-es/_getSymbols.js ***!
          \***********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _arrayFilter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_arrayFilter.js */ "./node_modules/lodash-es/_arrayFilter.js");
            /* harmony import */ var _stubArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stubArray.js */ "./node_modules/lodash-es/stubArray.js");
            /** Used for built-in method references. */
            var objectProto = Object.prototype;
            /** Built-in value references. */
            var propertyIsEnumerable = objectProto.propertyIsEnumerable;
            /* Built-in method references for those with the same name as other `lodash` methods. */
            var nativeGetSymbols = Object.getOwnPropertySymbols;
            /**
             * Creates an array of the own enumerable symbols of `object`.
             *
             * @private
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of symbols.
             */
            var getSymbols = !nativeGetSymbols ? _stubArray_js__WEBPACK_IMPORTED_MODULE_1__["default"] : function (object) {
                if (object == null) {
                    return [];
                }
                object = Object(object);
                return Object(_arrayFilter_js__WEBPACK_IMPORTED_MODULE_0__["default"])(nativeGetSymbols(object), function (symbol) {
                    return propertyIsEnumerable.call(object, symbol);
                });
            };
            /* harmony default export */ __webpack_exports__["default"] = (getSymbols);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_getSymbolsIn.js": 
        /*!*************************************************!*\
          !*** ./node_modules/lodash-es/_getSymbolsIn.js ***!
          \*************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _arrayPush_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_arrayPush.js */ "./node_modules/lodash-es/_arrayPush.js");
            /* harmony import */ var _getPrototype_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getPrototype.js */ "./node_modules/lodash-es/_getPrototype.js");
            /* harmony import */ var _getSymbols_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_getSymbols.js */ "./node_modules/lodash-es/_getSymbols.js");
            /* harmony import */ var _stubArray_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stubArray.js */ "./node_modules/lodash-es/stubArray.js");
            /* Built-in method references for those with the same name as other `lodash` methods. */
            var nativeGetSymbols = Object.getOwnPropertySymbols;
            /**
             * Creates an array of the own and inherited enumerable symbols of `object`.
             *
             * @private
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of symbols.
             */
            var getSymbolsIn = !nativeGetSymbols ? _stubArray_js__WEBPACK_IMPORTED_MODULE_3__["default"] : function (object) {
                var result = [];
                while (object) {
                    Object(_arrayPush_js__WEBPACK_IMPORTED_MODULE_0__["default"])(result, Object(_getSymbols_js__WEBPACK_IMPORTED_MODULE_2__["default"])(object));
                    object = Object(_getPrototype_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object);
                }
                return result;
            };
            /* harmony default export */ __webpack_exports__["default"] = (getSymbolsIn);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_getTag.js": 
        /*!*******************************************!*\
          !*** ./node_modules/lodash-es/_getTag.js ***!
          \*******************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _DataView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_DataView.js */ "./node_modules/lodash-es/_DataView.js");
            /* harmony import */ var _Map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_Map.js */ "./node_modules/lodash-es/_Map.js");
            /* harmony import */ var _Promise_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_Promise.js */ "./node_modules/lodash-es/_Promise.js");
            /* harmony import */ var _Set_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_Set.js */ "./node_modules/lodash-es/_Set.js");
            /* harmony import */ var _WeakMap_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_WeakMap.js */ "./node_modules/lodash-es/_WeakMap.js");
            /* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_baseGetTag.js */ "./node_modules/lodash-es/_baseGetTag.js");
            /* harmony import */ var _toSource_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_toSource.js */ "./node_modules/lodash-es/_toSource.js");
            /** `Object#toString` result references. */
            var mapTag = '[object Map]', objectTag = '[object Object]', promiseTag = '[object Promise]', setTag = '[object Set]', weakMapTag = '[object WeakMap]';
            var dataViewTag = '[object DataView]';
            /** Used to detect maps, sets, and weakmaps. */
            var dataViewCtorString = Object(_toSource_js__WEBPACK_IMPORTED_MODULE_6__["default"])(_DataView_js__WEBPACK_IMPORTED_MODULE_0__["default"]), mapCtorString = Object(_toSource_js__WEBPACK_IMPORTED_MODULE_6__["default"])(_Map_js__WEBPACK_IMPORTED_MODULE_1__["default"]), promiseCtorString = Object(_toSource_js__WEBPACK_IMPORTED_MODULE_6__["default"])(_Promise_js__WEBPACK_IMPORTED_MODULE_2__["default"]), setCtorString = Object(_toSource_js__WEBPACK_IMPORTED_MODULE_6__["default"])(_Set_js__WEBPACK_IMPORTED_MODULE_3__["default"]), weakMapCtorString = Object(_toSource_js__WEBPACK_IMPORTED_MODULE_6__["default"])(_WeakMap_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
            /**
             * Gets the `toStringTag` of `value`.
             *
             * @private
             * @param {*} value The value to query.
             * @returns {string} Returns the `toStringTag`.
             */
            var getTag = _baseGetTag_js__WEBPACK_IMPORTED_MODULE_5__["default"];
            // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
            if ((_DataView_js__WEBPACK_IMPORTED_MODULE_0__["default"] && getTag(new _DataView_js__WEBPACK_IMPORTED_MODULE_0__["default"](new ArrayBuffer(1))) != dataViewTag) ||
                (_Map_js__WEBPACK_IMPORTED_MODULE_1__["default"] && getTag(new _Map_js__WEBPACK_IMPORTED_MODULE_1__["default"]) != mapTag) ||
                (_Promise_js__WEBPACK_IMPORTED_MODULE_2__["default"] && getTag(_Promise_js__WEBPACK_IMPORTED_MODULE_2__["default"].resolve()) != promiseTag) ||
                (_Set_js__WEBPACK_IMPORTED_MODULE_3__["default"] && getTag(new _Set_js__WEBPACK_IMPORTED_MODULE_3__["default"]) != setTag) ||
                (_WeakMap_js__WEBPACK_IMPORTED_MODULE_4__["default"] && getTag(new _WeakMap_js__WEBPACK_IMPORTED_MODULE_4__["default"]) != weakMapTag)) {
                getTag = function (value) {
                    var result = Object(_baseGetTag_js__WEBPACK_IMPORTED_MODULE_5__["default"])(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? Object(_toSource_js__WEBPACK_IMPORTED_MODULE_6__["default"])(Ctor) : '';
                    if (ctorString) {
                        switch (ctorString) {
                            case dataViewCtorString: return dataViewTag;
                            case mapCtorString: return mapTag;
                            case promiseCtorString: return promiseTag;
                            case setCtorString: return setTag;
                            case weakMapCtorString: return weakMapTag;
                        }
                    }
                    return result;
                };
            }
            /* harmony default export */ __webpack_exports__["default"] = (getTag);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_getValue.js": 
        /*!*********************************************!*\
          !*** ./node_modules/lodash-es/_getValue.js ***!
          \*********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * Gets the value at `key` of `object`.
             *
             * @private
             * @param {Object} [object] The object to query.
             * @param {string} key The key of the property to get.
             * @returns {*} Returns the property value.
             */
            function getValue(object, key) {
                return object == null ? undefined : object[key];
            }
            /* harmony default export */ __webpack_exports__["default"] = (getValue);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_hasPath.js": 
        /*!********************************************!*\
          !*** ./node_modules/lodash-es/_hasPath.js ***!
          \********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _castPath_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_castPath.js */ "./node_modules/lodash-es/_castPath.js");
            /* harmony import */ var _isArguments_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArguments.js */ "./node_modules/lodash-es/isArguments.js");
            /* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js");
            /* harmony import */ var _isIndex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_isIndex.js */ "./node_modules/lodash-es/_isIndex.js");
            /* harmony import */ var _isLength_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./isLength.js */ "./node_modules/lodash-es/isLength.js");
            /* harmony import */ var _toKey_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_toKey.js */ "./node_modules/lodash-es/_toKey.js");
            /**
             * Checks if `path` exists on `object`.
             *
             * @private
             * @param {Object} object The object to query.
             * @param {Array|string} path The path to check.
             * @param {Function} hasFunc The function to check properties.
             * @returns {boolean} Returns `true` if `path` exists, else `false`.
             */
            function hasPath(object, path, hasFunc) {
                path = Object(_castPath_js__WEBPACK_IMPORTED_MODULE_0__["default"])(path, object);
                var index = -1, length = path.length, result = false;
                while (++index < length) {
                    var key = Object(_toKey_js__WEBPACK_IMPORTED_MODULE_5__["default"])(path[index]);
                    if (!(result = object != null && hasFunc(object, key))) {
                        break;
                    }
                    object = object[key];
                }
                if (result || ++index != length) {
                    return result;
                }
                length = object == null ? 0 : object.length;
                return !!length && Object(_isLength_js__WEBPACK_IMPORTED_MODULE_4__["default"])(length) && Object(_isIndex_js__WEBPACK_IMPORTED_MODULE_3__["default"])(key, length) &&
                    (Object(_isArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(object) || Object(_isArguments_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object));
            }
            /* harmony default export */ __webpack_exports__["default"] = (hasPath);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_hashClear.js": 
        /*!**********************************************!*\
          !*** ./node_modules/lodash-es/_hashClear.js ***!
          \**********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _nativeCreate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_nativeCreate.js */ "./node_modules/lodash-es/_nativeCreate.js");
            /**
             * Removes all key-value entries from the hash.
             *
             * @private
             * @name clear
             * @memberOf Hash
             */
            function hashClear() {
                this.__data__ = _nativeCreate_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? Object(_nativeCreate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(null) : {};
                this.size = 0;
            }
            /* harmony default export */ __webpack_exports__["default"] = (hashClear);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_hashDelete.js": 
        /*!***********************************************!*\
          !*** ./node_modules/lodash-es/_hashDelete.js ***!
          \***********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * Removes `key` and its value from the hash.
             *
             * @private
             * @name delete
             * @memberOf Hash
             * @param {Object} hash The hash to modify.
             * @param {string} key The key of the value to remove.
             * @returns {boolean} Returns `true` if the entry was removed, else `false`.
             */
            function hashDelete(key) {
                var result = this.has(key) && delete this.__data__[key];
                this.size -= result ? 1 : 0;
                return result;
            }
            /* harmony default export */ __webpack_exports__["default"] = (hashDelete);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_hashGet.js": 
        /*!********************************************!*\
          !*** ./node_modules/lodash-es/_hashGet.js ***!
          \********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _nativeCreate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_nativeCreate.js */ "./node_modules/lodash-es/_nativeCreate.js");
            /** Used to stand-in for `undefined` hash values. */
            var HASH_UNDEFINED = '__lodash_hash_undefined__';
            /** Used for built-in method references. */
            var objectProto = Object.prototype;
            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty;
            /**
             * Gets the hash value for `key`.
             *
             * @private
             * @name get
             * @memberOf Hash
             * @param {string} key The key of the value to get.
             * @returns {*} Returns the entry value.
             */
            function hashGet(key) {
                var data = this.__data__;
                if (_nativeCreate_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
                    var result = data[key];
                    return result === HASH_UNDEFINED ? undefined : result;
                }
                return hasOwnProperty.call(data, key) ? data[key] : undefined;
            }
            /* harmony default export */ __webpack_exports__["default"] = (hashGet);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_hashHas.js": 
        /*!********************************************!*\
          !*** ./node_modules/lodash-es/_hashHas.js ***!
          \********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _nativeCreate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_nativeCreate.js */ "./node_modules/lodash-es/_nativeCreate.js");
            /** Used for built-in method references. */
            var objectProto = Object.prototype;
            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty;
            /**
             * Checks if a hash value for `key` exists.
             *
             * @private
             * @name has
             * @memberOf Hash
             * @param {string} key The key of the entry to check.
             * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
             */
            function hashHas(key) {
                var data = this.__data__;
                return _nativeCreate_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
            }
            /* harmony default export */ __webpack_exports__["default"] = (hashHas);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_hashSet.js": 
        /*!********************************************!*\
          !*** ./node_modules/lodash-es/_hashSet.js ***!
          \********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _nativeCreate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_nativeCreate.js */ "./node_modules/lodash-es/_nativeCreate.js");
            /** Used to stand-in for `undefined` hash values. */
            var HASH_UNDEFINED = '__lodash_hash_undefined__';
            /**
             * Sets the hash `key` to `value`.
             *
             * @private
             * @name set
             * @memberOf Hash
             * @param {string} key The key of the value to set.
             * @param {*} value The value to set.
             * @returns {Object} Returns the hash instance.
             */
            function hashSet(key, value) {
                var data = this.__data__;
                this.size += this.has(key) ? 0 : 1;
                data[key] = (_nativeCreate_js__WEBPACK_IMPORTED_MODULE_0__["default"] && value === undefined) ? HASH_UNDEFINED : value;
                return this;
            }
            /* harmony default export */ __webpack_exports__["default"] = (hashSet);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_initCloneArray.js": 
        /*!***************************************************!*\
          !*** ./node_modules/lodash-es/_initCloneArray.js ***!
          \***************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /** Used for built-in method references. */
            var objectProto = Object.prototype;
            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty;
            /**
             * Initializes an array clone.
             *
             * @private
             * @param {Array} array The array to clone.
             * @returns {Array} Returns the initialized clone.
             */
            function initCloneArray(array) {
                var length = array.length, result = new array.constructor(length);
                // Add properties assigned by `RegExp#exec`.
                if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
                    result.index = array.index;
                    result.input = array.input;
                }
                return result;
            }
            /* harmony default export */ __webpack_exports__["default"] = (initCloneArray);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_initCloneByTag.js": 
        /*!***************************************************!*\
          !*** ./node_modules/lodash-es/_initCloneByTag.js ***!
          \***************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _cloneArrayBuffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cloneArrayBuffer.js */ "./node_modules/lodash-es/_cloneArrayBuffer.js");
            /* harmony import */ var _cloneDataView_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_cloneDataView.js */ "./node_modules/lodash-es/_cloneDataView.js");
            /* harmony import */ var _cloneRegExp_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_cloneRegExp.js */ "./node_modules/lodash-es/_cloneRegExp.js");
            /* harmony import */ var _cloneSymbol_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_cloneSymbol.js */ "./node_modules/lodash-es/_cloneSymbol.js");
            /* harmony import */ var _cloneTypedArray_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_cloneTypedArray.js */ "./node_modules/lodash-es/_cloneTypedArray.js");
            /** `Object#toString` result references. */
            var boolTag = '[object Boolean]', dateTag = '[object Date]', mapTag = '[object Map]', numberTag = '[object Number]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]';
            var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
            /**
             * Initializes an object clone based on its `toStringTag`.
             *
             * **Note:** This function only supports cloning values with tags of
             * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
             *
             * @private
             * @param {Object} object The object to clone.
             * @param {string} tag The `toStringTag` of the object to clone.
             * @param {boolean} [isDeep] Specify a deep clone.
             * @returns {Object} Returns the initialized clone.
             */
            function initCloneByTag(object, tag, isDeep) {
                var Ctor = object.constructor;
                switch (tag) {
                    case arrayBufferTag:
                        return Object(_cloneArrayBuffer_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object);
                    case boolTag:
                    case dateTag:
                        return new Ctor(+object);
                    case dataViewTag:
                        return Object(_cloneDataView_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, isDeep);
                    case float32Tag:
                    case float64Tag:
                    case int8Tag:
                    case int16Tag:
                    case int32Tag:
                    case uint8Tag:
                    case uint8ClampedTag:
                    case uint16Tag:
                    case uint32Tag:
                        return Object(_cloneTypedArray_js__WEBPACK_IMPORTED_MODULE_4__["default"])(object, isDeep);
                    case mapTag:
                        return new Ctor;
                    case numberTag:
                    case stringTag:
                        return new Ctor(object);
                    case regexpTag:
                        return Object(_cloneRegExp_js__WEBPACK_IMPORTED_MODULE_2__["default"])(object);
                    case setTag:
                        return new Ctor;
                    case symbolTag:
                        return Object(_cloneSymbol_js__WEBPACK_IMPORTED_MODULE_3__["default"])(object);
                }
            }
            /* harmony default export */ __webpack_exports__["default"] = (initCloneByTag);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_initCloneObject.js": 
        /*!****************************************************!*\
          !*** ./node_modules/lodash-es/_initCloneObject.js ***!
          \****************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _baseCreate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseCreate.js */ "./node_modules/lodash-es/_baseCreate.js");
            /* harmony import */ var _getPrototype_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getPrototype.js */ "./node_modules/lodash-es/_getPrototype.js");
            /* harmony import */ var _isPrototype_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_isPrototype.js */ "./node_modules/lodash-es/_isPrototype.js");
            /**
             * Initializes an object clone.
             *
             * @private
             * @param {Object} object The object to clone.
             * @returns {Object} Returns the initialized clone.
             */
            function initCloneObject(object) {
                return (typeof object.constructor == 'function' && !Object(_isPrototype_js__WEBPACK_IMPORTED_MODULE_2__["default"])(object))
                    ? Object(_baseCreate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Object(_getPrototype_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object))
                    : {};
            }
            /* harmony default export */ __webpack_exports__["default"] = (initCloneObject);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_isIndex.js": 
        /*!********************************************!*\
          !*** ./node_modules/lodash-es/_isIndex.js ***!
          \********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /** Used as references for various `Number` constants. */
            var MAX_SAFE_INTEGER = 9007199254740991;
            /** Used to detect unsigned integer values. */
            var reIsUint = /^(?:0|[1-9]\d*)$/;
            /**
             * Checks if `value` is a valid array-like index.
             *
             * @private
             * @param {*} value The value to check.
             * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
             * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
             */
            function isIndex(value, length) {
                var type = typeof value;
                length = length == null ? MAX_SAFE_INTEGER : length;
                return !!length &&
                    (type == 'number' ||
                        (type != 'symbol' && reIsUint.test(value))) &&
                    (value > -1 && value % 1 == 0 && value < length);
            }
            /* harmony default export */ __webpack_exports__["default"] = (isIndex);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_isKey.js": 
        /*!******************************************!*\
          !*** ./node_modules/lodash-es/_isKey.js ***!
          \******************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js");
            /* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isSymbol.js */ "./node_modules/lodash-es/isSymbol.js");
            /** Used to match property names within property paths. */
            var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
            /**
             * Checks if `value` is a property name and not a property path.
             *
             * @private
             * @param {*} value The value to check.
             * @param {Object} [object] The object to query keys on.
             * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
             */
            function isKey(value, object) {
                if (Object(_isArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value)) {
                    return false;
                }
                var type = typeof value;
                if (type == 'number' || type == 'symbol' || type == 'boolean' ||
                    value == null || Object(_isSymbol_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value)) {
                    return true;
                }
                return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
                    (object != null && value in Object(object));
            }
            /* harmony default export */ __webpack_exports__["default"] = (isKey);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_isKeyable.js": 
        /*!**********************************************!*\
          !*** ./node_modules/lodash-es/_isKeyable.js ***!
          \**********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * Checks if `value` is suitable for use as unique object key.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
             */
            function isKeyable(value) {
                var type = typeof value;
                return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
                    ? (value !== '__proto__')
                    : (value === null);
            }
            /* harmony default export */ __webpack_exports__["default"] = (isKeyable);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_isMasked.js": 
        /*!*********************************************!*\
          !*** ./node_modules/lodash-es/_isMasked.js ***!
          \*********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _coreJsData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_coreJsData.js */ "./node_modules/lodash-es/_coreJsData.js");
            /** Used to detect methods masquerading as native. */
            var maskSrcKey = (function () {
                var uid = /[^.]+$/.exec(_coreJsData_js__WEBPACK_IMPORTED_MODULE_0__["default"] && _coreJsData_js__WEBPACK_IMPORTED_MODULE_0__["default"].keys && _coreJsData_js__WEBPACK_IMPORTED_MODULE_0__["default"].keys.IE_PROTO || '');
                return uid ? ('Symbol(src)_1.' + uid) : '';
            }());
            /**
             * Checks if `func` has its source masked.
             *
             * @private
             * @param {Function} func The function to check.
             * @returns {boolean} Returns `true` if `func` is masked, else `false`.
             */
            function isMasked(func) {
                return !!maskSrcKey && (maskSrcKey in func);
            }
            /* harmony default export */ __webpack_exports__["default"] = (isMasked);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_isPrototype.js": 
        /*!************************************************!*\
          !*** ./node_modules/lodash-es/_isPrototype.js ***!
          \************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /** Used for built-in method references. */
            var objectProto = Object.prototype;
            /**
             * Checks if `value` is likely a prototype object.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
             */
            function isPrototype(value) {
                var Ctor = value && value.constructor, proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
                return value === proto;
            }
            /* harmony default export */ __webpack_exports__["default"] = (isPrototype);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_isStrictComparable.js": 
        /*!*******************************************************!*\
          !*** ./node_modules/lodash-es/_isStrictComparable.js ***!
          \*******************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js");
            /**
             * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` if suitable for strict
             *  equality comparisons, else `false`.
             */
            function isStrictComparable(value) {
                return value === value && !Object(_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value);
            }
            /* harmony default export */ __webpack_exports__["default"] = (isStrictComparable);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_listCacheClear.js": 
        /*!***************************************************!*\
          !*** ./node_modules/lodash-es/_listCacheClear.js ***!
          \***************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * Removes all key-value entries from the list cache.
             *
             * @private
             * @name clear
             * @memberOf ListCache
             */
            function listCacheClear() {
                this.__data__ = [];
                this.size = 0;
            }
            /* harmony default export */ __webpack_exports__["default"] = (listCacheClear);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_listCacheDelete.js": 
        /*!****************************************************!*\
          !*** ./node_modules/lodash-es/_listCacheDelete.js ***!
          \****************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _assocIndexOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assocIndexOf.js */ "./node_modules/lodash-es/_assocIndexOf.js");
            /** Used for built-in method references. */
            var arrayProto = Array.prototype;
            /** Built-in value references. */
            var splice = arrayProto.splice;
            /**
             * Removes `key` and its value from the list cache.
             *
             * @private
             * @name delete
             * @memberOf ListCache
             * @param {string} key The key of the value to remove.
             * @returns {boolean} Returns `true` if the entry was removed, else `false`.
             */
            function listCacheDelete(key) {
                var data = this.__data__, index = Object(_assocIndexOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(data, key);
                if (index < 0) {
                    return false;
                }
                var lastIndex = data.length - 1;
                if (index == lastIndex) {
                    data.pop();
                }
                else {
                    splice.call(data, index, 1);
                }
                --this.size;
                return true;
            }
            /* harmony default export */ __webpack_exports__["default"] = (listCacheDelete);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_listCacheGet.js": 
        /*!*************************************************!*\
          !*** ./node_modules/lodash-es/_listCacheGet.js ***!
          \*************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _assocIndexOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assocIndexOf.js */ "./node_modules/lodash-es/_assocIndexOf.js");
            /**
             * Gets the list cache value for `key`.
             *
             * @private
             * @name get
             * @memberOf ListCache
             * @param {string} key The key of the value to get.
             * @returns {*} Returns the entry value.
             */
            function listCacheGet(key) {
                var data = this.__data__, index = Object(_assocIndexOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(data, key);
                return index < 0 ? undefined : data[index][1];
            }
            /* harmony default export */ __webpack_exports__["default"] = (listCacheGet);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_listCacheHas.js": 
        /*!*************************************************!*\
          !*** ./node_modules/lodash-es/_listCacheHas.js ***!
          \*************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _assocIndexOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assocIndexOf.js */ "./node_modules/lodash-es/_assocIndexOf.js");
            /**
             * Checks if a list cache value for `key` exists.
             *
             * @private
             * @name has
             * @memberOf ListCache
             * @param {string} key The key of the entry to check.
             * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
             */
            function listCacheHas(key) {
                return Object(_assocIndexOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this.__data__, key) > -1;
            }
            /* harmony default export */ __webpack_exports__["default"] = (listCacheHas);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_listCacheSet.js": 
        /*!*************************************************!*\
          !*** ./node_modules/lodash-es/_listCacheSet.js ***!
          \*************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _assocIndexOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assocIndexOf.js */ "./node_modules/lodash-es/_assocIndexOf.js");
            /**
             * Sets the list cache `key` to `value`.
             *
             * @private
             * @name set
             * @memberOf ListCache
             * @param {string} key The key of the value to set.
             * @param {*} value The value to set.
             * @returns {Object} Returns the list cache instance.
             */
            function listCacheSet(key, value) {
                var data = this.__data__, index = Object(_assocIndexOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(data, key);
                if (index < 0) {
                    ++this.size;
                    data.push([key, value]);
                }
                else {
                    data[index][1] = value;
                }
                return this;
            }
            /* harmony default export */ __webpack_exports__["default"] = (listCacheSet);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_mapCacheClear.js": 
        /*!**************************************************!*\
          !*** ./node_modules/lodash-es/_mapCacheClear.js ***!
          \**************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Hash.js */ "./node_modules/lodash-es/_Hash.js");
            /* harmony import */ var _ListCache_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_ListCache.js */ "./node_modules/lodash-es/_ListCache.js");
            /* harmony import */ var _Map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_Map.js */ "./node_modules/lodash-es/_Map.js");
            /**
             * Removes all key-value entries from the map.
             *
             * @private
             * @name clear
             * @memberOf MapCache
             */
            function mapCacheClear() {
                this.size = 0;
                this.__data__ = {
                    'hash': new _Hash_js__WEBPACK_IMPORTED_MODULE_0__["default"],
                    'map': new (_Map_js__WEBPACK_IMPORTED_MODULE_2__["default"] || _ListCache_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
                    'string': new _Hash_js__WEBPACK_IMPORTED_MODULE_0__["default"]
                };
            }
            /* harmony default export */ __webpack_exports__["default"] = (mapCacheClear);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_mapCacheDelete.js": 
        /*!***************************************************!*\
          !*** ./node_modules/lodash-es/_mapCacheDelete.js ***!
          \***************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _getMapData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getMapData.js */ "./node_modules/lodash-es/_getMapData.js");
            /**
             * Removes `key` and its value from the map.
             *
             * @private
             * @name delete
             * @memberOf MapCache
             * @param {string} key The key of the value to remove.
             * @returns {boolean} Returns `true` if the entry was removed, else `false`.
             */
            function mapCacheDelete(key) {
                var result = Object(_getMapData_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this, key)['delete'](key);
                this.size -= result ? 1 : 0;
                return result;
            }
            /* harmony default export */ __webpack_exports__["default"] = (mapCacheDelete);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_mapCacheGet.js": 
        /*!************************************************!*\
          !*** ./node_modules/lodash-es/_mapCacheGet.js ***!
          \************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _getMapData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getMapData.js */ "./node_modules/lodash-es/_getMapData.js");
            /**
             * Gets the map value for `key`.
             *
             * @private
             * @name get
             * @memberOf MapCache
             * @param {string} key The key of the value to get.
             * @returns {*} Returns the entry value.
             */
            function mapCacheGet(key) {
                return Object(_getMapData_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this, key).get(key);
            }
            /* harmony default export */ __webpack_exports__["default"] = (mapCacheGet);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_mapCacheHas.js": 
        /*!************************************************!*\
          !*** ./node_modules/lodash-es/_mapCacheHas.js ***!
          \************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _getMapData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getMapData.js */ "./node_modules/lodash-es/_getMapData.js");
            /**
             * Checks if a map value for `key` exists.
             *
             * @private
             * @name has
             * @memberOf MapCache
             * @param {string} key The key of the entry to check.
             * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
             */
            function mapCacheHas(key) {
                return Object(_getMapData_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this, key).has(key);
            }
            /* harmony default export */ __webpack_exports__["default"] = (mapCacheHas);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_mapCacheSet.js": 
        /*!************************************************!*\
          !*** ./node_modules/lodash-es/_mapCacheSet.js ***!
          \************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _getMapData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getMapData.js */ "./node_modules/lodash-es/_getMapData.js");
            /**
             * Sets the map `key` to `value`.
             *
             * @private
             * @name set
             * @memberOf MapCache
             * @param {string} key The key of the value to set.
             * @param {*} value The value to set.
             * @returns {Object} Returns the map cache instance.
             */
            function mapCacheSet(key, value) {
                var data = Object(_getMapData_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this, key), size = data.size;
                data.set(key, value);
                this.size += data.size == size ? 0 : 1;
                return this;
            }
            /* harmony default export */ __webpack_exports__["default"] = (mapCacheSet);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_mapToArray.js": 
        /*!***********************************************!*\
          !*** ./node_modules/lodash-es/_mapToArray.js ***!
          \***********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * Converts `map` to its key-value pairs.
             *
             * @private
             * @param {Object} map The map to convert.
             * @returns {Array} Returns the key-value pairs.
             */
            function mapToArray(map) {
                var index = -1, result = Array(map.size);
                map.forEach(function (value, key) {
                    result[++index] = [key, value];
                });
                return result;
            }
            /* harmony default export */ __webpack_exports__["default"] = (mapToArray);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_matchesStrictComparable.js": 
        /*!************************************************************!*\
          !*** ./node_modules/lodash-es/_matchesStrictComparable.js ***!
          \************************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * A specialized version of `matchesProperty` for source values suitable
             * for strict equality comparisons, i.e. `===`.
             *
             * @private
             * @param {string} key The key of the property to get.
             * @param {*} srcValue The value to match.
             * @returns {Function} Returns the new spec function.
             */
            function matchesStrictComparable(key, srcValue) {
                return function (object) {
                    if (object == null) {
                        return false;
                    }
                    return object[key] === srcValue &&
                        (srcValue !== undefined || (key in Object(object)));
                };
            }
            /* harmony default export */ __webpack_exports__["default"] = (matchesStrictComparable);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_memoizeCapped.js": 
        /*!**************************************************!*\
          !*** ./node_modules/lodash-es/_memoizeCapped.js ***!
          \**************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _memoize_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./memoize.js */ "./node_modules/lodash-es/memoize.js");
            /** Used as the maximum memoize cache size. */
            var MAX_MEMOIZE_SIZE = 500;
            /**
             * A specialized version of `_.memoize` which clears the memoized function's
             * cache when it exceeds `MAX_MEMOIZE_SIZE`.
             *
             * @private
             * @param {Function} func The function to have its output memoized.
             * @returns {Function} Returns the new memoized function.
             */
            function memoizeCapped(func) {
                var result = Object(_memoize_js__WEBPACK_IMPORTED_MODULE_0__["default"])(func, function (key) {
                    if (cache.size === MAX_MEMOIZE_SIZE) {
                        cache.clear();
                    }
                    return key;
                });
                var cache = result.cache;
                return result;
            }
            /* harmony default export */ __webpack_exports__["default"] = (memoizeCapped);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_nativeCreate.js": 
        /*!*************************************************!*\
          !*** ./node_modules/lodash-es/_nativeCreate.js ***!
          \*************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _getNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getNative.js */ "./node_modules/lodash-es/_getNative.js");
            /* Built-in method references that are verified to be native. */
            var nativeCreate = Object(_getNative_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Object, 'create');
            /* harmony default export */ __webpack_exports__["default"] = (nativeCreate);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_nativeKeys.js": 
        /*!***********************************************!*\
          !*** ./node_modules/lodash-es/_nativeKeys.js ***!
          \***********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _overArg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_overArg.js */ "./node_modules/lodash-es/_overArg.js");
            /* Built-in method references for those with the same name as other `lodash` methods. */
            var nativeKeys = Object(_overArg_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Object.keys, Object);
            /* harmony default export */ __webpack_exports__["default"] = (nativeKeys);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_nativeKeysIn.js": 
        /*!*************************************************!*\
          !*** ./node_modules/lodash-es/_nativeKeysIn.js ***!
          \*************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * This function is like
             * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
             * except that it includes inherited enumerable properties.
             *
             * @private
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of property names.
             */
            function nativeKeysIn(object) {
                var result = [];
                if (object != null) {
                    for (var key in Object(object)) {
                        result.push(key);
                    }
                }
                return result;
            }
            /* harmony default export */ __webpack_exports__["default"] = (nativeKeysIn);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_nodeUtil.js": 
        /*!*********************************************!*\
          !*** ./node_modules/lodash-es/_nodeUtil.js ***!
          \*********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* WEBPACK VAR INJECTION */ (function (module) {
                var _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_freeGlobal.js */ "./node_modules/lodash-es/_freeGlobal.js");
                /** Detect free variable `exports`. */
                var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
                /** Detect free variable `module`. */
                var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
                /** Detect the popular CommonJS extension `module.exports`. */
                var moduleExports = freeModule && freeModule.exports === freeExports;
                /** Detect free variable `process` from Node.js. */
                var freeProcess = moduleExports && _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__["default"].process;
                /** Used to access faster Node.js helpers. */
                var nodeUtil = (function () {
                    try {
                        // Use `util.types` for Node.js 10+.
                        var types = freeModule && freeModule.require && freeModule.require('util').types;
                        if (types) {
                            return types;
                        }
                        // Legacy `process.binding('util')` for Node.js < 10.
                        return freeProcess && freeProcess.binding && freeProcess.binding('util');
                    }
                    catch (e) { }
                }());
                /* harmony default export */ __webpack_exports__["default"] = (nodeUtil);
                /* WEBPACK VAR INJECTION */ 
            }.call(this, __webpack_require__(/*! ./../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)));
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_objectToString.js": 
        /*!***************************************************!*\
          !*** ./node_modules/lodash-es/_objectToString.js ***!
          \***************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /** Used for built-in method references. */
            var objectProto = Object.prototype;
            /**
             * Used to resolve the
             * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
             * of values.
             */
            var nativeObjectToString = objectProto.toString;
            /**
             * Converts `value` to a string using `Object.prototype.toString`.
             *
             * @private
             * @param {*} value The value to convert.
             * @returns {string} Returns the converted string.
             */
            function objectToString(value) {
                return nativeObjectToString.call(value);
            }
            /* harmony default export */ __webpack_exports__["default"] = (objectToString);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_overArg.js": 
        /*!********************************************!*\
          !*** ./node_modules/lodash-es/_overArg.js ***!
          \********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * Creates a unary function that invokes `func` with its argument transformed.
             *
             * @private
             * @param {Function} func The function to wrap.
             * @param {Function} transform The argument transform.
             * @returns {Function} Returns the new function.
             */
            function overArg(func, transform) {
                return function (arg) {
                    return func(transform(arg));
                };
            }
            /* harmony default export */ __webpack_exports__["default"] = (overArg);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_root.js": 
        /*!*****************************************!*\
          !*** ./node_modules/lodash-es/_root.js ***!
          \*****************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_freeGlobal.js */ "./node_modules/lodash-es/_freeGlobal.js");
            /** Detect free variable `self`. */
            var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
            /** Used as a reference to the global object. */
            var root = _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__["default"] || freeSelf || Function('return this')();
            /* harmony default export */ __webpack_exports__["default"] = (root);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_setCacheAdd.js": 
        /*!************************************************!*\
          !*** ./node_modules/lodash-es/_setCacheAdd.js ***!
          \************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /** Used to stand-in for `undefined` hash values. */
            var HASH_UNDEFINED = '__lodash_hash_undefined__';
            /**
             * Adds `value` to the array cache.
             *
             * @private
             * @name add
             * @memberOf SetCache
             * @alias push
             * @param {*} value The value to cache.
             * @returns {Object} Returns the cache instance.
             */
            function setCacheAdd(value) {
                this.__data__.set(value, HASH_UNDEFINED);
                return this;
            }
            /* harmony default export */ __webpack_exports__["default"] = (setCacheAdd);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_setCacheHas.js": 
        /*!************************************************!*\
          !*** ./node_modules/lodash-es/_setCacheHas.js ***!
          \************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * Checks if `value` is in the array cache.
             *
             * @private
             * @name has
             * @memberOf SetCache
             * @param {*} value The value to search for.
             * @returns {number} Returns `true` if `value` is found, else `false`.
             */
            function setCacheHas(value) {
                return this.__data__.has(value);
            }
            /* harmony default export */ __webpack_exports__["default"] = (setCacheHas);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_setToArray.js": 
        /*!***********************************************!*\
          !*** ./node_modules/lodash-es/_setToArray.js ***!
          \***********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * Converts `set` to an array of its values.
             *
             * @private
             * @param {Object} set The set to convert.
             * @returns {Array} Returns the values.
             */
            function setToArray(set) {
                var index = -1, result = Array(set.size);
                set.forEach(function (value) {
                    result[++index] = value;
                });
                return result;
            }
            /* harmony default export */ __webpack_exports__["default"] = (setToArray);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_stackClear.js": 
        /*!***********************************************!*\
          !*** ./node_modules/lodash-es/_stackClear.js ***!
          \***********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _ListCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_ListCache.js */ "./node_modules/lodash-es/_ListCache.js");
            /**
             * Removes all key-value entries from the stack.
             *
             * @private
             * @name clear
             * @memberOf Stack
             */
            function stackClear() {
                this.__data__ = new _ListCache_js__WEBPACK_IMPORTED_MODULE_0__["default"];
                this.size = 0;
            }
            /* harmony default export */ __webpack_exports__["default"] = (stackClear);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_stackDelete.js": 
        /*!************************************************!*\
          !*** ./node_modules/lodash-es/_stackDelete.js ***!
          \************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * Removes `key` and its value from the stack.
             *
             * @private
             * @name delete
             * @memberOf Stack
             * @param {string} key The key of the value to remove.
             * @returns {boolean} Returns `true` if the entry was removed, else `false`.
             */
            function stackDelete(key) {
                var data = this.__data__, result = data['delete'](key);
                this.size = data.size;
                return result;
            }
            /* harmony default export */ __webpack_exports__["default"] = (stackDelete);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_stackGet.js": 
        /*!*********************************************!*\
          !*** ./node_modules/lodash-es/_stackGet.js ***!
          \*********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * Gets the stack value for `key`.
             *
             * @private
             * @name get
             * @memberOf Stack
             * @param {string} key The key of the value to get.
             * @returns {*} Returns the entry value.
             */
            function stackGet(key) {
                return this.__data__.get(key);
            }
            /* harmony default export */ __webpack_exports__["default"] = (stackGet);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_stackHas.js": 
        /*!*********************************************!*\
          !*** ./node_modules/lodash-es/_stackHas.js ***!
          \*********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * Checks if a stack value for `key` exists.
             *
             * @private
             * @name has
             * @memberOf Stack
             * @param {string} key The key of the entry to check.
             * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
             */
            function stackHas(key) {
                return this.__data__.has(key);
            }
            /* harmony default export */ __webpack_exports__["default"] = (stackHas);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_stackSet.js": 
        /*!*********************************************!*\
          !*** ./node_modules/lodash-es/_stackSet.js ***!
          \*********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _ListCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_ListCache.js */ "./node_modules/lodash-es/_ListCache.js");
            /* harmony import */ var _Map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_Map.js */ "./node_modules/lodash-es/_Map.js");
            /* harmony import */ var _MapCache_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_MapCache.js */ "./node_modules/lodash-es/_MapCache.js");
            /** Used as the size to enable large array optimizations. */
            var LARGE_ARRAY_SIZE = 200;
            /**
             * Sets the stack `key` to `value`.
             *
             * @private
             * @name set
             * @memberOf Stack
             * @param {string} key The key of the value to set.
             * @param {*} value The value to set.
             * @returns {Object} Returns the stack cache instance.
             */
            function stackSet(key, value) {
                var data = this.__data__;
                if (data instanceof _ListCache_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
                    var pairs = data.__data__;
                    if (!_Map_js__WEBPACK_IMPORTED_MODULE_1__["default"] || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
                        pairs.push([key, value]);
                        this.size = ++data.size;
                        return this;
                    }
                    data = this.__data__ = new _MapCache_js__WEBPACK_IMPORTED_MODULE_2__["default"](pairs);
                }
                data.set(key, value);
                this.size = data.size;
                return this;
            }
            /* harmony default export */ __webpack_exports__["default"] = (stackSet);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_stringToPath.js": 
        /*!*************************************************!*\
          !*** ./node_modules/lodash-es/_stringToPath.js ***!
          \*************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _memoizeCapped_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_memoizeCapped.js */ "./node_modules/lodash-es/_memoizeCapped.js");
            /** Used to match property names within property paths. */
            var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
            /** Used to match backslashes in property paths. */
            var reEscapeChar = /\\(\\)?/g;
            /**
             * Converts `string` to a property path array.
             *
             * @private
             * @param {string} string The string to convert.
             * @returns {Array} Returns the property path array.
             */
            var stringToPath = Object(_memoizeCapped_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function (string) {
                var result = [];
                if (string.charCodeAt(0) === 46 /* . */) {
                    result.push('');
                }
                string.replace(rePropName, function (match, number, quote, subString) {
                    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
                });
                return result;
            });
            /* harmony default export */ __webpack_exports__["default"] = (stringToPath);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_toKey.js": 
        /*!******************************************!*\
          !*** ./node_modules/lodash-es/_toKey.js ***!
          \******************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isSymbol.js */ "./node_modules/lodash-es/isSymbol.js");
            /** Used as references for various `Number` constants. */
            var INFINITY = 1 / 0;
            /**
             * Converts `value` to a string key if it's not a string or symbol.
             *
             * @private
             * @param {*} value The value to inspect.
             * @returns {string|symbol} Returns the key.
             */
            function toKey(value) {
                if (typeof value == 'string' || Object(_isSymbol_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value)) {
                    return value;
                }
                var result = (value + '');
                return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
            }
            /* harmony default export */ __webpack_exports__["default"] = (toKey);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/_toSource.js": 
        /*!*********************************************!*\
          !*** ./node_modules/lodash-es/_toSource.js ***!
          \*********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /** Used for built-in method references. */
            var funcProto = Function.prototype;
            /** Used to resolve the decompiled source of functions. */
            var funcToString = funcProto.toString;
            /**
             * Converts `func` to its source code.
             *
             * @private
             * @param {Function} func The function to convert.
             * @returns {string} Returns the source code.
             */
            function toSource(func) {
                if (func != null) {
                    try {
                        return funcToString.call(func);
                    }
                    catch (e) { }
                    try {
                        return (func + '');
                    }
                    catch (e) { }
                }
                return '';
            }
            /* harmony default export */ __webpack_exports__["default"] = (toSource);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/cloneDeep.js": 
        /*!*********************************************!*\
          !*** ./node_modules/lodash-es/cloneDeep.js ***!
          \*********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _baseClone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseClone.js */ "./node_modules/lodash-es/_baseClone.js");
            /** Used to compose bitmasks for cloning. */
            var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
            /**
             * This method is like `_.clone` except that it recursively clones `value`.
             *
             * @static
             * @memberOf _
             * @since 1.0.0
             * @category Lang
             * @param {*} value The value to recursively clone.
             * @returns {*} Returns the deep cloned value.
             * @see _.clone
             * @example
             *
             * var objects = [{ 'a': 1 }, { 'b': 2 }];
             *
             * var deep = _.cloneDeep(objects);
             * console.log(deep[0] === objects[0]);
             * // => false
             */
            function cloneDeep(value) {
                return Object(_baseClone_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
            }
            /* harmony default export */ __webpack_exports__["default"] = (cloneDeep);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/eq.js": 
        /*!**************************************!*\
          !*** ./node_modules/lodash-es/eq.js ***!
          \**************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * Performs a
             * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
             * comparison between two values to determine if they are equivalent.
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Lang
             * @param {*} value The value to compare.
             * @param {*} other The other value to compare.
             * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
             * @example
             *
             * var object = { 'a': 1 };
             * var other = { 'a': 1 };
             *
             * _.eq(object, object);
             * // => true
             *
             * _.eq(object, other);
             * // => false
             *
             * _.eq('a', 'a');
             * // => true
             *
             * _.eq('a', Object('a'));
             * // => false
             *
             * _.eq(NaN, NaN);
             * // => true
             */
            function eq(value, other) {
                return value === other || (value !== value && other !== other);
            }
            /* harmony default export */ __webpack_exports__["default"] = (eq);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/filter.js": 
        /*!******************************************!*\
          !*** ./node_modules/lodash-es/filter.js ***!
          \******************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _arrayFilter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_arrayFilter.js */ "./node_modules/lodash-es/_arrayFilter.js");
            /* harmony import */ var _baseFilter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseFilter.js */ "./node_modules/lodash-es/_baseFilter.js");
            /* harmony import */ var _baseIteratee_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseIteratee.js */ "./node_modules/lodash-es/_baseIteratee.js");
            /* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js");
            /**
             * Iterates over elements of `collection`, returning an array of all elements
             * `predicate` returns truthy for. The predicate is invoked with three
             * arguments: (value, index|key, collection).
             *
             * **Note:** Unlike `_.remove`, this method returns a new array.
             *
             * @static
             * @memberOf _
             * @since 0.1.0
             * @category Collection
             * @param {Array|Object} collection The collection to iterate over.
             * @param {Function} [predicate=_.identity] The function invoked per iteration.
             * @returns {Array} Returns the new filtered array.
             * @see _.reject
             * @example
             *
             * var users = [
             *   { 'user': 'barney', 'age': 36, 'active': true },
             *   { 'user': 'fred',   'age': 40, 'active': false }
             * ];
             *
             * _.filter(users, function(o) { return !o.active; });
             * // => objects for ['fred']
             *
             * // The `_.matches` iteratee shorthand.
             * _.filter(users, { 'age': 36, 'active': true });
             * // => objects for ['barney']
             *
             * // The `_.matchesProperty` iteratee shorthand.
             * _.filter(users, ['active', false]);
             * // => objects for ['fred']
             *
             * // The `_.property` iteratee shorthand.
             * _.filter(users, 'active');
             * // => objects for ['barney']
             */
            function filter(collection, predicate) {
                var func = Object(_isArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(collection) ? _arrayFilter_js__WEBPACK_IMPORTED_MODULE_0__["default"] : _baseFilter_js__WEBPACK_IMPORTED_MODULE_1__["default"];
                return func(collection, Object(_baseIteratee_js__WEBPACK_IMPORTED_MODULE_2__["default"])(predicate, 3));
            }
            /* harmony default export */ __webpack_exports__["default"] = (filter);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/get.js": 
        /*!***************************************!*\
          !*** ./node_modules/lodash-es/get.js ***!
          \***************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _baseGet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseGet.js */ "./node_modules/lodash-es/_baseGet.js");
            /**
             * Gets the value at `path` of `object`. If the resolved value is
             * `undefined`, the `defaultValue` is returned in its place.
             *
             * @static
             * @memberOf _
             * @since 3.7.0
             * @category Object
             * @param {Object} object The object to query.
             * @param {Array|string} path The path of the property to get.
             * @param {*} [defaultValue] The value returned for `undefined` resolved values.
             * @returns {*} Returns the resolved value.
             * @example
             *
             * var object = { 'a': [{ 'b': { 'c': 3 } }] };
             *
             * _.get(object, 'a[0].b.c');
             * // => 3
             *
             * _.get(object, ['a', '0', 'b', 'c']);
             * // => 3
             *
             * _.get(object, 'a.b.c', 'default');
             * // => 'default'
             */
            function get(object, path, defaultValue) {
                var result = object == null ? undefined : Object(_baseGet_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, path);
                return result === undefined ? defaultValue : result;
            }
            /* harmony default export */ __webpack_exports__["default"] = (get);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/hasIn.js": 
        /*!*****************************************!*\
          !*** ./node_modules/lodash-es/hasIn.js ***!
          \*****************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _baseHasIn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseHasIn.js */ "./node_modules/lodash-es/_baseHasIn.js");
            /* harmony import */ var _hasPath_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_hasPath.js */ "./node_modules/lodash-es/_hasPath.js");
            /**
             * Checks if `path` is a direct or inherited property of `object`.
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Object
             * @param {Object} object The object to query.
             * @param {Array|string} path The path to check.
             * @returns {boolean} Returns `true` if `path` exists, else `false`.
             * @example
             *
             * var object = _.create({ 'a': _.create({ 'b': 2 }) });
             *
             * _.hasIn(object, 'a');
             * // => true
             *
             * _.hasIn(object, 'a.b');
             * // => true
             *
             * _.hasIn(object, ['a', 'b']);
             * // => true
             *
             * _.hasIn(object, 'b');
             * // => false
             */
            function hasIn(object, path) {
                return object != null && Object(_hasPath_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, path, _baseHasIn_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
            }
            /* harmony default export */ __webpack_exports__["default"] = (hasIn);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/identity.js": 
        /*!********************************************!*\
          !*** ./node_modules/lodash-es/identity.js ***!
          \********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * This method returns the first argument it receives.
             *
             * @static
             * @since 0.1.0
             * @memberOf _
             * @category Util
             * @param {*} value Any value.
             * @returns {*} Returns `value`.
             * @example
             *
             * var object = { 'a': 1 };
             *
             * console.log(_.identity(object) === object);
             * // => true
             */
            function identity(value) {
                return value;
            }
            /* harmony default export */ __webpack_exports__["default"] = (identity);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/isArguments.js": 
        /*!***********************************************!*\
          !*** ./node_modules/lodash-es/isArguments.js ***!
          \***********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _baseIsArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseIsArguments.js */ "./node_modules/lodash-es/_baseIsArguments.js");
            /* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isObjectLike.js */ "./node_modules/lodash-es/isObjectLike.js");
            /** Used for built-in method references. */
            var objectProto = Object.prototype;
            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty;
            /** Built-in value references. */
            var propertyIsEnumerable = objectProto.propertyIsEnumerable;
            /**
             * Checks if `value` is likely an `arguments` object.
             *
             * @static
             * @memberOf _
             * @since 0.1.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is an `arguments` object,
             *  else `false`.
             * @example
             *
             * _.isArguments(function() { return arguments; }());
             * // => true
             *
             * _.isArguments([1, 2, 3]);
             * // => false
             */
            var isArguments = Object(_baseIsArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function () { return arguments; }()) ? _baseIsArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"] : function (value) {
                return Object(_isObjectLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) && hasOwnProperty.call(value, 'callee') &&
                    !propertyIsEnumerable.call(value, 'callee');
            };
            /* harmony default export */ __webpack_exports__["default"] = (isArguments);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/isArray.js": 
        /*!*******************************************!*\
          !*** ./node_modules/lodash-es/isArray.js ***!
          \*******************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * Checks if `value` is classified as an `Array` object.
             *
             * @static
             * @memberOf _
             * @since 0.1.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is an array, else `false`.
             * @example
             *
             * _.isArray([1, 2, 3]);
             * // => true
             *
             * _.isArray(document.body.children);
             * // => false
             *
             * _.isArray('abc');
             * // => false
             *
             * _.isArray(_.noop);
             * // => false
             */
            var isArray = Array.isArray;
            /* harmony default export */ __webpack_exports__["default"] = (isArray);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/isArrayLike.js": 
        /*!***********************************************!*\
          !*** ./node_modules/lodash-es/isArrayLike.js ***!
          \***********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/lodash-es/isFunction.js");
            /* harmony import */ var _isLength_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isLength.js */ "./node_modules/lodash-es/isLength.js");
            /**
             * Checks if `value` is array-like. A value is considered array-like if it's
             * not a function and has a `value.length` that's an integer greater than or
             * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
             * @example
             *
             * _.isArrayLike([1, 2, 3]);
             * // => true
             *
             * _.isArrayLike(document.body.children);
             * // => true
             *
             * _.isArrayLike('abc');
             * // => true
             *
             * _.isArrayLike(_.noop);
             * // => false
             */
            function isArrayLike(value) {
                return value != null && Object(_isLength_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value.length) && !Object(_isFunction_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value);
            }
            /* harmony default export */ __webpack_exports__["default"] = (isArrayLike);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/isBuffer.js": 
        /*!********************************************!*\
          !*** ./node_modules/lodash-es/isBuffer.js ***!
          \********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* WEBPACK VAR INJECTION */ (function (module) {
                var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");
                /* harmony import */ var _stubFalse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stubFalse.js */ "./node_modules/lodash-es/stubFalse.js");
                /** Detect free variable `exports`. */
                var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
                /** Detect free variable `module`. */
                var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
                /** Detect the popular CommonJS extension `module.exports`. */
                var moduleExports = freeModule && freeModule.exports === freeExports;
                /** Built-in value references. */
                var Buffer = moduleExports ? _root_js__WEBPACK_IMPORTED_MODULE_0__["default"].Buffer : undefined;
                /* Built-in method references for those with the same name as other `lodash` methods. */
                var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
                /**
                 * Checks if `value` is a buffer.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.3.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
                 * @example
                 *
                 * _.isBuffer(new Buffer(2));
                 * // => true
                 *
                 * _.isBuffer(new Uint8Array(2));
                 * // => false
                 */
                var isBuffer = nativeIsBuffer || _stubFalse_js__WEBPACK_IMPORTED_MODULE_1__["default"];
                /* harmony default export */ __webpack_exports__["default"] = (isBuffer);
                /* WEBPACK VAR INJECTION */ 
            }.call(this, __webpack_require__(/*! ./../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)));
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/isEqual.js": 
        /*!*******************************************!*\
          !*** ./node_modules/lodash-es/isEqual.js ***!
          \*******************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _baseIsEqual_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseIsEqual.js */ "./node_modules/lodash-es/_baseIsEqual.js");
            /**
             * Performs a deep comparison between two values to determine if they are
             * equivalent.
             *
             * **Note:** This method supports comparing arrays, array buffers, booleans,
             * date objects, error objects, maps, numbers, `Object` objects, regexes,
             * sets, strings, symbols, and typed arrays. `Object` objects are compared
             * by their own, not inherited, enumerable properties. Functions and DOM
             * nodes are compared by strict equality, i.e. `===`.
             *
             * @static
             * @memberOf _
             * @since 0.1.0
             * @category Lang
             * @param {*} value The value to compare.
             * @param {*} other The other value to compare.
             * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
             * @example
             *
             * var object = { 'a': 1 };
             * var other = { 'a': 1 };
             *
             * _.isEqual(object, other);
             * // => true
             *
             * object === other;
             * // => false
             */
            function isEqual(value, other) {
                return Object(_baseIsEqual_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value, other);
            }
            /* harmony default export */ __webpack_exports__["default"] = (isEqual);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/isFunction.js": 
        /*!**********************************************!*\
          !*** ./node_modules/lodash-es/isFunction.js ***!
          \**********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseGetTag.js */ "./node_modules/lodash-es/_baseGetTag.js");
            /* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js");
            /** `Object#toString` result references. */
            var asyncTag = '[object AsyncFunction]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', proxyTag = '[object Proxy]';
            /**
             * Checks if `value` is classified as a `Function` object.
             *
             * @static
             * @memberOf _
             * @since 0.1.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a function, else `false`.
             * @example
             *
             * _.isFunction(_);
             * // => true
             *
             * _.isFunction(/abc/);
             * // => false
             */
            function isFunction(value) {
                if (!Object(_isObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value)) {
                    return false;
                }
                // The use of `Object#toString` avoids issues with the `typeof` operator
                // in Safari 9 which returns 'object' for typed arrays and other constructors.
                var tag = Object(_baseGetTag_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value);
                return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
            }
            /* harmony default export */ __webpack_exports__["default"] = (isFunction);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/isLength.js": 
        /*!********************************************!*\
          !*** ./node_modules/lodash-es/isLength.js ***!
          \********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /** Used as references for various `Number` constants. */
            var MAX_SAFE_INTEGER = 9007199254740991;
            /**
             * Checks if `value` is a valid array-like length.
             *
             * **Note:** This method is loosely based on
             * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
             * @example
             *
             * _.isLength(3);
             * // => true
             *
             * _.isLength(Number.MIN_VALUE);
             * // => false
             *
             * _.isLength(Infinity);
             * // => false
             *
             * _.isLength('3');
             * // => false
             */
            function isLength(value) {
                return typeof value == 'number' &&
                    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
            }
            /* harmony default export */ __webpack_exports__["default"] = (isLength);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/isMap.js": 
        /*!*****************************************!*\
          !*** ./node_modules/lodash-es/isMap.js ***!
          \*****************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _baseIsMap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseIsMap.js */ "./node_modules/lodash-es/_baseIsMap.js");
            /* harmony import */ var _baseUnary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseUnary.js */ "./node_modules/lodash-es/_baseUnary.js");
            /* harmony import */ var _nodeUtil_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_nodeUtil.js */ "./node_modules/lodash-es/_nodeUtil.js");
            /* Node.js helper references. */
            var nodeIsMap = _nodeUtil_js__WEBPACK_IMPORTED_MODULE_2__["default"] && _nodeUtil_js__WEBPACK_IMPORTED_MODULE_2__["default"].isMap;
            /**
             * Checks if `value` is classified as a `Map` object.
             *
             * @static
             * @memberOf _
             * @since 4.3.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a map, else `false`.
             * @example
             *
             * _.isMap(new Map);
             * // => true
             *
             * _.isMap(new WeakMap);
             * // => false
             */
            var isMap = nodeIsMap ? Object(_baseUnary_js__WEBPACK_IMPORTED_MODULE_1__["default"])(nodeIsMap) : _baseIsMap_js__WEBPACK_IMPORTED_MODULE_0__["default"];
            /* harmony default export */ __webpack_exports__["default"] = (isMap);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/isObject.js": 
        /*!********************************************!*\
          !*** ./node_modules/lodash-es/isObject.js ***!
          \********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * Checks if `value` is the
             * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
             * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
             *
             * @static
             * @memberOf _
             * @since 0.1.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is an object, else `false`.
             * @example
             *
             * _.isObject({});
             * // => true
             *
             * _.isObject([1, 2, 3]);
             * // => true
             *
             * _.isObject(_.noop);
             * // => true
             *
             * _.isObject(null);
             * // => false
             */
            function isObject(value) {
                var type = typeof value;
                return value != null && (type == 'object' || type == 'function');
            }
            /* harmony default export */ __webpack_exports__["default"] = (isObject);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/isObjectLike.js": 
        /*!************************************************!*\
          !*** ./node_modules/lodash-es/isObjectLike.js ***!
          \************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * Checks if `value` is object-like. A value is object-like if it's not `null`
             * and has a `typeof` result of "object".
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
             * @example
             *
             * _.isObjectLike({});
             * // => true
             *
             * _.isObjectLike([1, 2, 3]);
             * // => true
             *
             * _.isObjectLike(_.noop);
             * // => false
             *
             * _.isObjectLike(null);
             * // => false
             */
            function isObjectLike(value) {
                return value != null && typeof value == 'object';
            }
            /* harmony default export */ __webpack_exports__["default"] = (isObjectLike);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/isSet.js": 
        /*!*****************************************!*\
          !*** ./node_modules/lodash-es/isSet.js ***!
          \*****************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _baseIsSet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseIsSet.js */ "./node_modules/lodash-es/_baseIsSet.js");
            /* harmony import */ var _baseUnary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseUnary.js */ "./node_modules/lodash-es/_baseUnary.js");
            /* harmony import */ var _nodeUtil_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_nodeUtil.js */ "./node_modules/lodash-es/_nodeUtil.js");
            /* Node.js helper references. */
            var nodeIsSet = _nodeUtil_js__WEBPACK_IMPORTED_MODULE_2__["default"] && _nodeUtil_js__WEBPACK_IMPORTED_MODULE_2__["default"].isSet;
            /**
             * Checks if `value` is classified as a `Set` object.
             *
             * @static
             * @memberOf _
             * @since 4.3.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a set, else `false`.
             * @example
             *
             * _.isSet(new Set);
             * // => true
             *
             * _.isSet(new WeakSet);
             * // => false
             */
            var isSet = nodeIsSet ? Object(_baseUnary_js__WEBPACK_IMPORTED_MODULE_1__["default"])(nodeIsSet) : _baseIsSet_js__WEBPACK_IMPORTED_MODULE_0__["default"];
            /* harmony default export */ __webpack_exports__["default"] = (isSet);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/isSymbol.js": 
        /*!********************************************!*\
          !*** ./node_modules/lodash-es/isSymbol.js ***!
          \********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseGetTag.js */ "./node_modules/lodash-es/_baseGetTag.js");
            /* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isObjectLike.js */ "./node_modules/lodash-es/isObjectLike.js");
            /** `Object#toString` result references. */
            var symbolTag = '[object Symbol]';
            /**
             * Checks if `value` is classified as a `Symbol` primitive or object.
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
             * @example
             *
             * _.isSymbol(Symbol.iterator);
             * // => true
             *
             * _.isSymbol('abc');
             * // => false
             */
            function isSymbol(value) {
                return typeof value == 'symbol' ||
                    (Object(_isObjectLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) && Object(_baseGetTag_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) == symbolTag);
            }
            /* harmony default export */ __webpack_exports__["default"] = (isSymbol);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/isTypedArray.js": 
        /*!************************************************!*\
          !*** ./node_modules/lodash-es/isTypedArray.js ***!
          \************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _baseIsTypedArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseIsTypedArray.js */ "./node_modules/lodash-es/_baseIsTypedArray.js");
            /* harmony import */ var _baseUnary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseUnary.js */ "./node_modules/lodash-es/_baseUnary.js");
            /* harmony import */ var _nodeUtil_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_nodeUtil.js */ "./node_modules/lodash-es/_nodeUtil.js");
            /* Node.js helper references. */
            var nodeIsTypedArray = _nodeUtil_js__WEBPACK_IMPORTED_MODULE_2__["default"] && _nodeUtil_js__WEBPACK_IMPORTED_MODULE_2__["default"].isTypedArray;
            /**
             * Checks if `value` is classified as a typed array.
             *
             * @static
             * @memberOf _
             * @since 3.0.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
             * @example
             *
             * _.isTypedArray(new Uint8Array);
             * // => true
             *
             * _.isTypedArray([]);
             * // => false
             */
            var isTypedArray = nodeIsTypedArray ? Object(_baseUnary_js__WEBPACK_IMPORTED_MODULE_1__["default"])(nodeIsTypedArray) : _baseIsTypedArray_js__WEBPACK_IMPORTED_MODULE_0__["default"];
            /* harmony default export */ __webpack_exports__["default"] = (isTypedArray);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/keys.js": 
        /*!****************************************!*\
          !*** ./node_modules/lodash-es/keys.js ***!
          \****************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _arrayLikeKeys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_arrayLikeKeys.js */ "./node_modules/lodash-es/_arrayLikeKeys.js");
            /* harmony import */ var _baseKeys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseKeys.js */ "./node_modules/lodash-es/_baseKeys.js");
            /* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isArrayLike.js */ "./node_modules/lodash-es/isArrayLike.js");
            /**
             * Creates an array of the own enumerable property names of `object`.
             *
             * **Note:** Non-object values are coerced to objects. See the
             * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
             * for more details.
             *
             * @static
             * @since 0.1.0
             * @memberOf _
             * @category Object
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of property names.
             * @example
             *
             * function Foo() {
             *   this.a = 1;
             *   this.b = 2;
             * }
             *
             * Foo.prototype.c = 3;
             *
             * _.keys(new Foo);
             * // => ['a', 'b'] (iteration order is not guaranteed)
             *
             * _.keys('hi');
             * // => ['0', '1']
             */
            function keys(object) {
                return Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_2__["default"])(object) ? Object(_arrayLikeKeys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object) : Object(_baseKeys_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object);
            }
            /* harmony default export */ __webpack_exports__["default"] = (keys);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/keysIn.js": 
        /*!******************************************!*\
          !*** ./node_modules/lodash-es/keysIn.js ***!
          \******************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _arrayLikeKeys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_arrayLikeKeys.js */ "./node_modules/lodash-es/_arrayLikeKeys.js");
            /* harmony import */ var _baseKeysIn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseKeysIn.js */ "./node_modules/lodash-es/_baseKeysIn.js");
            /* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isArrayLike.js */ "./node_modules/lodash-es/isArrayLike.js");
            /**
             * Creates an array of the own and inherited enumerable property names of `object`.
             *
             * **Note:** Non-object values are coerced to objects.
             *
             * @static
             * @memberOf _
             * @since 3.0.0
             * @category Object
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of property names.
             * @example
             *
             * function Foo() {
             *   this.a = 1;
             *   this.b = 2;
             * }
             *
             * Foo.prototype.c = 3;
             *
             * _.keysIn(new Foo);
             * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
             */
            function keysIn(object) {
                return Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_2__["default"])(object) ? Object(_arrayLikeKeys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, true) : Object(_baseKeysIn_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object);
            }
            /* harmony default export */ __webpack_exports__["default"] = (keysIn);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/map.js": 
        /*!***************************************!*\
          !*** ./node_modules/lodash-es/map.js ***!
          \***************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _arrayMap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_arrayMap.js */ "./node_modules/lodash-es/_arrayMap.js");
            /* harmony import */ var _baseIteratee_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseIteratee.js */ "./node_modules/lodash-es/_baseIteratee.js");
            /* harmony import */ var _baseMap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseMap.js */ "./node_modules/lodash-es/_baseMap.js");
            /* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js");
            /**
             * Creates an array of values by running each element in `collection` thru
             * `iteratee`. The iteratee is invoked with three arguments:
             * (value, index|key, collection).
             *
             * Many lodash methods are guarded to work as iteratees for methods like
             * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
             *
             * The guarded methods are:
             * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
             * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
             * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
             * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
             *
             * @static
             * @memberOf _
             * @since 0.1.0
             * @category Collection
             * @param {Array|Object} collection The collection to iterate over.
             * @param {Function} [iteratee=_.identity] The function invoked per iteration.
             * @returns {Array} Returns the new mapped array.
             * @example
             *
             * function square(n) {
             *   return n * n;
             * }
             *
             * _.map([4, 8], square);
             * // => [16, 64]
             *
             * _.map({ 'a': 4, 'b': 8 }, square);
             * // => [16, 64] (iteration order is not guaranteed)
             *
             * var users = [
             *   { 'user': 'barney' },
             *   { 'user': 'fred' }
             * ];
             *
             * // The `_.property` iteratee shorthand.
             * _.map(users, 'user');
             * // => ['barney', 'fred']
             */
            function map(collection, iteratee) {
                var func = Object(_isArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(collection) ? _arrayMap_js__WEBPACK_IMPORTED_MODULE_0__["default"] : _baseMap_js__WEBPACK_IMPORTED_MODULE_2__["default"];
                return func(collection, Object(_baseIteratee_js__WEBPACK_IMPORTED_MODULE_1__["default"])(iteratee, 3));
            }
            /* harmony default export */ __webpack_exports__["default"] = (map);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/memoize.js": 
        /*!*******************************************!*\
          !*** ./node_modules/lodash-es/memoize.js ***!
          \*******************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _MapCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_MapCache.js */ "./node_modules/lodash-es/_MapCache.js");
            /** Error message constants. */
            var FUNC_ERROR_TEXT = 'Expected a function';
            /**
             * Creates a function that memoizes the result of `func`. If `resolver` is
             * provided, it determines the cache key for storing the result based on the
             * arguments provided to the memoized function. By default, the first argument
             * provided to the memoized function is used as the map cache key. The `func`
             * is invoked with the `this` binding of the memoized function.
             *
             * **Note:** The cache is exposed as the `cache` property on the memoized
             * function. Its creation may be customized by replacing the `_.memoize.Cache`
             * constructor with one whose instances implement the
             * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
             * method interface of `clear`, `delete`, `get`, `has`, and `set`.
             *
             * @static
             * @memberOf _
             * @since 0.1.0
             * @category Function
             * @param {Function} func The function to have its output memoized.
             * @param {Function} [resolver] The function to resolve the cache key.
             * @returns {Function} Returns the new memoized function.
             * @example
             *
             * var object = { 'a': 1, 'b': 2 };
             * var other = { 'c': 3, 'd': 4 };
             *
             * var values = _.memoize(_.values);
             * values(object);
             * // => [1, 2]
             *
             * values(other);
             * // => [3, 4]
             *
             * object.a = 2;
             * values(object);
             * // => [1, 2]
             *
             * // Modify the result cache.
             * values.cache.set(object, ['a', 'b']);
             * values(object);
             * // => ['a', 'b']
             *
             * // Replace `_.memoize.Cache`.
             * _.memoize.Cache = WeakMap;
             */
            function memoize(func, resolver) {
                if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
                    throw new TypeError(FUNC_ERROR_TEXT);
                }
                var memoized = function () {
                    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
                    if (cache.has(key)) {
                        return cache.get(key);
                    }
                    var result = func.apply(this, args);
                    memoized.cache = cache.set(key, result) || cache;
                    return result;
                };
                memoized.cache = new (memoize.Cache || _MapCache_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
                return memoized;
            }
            // Expose `MapCache`.
            memoize.Cache = _MapCache_js__WEBPACK_IMPORTED_MODULE_0__["default"];
            /* harmony default export */ __webpack_exports__["default"] = (memoize);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/property.js": 
        /*!********************************************!*\
          !*** ./node_modules/lodash-es/property.js ***!
          \********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _baseProperty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseProperty.js */ "./node_modules/lodash-es/_baseProperty.js");
            /* harmony import */ var _basePropertyDeep_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_basePropertyDeep.js */ "./node_modules/lodash-es/_basePropertyDeep.js");
            /* harmony import */ var _isKey_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_isKey.js */ "./node_modules/lodash-es/_isKey.js");
            /* harmony import */ var _toKey_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_toKey.js */ "./node_modules/lodash-es/_toKey.js");
            /**
             * Creates a function that returns the value at `path` of a given object.
             *
             * @static
             * @memberOf _
             * @since 2.4.0
             * @category Util
             * @param {Array|string} path The path of the property to get.
             * @returns {Function} Returns the new accessor function.
             * @example
             *
             * var objects = [
             *   { 'a': { 'b': 2 } },
             *   { 'a': { 'b': 1 } }
             * ];
             *
             * _.map(objects, _.property('a.b'));
             * // => [2, 1]
             *
             * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
             * // => [1, 2]
             */
            function property(path) {
                return Object(_isKey_js__WEBPACK_IMPORTED_MODULE_2__["default"])(path) ? Object(_baseProperty_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Object(_toKey_js__WEBPACK_IMPORTED_MODULE_3__["default"])(path)) : Object(_basePropertyDeep_js__WEBPACK_IMPORTED_MODULE_1__["default"])(path);
            }
            /* harmony default export */ __webpack_exports__["default"] = (property);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/stubArray.js": 
        /*!*********************************************!*\
          !*** ./node_modules/lodash-es/stubArray.js ***!
          \*********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * This method returns a new empty array.
             *
             * @static
             * @memberOf _
             * @since 4.13.0
             * @category Util
             * @returns {Array} Returns the new empty array.
             * @example
             *
             * var arrays = _.times(2, _.stubArray);
             *
             * console.log(arrays);
             * // => [[], []]
             *
             * console.log(arrays[0] === arrays[1]);
             * // => false
             */
            function stubArray() {
                return [];
            }
            /* harmony default export */ __webpack_exports__["default"] = (stubArray);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/stubFalse.js": 
        /*!*********************************************!*\
          !*** ./node_modules/lodash-es/stubFalse.js ***!
          \*********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /**
             * This method returns `false`.
             *
             * @static
             * @memberOf _
             * @since 4.13.0
             * @category Util
             * @returns {boolean} Returns `false`.
             * @example
             *
             * _.times(2, _.stubFalse);
             * // => [false, false]
             */
            function stubFalse() {
                return false;
            }
            /* harmony default export */ __webpack_exports__["default"] = (stubFalse);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/toString.js": 
        /*!********************************************!*\
          !*** ./node_modules/lodash-es/toString.js ***!
          \********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _baseToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseToString.js */ "./node_modules/lodash-es/_baseToString.js");
            /**
             * Converts `value` to a string. An empty string is returned for `null`
             * and `undefined` values. The sign of `-0` is preserved.
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Lang
             * @param {*} value The value to convert.
             * @returns {string} Returns the converted string.
             * @example
             *
             * _.toString(null);
             * // => ''
             *
             * _.toString(-0);
             * // => '-0'
             *
             * _.toString([1, 2, 3]);
             * // => '1,2,3'
             */
            function toString(value) {
                return value == null ? '' : Object(_baseToString_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value);
            }
            /* harmony default export */ __webpack_exports__["default"] = (toString);
            /***/ 
        }),
        /***/ "./node_modules/lodash-es/uniqueId.js": 
        /*!********************************************!*\
          !*** ./node_modules/lodash-es/uniqueId.js ***!
          \********************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _toString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toString.js */ "./node_modules/lodash-es/toString.js");
            /** Used to generate unique IDs. */
            var idCounter = 0;
            /**
             * Generates a unique ID. If `prefix` is given, the ID is appended to it.
             *
             * @static
             * @since 0.1.0
             * @memberOf _
             * @category Util
             * @param {string} [prefix=''] The value to prefix the ID with.
             * @returns {string} Returns the unique ID.
             * @example
             *
             * _.uniqueId('contact_');
             * // => 'contact_104'
             *
             * _.uniqueId();
             * // => '105'
             */
            function uniqueId(prefix) {
                var id = ++idCounter;
                return Object(_toString_js__WEBPACK_IMPORTED_MODULE_0__["default"])(prefix) + id;
            }
            /* harmony default export */ __webpack_exports__["default"] = (uniqueId);
            /***/ 
        }),
        /***/ "./node_modules/marked/lib/marked.js": 
        /*!*******************************************!*\
          !*** ./node_modules/marked/lib/marked.js ***!
          \*******************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            /**
             * marked - a markdown parser
             * Copyright (c) 2011-2018, Christopher Jeffrey. (MIT Licensed)
             * https://github.com/markedjs/marked
             */
            ;
            (function (root) {
                'use strict';
                /**
                 * Block-Level Grammar
                 */
                var block = {
                    newline: /^\n+/,
                    code: /^( {4}[^\n]+\n*)+/,
                    fences: /^ {0,3}(`{3,}|~{3,})([^`~\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/,
                    hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
                    heading: /^ {0,3}(#{1,6}) +([^\n]*?)(?: +#+)? *(?:\n+|$)/,
                    blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
                    list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
                    html: '^ {0,3}(?:' // optional indentation
                        + '<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
                        + '|comment[^\\n]*(\\n+|$)' // (2)
                        + '|<\\?[\\s\\S]*?\\?>\\n*' // (3)
                        + '|<![A-Z][\\s\\S]*?>\\n*' // (4)
                        + '|<!\\[CDATA\\[[\\s\\S]*?\\]\\]>\\n*' // (5)
                        + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)' // (6)
                        + '|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) open tag
                        + '|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) closing tag
                        + ')',
                    def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
                    nptable: noop,
                    table: noop,
                    lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
                    // regex template, placeholders will be replaced according to different paragraph
                    // interruption rules of commonmark and the original markdown spec:
                    _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html)[^\n]+)*)/,
                    text: /^[^\n]+/
                };
                block._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
                block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
                block.def = edit(block.def)
                    .replace('label', block._label)
                    .replace('title', block._title)
                    .getRegex();
                block.bullet = /(?:[*+-]|\d{1,9}\.)/;
                block.item = /^( *)(bull) ?[^\n]*(?:\n(?!\1bull ?)[^\n]*)*/;
                block.item = edit(block.item, 'gm')
                    .replace(/bull/g, block.bullet)
                    .getRegex();
                block.list = edit(block.list)
                    .replace(/bull/g, block.bullet)
                    .replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))')
                    .replace('def', '\\n+(?=' + block.def.source + ')')
                    .getRegex();
                block._tag = 'address|article|aside|base|basefont|blockquote|body|caption'
                    + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'
                    + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'
                    + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'
                    + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr'
                    + '|track|ul';
                block._comment = /<!--(?!-?>)[\s\S]*?-->/;
                block.html = edit(block.html, 'i')
                    .replace('comment', block._comment)
                    .replace('tag', block._tag)
                    .replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
                    .getRegex();
                block.paragraph = edit(block._paragraph)
                    .replace('hr', block.hr)
                    .replace('heading', ' {0,3}#{1,6} +')
                    .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
                    .replace('blockquote', ' {0,3}>')
                    .replace('fences', ' {0,3}(?:`{3,}|~{3,})[^`\\n]*\\n')
                    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
                    .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)')
                    .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
                    .getRegex();
                block.blockquote = edit(block.blockquote)
                    .replace('paragraph', block.paragraph)
                    .getRegex();
                /**
                 * Normal Block Grammar
                 */
                block.normal = merge({}, block);
                /**
                 * GFM Block Grammar
                 */
                block.gfm = merge({}, block.normal, {
                    nptable: /^ *([^|\n ].*\|.*)\n *([-:]+ *\|[-| :]*)(?:\n((?:.*[^>\n ].*(?:\n|$))*)\n*|$)/,
                    table: /^ *\|(.+)\n *\|?( *[-:]+[-| :]*)(?:\n((?: *[^>\n ].*(?:\n|$))*)\n*|$)/
                });
                /**
                 * Pedantic grammar (original John Gruber's loose markdown specification)
                 */
                block.pedantic = merge({}, block.normal, {
                    html: edit('^ *(?:comment *(?:\\n|\\s*$)'
                        + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
                        + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))')
                        .replace('comment', block._comment)
                        .replace(/tag/g, '(?!(?:'
                        + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'
                        + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'
                        + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b')
                        .getRegex(),
                    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
                    heading: /^ *(#{1,6}) *([^\n]+?) *(?:#+ *)?(?:\n+|$)/,
                    fences: noop,
                    paragraph: edit(block.normal._paragraph)
                        .replace('hr', block.hr)
                        .replace('heading', ' *#{1,6} *[^\n]')
                        .replace('lheading', block.lheading)
                        .replace('blockquote', ' {0,3}>')
                        .replace('|fences', '')
                        .replace('|list', '')
                        .replace('|html', '')
                        .getRegex()
                });
                /**
                 * Block Lexer
                 */
                function Lexer(options) {
                    this.tokens = [];
                    this.tokens.links = Object.create(null);
                    this.options = options || marked.defaults;
                    this.rules = block.normal;
                    if (this.options.pedantic) {
                        this.rules = block.pedantic;
                    }
                    else if (this.options.gfm) {
                        this.rules = block.gfm;
                    }
                }
                /**
                 * Expose Block Rules
                 */
                Lexer.rules = block;
                /**
                 * Static Lex Method
                 */
                Lexer.lex = function (src, options) {
                    var lexer = new Lexer(options);
                    return lexer.lex(src);
                };
                /**
                 * Preprocessing
                 */
                Lexer.prototype.lex = function (src) {
                    src = src
                        .replace(/\r\n|\r/g, '\n')
                        .replace(/\t/g, '    ')
                        .replace(/\u00a0/g, ' ')
                        .replace(/\u2424/g, '\n');
                    return this.token(src, true);
                };
                /**
                 * Lexing
                 */
                Lexer.prototype.token = function (src, top) {
                    src = src.replace(/^ +$/gm, '');
                    var next, loose, cap, bull, b, item, listStart, listItems, t, space, i, tag, l, isordered, istask, ischecked;
                    while (src) {
                        // newline
                        if (cap = this.rules.newline.exec(src)) {
                            src = src.substring(cap[0].length);
                            if (cap[0].length > 1) {
                                this.tokens.push({
                                    type: 'space'
                                });
                            }
                        }
                        // code
                        if (cap = this.rules.code.exec(src)) {
                            var lastToken = this.tokens[this.tokens.length - 1];
                            src = src.substring(cap[0].length);
                            // An indented code block cannot interrupt a paragraph.
                            if (lastToken && lastToken.type === 'paragraph') {
                                lastToken.text += '\n' + cap[0].trimRight();
                            }
                            else {
                                cap = cap[0].replace(/^ {4}/gm, '');
                                this.tokens.push({
                                    type: 'code',
                                    codeBlockStyle: 'indented',
                                    text: !this.options.pedantic
                                        ? rtrim(cap, '\n')
                                        : cap
                                });
                            }
                            continue;
                        }
                        // fences
                        if (cap = this.rules.fences.exec(src)) {
                            src = src.substring(cap[0].length);
                            this.tokens.push({
                                type: 'code',
                                lang: cap[2] ? cap[2].trim() : cap[2],
                                text: cap[3] || ''
                            });
                            continue;
                        }
                        // heading
                        if (cap = this.rules.heading.exec(src)) {
                            src = src.substring(cap[0].length);
                            this.tokens.push({
                                type: 'heading',
                                depth: cap[1].length,
                                text: cap[2]
                            });
                            continue;
                        }
                        // table no leading pipe (gfm)
                        if (cap = this.rules.nptable.exec(src)) {
                            item = {
                                type: 'table',
                                header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
                                align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
                                cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
                            };
                            if (item.header.length === item.align.length) {
                                src = src.substring(cap[0].length);
                                for (i = 0; i < item.align.length; i++) {
                                    if (/^ *-+: *$/.test(item.align[i])) {
                                        item.align[i] = 'right';
                                    }
                                    else if (/^ *:-+: *$/.test(item.align[i])) {
                                        item.align[i] = 'center';
                                    }
                                    else if (/^ *:-+ *$/.test(item.align[i])) {
                                        item.align[i] = 'left';
                                    }
                                    else {
                                        item.align[i] = null;
                                    }
                                }
                                for (i = 0; i < item.cells.length; i++) {
                                    item.cells[i] = splitCells(item.cells[i], item.header.length);
                                }
                                this.tokens.push(item);
                                continue;
                            }
                        }
                        // hr
                        if (cap = this.rules.hr.exec(src)) {
                            src = src.substring(cap[0].length);
                            this.tokens.push({
                                type: 'hr'
                            });
                            continue;
                        }
                        // blockquote
                        if (cap = this.rules.blockquote.exec(src)) {
                            src = src.substring(cap[0].length);
                            this.tokens.push({
                                type: 'blockquote_start'
                            });
                            cap = cap[0].replace(/^ *> ?/gm, '');
                            // Pass `top` to keep the current
                            // "toplevel" state. This is exactly
                            // how markdown.pl works.
                            this.token(cap, top);
                            this.tokens.push({
                                type: 'blockquote_end'
                            });
                            continue;
                        }
                        // list
                        if (cap = this.rules.list.exec(src)) {
                            src = src.substring(cap[0].length);
                            bull = cap[2];
                            isordered = bull.length > 1;
                            listStart = {
                                type: 'list_start',
                                ordered: isordered,
                                start: isordered ? +bull : '',
                                loose: false
                            };
                            this.tokens.push(listStart);
                            // Get each top-level item.
                            cap = cap[0].match(this.rules.item);
                            listItems = [];
                            next = false;
                            l = cap.length;
                            i = 0;
                            for (; i < l; i++) {
                                item = cap[i];
                                // Remove the list item's bullet
                                // so it is seen as the next token.
                                space = item.length;
                                item = item.replace(/^ *([*+-]|\d+\.) */, '');
                                // Outdent whatever the
                                // list item contains. Hacky.
                                if (~item.indexOf('\n ')) {
                                    space -= item.length;
                                    item = !this.options.pedantic
                                        ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
                                        : item.replace(/^ {1,4}/gm, '');
                                }
                                // Determine whether the next list item belongs here.
                                // Backpedal if it does not belong in this list.
                                if (i !== l - 1) {
                                    b = block.bullet.exec(cap[i + 1])[0];
                                    if (bull.length > 1 ? b.length === 1
                                        : (b.length > 1 || (this.options.smartLists && b !== bull))) {
                                        src = cap.slice(i + 1).join('\n') + src;
                                        i = l - 1;
                                    }
                                }
                                // Determine whether item is loose or not.
                                // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
                                // for discount behavior.
                                loose = next || /\n\n(?!\s*$)/.test(item);
                                if (i !== l - 1) {
                                    next = item.charAt(item.length - 1) === '\n';
                                    if (!loose)
                                        loose = next;
                                }
                                if (loose) {
                                    listStart.loose = true;
                                }
                                // Check for task list items
                                istask = /^\[[ xX]\] /.test(item);
                                ischecked = undefined;
                                if (istask) {
                                    ischecked = item[1] !== ' ';
                                    item = item.replace(/^\[[ xX]\] +/, '');
                                }
                                t = {
                                    type: 'list_item_start',
                                    task: istask,
                                    checked: ischecked,
                                    loose: loose
                                };
                                listItems.push(t);
                                this.tokens.push(t);
                                // Recurse.
                                this.token(item, false);
                                this.tokens.push({
                                    type: 'list_item_end'
                                });
                            }
                            if (listStart.loose) {
                                l = listItems.length;
                                i = 0;
                                for (; i < l; i++) {
                                    listItems[i].loose = true;
                                }
                            }
                            this.tokens.push({
                                type: 'list_end'
                            });
                            continue;
                        }
                        // html
                        if (cap = this.rules.html.exec(src)) {
                            src = src.substring(cap[0].length);
                            this.tokens.push({
                                type: this.options.sanitize
                                    ? 'paragraph'
                                    : 'html',
                                pre: !this.options.sanitizer
                                    && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
                                text: this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0]
                            });
                            continue;
                        }
                        // def
                        if (top && (cap = this.rules.def.exec(src))) {
                            src = src.substring(cap[0].length);
                            if (cap[3])
                                cap[3] = cap[3].substring(1, cap[3].length - 1);
                            tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
                            if (!this.tokens.links[tag]) {
                                this.tokens.links[tag] = {
                                    href: cap[2],
                                    title: cap[3]
                                };
                            }
                            continue;
                        }
                        // table (gfm)
                        if (cap = this.rules.table.exec(src)) {
                            item = {
                                type: 'table',
                                header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
                                align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
                                cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
                            };
                            if (item.header.length === item.align.length) {
                                src = src.substring(cap[0].length);
                                for (i = 0; i < item.align.length; i++) {
                                    if (/^ *-+: *$/.test(item.align[i])) {
                                        item.align[i] = 'right';
                                    }
                                    else if (/^ *:-+: *$/.test(item.align[i])) {
                                        item.align[i] = 'center';
                                    }
                                    else if (/^ *:-+ *$/.test(item.align[i])) {
                                        item.align[i] = 'left';
                                    }
                                    else {
                                        item.align[i] = null;
                                    }
                                }
                                for (i = 0; i < item.cells.length; i++) {
                                    item.cells[i] = splitCells(item.cells[i].replace(/^ *\| *| *\| *$/g, ''), item.header.length);
                                }
                                this.tokens.push(item);
                                continue;
                            }
                        }
                        // lheading
                        if (cap = this.rules.lheading.exec(src)) {
                            src = src.substring(cap[0].length);
                            this.tokens.push({
                                type: 'heading',
                                depth: cap[2].charAt(0) === '=' ? 1 : 2,
                                text: cap[1]
                            });
                            continue;
                        }
                        // top-level paragraph
                        if (top && (cap = this.rules.paragraph.exec(src))) {
                            src = src.substring(cap[0].length);
                            this.tokens.push({
                                type: 'paragraph',
                                text: cap[1].charAt(cap[1].length - 1) === '\n'
                                    ? cap[1].slice(0, -1)
                                    : cap[1]
                            });
                            continue;
                        }
                        // text
                        if (cap = this.rules.text.exec(src)) {
                            // Top-level should never reach here.
                            src = src.substring(cap[0].length);
                            this.tokens.push({
                                type: 'text',
                                text: cap[0]
                            });
                            continue;
                        }
                        if (src) {
                            throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
                        }
                    }
                    return this.tokens;
                };
                /**
                 * Inline-Level Grammar
                 */
                var inline = {
                    escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
                    autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
                    url: noop,
                    tag: '^comment'
                        + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
                        + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
                        + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
                        + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
                        + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>',
                    link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
                    reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
                    nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
                    strong: /^__([^\s_])__(?!_)|^\*\*([^\s*])\*\*(?!\*)|^__([^\s][\s\S]*?[^\s])__(?!_)|^\*\*([^\s][\s\S]*?[^\s])\*\*(?!\*)/,
                    em: /^_([^\s_])_(?!_)|^\*([^\s*<\[])\*(?!\*)|^_([^\s<][\s\S]*?[^\s_])_(?!_|[^\spunctuation])|^_([^\s_<][\s\S]*?[^\s])_(?!_|[^\spunctuation])|^\*([^\s<"][\s\S]*?[^\s\*])\*(?!\*|[^\spunctuation])|^\*([^\s*"<\[][\s\S]*?[^\s])\*(?!\*)/,
                    code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
                    br: /^( {2,}|\\)\n(?!\s*$)/,
                    del: noop,
                    text: /^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*]|\b_|$)|[^ ](?= {2,}\n))|(?= {2,}\n))/
                };
                // list of punctuation marks from common mark spec
                // without ` and ] to workaround Rule 17 (inline code blocks/links)
                inline._punctuation = '!"#$%&\'()*+,\\-./:;<=>?@\\[^_{|}~';
                inline.em = edit(inline.em).replace(/punctuation/g, inline._punctuation).getRegex();
                inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
                inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
                inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
                inline.autolink = edit(inline.autolink)
                    .replace('scheme', inline._scheme)
                    .replace('email', inline._email)
                    .getRegex();
                inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
                inline.tag = edit(inline.tag)
                    .replace('comment', block._comment)
                    .replace('attribute', inline._attribute)
                    .getRegex();
                inline._label = /(?:\[[^\[\]]*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
                inline._href = /<(?:\\[<>]?|[^\s<>\\])*>|[^\s\x00-\x1f]*/;
                inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
                inline.link = edit(inline.link)
                    .replace('label', inline._label)
                    .replace('href', inline._href)
                    .replace('title', inline._title)
                    .getRegex();
                inline.reflink = edit(inline.reflink)
                    .replace('label', inline._label)
                    .getRegex();
                /**
                 * Normal Inline Grammar
                 */
                inline.normal = merge({}, inline);
                /**
                 * Pedantic Inline Grammar
                 */
                inline.pedantic = merge({}, inline.normal, {
                    strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
                    em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/,
                    link: edit(/^!?\[(label)\]\((.*?)\)/)
                        .replace('label', inline._label)
                        .getRegex(),
                    reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/)
                        .replace('label', inline._label)
                        .getRegex()
                });
                /**
                 * GFM Inline Grammar
                 */
                inline.gfm = merge({}, inline.normal, {
                    escape: edit(inline.escape).replace('])', '~|])').getRegex(),
                    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
                    url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
                    _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
                    del: /^~+(?=\S)([\s\S]*?\S)~+/,
                    text: /^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*~]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))|(?= {2,}\n|[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))/
                });
                inline.gfm.url = edit(inline.gfm.url, 'i')
                    .replace('email', inline.gfm._extended_email)
                    .getRegex();
                /**
                 * GFM + Line Breaks Inline Grammar
                 */
                inline.breaks = merge({}, inline.gfm, {
                    br: edit(inline.br).replace('{2,}', '*').getRegex(),
                    text: edit(inline.gfm.text)
                        .replace('\\b_', '\\b_| {2,}\\n')
                        .replace(/\{2,\}/g, '*')
                        .getRegex()
                });
                /**
                 * Inline Lexer & Compiler
                 */
                function InlineLexer(links, options) {
                    this.options = options || marked.defaults;
                    this.links = links;
                    this.rules = inline.normal;
                    this.renderer = this.options.renderer || new Renderer();
                    this.renderer.options = this.options;
                    if (!this.links) {
                        throw new Error('Tokens array requires a `links` property.');
                    }
                    if (this.options.pedantic) {
                        this.rules = inline.pedantic;
                    }
                    else if (this.options.gfm) {
                        if (this.options.breaks) {
                            this.rules = inline.breaks;
                        }
                        else {
                            this.rules = inline.gfm;
                        }
                    }
                }
                /**
                 * Expose Inline Rules
                 */
                InlineLexer.rules = inline;
                /**
                 * Static Lexing/Compiling Method
                 */
                InlineLexer.output = function (src, links, options) {
                    var inline = new InlineLexer(links, options);
                    return inline.output(src);
                };
                /**
                 * Lexing/Compiling
                 */
                InlineLexer.prototype.output = function (src) {
                    var out = '', link, text, href, title, cap, prevCapZero;
                    while (src) {
                        // escape
                        if (cap = this.rules.escape.exec(src)) {
                            src = src.substring(cap[0].length);
                            out += escape(cap[1]);
                            continue;
                        }
                        // tag
                        if (cap = this.rules.tag.exec(src)) {
                            if (!this.inLink && /^<a /i.test(cap[0])) {
                                this.inLink = true;
                            }
                            else if (this.inLink && /^<\/a>/i.test(cap[0])) {
                                this.inLink = false;
                            }
                            if (!this.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
                                this.inRawBlock = true;
                            }
                            else if (this.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
                                this.inRawBlock = false;
                            }
                            src = src.substring(cap[0].length);
                            out += this.options.sanitize
                                ? this.options.sanitizer
                                    ? this.options.sanitizer(cap[0])
                                    : escape(cap[0])
                                : cap[0];
                            continue;
                        }
                        // link
                        if (cap = this.rules.link.exec(src)) {
                            var lastParenIndex = findClosingBracket(cap[2], '()');
                            if (lastParenIndex > -1) {
                                var linkLen = 4 + cap[1].length + lastParenIndex;
                                cap[2] = cap[2].substring(0, lastParenIndex);
                                cap[0] = cap[0].substring(0, linkLen).trim();
                                cap[3] = '';
                            }
                            src = src.substring(cap[0].length);
                            this.inLink = true;
                            href = cap[2];
                            if (this.options.pedantic) {
                                link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
                                if (link) {
                                    href = link[1];
                                    title = link[3];
                                }
                                else {
                                    title = '';
                                }
                            }
                            else {
                                title = cap[3] ? cap[3].slice(1, -1) : '';
                            }
                            href = href.trim().replace(/^<([\s\S]*)>$/, '$1');
                            out += this.outputLink(cap, {
                                href: InlineLexer.escapes(href),
                                title: InlineLexer.escapes(title)
                            });
                            this.inLink = false;
                            continue;
                        }
                        // reflink, nolink
                        if ((cap = this.rules.reflink.exec(src))
                            || (cap = this.rules.nolink.exec(src))) {
                            src = src.substring(cap[0].length);
                            link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
                            link = this.links[link.toLowerCase()];
                            if (!link || !link.href) {
                                out += cap[0].charAt(0);
                                src = cap[0].substring(1) + src;
                                continue;
                            }
                            this.inLink = true;
                            out += this.outputLink(cap, link);
                            this.inLink = false;
                            continue;
                        }
                        // strong
                        if (cap = this.rules.strong.exec(src)) {
                            src = src.substring(cap[0].length);
                            out += this.renderer.strong(this.output(cap[4] || cap[3] || cap[2] || cap[1]));
                            continue;
                        }
                        // em
                        if (cap = this.rules.em.exec(src)) {
                            src = src.substring(cap[0].length);
                            out += this.renderer.em(this.output(cap[6] || cap[5] || cap[4] || cap[3] || cap[2] || cap[1]));
                            continue;
                        }
                        // code
                        if (cap = this.rules.code.exec(src)) {
                            src = src.substring(cap[0].length);
                            out += this.renderer.codespan(escape(cap[2].trim(), true));
                            continue;
                        }
                        // br
                        if (cap = this.rules.br.exec(src)) {
                            src = src.substring(cap[0].length);
                            out += this.renderer.br();
                            continue;
                        }
                        // del (gfm)
                        if (cap = this.rules.del.exec(src)) {
                            src = src.substring(cap[0].length);
                            out += this.renderer.del(this.output(cap[1]));
                            continue;
                        }
                        // autolink
                        if (cap = this.rules.autolink.exec(src)) {
                            src = src.substring(cap[0].length);
                            if (cap[2] === '@') {
                                text = escape(this.mangle(cap[1]));
                                href = 'mailto:' + text;
                            }
                            else {
                                text = escape(cap[1]);
                                href = text;
                            }
                            out += this.renderer.link(href, null, text);
                            continue;
                        }
                        // url (gfm)
                        if (!this.inLink && (cap = this.rules.url.exec(src))) {
                            if (cap[2] === '@') {
                                text = escape(cap[0]);
                                href = 'mailto:' + text;
                            }
                            else {
                                // do extended autolink path validation
                                do {
                                    prevCapZero = cap[0];
                                    cap[0] = this.rules._backpedal.exec(cap[0])[0];
                                } while (prevCapZero !== cap[0]);
                                text = escape(cap[0]);
                                if (cap[1] === 'www.') {
                                    href = 'http://' + text;
                                }
                                else {
                                    href = text;
                                }
                            }
                            src = src.substring(cap[0].length);
                            out += this.renderer.link(href, null, text);
                            continue;
                        }
                        // text
                        if (cap = this.rules.text.exec(src)) {
                            src = src.substring(cap[0].length);
                            if (this.inRawBlock) {
                                out += this.renderer.text(this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0]);
                            }
                            else {
                                out += this.renderer.text(escape(this.smartypants(cap[0])));
                            }
                            continue;
                        }
                        if (src) {
                            throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
                        }
                    }
                    return out;
                };
                InlineLexer.escapes = function (text) {
                    return text ? text.replace(InlineLexer.rules._escapes, '$1') : text;
                };
                /**
                 * Compile Link
                 */
                InlineLexer.prototype.outputLink = function (cap, link) {
                    var href = link.href, title = link.title ? escape(link.title) : null;
                    return cap[0].charAt(0) !== '!'
                        ? this.renderer.link(href, title, this.output(cap[1]))
                        : this.renderer.image(href, title, escape(cap[1]));
                };
                /**
                 * Smartypants Transformations
                 */
                InlineLexer.prototype.smartypants = function (text) {
                    if (!this.options.smartypants)
                        return text;
                    return text
                        // em-dashes
                        .replace(/---/g, '\u2014')
                        // en-dashes
                        .replace(/--/g, '\u2013')
                        // opening singles
                        .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
                        // closing singles & apostrophes
                        .replace(/'/g, '\u2019')
                        // opening doubles
                        .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
                        // closing doubles
                        .replace(/"/g, '\u201d')
                        // ellipses
                        .replace(/\.{3}/g, '\u2026');
                };
                /**
                 * Mangle Links
                 */
                InlineLexer.prototype.mangle = function (text) {
                    if (!this.options.mangle)
                        return text;
                    var out = '', l = text.length, i = 0, ch;
                    for (; i < l; i++) {
                        ch = text.charCodeAt(i);
                        if (Math.random() > 0.5) {
                            ch = 'x' + ch.toString(16);
                        }
                        out += '&#' + ch + ';';
                    }
                    return out;
                };
                /**
                 * Renderer
                 */
                function Renderer(options) {
                    this.options = options || marked.defaults;
                }
                Renderer.prototype.code = function (code, infostring, escaped) {
                    var lang = (infostring || '').match(/\S*/)[0];
                    if (this.options.highlight) {
                        var out = this.options.highlight(code, lang);
                        if (out != null && out !== code) {
                            escaped = true;
                            code = out;
                        }
                    }
                    if (!lang) {
                        return '<pre><code>'
                            + (escaped ? code : escape(code, true))
                            + '</code></pre>';
                    }
                    return '<pre><code class="'
                        + this.options.langPrefix
                        + escape(lang, true)
                        + '">'
                        + (escaped ? code : escape(code, true))
                        + '</code></pre>\n';
                };
                Renderer.prototype.blockquote = function (quote) {
                    return '<blockquote>\n' + quote + '</blockquote>\n';
                };
                Renderer.prototype.html = function (html) {
                    return html;
                };
                Renderer.prototype.heading = function (text, level, raw, slugger) {
                    if (this.options.headerIds) {
                        return '<h'
                            + level
                            + ' id="'
                            + this.options.headerPrefix
                            + slugger.slug(raw)
                            + '">'
                            + text
                            + '</h'
                            + level
                            + '>\n';
                    }
                    // ignore IDs
                    return '<h' + level + '>' + text + '</h' + level + '>\n';
                };
                Renderer.prototype.hr = function () {
                    return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
                };
                Renderer.prototype.list = function (body, ordered, start) {
                    var type = ordered ? 'ol' : 'ul', startatt = (ordered && start !== 1) ? (' start="' + start + '"') : '';
                    return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
                };
                Renderer.prototype.listitem = function (text) {
                    return '<li>' + text + '</li>\n';
                };
                Renderer.prototype.checkbox = function (checked) {
                    return '<input '
                        + (checked ? 'checked="" ' : '')
                        + 'disabled="" type="checkbox"'
                        + (this.options.xhtml ? ' /' : '')
                        + '> ';
                };
                Renderer.prototype.paragraph = function (text) {
                    return '<p>' + text + '</p>\n';
                };
                Renderer.prototype.table = function (header, body) {
                    if (body)
                        body = '<tbody>' + body + '</tbody>';
                    return '<table>\n'
                        + '<thead>\n'
                        + header
                        + '</thead>\n'
                        + body
                        + '</table>\n';
                };
                Renderer.prototype.tablerow = function (content) {
                    return '<tr>\n' + content + '</tr>\n';
                };
                Renderer.prototype.tablecell = function (content, flags) {
                    var type = flags.header ? 'th' : 'td';
                    var tag = flags.align
                        ? '<' + type + ' align="' + flags.align + '">'
                        : '<' + type + '>';
                    return tag + content + '</' + type + '>\n';
                };
                // span level renderer
                Renderer.prototype.strong = function (text) {
                    return '<strong>' + text + '</strong>';
                };
                Renderer.prototype.em = function (text) {
                    return '<em>' + text + '</em>';
                };
                Renderer.prototype.codespan = function (text) {
                    return '<code>' + text + '</code>';
                };
                Renderer.prototype.br = function () {
                    return this.options.xhtml ? '<br/>' : '<br>';
                };
                Renderer.prototype.del = function (text) {
                    return '<del>' + text + '</del>';
                };
                Renderer.prototype.link = function (href, title, text) {
                    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
                    if (href === null) {
                        return text;
                    }
                    var out = '<a href="' + escape(href) + '"';
                    if (title) {
                        out += ' title="' + title + '"';
                    }
                    out += '>' + text + '</a>';
                    return out;
                };
                Renderer.prototype.image = function (href, title, text) {
                    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
                    if (href === null) {
                        return text;
                    }
                    var out = '<img src="' + href + '" alt="' + text + '"';
                    if (title) {
                        out += ' title="' + title + '"';
                    }
                    out += this.options.xhtml ? '/>' : '>';
                    return out;
                };
                Renderer.prototype.text = function (text) {
                    return text;
                };
                /**
                 * TextRenderer
                 * returns only the textual part of the token
                 */
                function TextRenderer() { }
                // no need for block level renderers
                TextRenderer.prototype.strong =
                    TextRenderer.prototype.em =
                        TextRenderer.prototype.codespan =
                            TextRenderer.prototype.del =
                                TextRenderer.prototype.text = function (text) {
                                    return text;
                                };
                TextRenderer.prototype.link =
                    TextRenderer.prototype.image = function (href, title, text) {
                        return '' + text;
                    };
                TextRenderer.prototype.br = function () {
                    return '';
                };
                /**
                 * Parsing & Compiling
                 */
                function Parser(options) {
                    this.tokens = [];
                    this.token = null;
                    this.options = options || marked.defaults;
                    this.options.renderer = this.options.renderer || new Renderer();
                    this.renderer = this.options.renderer;
                    this.renderer.options = this.options;
                    this.slugger = new Slugger();
                }
                /**
                 * Static Parse Method
                 */
                Parser.parse = function (src, options) {
                    var parser = new Parser(options);
                    return parser.parse(src);
                };
                /**
                 * Parse Loop
                 */
                Parser.prototype.parse = function (src) {
                    this.inline = new InlineLexer(src.links, this.options);
                    // use an InlineLexer with a TextRenderer to extract pure text
                    this.inlineText = new InlineLexer(src.links, merge({}, this.options, { renderer: new TextRenderer() }));
                    this.tokens = src.reverse();
                    var out = '';
                    while (this.next()) {
                        out += this.tok();
                    }
                    return out;
                };
                /**
                 * Next Token
                 */
                Parser.prototype.next = function () {
                    this.token = this.tokens.pop();
                    return this.token;
                };
                /**
                 * Preview Next Token
                 */
                Parser.prototype.peek = function () {
                    return this.tokens[this.tokens.length - 1] || 0;
                };
                /**
                 * Parse Text Tokens
                 */
                Parser.prototype.parseText = function () {
                    var body = this.token.text;
                    while (this.peek().type === 'text') {
                        body += '\n' + this.next().text;
                    }
                    return this.inline.output(body);
                };
                /**
                 * Parse Current Token
                 */
                Parser.prototype.tok = function () {
                    switch (this.token.type) {
                        case 'space': {
                            return '';
                        }
                        case 'hr': {
                            return this.renderer.hr();
                        }
                        case 'heading': {
                            return this.renderer.heading(this.inline.output(this.token.text), this.token.depth, unescape(this.inlineText.output(this.token.text)), this.slugger);
                        }
                        case 'code': {
                            return this.renderer.code(this.token.text, this.token.lang, this.token.escaped);
                        }
                        case 'table': {
                            var header = '', body = '', i, row, cell, j;
                            // header
                            cell = '';
                            for (i = 0; i < this.token.header.length; i++) {
                                cell += this.renderer.tablecell(this.inline.output(this.token.header[i]), { header: true, align: this.token.align[i] });
                            }
                            header += this.renderer.tablerow(cell);
                            for (i = 0; i < this.token.cells.length; i++) {
                                row = this.token.cells[i];
                                cell = '';
                                for (j = 0; j < row.length; j++) {
                                    cell += this.renderer.tablecell(this.inline.output(row[j]), { header: false, align: this.token.align[j] });
                                }
                                body += this.renderer.tablerow(cell);
                            }
                            return this.renderer.table(header, body);
                        }
                        case 'blockquote_start': {
                            body = '';
                            while (this.next().type !== 'blockquote_end') {
                                body += this.tok();
                            }
                            return this.renderer.blockquote(body);
                        }
                        case 'list_start': {
                            body = '';
                            var ordered = this.token.ordered, start = this.token.start;
                            while (this.next().type !== 'list_end') {
                                body += this.tok();
                            }
                            return this.renderer.list(body, ordered, start);
                        }
                        case 'list_item_start': {
                            body = '';
                            var loose = this.token.loose;
                            var checked = this.token.checked;
                            var task = this.token.task;
                            if (this.token.task) {
                                body += this.renderer.checkbox(checked);
                            }
                            while (this.next().type !== 'list_item_end') {
                                body += !loose && this.token.type === 'text'
                                    ? this.parseText()
                                    : this.tok();
                            }
                            return this.renderer.listitem(body, task, checked);
                        }
                        case 'html': {
                            // TODO parse inline content if parameter markdown=1
                            return this.renderer.html(this.token.text);
                        }
                        case 'paragraph': {
                            return this.renderer.paragraph(this.inline.output(this.token.text));
                        }
                        case 'text': {
                            return this.renderer.paragraph(this.parseText());
                        }
                        default: {
                            var errMsg = 'Token with "' + this.token.type + '" type was not found.';
                            if (this.options.silent) {
                                console.log(errMsg);
                            }
                            else {
                                throw new Error(errMsg);
                            }
                        }
                    }
                };
                /**
                 * Slugger generates header id
                 */
                function Slugger() {
                    this.seen = {};
                }
                /**
                 * Convert string to unique id
                 */
                Slugger.prototype.slug = function (value) {
                    var slug = value
                        .toLowerCase()
                        .trim()
                        .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '')
                        .replace(/\s/g, '-');
                    if (this.seen.hasOwnProperty(slug)) {
                        var originalSlug = slug;
                        do {
                            this.seen[originalSlug]++;
                            slug = originalSlug + '-' + this.seen[originalSlug];
                        } while (this.seen.hasOwnProperty(slug));
                    }
                    this.seen[slug] = 0;
                    return slug;
                };
                /**
                 * Helpers
                 */
                function escape(html, encode) {
                    if (encode) {
                        if (escape.escapeTest.test(html)) {
                            return html.replace(escape.escapeReplace, function (ch) { return escape.replacements[ch]; });
                        }
                    }
                    else {
                        if (escape.escapeTestNoEncode.test(html)) {
                            return html.replace(escape.escapeReplaceNoEncode, function (ch) { return escape.replacements[ch]; });
                        }
                    }
                    return html;
                }
                escape.escapeTest = /[&<>"']/;
                escape.escapeReplace = /[&<>"']/g;
                escape.replacements = {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#39;'
                };
                escape.escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
                escape.escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
                function unescape(html) {
                    // explicitly match decimal, hex, and named HTML entities
                    return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, function (_, n) {
                        n = n.toLowerCase();
                        if (n === 'colon')
                            return ':';
                        if (n.charAt(0) === '#') {
                            return n.charAt(1) === 'x'
                                ? String.fromCharCode(parseInt(n.substring(2), 16))
                                : String.fromCharCode(+n.substring(1));
                        }
                        return '';
                    });
                }
                function edit(regex, opt) {
                    regex = regex.source || regex;
                    opt = opt || '';
                    return {
                        replace: function (name, val) {
                            val = val.source || val;
                            val = val.replace(/(^|[^\[])\^/g, '$1');
                            regex = regex.replace(name, val);
                            return this;
                        },
                        getRegex: function () {
                            return new RegExp(regex, opt);
                        }
                    };
                }
                function cleanUrl(sanitize, base, href) {
                    if (sanitize) {
                        try {
                            var prot = decodeURIComponent(unescape(href))
                                .replace(/[^\w:]/g, '')
                                .toLowerCase();
                        }
                        catch (e) {
                            return null;
                        }
                        if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
                            return null;
                        }
                    }
                    if (base && !originIndependentUrl.test(href)) {
                        href = resolveUrl(base, href);
                    }
                    try {
                        href = encodeURI(href).replace(/%25/g, '%');
                    }
                    catch (e) {
                        return null;
                    }
                    return href;
                }
                function resolveUrl(base, href) {
                    if (!baseUrls[' ' + base]) {
                        // we can ignore everything in base after the last slash of its path component,
                        // but we might need to add _that_
                        // https://tools.ietf.org/html/rfc3986#section-3
                        if (/^[^:]+:\/*[^/]*$/.test(base)) {
                            baseUrls[' ' + base] = base + '/';
                        }
                        else {
                            baseUrls[' ' + base] = rtrim(base, '/', true);
                        }
                    }
                    base = baseUrls[' ' + base];
                    if (href.slice(0, 2) === '//') {
                        return base.replace(/:[\s\S]*/, ':') + href;
                    }
                    else if (href.charAt(0) === '/') {
                        return base.replace(/(:\/*[^/]*)[\s\S]*/, '$1') + href;
                    }
                    else {
                        return base + href;
                    }
                }
                var baseUrls = {};
                var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
                function noop() { }
                noop.exec = noop;
                function merge(obj) {
                    var i = 1, target, key;
                    for (; i < arguments.length; i++) {
                        target = arguments[i];
                        for (key in target) {
                            if (Object.prototype.hasOwnProperty.call(target, key)) {
                                obj[key] = target[key];
                            }
                        }
                    }
                    return obj;
                }
                function splitCells(tableRow, count) {
                    // ensure that every cell-delimiting pipe has a space
                    // before it to distinguish it from an escaped pipe
                    var row = tableRow.replace(/\|/g, function (match, offset, str) {
                        var escaped = false, curr = offset;
                        while (--curr >= 0 && str[curr] === '\\')
                            escaped = !escaped;
                        if (escaped) {
                            // odd number of slashes means | is escaped
                            // so we leave it alone
                            return '|';
                        }
                        else {
                            // add space before unescaped |
                            return ' |';
                        }
                    }), cells = row.split(/ \|/), i = 0;
                    if (cells.length > count) {
                        cells.splice(count);
                    }
                    else {
                        while (cells.length < count)
                            cells.push('');
                    }
                    for (; i < cells.length; i++) {
                        // leading or trailing whitespace is ignored per the gfm spec
                        cells[i] = cells[i].trim().replace(/\\\|/g, '|');
                    }
                    return cells;
                }
                // Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
                // /c*$/ is vulnerable to REDOS.
                // invert: Remove suffix of non-c chars instead. Default falsey.
                function rtrim(str, c, invert) {
                    if (str.length === 0) {
                        return '';
                    }
                    // Length of suffix matching the invert condition.
                    var suffLen = 0;
                    // Step left until we fail to match the invert condition.
                    while (suffLen < str.length) {
                        var currChar = str.charAt(str.length - suffLen - 1);
                        if (currChar === c && !invert) {
                            suffLen++;
                        }
                        else if (currChar !== c && invert) {
                            suffLen++;
                        }
                        else {
                            break;
                        }
                    }
                    return str.substr(0, str.length - suffLen);
                }
                function findClosingBracket(str, b) {
                    if (str.indexOf(b[1]) === -1) {
                        return -1;
                    }
                    var level = 0;
                    for (var i = 0; i < str.length; i++) {
                        if (str[i] === '\\') {
                            i++;
                        }
                        else if (str[i] === b[0]) {
                            level++;
                        }
                        else if (str[i] === b[1]) {
                            level--;
                            if (level < 0) {
                                return i;
                            }
                        }
                    }
                    return -1;
                }
                function checkSanitizeDeprecation(opt) {
                    if (opt && opt.sanitize && !opt.silent) {
                        console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');
                    }
                }
                /**
                 * Marked
                 */
                function marked(src, opt, callback) {
                    // throw error in case of non string input
                    if (typeof src === 'undefined' || src === null) {
                        throw new Error('marked(): input parameter is undefined or null');
                    }
                    if (typeof src !== 'string') {
                        throw new Error('marked(): input parameter is of type '
                            + Object.prototype.toString.call(src) + ', string expected');
                    }
                    if (callback || typeof opt === 'function') {
                        if (!callback) {
                            callback = opt;
                            opt = null;
                        }
                        opt = merge({}, marked.defaults, opt || {});
                        checkSanitizeDeprecation(opt);
                        var highlight = opt.highlight, tokens, pending, i = 0;
                        try {
                            tokens = Lexer.lex(src, opt);
                        }
                        catch (e) {
                            return callback(e);
                        }
                        pending = tokens.length;
                        var done = function (err) {
                            if (err) {
                                opt.highlight = highlight;
                                return callback(err);
                            }
                            var out;
                            try {
                                out = Parser.parse(tokens, opt);
                            }
                            catch (e) {
                                err = e;
                            }
                            opt.highlight = highlight;
                            return err
                                ? callback(err)
                                : callback(null, out);
                        };
                        if (!highlight || highlight.length < 3) {
                            return done();
                        }
                        delete opt.highlight;
                        if (!pending)
                            return done();
                        for (; i < tokens.length; i++) {
                            (function (token) {
                                if (token.type !== 'code') {
                                    return --pending || done();
                                }
                                return highlight(token.text, token.lang, function (err, code) {
                                    if (err)
                                        return done(err);
                                    if (code == null || code === token.text) {
                                        return --pending || done();
                                    }
                                    token.text = code;
                                    token.escaped = true;
                                    --pending || done();
                                });
                            })(tokens[i]);
                        }
                        return;
                    }
                    try {
                        if (opt)
                            opt = merge({}, marked.defaults, opt);
                        checkSanitizeDeprecation(opt);
                        return Parser.parse(Lexer.lex(src, opt), opt);
                    }
                    catch (e) {
                        e.message += '\nPlease report this to https://github.com/markedjs/marked.';
                        if ((opt || marked.defaults).silent) {
                            return '<p>An error occurred:</p><pre>'
                                + escape(e.message + '', true)
                                + '</pre>';
                        }
                        throw e;
                    }
                }
                /**
                 * Options
                 */
                marked.options =
                    marked.setOptions = function (opt) {
                        merge(marked.defaults, opt);
                        return marked;
                    };
                marked.getDefaults = function () {
                    return {
                        baseUrl: null,
                        breaks: false,
                        gfm: true,
                        headerIds: true,
                        headerPrefix: '',
                        highlight: null,
                        langPrefix: 'language-',
                        mangle: true,
                        pedantic: false,
                        renderer: new Renderer(),
                        sanitize: false,
                        sanitizer: null,
                        silent: false,
                        smartLists: false,
                        smartypants: false,
                        xhtml: false
                    };
                };
                marked.defaults = marked.getDefaults();
                /**
                 * Expose
                 */
                marked.Parser = Parser;
                marked.parser = Parser.parse;
                marked.Renderer = Renderer;
                marked.TextRenderer = TextRenderer;
                marked.Lexer = Lexer;
                marked.lexer = Lexer.lex;
                marked.InlineLexer = InlineLexer;
                marked.inlineLexer = InlineLexer.output;
                marked.Slugger = Slugger;
                marked.parse = marked;
                if (true) {
                    module.exports = marked;
                }
                else { }
            })(this || (typeof window !== 'undefined' ? window : global));
            /***/ 
        }),
        /***/ "./node_modules/ngx-markdown/fesm2015/ngx-markdown.js": 
        /*!************************************************************!*\
          !*** ./node_modules/ngx-markdown/fesm2015/ngx-markdown.js ***!
          \************************************************************/
        /*! exports provided: LanguagePipe, MarkdownComponent, MarkdownModule, MarkdownPipe, MarkdownService, MarkedOptions, MarkedRenderer, PrismPlugin, errorKatexNotLoaded, errorSrcWithoutHttpClient, initialMarkedOptions */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LanguagePipe", function () { return LanguagePipe; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MarkdownComponent", function () { return MarkdownComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MarkdownModule", function () { return MarkdownModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MarkdownPipe", function () { return MarkdownPipe; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MarkdownService", function () { return MarkdownService; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MarkedOptions", function () { return MarkedOptions; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MarkedRenderer", function () { return MarkedRenderer; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PrismPlugin", function () { return PrismPlugin; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "errorKatexNotLoaded", function () { return errorKatexNotLoaded; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "errorSrcWithoutHttpClient", function () { return errorSrcWithoutHttpClient; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initialMarkedOptions", function () { return initialMarkedOptions; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_common_http__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common/http */ "./node_modules/@angular/common/fesm2015/http.js");
            /* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/platform-browser */ "./node_modules/@angular/platform-browser/fesm2015/platform-browser.js");
            /* harmony import */ var marked__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! marked */ "./node_modules/marked/lib/marked.js");
            /* harmony import */ var marked__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/ __webpack_require__.n(marked__WEBPACK_IMPORTED_MODULE_4__);
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var LanguagePipe = /** @class */ (function () {
                function LanguagePipe() {
                }
                /**
                 * @param {?} value
                 * @param {?} language
                 * @return {?}
                 */
                LanguagePipe.prototype.transform = function (value, language) {
                    if (typeof value !== 'string') {
                        console.error("LanguagePipe has been invoked with an invalid value type [" + value + "]");
                        return value;
                    }
                    if (typeof language !== 'string') {
                        console.error("LanguagePipe has been invoked with an invalid parameter [" + language + "]");
                        return value;
                    }
                    return '```' + language + '\n' + value + '\n```';
                };
                return LanguagePipe;
            }());
            LanguagePipe.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Pipe"], args: [{
                            name: 'language',
                        },] }
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MarkedOptions = /** @class */ (function () {
                function MarkedOptions() {
                }
                return MarkedOptions;
            }());
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MarkedRenderer = /** @class */ (function (_super) {
                __extends(MarkedRenderer, _super);
                function MarkedRenderer() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MarkedRenderer;
            }(marked__WEBPACK_IMPORTED_MODULE_4__["Renderer"]));
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // tslint:disable:max-line-length
            /** @type {?} */
            var errorKatexNotLoaded = '[ngx-markdown When using the [katex] attribute you *have to* include KaTeX files to `angular.json` or use imports. See README for more information';
            /** @type {?} */
            var errorSrcWithoutHttpClient = '[ngx-markdown] When using the [src] attribute you *have to* pass the `HttpClient` as a parameter of the `forRoot` method. See README for more information';
            // tslint:enable:max-line-length
            var MarkdownService = /** @class */ (function () {
                /**
                 * @param {?} platform
                 * @param {?} http
                 * @param {?} domSanitizer
                 * @param {?} options
                 */
                function MarkdownService(platform, http, domSanitizer, options) {
                    this.platform = platform;
                    this.http = http;
                    this.domSanitizer = domSanitizer;
                    this.options = options;
                }
                Object.defineProperty(MarkdownService.prototype, "options", {
                    /**
                     * @return {?}
                     */
                    get: function () { return this._options; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._options = Object.assign({}, { renderer: new MarkedRenderer() }, this._options, value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MarkdownService.prototype, "renderer", {
                    /**
                     * @return {?}
                     */
                    get: function () { return this.options.renderer; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this.options.renderer = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @param {?} markdown
                 * @param {?=} decodeHtml
                 * @param {?=} markedOptions
                 * @return {?}
                 */
                MarkdownService.prototype.compile = function (markdown, decodeHtml, markedOptions) {
                    if (decodeHtml === void 0) { decodeHtml = false; }
                    if (markedOptions === void 0) { markedOptions = this.options; }
                    /** @type {?} */
                    var precompiled = this.trimIndentation(markdown);
                    precompiled = decodeHtml ? this.decodeHtml(precompiled) : precompiled;
                    /** @type {?} */
                    var compiled = Object(marked__WEBPACK_IMPORTED_MODULE_4__["parse"])(precompiled, markedOptions);
                    return markedOptions.sanitize && !markedOptions.sanitizer
                        ? this.domSanitizer.sanitize(_angular_core__WEBPACK_IMPORTED_MODULE_0__["SecurityContext"].HTML, compiled)
                        : compiled;
                };
                /**
                 * @param {?} src
                 * @return {?}
                 */
                MarkdownService.prototype.getSource = function (src) {
                    var _this_1 = this;
                    if (!this.http) {
                        throw new Error(errorSrcWithoutHttpClient);
                    }
                    return this.http
                        .get(src, { responseType: 'text' })
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["map"])(( /**
                 * @param {?} markdown
                 * @return {?}
                 */function (/**
                 * @param {?} markdown
                 * @return {?}
                 */ markdown) { return _this_1.handleExtension(src, markdown); })));
                };
                /**
                 * @param {?=} element
                 * @return {?}
                 */
                MarkdownService.prototype.highlight = function (element) {
                    if (Object(_angular_common__WEBPACK_IMPORTED_MODULE_1__["isPlatformBrowser"])(this.platform) && typeof Prism !== 'undefined') {
                        if (!element) {
                            element = document;
                        }
                        /** @type {?} */
                        var noLanguageElements = element.querySelectorAll('pre code:not([class*="language-"])');
                        Array.prototype.forEach.call(noLanguageElements, ( /**
                         * @param {?} x
                         * @return {?}
                         */function (x) { return x.classList.add('language-none'); }));
                        Prism.highlightAllUnder(element);
                    }
                };
                /**
                 * @param {?} html
                 * @param {?=} options
                 * @return {?}
                 */
                MarkdownService.prototype.renderKatex = function (html, options) {
                    if (typeof katex === 'undefined' || typeof katex.renderToString === 'undefined') {
                        throw new Error(errorKatexNotLoaded);
                    }
                    return html.replace(/\$([^\s][^$]*?[^\s])\$/gm, ( /**
                     * @param {?} _
                     * @param {?} tex
                     * @return {?}
                     */function (_, tex) { return katex.renderToString(tex, options); }));
                };
                /**
                 * @private
                 * @param {?} html
                 * @return {?}
                 */
                MarkdownService.prototype.decodeHtml = function (html) {
                    if (Object(_angular_common__WEBPACK_IMPORTED_MODULE_1__["isPlatformBrowser"])(this.platform)) {
                        /** @type {?} */
                        var textarea = document.createElement('textarea');
                        textarea.innerHTML = html;
                        return textarea.value;
                    }
                    return html;
                };
                /**
                 * @private
                 * @param {?} src
                 * @param {?} markdown
                 * @return {?}
                 */
                MarkdownService.prototype.handleExtension = function (src, markdown) {
                    /** @type {?} */
                    var extension = src
                        ? src.split('?')[0].split('.').splice(-1).join()
                        : null;
                    return extension !== 'md'
                        ? '```' + extension + '\n' + markdown + '\n```'
                        : markdown;
                };
                /**
                 * @private
                 * @param {?} markdown
                 * @return {?}
                 */
                MarkdownService.prototype.trimIndentation = function (markdown) {
                    if (!markdown) {
                        return '';
                    }
                    /** @type {?} */
                    var indentStart;
                    return markdown
                        .split('\n')
                        .map(( /**
                 * @param {?} line
                 * @return {?}
                 */function (/**
                 * @param {?} line
                 * @return {?}
                 */ line) {
                        /** @type {?} */
                        var lineIdentStart = indentStart;
                        if (line.length > 0) {
                            lineIdentStart = isNaN(lineIdentStart)
                                ? line.search(/\S|$/)
                                : Math.min(line.search(/\S|$/), lineIdentStart);
                        }
                        if (isNaN(indentStart)) {
                            indentStart = lineIdentStart;
                        }
                        return !!lineIdentStart
                            ? line.substring(lineIdentStart)
                            : line;
                    })).join('\n');
                };
                return MarkdownService;
            }());
            MarkdownService.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"] }
            ];
            /** @nocollapse */
            MarkdownService.ctorParameters = function () { return [
                { type: Object, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["PLATFORM_ID"],] }] },
                { type: _angular_common_http__WEBPACK_IMPORTED_MODULE_2__["HttpClient"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_3__["DomSanitizer"] },
                { type: MarkedOptions }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @enum {string} */
            var PrismPlugin = {
                LineHighlight: 'line-highlight',
                LineNumbers: 'line-numbers',
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MarkdownComponent = /** @class */ (function () {
                /**
                 * @param {?} element
                 * @param {?} markdownService
                 */
                function MarkdownComponent(element, markdownService) {
                    this.element = element;
                    this.markdownService = markdownService;
                    this.error = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    this.load = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    this._katex = false;
                    this._lineHighlight = false;
                    this._lineNumbers = false;
                }
                Object.defineProperty(MarkdownComponent.prototype, "katex", {
                    // Plugin - katex
                    /**
                     * @return {?}
                     */
                    get: function () { return this._katex; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._katex = this.coerceBooleanProperty(value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MarkdownComponent.prototype, "lineNumbers", {
                    // Plugin - lineNumbers
                    /**
                     * @return {?}
                     */
                    get: function () { return this._lineNumbers; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._lineNumbers = this.coerceBooleanProperty(value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MarkdownComponent.prototype, "lineHighlight", {
                    // Plugin - lineHighlight
                    /**
                     * @return {?}
                     */
                    get: function () { return this._lineHighlight; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._lineHighlight = this.coerceBooleanProperty(value); },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MarkdownComponent.prototype.ngOnChanges = function () {
                    if (this.data != null) {
                        this.handleData();
                        return;
                    }
                    if (this.src != null) {
                        this.handleSrc();
                        return;
                    }
                };
                /**
                 * @return {?}
                 */
                MarkdownComponent.prototype.ngAfterViewInit = function () {
                    if (!this.data && !this.src) {
                        this.handleTransclusion();
                    }
                };
                /**
                 * @param {?} markdown
                 * @param {?=} decodeHtml
                 * @return {?}
                 */
                MarkdownComponent.prototype.render = function (markdown, decodeHtml) {
                    if (decodeHtml === void 0) { decodeHtml = false; }
                    /** @type {?} */
                    var compiled = this.markdownService.compile(markdown, decodeHtml);
                    compiled = this.katex ? this.markdownService.renderKatex(compiled, this.katexOptions) : compiled;
                    this.element.nativeElement.innerHTML = compiled;
                    this.handlePlugins();
                    this.markdownService.highlight(this.element.nativeElement);
                };
                /**
                 * @private
                 * @param {?} value
                 * @return {?}
                 */
                MarkdownComponent.prototype.coerceBooleanProperty = function (value) {
                    return value != null && "" + value !== 'false';
                };
                /**
                 * @private
                 * @return {?}
                 */
                MarkdownComponent.prototype.handleData = function () {
                    this.render(this.data);
                };
                /**
                 * @private
                 * @return {?}
                 */
                MarkdownComponent.prototype.handleSrc = function () {
                    var _this_1 = this;
                    this.markdownService
                        .getSource(this.src)
                        .subscribe(( /**
                 * @param {?} markdown
                 * @return {?}
                 */function (/**
                 * @param {?} markdown
                 * @return {?}
                 */ markdown) {
                        _this_1.render(markdown);
                        _this_1.load.emit(markdown);
                    }), ( /**
                     * @param {?} error
                     * @return {?}
                     */function (/**
                     * @param {?} error
                     * @return {?}
                     */ error) { return _this_1.error.emit(error); }));
                };
                /**
                 * @private
                 * @return {?}
                 */
                MarkdownComponent.prototype.handleTransclusion = function () {
                    this.render(this.element.nativeElement.innerHTML, true);
                };
                /**
                 * @private
                 * @return {?}
                 */
                MarkdownComponent.prototype.handlePlugins = function () {
                    if (this.lineHighlight) {
                        this.setPluginClass(this.element.nativeElement, PrismPlugin.LineHighlight);
                        this.setPluginOptions(this.element.nativeElement, { dataLine: this.line, dataLineOffset: this.lineOffset });
                    }
                    if (this.lineNumbers) {
                        this.setPluginClass(this.element.nativeElement, PrismPlugin.LineNumbers);
                        this.setPluginOptions(this.element.nativeElement, { dataStart: this.start });
                    }
                };
                /**
                 * @private
                 * @param {?} element
                 * @param {?} plugin
                 * @return {?}
                 */
                MarkdownComponent.prototype.setPluginClass = function (element, plugin) {
                    var _a;
                    /** @type {?} */
                    var preElements = element.querySelectorAll('pre');
                    for (var i = 0; i < preElements.length; i++) {
                        /** @type {?} */
                        var classes = plugin instanceof Array ? plugin : [plugin];
                        (_a = preElements.item(i).classList).add.apply(_a, classes);
                    }
                };
                /**
                 * @private
                 * @param {?} element
                 * @param {?} options
                 * @return {?}
                 */
                MarkdownComponent.prototype.setPluginOptions = function (element, options) {
                    var _this_1 = this;
                    /** @type {?} */
                    var preElements = element.querySelectorAll('pre');
                    var _loop_4 = function (i) {
                        Object.keys(options).forEach(( /**
                         * @param {?} option
                         * @return {?}
                         */function (/**
                         * @param {?} option
                         * @return {?}
                         */ option) {
                            /** @type {?} */
                            var attributeValue = options[option];
                            if (!!attributeValue) {
                                /** @type {?} */
                                var attributeName = _this_1.toLispCase(option);
                                preElements.item(i).setAttribute(attributeName, attributeValue.toString());
                            }
                        }));
                    };
                    for (var i = 0; i < preElements.length; i++) {
                        _loop_4(i);
                    }
                };
                /**
                 * @private
                 * @param {?} value
                 * @return {?}
                 */
                MarkdownComponent.prototype.toLispCase = function (value) {
                    /** @type {?} */
                    var upperChars = value.match(/([A-Z])/g);
                    if (!upperChars) {
                        return value;
                    }
                    /** @type {?} */
                    var str = value.toString();
                    for (var i = 0, n = upperChars.length; i < n; i++) {
                        str = str.replace(new RegExp(upperChars[i]), '-' + upperChars[i].toLowerCase());
                    }
                    if (str.slice(0, 1) === '-') {
                        str = str.slice(1);
                    }
                    return str;
                };
                return MarkdownComponent;
            }());
            MarkdownComponent.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{
                            // tslint:disable-next-line:component-selector
                            selector: 'markdown, [markdown]',
                            template: '<ng-content></ng-content>'
                        }] }
            ];
            /** @nocollapse */
            MarkdownComponent.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: MarkdownService }
            ]; };
            MarkdownComponent.propDecorators = {
                data: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                src: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                katex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                katexOptions: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                lineNumbers: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                start: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                lineHighlight: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                line: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                lineOffset: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                error: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                load: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MarkdownPipe = /** @class */ (function () {
                /**
                 * @param {?} elementRef
                 * @param {?} markdownService
                 * @param {?} zone
                 */
                function MarkdownPipe(elementRef, markdownService, zone) {
                    this.elementRef = elementRef;
                    this.markdownService = markdownService;
                    this.zone = zone;
                }
                /**
                 * @param {?} value
                 * @return {?}
                 */
                MarkdownPipe.prototype.transform = function (value) {
                    var _this_1 = this;
                    if (value == null) {
                        return '';
                    }
                    if (typeof value !== 'string') {
                        console.error("MarkdownPipe has been invoked with an invalid value type [" + value + "]");
                        return value;
                    }
                    /** @type {?} */
                    var markdown = this.markdownService.compile(value);
                    this.zone.onStable
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])())
                        .subscribe(( /**
                 * @return {?}
                 */function () { return _this_1.markdownService.highlight(_this_1.elementRef.nativeElement); }));
                    return markdown;
                };
                return MarkdownPipe;
            }());
            MarkdownPipe.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Pipe"], args: [{
                            name: 'markdown',
                        },] }
            ];
            /** @nocollapse */
            MarkdownPipe.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: MarkdownService },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var ɵ0 = {
                gfm: true,
                tables: true,
                breaks: false,
                pedantic: false,
                sanitize: false,
                smartLists: true,
                smartypants: false,
            };
            /** @type {?} */
            var initialMarkedOptions = {
                provide: MarkedOptions,
                useValue: ɵ0,
            };
            /** @type {?} */
            var sharedDeclarations = [
                LanguagePipe,
                MarkdownComponent,
                MarkdownPipe,
            ];
            var MarkdownModule = /** @class */ (function () {
                function MarkdownModule() {
                }
                /**
                 * @param {?=} markdownModuleConfig
                 * @return {?}
                 */
                MarkdownModule.forRoot = function (markdownModuleConfig) {
                    return {
                        ngModule: MarkdownModule,
                        providers: [
                            MarkdownService,
                            markdownModuleConfig && markdownModuleConfig.loader || [],
                            markdownModuleConfig && markdownModuleConfig.markedOptions || initialMarkedOptions,
                        ],
                    };
                };
                /**
                 * @return {?}
                 */
                MarkdownModule.forChild = function () {
                    return {
                        ngModule: MarkdownModule,
                    };
                };
                return MarkdownModule;
            }());
            MarkdownModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            exports: sharedDeclarations,
                            declarations: sharedDeclarations,
                        },] }
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=ngx-markdown.js.map
            /***/ 
        }),
        /***/ "./node_modules/raw-loader/dist/cjs.js!./src/app/core/transform-tool/transform-tool.component.html": 
        /*!*********************************************************************************************************!*\
          !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/core/transform-tool/transform-tool.component.html ***!
          \*********************************************************************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony default export */ __webpack_exports__["default"] = ("<h1>{{ title }}</h1>\r\n\r\n<json-schema-form [layout]=\"layout\"\r\n    [schema]=\"schema\"\r\n    [options]=\"formOptions\"\r\n    [(data)]=\"data\"\r\n    framework=\"material-design\"\r\n    (onSubmit)=\"onSubmit()\">\r\n</json-schema-form>\r\n\r\n<pre *ngIf=\"result\">{{result}}</pre>\r\n\r\n<h2>Overview</h2>\r\n\r\n<markdown [data]=\"documentation\"></markdown>");
            /***/ 
        }),
        /***/ "./node_modules/type-of-is/index.js": 
        /*!******************************************!*\
          !*** ./node_modules/type-of-is/index.js ***!
          \******************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            (function (factory) {
                if (true) {
                    module.exports = factory();
                }
                else { }
            }(function () {
                var isBuiltIn = (function () {
                    var built_ins = [
                        Object,
                        Function,
                        Array,
                        String,
                        Boolean,
                        Number,
                        Date,
                        RegExp,
                        Error
                    ];
                    var built_ins_length = built_ins.length;
                    return function (_constructor) {
                        for (var i = 0; i < built_ins_length; i++) {
                            if (built_ins[i] === _constructor) {
                                return true;
                            }
                        }
                        return false;
                    };
                })();
                var stringType = (function () {
                    var _toString = ({}).toString;
                    return function (obj) {
                        // [object Blah] -> Blah
                        var stype = _toString.call(obj).slice(8, -1);
                        if ((obj === null) || (obj === undefined)) {
                            return stype.toLowerCase();
                        }
                        var ctype = of(obj);
                        if (ctype && !isBuiltIn(ctype)) {
                            return ctype.name;
                        }
                        else {
                            return stype;
                        }
                    };
                })();
                function of(obj) {
                    if ((obj === null) || (obj === undefined)) {
                        return obj;
                    }
                    else {
                        return obj.constructor;
                    }
                }
                function is(obj, test) {
                    var typer = (of(test) === String) ? stringType : of;
                    return (typer(obj) === test);
                }
                function instance(obj, test) {
                    return (obj instanceof test);
                }
                function extension(_Extension, _Base) {
                    return instance(_Extension.prototype, _Base);
                }
                function any(obj, tests) {
                    if (!is(tests, Array)) {
                        throw ("Second argument to .any() should be array");
                    }
                    for (var i = 0; i < tests.length; i++) {
                        var test = tests[i];
                        if (is(obj, test)) {
                            return true;
                        }
                    }
                    return false;
                }
                var exports = function (obj, type) {
                    if (arguments.length == 1) {
                        return of(obj);
                    }
                    else {
                        if (is(type, Array)) {
                            return any(obj, type);
                        }
                        else {
                            return is(obj, type);
                        }
                    }
                };
                exports.instance = instance;
                exports.string = stringType;
                exports.of = of;
                exports.is = is;
                exports.any = any;
                exports.extension = extension;
                return exports;
            }));
            /***/ 
        }),
        /***/ "./node_modules/uri-js/dist/es5/uri.all.js": 
        /*!*************************************************!*\
          !*** ./node_modules/uri-js/dist/es5/uri.all.js ***!
          \*************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            /** @license URI.js v4.2.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
            (function (global, factory) {
                true ? factory(exports) :
                    undefined;
            }(this, (function (exports) {
                'use strict';
                function merge() {
                    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
                        sets[_key] = arguments[_key];
                    }
                    if (sets.length > 1) {
                        sets[0] = sets[0].slice(0, -1);
                        var xl = sets.length - 1;
                        for (var x = 1; x < xl; ++x) {
                            sets[x] = sets[x].slice(1, -1);
                        }
                        sets[xl] = sets[xl].slice(1);
                        return sets.join('');
                    }
                    else {
                        return sets[0];
                    }
                }
                function subexp(str) {
                    return "(?:" + str + ")";
                }
                function typeOf(o) {
                    return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
                }
                function toUpperCase(str) {
                    return str.toUpperCase();
                }
                function toArray(obj) {
                    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
                }
                function assign(target, source) {
                    var obj = target;
                    if (source) {
                        for (var key in source) {
                            obj[key] = source[key];
                        }
                    }
                    return obj;
                }
                function buildExps(isIRI) {
                    var ALPHA$$ = "[A-Za-z]", CR$ = "[\\x0D]", DIGIT$$ = "[0-9]", DQUOTE$$ = "[\\x22]", HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"), 
                    //case-insensitive
                    LF$$ = "[\\x0A]", SP$$ = "[\\x20]", PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)), 
                    //expanded
                    GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", 
                    //subset, excludes bidi control characters
                    IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]", 
                    //subset
                    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), 
                    //relaxed parsing rules
                    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$ + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), 
                    //                           6( h16 ":" ) ls32
                    IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), 
                    //                      "::" 5( h16 ":" ) ls32
                    IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), 
                    //[               h16 ] "::" 4( h16 ":" ) ls32
                    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), 
                    //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
                    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), 
                    //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
                    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), 
                    //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
                    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), 
                    //[ *4( h16 ":" ) h16 ] "::"              ls32
                    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), 
                    //[ *5( h16 ":" ) h16 ] "::"              h16
                    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), 
                    //[ *6( h16 ":" ) h16 ] "::"
                    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+"), 
                    //RFC 6874
                    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), 
                    //RFC 6874
                    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + ZONEID$), 
                    //RFC 6874, with relaxed parsing rules
                    IPVFUTURE$ = subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), 
                    //RFC 6874
                    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")" + "|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), 
                    //simplified
                    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), 
                    //simplified
                    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), 
                    //simplified
                    PATH_EMPTY$ = "(?!" + PCHAR$ + ")", PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$", SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
                    return {
                        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
                        NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
                        NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
                        NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
                        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
                        NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
                        NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
                        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
                        UNRESERVED: new RegExp(UNRESERVED$$, "g"),
                        OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
                        PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
                        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
                        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$") //RFC 6874, with relaxed parsing rules
                    };
                }
                var URI_PROTOCOL = buildExps(false);
                var IRI_PROTOCOL = buildExps(true);
                var slicedToArray = function () {
                    function sliceIterator(arr, i) {
                        var _arr = [];
                        var _n = true;
                        var _d = false;
                        var _e = undefined;
                        try {
                            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                                _arr.push(_s.value);
                                if (i && _arr.length === i)
                                    break;
                            }
                        }
                        catch (err) {
                            _d = true;
                            _e = err;
                        }
                        finally {
                            try {
                                if (!_n && _i["return"])
                                    _i["return"]();
                            }
                            finally {
                                if (_d)
                                    throw _e;
                            }
                        }
                        return _arr;
                    }
                    return function (arr, i) {
                        if (Array.isArray(arr)) {
                            return arr;
                        }
                        else if (Symbol.iterator in Object(arr)) {
                            return sliceIterator(arr, i);
                        }
                        else {
                            throw new TypeError("Invalid attempt to destructure non-iterable instance");
                        }
                    };
                }();
                var toConsumableArray = function (arr) {
                    if (Array.isArray(arr)) {
                        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
                            arr2[i] = arr[i];
                        return arr2;
                    }
                    else {
                        return Array.from(arr);
                    }
                };
                /** Highest positive signed 32-bit float value */
                var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
                /** Bootstring parameters */
                var base = 36;
                var tMin = 1;
                var tMax = 26;
                var skew = 38;
                var damp = 700;
                var initialBias = 72;
                var initialN = 128; // 0x80
                var delimiter = '-'; // '\x2D'
                /** Regular expressions */
                var regexPunycode = /^xn--/;
                var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
                var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
                /** Error messages */
                var errors = {
                    'overflow': 'Overflow: input needs wider integers to process',
                    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
                    'invalid-input': 'Invalid input'
                };
                /** Convenience shortcuts */
                var baseMinusTMin = base - tMin;
                var floor = Math.floor;
                var stringFromCharCode = String.fromCharCode;
                /*--------------------------------------------------------------------------*/
                /**
                 * A generic error utility function.
                 * @private
                 * @param {String} type The error type.
                 * @returns {Error} Throws a `RangeError` with the applicable error message.
                 */
                function error$1(type) {
                    throw new RangeError(errors[type]);
                }
                /**
                 * A generic `Array#map` utility function.
                 * @private
                 * @param {Array} array The array to iterate over.
                 * @param {Function} callback The function that gets called for every array
                 * item.
                 * @returns {Array} A new array of values returned by the callback function.
                 */
                function map(array, fn) {
                    var result = [];
                    var length = array.length;
                    while (length--) {
                        result[length] = fn(array[length]);
                    }
                    return result;
                }
                /**
                 * A simple `Array#map`-like wrapper to work with domain name strings or email
                 * addresses.
                 * @private
                 * @param {String} domain The domain name or email address.
                 * @param {Function} callback The function that gets called for every
                 * character.
                 * @returns {Array} A new string of characters returned by the callback
                 * function.
                 */
                function mapDomain(string, fn) {
                    var parts = string.split('@');
                    var result = '';
                    if (parts.length > 1) {
                        // In email addresses, only the domain name should be punycoded. Leave
                        // the local part (i.e. everything up to `@`) intact.
                        result = parts[0] + '@';
                        string = parts[1];
                    }
                    // Avoid `split(regex)` for IE8 compatibility. See #17.
                    string = string.replace(regexSeparators, '\x2E');
                    var labels = string.split('.');
                    var encoded = map(labels, fn).join('.');
                    return result + encoded;
                }
                /**
                 * Creates an array containing the numeric code points of each Unicode
                 * character in the string. While JavaScript uses UCS-2 internally,
                 * this function will convert a pair of surrogate halves (each of which
                 * UCS-2 exposes as separate characters) into a single code point,
                 * matching UTF-16.
                 * @see `punycode.ucs2.encode`
                 * @see <https://mathiasbynens.be/notes/javascript-encoding>
                 * @memberOf punycode.ucs2
                 * @name decode
                 * @param {String} string The Unicode input string (UCS-2).
                 * @returns {Array} The new array of code points.
                 */
                function ucs2decode(string) {
                    var output = [];
                    var counter = 0;
                    var length = string.length;
                    while (counter < length) {
                        var value = string.charCodeAt(counter++);
                        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                            // It's a high surrogate, and there is a next character.
                            var extra = string.charCodeAt(counter++);
                            if ((extra & 0xFC00) == 0xDC00) {
                                // Low surrogate.
                                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                            }
                            else {
                                // It's an unmatched surrogate; only append this code unit, in case the
                                // next code unit is the high surrogate of a surrogate pair.
                                output.push(value);
                                counter--;
                            }
                        }
                        else {
                            output.push(value);
                        }
                    }
                    return output;
                }
                /**
                 * Creates a string based on an array of numeric code points.
                 * @see `punycode.ucs2.decode`
                 * @memberOf punycode.ucs2
                 * @name encode
                 * @param {Array} codePoints The array of numeric code points.
                 * @returns {String} The new Unicode string (UCS-2).
                 */
                var ucs2encode = function ucs2encode(array) {
                    return String.fromCodePoint.apply(String, toConsumableArray(array));
                };
                /**
                 * Converts a basic code point into a digit/integer.
                 * @see `digitToBasic()`
                 * @private
                 * @param {Number} codePoint The basic numeric code point value.
                 * @returns {Number} The numeric value of a basic code point (for use in
                 * representing integers) in the range `0` to `base - 1`, or `base` if
                 * the code point does not represent a value.
                 */
                var basicToDigit = function basicToDigit(codePoint) {
                    if (codePoint - 0x30 < 0x0A) {
                        return codePoint - 0x16;
                    }
                    if (codePoint - 0x41 < 0x1A) {
                        return codePoint - 0x41;
                    }
                    if (codePoint - 0x61 < 0x1A) {
                        return codePoint - 0x61;
                    }
                    return base;
                };
                /**
                 * Converts a digit/integer into a basic code point.
                 * @see `basicToDigit()`
                 * @private
                 * @param {Number} digit The numeric value of a basic code point.
                 * @returns {Number} The basic code point whose value (when used for
                 * representing integers) is `digit`, which needs to be in the range
                 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
                 * used; else, the lowercase form is used. The behavior is undefined
                 * if `flag` is non-zero and `digit` has no uppercase form.
                 */
                var digitToBasic = function digitToBasic(digit, flag) {
                    //  0..25 map to ASCII a..z or A..Z
                    // 26..35 map to ASCII 0..9
                    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
                };
                /**
                 * Bias adaptation function as per section 3.4 of RFC 3492.
                 * https://tools.ietf.org/html/rfc3492#section-3.4
                 * @private
                 */
                var adapt = function adapt(delta, numPoints, firstTime) {
                    var k = 0;
                    delta = firstTime ? floor(delta / damp) : delta >> 1;
                    delta += floor(delta / numPoints);
                    for (; /* no initialization */ delta > baseMinusTMin * tMax >> 1; k += base) {
                        delta = floor(delta / baseMinusTMin);
                    }
                    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
                };
                /**
                 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
                 * symbols.
                 * @memberOf punycode
                 * @param {String} input The Punycode string of ASCII-only symbols.
                 * @returns {String} The resulting string of Unicode symbols.
                 */
                var decode = function decode(input) {
                    // Don't use UCS-2.
                    var output = [];
                    var inputLength = input.length;
                    var i = 0;
                    var n = initialN;
                    var bias = initialBias;
                    // Handle the basic code points: let `basic` be the number of input code
                    // points before the last delimiter, or `0` if there is none, then copy
                    // the first basic code points to the output.
                    var basic = input.lastIndexOf(delimiter);
                    if (basic < 0) {
                        basic = 0;
                    }
                    for (var j = 0; j < basic; ++j) {
                        // if it's not a basic code point
                        if (input.charCodeAt(j) >= 0x80) {
                            error$1('not-basic');
                        }
                        output.push(input.charCodeAt(j));
                    }
                    // Main decoding loop: start just after the last delimiter if any basic code
                    // points were copied; start at the beginning otherwise.
                    for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */ {
                        // `index` is the index of the next character to be consumed.
                        // Decode a generalized variable-length integer into `delta`,
                        // which gets added to `i`. The overflow checking is easier
                        // if we increase `i` as we go, then subtract off its starting
                        // value at the end to obtain `delta`.
                        var oldi = i;
                        for (var w = 1, k = base;; /* no condition */ k += base) {
                            if (index >= inputLength) {
                                error$1('invalid-input');
                            }
                            var digit = basicToDigit(input.charCodeAt(index++));
                            if (digit >= base || digit > floor((maxInt - i) / w)) {
                                error$1('overflow');
                            }
                            i += digit * w;
                            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                            if (digit < t) {
                                break;
                            }
                            var baseMinusT = base - t;
                            if (w > floor(maxInt / baseMinusT)) {
                                error$1('overflow');
                            }
                            w *= baseMinusT;
                        }
                        var out = output.length + 1;
                        bias = adapt(i - oldi, out, oldi == 0);
                        // `i` was supposed to wrap around from `out` to `0`,
                        // incrementing `n` each time, so we'll fix that now:
                        if (floor(i / out) > maxInt - n) {
                            error$1('overflow');
                        }
                        n += floor(i / out);
                        i %= out;
                        // Insert `n` at position `i` of the output.
                        output.splice(i++, 0, n);
                    }
                    return String.fromCodePoint.apply(String, output);
                };
                /**
                 * Converts a string of Unicode symbols (e.g. a domain name label) to a
                 * Punycode string of ASCII-only symbols.
                 * @memberOf punycode
                 * @param {String} input The string of Unicode symbols.
                 * @returns {String} The resulting Punycode string of ASCII-only symbols.
                 */
                var encode = function encode(input) {
                    var output = [];
                    // Convert the input in UCS-2 to an array of Unicode code points.
                    input = ucs2decode(input);
                    // Cache the length.
                    var inputLength = input.length;
                    // Initialize the state.
                    var n = initialN;
                    var delta = 0;
                    var bias = initialBias;
                    // Handle the basic code points.
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;
                    try {
                        for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var _currentValue2 = _step.value;
                            if (_currentValue2 < 0x80) {
                                output.push(stringFromCharCode(_currentValue2));
                            }
                        }
                    }
                    catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    }
                    finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return) {
                                _iterator.return();
                            }
                        }
                        finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                    var basicLength = output.length;
                    var handledCPCount = basicLength;
                    // `handledCPCount` is the number of code points that have been handled;
                    // `basicLength` is the number of basic code points.
                    // Finish the basic string with a delimiter unless it's empty.
                    if (basicLength) {
                        output.push(delimiter);
                    }
                    // Main encoding loop:
                    while (handledCPCount < inputLength) {
                        // All non-basic code points < n have been handled already. Find the next
                        // larger one:
                        var m = maxInt;
                        var _iteratorNormalCompletion2 = true;
                        var _didIteratorError2 = false;
                        var _iteratorError2 = undefined;
                        try {
                            for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                var currentValue = _step2.value;
                                if (currentValue >= n && currentValue < m) {
                                    m = currentValue;
                                }
                            }
                            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                            // but guard against overflow.
                        }
                        catch (err) {
                            _didIteratorError2 = true;
                            _iteratorError2 = err;
                        }
                        finally {
                            try {
                                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                    _iterator2.return();
                                }
                            }
                            finally {
                                if (_didIteratorError2) {
                                    throw _iteratorError2;
                                }
                            }
                        }
                        var handledCPCountPlusOne = handledCPCount + 1;
                        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                            error$1('overflow');
                        }
                        delta += (m - n) * handledCPCountPlusOne;
                        n = m;
                        var _iteratorNormalCompletion3 = true;
                        var _didIteratorError3 = false;
                        var _iteratorError3 = undefined;
                        try {
                            for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                                var _currentValue = _step3.value;
                                if (_currentValue < n && ++delta > maxInt) {
                                    error$1('overflow');
                                }
                                if (_currentValue == n) {
                                    // Represent delta as a generalized variable-length integer.
                                    var q = delta;
                                    for (var k = base;; /* no condition */ k += base) {
                                        var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                                        if (q < t) {
                                            break;
                                        }
                                        var qMinusT = q - t;
                                        var baseMinusT = base - t;
                                        output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                                        q = floor(qMinusT / baseMinusT);
                                    }
                                    output.push(stringFromCharCode(digitToBasic(q, 0)));
                                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                                    delta = 0;
                                    ++handledCPCount;
                                }
                            }
                        }
                        catch (err) {
                            _didIteratorError3 = true;
                            _iteratorError3 = err;
                        }
                        finally {
                            try {
                                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                                    _iterator3.return();
                                }
                            }
                            finally {
                                if (_didIteratorError3) {
                                    throw _iteratorError3;
                                }
                            }
                        }
                        ++delta;
                        ++n;
                    }
                    return output.join('');
                };
                /**
                 * Converts a Punycode string representing a domain name or an email address
                 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
                 * it doesn't matter if you call it on a string that has already been
                 * converted to Unicode.
                 * @memberOf punycode
                 * @param {String} input The Punycoded domain name or email address to
                 * convert to Unicode.
                 * @returns {String} The Unicode representation of the given Punycode
                 * string.
                 */
                var toUnicode = function toUnicode(input) {
                    return mapDomain(input, function (string) {
                        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
                    });
                };
                /**
                 * Converts a Unicode string representing a domain name or an email address to
                 * Punycode. Only the non-ASCII parts of the domain name will be converted,
                 * i.e. it doesn't matter if you call it with a domain that's already in
                 * ASCII.
                 * @memberOf punycode
                 * @param {String} input The domain name or email address to convert, as a
                 * Unicode string.
                 * @returns {String} The Punycode representation of the given domain name or
                 * email address.
                 */
                var toASCII = function toASCII(input) {
                    return mapDomain(input, function (string) {
                        return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
                    });
                };
                /*--------------------------------------------------------------------------*/
                /** Define the public API */
                var punycode = {
                    /**
                  * A string representing the current Punycode.js version number.
                  * @memberOf punycode
                  * @type String
                  */
                    'version': '2.1.0',
                    /**
                  * An object of methods to convert from JavaScript's internal character
                  * representation (UCS-2) to Unicode code points, and back.
                  * @see <https://mathiasbynens.be/notes/javascript-encoding>
                  * @memberOf punycode
                  * @type Object
                  */
                    'ucs2': {
                        'decode': ucs2decode,
                        'encode': ucs2encode
                    },
                    'decode': decode,
                    'encode': encode,
                    'toASCII': toASCII,
                    'toUnicode': toUnicode
                };
                /**
                 * URI.js
                 *
                 * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
                 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
                 * @see http://github.com/garycourt/uri-js
                 */
                /**
                 * Copyright 2011 Gary Court. All rights reserved.
                 *
                 * Redistribution and use in source and binary forms, with or without modification, are
                 * permitted provided that the following conditions are met:
                 *
                 *    1. Redistributions of source code must retain the above copyright notice, this list of
                 *       conditions and the following disclaimer.
                 *
                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
                 *       of conditions and the following disclaimer in the documentation and/or other materials
                 *       provided with the distribution.
                 *
                 * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                 *
                 * The views and conclusions contained in the software and documentation are those of the
                 * authors and should not be interpreted as representing official policies, either expressed
                 * or implied, of Gary Court.
                 */
                var SCHEMES = {};
                function pctEncChar(chr) {
                    var c = chr.charCodeAt(0);
                    var e = void 0;
                    if (c < 16)
                        e = "%0" + c.toString(16).toUpperCase();
                    else if (c < 128)
                        e = "%" + c.toString(16).toUpperCase();
                    else if (c < 2048)
                        e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
                    else
                        e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
                    return e;
                }
                function pctDecChars(str) {
                    var newStr = "";
                    var i = 0;
                    var il = str.length;
                    while (i < il) {
                        var c = parseInt(str.substr(i + 1, 2), 16);
                        if (c < 128) {
                            newStr += String.fromCharCode(c);
                            i += 3;
                        }
                        else if (c >= 194 && c < 224) {
                            if (il - i >= 6) {
                                var c2 = parseInt(str.substr(i + 4, 2), 16);
                                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
                            }
                            else {
                                newStr += str.substr(i, 6);
                            }
                            i += 6;
                        }
                        else if (c >= 224) {
                            if (il - i >= 9) {
                                var _c = parseInt(str.substr(i + 4, 2), 16);
                                var c3 = parseInt(str.substr(i + 7, 2), 16);
                                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
                            }
                            else {
                                newStr += str.substr(i, 9);
                            }
                            i += 9;
                        }
                        else {
                            newStr += str.substr(i, 3);
                            i += 3;
                        }
                    }
                    return newStr;
                }
                function _normalizeComponentEncoding(components, protocol) {
                    function decodeUnreserved(str) {
                        var decStr = pctDecChars(str);
                        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
                    }
                    if (components.scheme)
                        components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
                    if (components.userinfo !== undefined)
                        components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
                    if (components.host !== undefined)
                        components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
                    if (components.path !== undefined)
                        components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
                    if (components.query !== undefined)
                        components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
                    if (components.fragment !== undefined)
                        components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
                    return components;
                }
                function _stripLeadingZeros(str) {
                    return str.replace(/^0*(.*)/, "$1") || "0";
                }
                function _normalizeIPv4(host, protocol) {
                    var matches = host.match(protocol.IPV4ADDRESS) || [];
                    var _matches = slicedToArray(matches, 2), address = _matches[1];
                    if (address) {
                        return address.split(".").map(_stripLeadingZeros).join(".");
                    }
                    else {
                        return host;
                    }
                }
                function _normalizeIPv6(host, protocol) {
                    var matches = host.match(protocol.IPV6ADDRESS) || [];
                    var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
                    if (address) {
                        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
                        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
                        var lastFields = last.split(":").map(_stripLeadingZeros);
                        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
                        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
                        var lastFieldsStart = lastFields.length - fieldCount;
                        var fields = Array(fieldCount);
                        for (var x = 0; x < fieldCount; ++x) {
                            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
                        }
                        if (isLastFieldIPv4Address) {
                            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
                        }
                        var allZeroFields = fields.reduce(function (acc, field, index) {
                            if (!field || field === "0") {
                                var lastLongest = acc[acc.length - 1];
                                if (lastLongest && lastLongest.index + lastLongest.length === index) {
                                    lastLongest.length++;
                                }
                                else {
                                    acc.push({ index: index, length: 1 });
                                }
                            }
                            return acc;
                        }, []);
                        var longestZeroFields = allZeroFields.sort(function (a, b) {
                            return b.length - a.length;
                        })[0];
                        var newHost = void 0;
                        if (longestZeroFields && longestZeroFields.length > 1) {
                            var newFirst = fields.slice(0, longestZeroFields.index);
                            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
                            newHost = newFirst.join(":") + "::" + newLast.join(":");
                        }
                        else {
                            newHost = fields.join(":");
                        }
                        if (zone) {
                            newHost += "%" + zone;
                        }
                        return newHost;
                    }
                    else {
                        return host;
                    }
                }
                var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
                var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
                function parse(uriString) {
                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                    var components = {};
                    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
                    if (options.reference === "suffix")
                        uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
                    var matches = uriString.match(URI_PARSE);
                    if (matches) {
                        if (NO_MATCH_IS_UNDEFINED) {
                            //store each component
                            components.scheme = matches[1];
                            components.userinfo = matches[3];
                            components.host = matches[4];
                            components.port = parseInt(matches[5], 10);
                            components.path = matches[6] || "";
                            components.query = matches[7];
                            components.fragment = matches[8];
                            //fix port number
                            if (isNaN(components.port)) {
                                components.port = matches[5];
                            }
                        }
                        else {
                            //IE FIX for improper RegExp matching
                            //store each component
                            components.scheme = matches[1] || undefined;
                            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
                            components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
                            components.port = parseInt(matches[5], 10);
                            components.path = matches[6] || "";
                            components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
                            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
                            //fix port number
                            if (isNaN(components.port)) {
                                components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
                            }
                        }
                        if (components.host) {
                            //normalize IP hosts
                            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
                        }
                        //determine reference type
                        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
                            components.reference = "same-document";
                        }
                        else if (components.scheme === undefined) {
                            components.reference = "relative";
                        }
                        else if (components.fragment === undefined) {
                            components.reference = "absolute";
                        }
                        else {
                            components.reference = "uri";
                        }
                        //check for reference errors
                        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
                            components.error = components.error || "URI is not a " + options.reference + " reference.";
                        }
                        //find scheme handler
                        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
                        //check if scheme can't handle IRIs
                        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
                            //if host component is a domain name
                            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
                                //convert Unicode IDN -> ASCII IDN
                                try {
                                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                                }
                                catch (e) {
                                    components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
                                }
                            }
                            //convert IRI -> URI
                            _normalizeComponentEncoding(components, URI_PROTOCOL);
                        }
                        else {
                            //normalize encodings
                            _normalizeComponentEncoding(components, protocol);
                        }
                        //perform scheme specific parsing
                        if (schemeHandler && schemeHandler.parse) {
                            schemeHandler.parse(components, options);
                        }
                    }
                    else {
                        components.error = components.error || "URI can not be parsed.";
                    }
                    return components;
                }
                function _recomposeAuthority(components, options) {
                    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
                    var uriTokens = [];
                    if (components.userinfo !== undefined) {
                        uriTokens.push(components.userinfo);
                        uriTokens.push("@");
                    }
                    if (components.host !== undefined) {
                        //normalize IP hosts, add brackets and escape zone separator for IPv6
                        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
                            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
                        }));
                    }
                    if (typeof components.port === "number") {
                        uriTokens.push(":");
                        uriTokens.push(components.port.toString(10));
                    }
                    return uriTokens.length ? uriTokens.join("") : undefined;
                }
                var RDS1 = /^\.\.?\//;
                var RDS2 = /^\/\.(\/|$)/;
                var RDS3 = /^\/\.\.(\/|$)/;
                var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
                function removeDotSegments(input) {
                    var output = [];
                    while (input.length) {
                        if (input.match(RDS1)) {
                            input = input.replace(RDS1, "");
                        }
                        else if (input.match(RDS2)) {
                            input = input.replace(RDS2, "/");
                        }
                        else if (input.match(RDS3)) {
                            input = input.replace(RDS3, "/");
                            output.pop();
                        }
                        else if (input === "." || input === "..") {
                            input = "";
                        }
                        else {
                            var im = input.match(RDS5);
                            if (im) {
                                var s = im[0];
                                input = input.slice(s.length);
                                output.push(s);
                            }
                            else {
                                throw new Error("Unexpected dot segment condition");
                            }
                        }
                    }
                    return output.join("");
                }
                function serialize(components) {
                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
                    var uriTokens = [];
                    //find scheme handler
                    var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
                    //perform scheme specific serialization
                    if (schemeHandler && schemeHandler.serialize)
                        schemeHandler.serialize(components, options);
                    if (components.host) {
                        //if host component is an IPv6 address
                        if (protocol.IPV6ADDRESS.test(components.host)) { }
                        //TODO: normalize IPv6 address as per RFC 5952
                        //if host component is a domain name
                        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
                            //convert IDN via punycode
                            try {
                                components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
                            }
                            catch (e) {
                                components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                            }
                        }
                    }
                    //normalize encoding
                    _normalizeComponentEncoding(components, protocol);
                    if (options.reference !== "suffix" && components.scheme) {
                        uriTokens.push(components.scheme);
                        uriTokens.push(":");
                    }
                    var authority = _recomposeAuthority(components, options);
                    if (authority !== undefined) {
                        if (options.reference !== "suffix") {
                            uriTokens.push("//");
                        }
                        uriTokens.push(authority);
                        if (components.path && components.path.charAt(0) !== "/") {
                            uriTokens.push("/");
                        }
                    }
                    if (components.path !== undefined) {
                        var s = components.path;
                        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
                            s = removeDotSegments(s);
                        }
                        if (authority === undefined) {
                            s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
                        }
                        uriTokens.push(s);
                    }
                    if (components.query !== undefined) {
                        uriTokens.push("?");
                        uriTokens.push(components.query);
                    }
                    if (components.fragment !== undefined) {
                        uriTokens.push("#");
                        uriTokens.push(components.fragment);
                    }
                    return uriTokens.join(""); //merge tokens into a string
                }
                function resolveComponents(base, relative) {
                    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                    var skipNormalization = arguments[3];
                    var target = {};
                    if (!skipNormalization) {
                        base = parse(serialize(base, options), options); //normalize base components
                        relative = parse(serialize(relative, options), options); //normalize relative components
                    }
                    options = options || {};
                    if (!options.tolerant && relative.scheme) {
                        target.scheme = relative.scheme;
                        //target.authority = relative.authority;
                        target.userinfo = relative.userinfo;
                        target.host = relative.host;
                        target.port = relative.port;
                        target.path = removeDotSegments(relative.path || "");
                        target.query = relative.query;
                    }
                    else {
                        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
                            //target.authority = relative.authority;
                            target.userinfo = relative.userinfo;
                            target.host = relative.host;
                            target.port = relative.port;
                            target.path = removeDotSegments(relative.path || "");
                            target.query = relative.query;
                        }
                        else {
                            if (!relative.path) {
                                target.path = base.path;
                                if (relative.query !== undefined) {
                                    target.query = relative.query;
                                }
                                else {
                                    target.query = base.query;
                                }
                            }
                            else {
                                if (relative.path.charAt(0) === "/") {
                                    target.path = removeDotSegments(relative.path);
                                }
                                else {
                                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
                                        target.path = "/" + relative.path;
                                    }
                                    else if (!base.path) {
                                        target.path = relative.path;
                                    }
                                    else {
                                        target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
                                    }
                                    target.path = removeDotSegments(target.path);
                                }
                                target.query = relative.query;
                            }
                            //target.authority = base.authority;
                            target.userinfo = base.userinfo;
                            target.host = base.host;
                            target.port = base.port;
                        }
                        target.scheme = base.scheme;
                    }
                    target.fragment = relative.fragment;
                    return target;
                }
                function resolve(baseURI, relativeURI, options) {
                    var schemelessOptions = assign({ scheme: 'null' }, options);
                    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
                }
                function normalize(uri, options) {
                    if (typeof uri === "string") {
                        uri = serialize(parse(uri, options), options);
                    }
                    else if (typeOf(uri) === "object") {
                        uri = parse(serialize(uri, options), options);
                    }
                    return uri;
                }
                function equal(uriA, uriB, options) {
                    if (typeof uriA === "string") {
                        uriA = serialize(parse(uriA, options), options);
                    }
                    else if (typeOf(uriA) === "object") {
                        uriA = serialize(uriA, options);
                    }
                    if (typeof uriB === "string") {
                        uriB = serialize(parse(uriB, options), options);
                    }
                    else if (typeOf(uriB) === "object") {
                        uriB = serialize(uriB, options);
                    }
                    return uriA === uriB;
                }
                function escapeComponent(str, options) {
                    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
                }
                function unescapeComponent(str, options) {
                    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
                }
                var handler = {
                    scheme: "http",
                    domainHost: true,
                    parse: function parse(components, options) {
                        //report missing host
                        if (!components.host) {
                            components.error = components.error || "HTTP URIs must have a host.";
                        }
                        return components;
                    },
                    serialize: function serialize(components, options) {
                        //normalize the default port
                        if (components.port === (String(components.scheme).toLowerCase() !== "https" ? 80 : 443) || components.port === "") {
                            components.port = undefined;
                        }
                        //normalize the empty path
                        if (!components.path) {
                            components.path = "/";
                        }
                        //NOTE: We do not parse query strings for HTTP URIs
                        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
                        //and not the HTTP spec.
                        return components;
                    }
                };
                var handler$1 = {
                    scheme: "https",
                    domainHost: handler.domainHost,
                    parse: handler.parse,
                    serialize: handler.serialize
                };
                var O = {};
                var isIRI = true;
                //RFC 3986
                var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
                var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive
                var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
                //RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
                //const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
                //const WSP$$ = "[\\x20\\x09]";
                //const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
                //const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
                //const VCHAR$$ = "[\\x21-\\x7E]";
                //const WSP$$ = "[\\x20\\x09]";
                //const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
                //const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
                //const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
                //const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');
                var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
                var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
                var VCHAR$$ = merge(QTEXT$$, "[\\\"\\\\]");
                var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
                var UNRESERVED = new RegExp(UNRESERVED$$, "g");
                var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
                var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
                var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
                var NOT_HFVALUE = NOT_HFNAME;
                function decodeUnreserved(str) {
                    var decStr = pctDecChars(str);
                    return !decStr.match(UNRESERVED) ? str : decStr;
                }
                var handler$2 = {
                    scheme: "mailto",
                    parse: function parse$$1(components, options) {
                        var mailtoComponents = components;
                        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
                        mailtoComponents.path = undefined;
                        if (mailtoComponents.query) {
                            var unknownHeaders = false;
                            var headers = {};
                            var hfields = mailtoComponents.query.split("&");
                            for (var x = 0, xl = hfields.length; x < xl; ++x) {
                                var hfield = hfields[x].split("=");
                                switch (hfield[0]) {
                                    case "to":
                                        var toAddrs = hfield[1].split(",");
                                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                                            to.push(toAddrs[_x]);
                                        }
                                        break;
                                    case "subject":
                                        mailtoComponents.subject = unescapeComponent(hfield[1], options);
                                        break;
                                    case "body":
                                        mailtoComponents.body = unescapeComponent(hfield[1], options);
                                        break;
                                    default:
                                        unknownHeaders = true;
                                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                                        break;
                                }
                            }
                            if (unknownHeaders)
                                mailtoComponents.headers = headers;
                        }
                        mailtoComponents.query = undefined;
                        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
                            var addr = to[_x2].split("@");
                            addr[0] = unescapeComponent(addr[0]);
                            if (!options.unicodeSupport) {
                                //convert Unicode IDN -> ASCII IDN
                                try {
                                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
                                }
                                catch (e) {
                                    mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
                                }
                            }
                            else {
                                addr[1] = unescapeComponent(addr[1], options).toLowerCase();
                            }
                            to[_x2] = addr.join("@");
                        }
                        return mailtoComponents;
                    },
                    serialize: function serialize$$1(mailtoComponents, options) {
                        var components = mailtoComponents;
                        var to = toArray(mailtoComponents.to);
                        if (to) {
                            for (var x = 0, xl = to.length; x < xl; ++x) {
                                var toAddr = String(to[x]);
                                var atIdx = toAddr.lastIndexOf("@");
                                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
                                var domain = toAddr.slice(atIdx + 1);
                                //convert IDN via punycode
                                try {
                                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
                                }
                                catch (e) {
                                    components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                                }
                                to[x] = localPart + "@" + domain;
                            }
                            components.path = to.join(",");
                        }
                        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
                        if (mailtoComponents.subject)
                            headers["subject"] = mailtoComponents.subject;
                        if (mailtoComponents.body)
                            headers["body"] = mailtoComponents.body;
                        var fields = [];
                        for (var name in headers) {
                            if (headers[name] !== O[name]) {
                                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
                            }
                        }
                        if (fields.length) {
                            components.query = fields.join("&");
                        }
                        return components;
                    }
                };
                var URN_PARSE = /^([^\:]+)\:(.*)/;
                //RFC 2141
                var handler$3 = {
                    scheme: "urn",
                    parse: function parse$$1(components, options) {
                        var matches = components.path && components.path.match(URN_PARSE);
                        var urnComponents = components;
                        if (matches) {
                            var scheme = options.scheme || urnComponents.scheme || "urn";
                            var nid = matches[1].toLowerCase();
                            var nss = matches[2];
                            var urnScheme = scheme + ":" + (options.nid || nid);
                            var schemeHandler = SCHEMES[urnScheme];
                            urnComponents.nid = nid;
                            urnComponents.nss = nss;
                            urnComponents.path = undefined;
                            if (schemeHandler) {
                                urnComponents = schemeHandler.parse(urnComponents, options);
                            }
                        }
                        else {
                            urnComponents.error = urnComponents.error || "URN can not be parsed.";
                        }
                        return urnComponents;
                    },
                    serialize: function serialize$$1(urnComponents, options) {
                        var scheme = options.scheme || urnComponents.scheme || "urn";
                        var nid = urnComponents.nid;
                        var urnScheme = scheme + ":" + (options.nid || nid);
                        var schemeHandler = SCHEMES[urnScheme];
                        if (schemeHandler) {
                            urnComponents = schemeHandler.serialize(urnComponents, options);
                        }
                        var uriComponents = urnComponents;
                        var nss = urnComponents.nss;
                        uriComponents.path = (nid || options.nid) + ":" + nss;
                        return uriComponents;
                    }
                };
                var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
                //RFC 4122
                var handler$4 = {
                    scheme: "urn:uuid",
                    parse: function parse(urnComponents, options) {
                        var uuidComponents = urnComponents;
                        uuidComponents.uuid = uuidComponents.nss;
                        uuidComponents.nss = undefined;
                        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
                            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
                        }
                        return uuidComponents;
                    },
                    serialize: function serialize(uuidComponents, options) {
                        var urnComponents = uuidComponents;
                        //normalize UUID
                        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
                        return urnComponents;
                    }
                };
                SCHEMES[handler.scheme] = handler;
                SCHEMES[handler$1.scheme] = handler$1;
                SCHEMES[handler$2.scheme] = handler$2;
                SCHEMES[handler$3.scheme] = handler$3;
                SCHEMES[handler$4.scheme] = handler$4;
                exports.SCHEMES = SCHEMES;
                exports.pctEncChar = pctEncChar;
                exports.pctDecChars = pctDecChars;
                exports.parse = parse;
                exports.removeDotSegments = removeDotSegments;
                exports.serialize = serialize;
                exports.resolveComponents = resolveComponents;
                exports.resolve = resolve;
                exports.normalize = normalize;
                exports.equal = equal;
                exports.escapeComponent = escapeComponent;
                exports.unescapeComponent = unescapeComponent;
                Object.defineProperty(exports, '__esModule', { value: true });
            })));
            //# sourceMappingURL=uri.all.js.map
            /***/ 
        }),
        /***/ "./node_modules/webpack/buildin/harmony-module.js": 
        /*!*******************************************!*\
          !*** (webpack)/buildin/harmony-module.js ***!
          \*******************************************/
        /*! no static exports found */
        /***/ (function (module, exports) {
            module.exports = function (originalModule) {
                if (!originalModule.webpackPolyfill) {
                    var module = Object.create(originalModule);
                    // module.parent = undefined by default
                    if (!module.children)
                        module.children = [];
                    Object.defineProperty(module, "loaded", {
                        enumerable: true,
                        get: function () {
                            return module.l;
                        }
                    });
                    Object.defineProperty(module, "id", {
                        enumerable: true,
                        get: function () {
                            return module.i;
                        }
                    });
                    Object.defineProperty(module, "exports", {
                        enumerable: true
                    });
                    module.webpackPolyfill = 1;
                }
                return module;
            };
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/Anchors.js": 
        /*!***************************************************!*\
          !*** ./node_modules/yaml/browser/dist/Anchors.js ***!
          \***************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));
            var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));
            var _Alias = _interopRequireDefault(__webpack_require__(/*! ./schema/Alias */ "./node_modules/yaml/browser/dist/schema/Alias.js"));
            var _Map = _interopRequireDefault(__webpack_require__(/*! ./schema/Map */ "./node_modules/yaml/browser/dist/schema/Map.js"));
            var _Merge = _interopRequireDefault(__webpack_require__(/*! ./schema/Merge */ "./node_modules/yaml/browser/dist/schema/Merge.js"));
            var _Scalar = _interopRequireDefault(__webpack_require__(/*! ./schema/Scalar */ "./node_modules/yaml/browser/dist/schema/Scalar.js"));
            var _Seq = _interopRequireDefault(__webpack_require__(/*! ./schema/Seq */ "./node_modules/yaml/browser/dist/schema/Seq.js"));
            var Anchors = 
            /*#__PURE__*/
            function () {
                (0, _createClass2.default)(Anchors, null, [{
                        key: "validAnchorNode",
                        value: function validAnchorNode(node) {
                            return node instanceof _Scalar.default || node instanceof _Seq.default || node instanceof _Map.default;
                        }
                    }]);
                function Anchors(prefix) {
                    (0, _classCallCheck2.default)(this, Anchors);
                    (0, _defineProperty2.default)(this, "map", {});
                    this.prefix = prefix;
                }
                (0, _createClass2.default)(Anchors, [{
                        key: "createAlias",
                        value: function createAlias(node, name) {
                            this.setAnchor(node, name);
                            return new _Alias.default(node);
                        }
                    }, {
                        key: "createMergePair",
                        value: function createMergePair() {
                            var _this = this;
                            var merge = new _Merge.default();
                            for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
                                sources[_key] = arguments[_key];
                            }
                            merge.value.items = sources.map(function (s) {
                                if (s instanceof _Alias.default) {
                                    if (s.source instanceof _Map.default)
                                        return s;
                                }
                                else if (s instanceof _Map.default) {
                                    return _this.createAlias(s);
                                }
                                throw new Error('Merge sources must be Map nodes or their Aliases');
                            });
                            return merge;
                        }
                    }, {
                        key: "getName",
                        value: function getName(node) {
                            var map = this.map;
                            return Object.keys(map).find(function (a) {
                                return map[a] === node;
                            });
                        }
                    }, {
                        key: "getNode",
                        value: function getNode(name) {
                            return this.map[name];
                        }
                    }, {
                        key: "newName",
                        value: function newName(prefix) {
                            if (!prefix)
                                prefix = this.prefix;
                            var names = Object.keys(this.map);
                            for (var i = 1; true; ++i) {
                                var name = "".concat(prefix).concat(i);
                                if (!names.includes(name))
                                    return name;
                            }
                        } // During parsing, map & aliases contain CST nodes
                    }, {
                        key: "resolveNodes",
                        value: function resolveNodes() {
                            var map = this.map, _cstAliases = this._cstAliases;
                            Object.keys(map).forEach(function (a) {
                                map[a] = map[a].resolved;
                            });
                            _cstAliases.forEach(function (a) {
                                a.source = a.source.resolved;
                            });
                            delete this._cstAliases;
                        }
                    }, {
                        key: "setAnchor",
                        value: function setAnchor(node, name) {
                            if (node != null && !Anchors.validAnchorNode(node)) {
                                throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');
                            }
                            if (name && /[\x00-\x19\s,[\]{}]/.test(name)) {
                                throw new Error('Anchor names must not contain whitespace or control characters');
                            }
                            var map = this.map;
                            var prev = node && Object.keys(map).find(function (a) {
                                return map[a] === node;
                            });
                            if (prev) {
                                if (!name) {
                                    return prev;
                                }
                                else if (prev !== name) {
                                    delete map[prev];
                                    map[name] = node;
                                }
                            }
                            else {
                                if (!name) {
                                    if (!node)
                                        return null;
                                    name = this.newName();
                                }
                                map[name] = node;
                            }
                            return name;
                        }
                    }]);
                return Anchors;
            }();
            exports.default = Anchors;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/Document.js": 
        /*!****************************************************!*\
          !*** ./node_modules/yaml/browser/dist/Document.js ***!
          \****************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _slicedToArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js"));
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));
            var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));
            var _addComment = _interopRequireDefault(__webpack_require__(/*! ./addComment */ "./node_modules/yaml/browser/dist/addComment.js"));
            var _Anchors = _interopRequireDefault(__webpack_require__(/*! ./Anchors */ "./node_modules/yaml/browser/dist/Anchors.js"));
            var _constants = __webpack_require__(/*! ./constants */ "./node_modules/yaml/browser/dist/constants.js");
            var _errors = __webpack_require__(/*! ./errors */ "./node_modules/yaml/browser/dist/errors.js");
            var _listTagNames = _interopRequireDefault(__webpack_require__(/*! ./listTagNames */ "./node_modules/yaml/browser/dist/listTagNames.js"));
            var _schema = _interopRequireDefault(__webpack_require__(/*! ./schema */ "./node_modules/yaml/browser/dist/schema/index.js"));
            var _Alias = _interopRequireDefault(__webpack_require__(/*! ./schema/Alias */ "./node_modules/yaml/browser/dist/schema/Alias.js"));
            var _Collection = _interopRequireWildcard(__webpack_require__(/*! ./schema/Collection */ "./node_modules/yaml/browser/dist/schema/Collection.js"));
            var _Node = _interopRequireDefault(__webpack_require__(/*! ./schema/Node */ "./node_modules/yaml/browser/dist/schema/Node.js"));
            var _Scalar = _interopRequireDefault(__webpack_require__(/*! ./schema/Scalar */ "./node_modules/yaml/browser/dist/schema/Scalar.js"));
            var _toJSON2 = _interopRequireDefault(__webpack_require__(/*! ./toJSON */ "./node_modules/yaml/browser/dist/toJSON.js"));
            var isCollectionItem = function isCollectionItem(node) {
                return node && [_constants.Type.MAP_KEY, _constants.Type.MAP_VALUE, _constants.Type.SEQ_ITEM].includes(node.type);
            };
            var Document = 
            /*#__PURE__*/
            function () {
                function Document(options) {
                    (0, _classCallCheck2.default)(this, Document);
                    this.anchors = new _Anchors.default(options.anchorPrefix);
                    this.commentBefore = null;
                    this.comment = null;
                    this.contents = null;
                    this.directivesEndMarker = null;
                    this.errors = [];
                    this.options = options;
                    this.schema = null;
                    this.tagPrefixes = [];
                    this.version = null;
                    this.warnings = [];
                }
                (0, _createClass2.default)(Document, [{
                        key: "assertCollectionContents",
                        value: function assertCollectionContents() {
                            if (this.contents instanceof _Collection.default)
                                return true;
                            throw new Error('Expected a YAML collection as document contents');
                        }
                    }, {
                        key: "add",
                        value: function add(value) {
                            this.assertCollectionContents();
                            return this.contents.add(value);
                        }
                    }, {
                        key: "addIn",
                        value: function addIn(path, value) {
                            this.assertCollectionContents();
                            this.contents.addIn(path, value);
                        }
                    }, {
                        key: "delete",
                        value: function _delete(key) {
                            this.assertCollectionContents();
                            return this.contents.delete(key);
                        }
                    }, {
                        key: "deleteIn",
                        value: function deleteIn(path) {
                            if ((0, _Collection.isEmptyPath)(path)) {
                                if (this.contents == null)
                                    return false;
                                this.contents = null;
                                return true;
                            }
                            this.assertCollectionContents();
                            return this.contents.deleteIn(path);
                        }
                    }, {
                        key: "getDefaults",
                        value: function getDefaults() {
                            return Document.defaults[this.version] || Document.defaults[this.options.version] || {};
                        }
                    }, {
                        key: "get",
                        value: function get(key, keepScalar) {
                            return this.contents instanceof _Collection.default ? this.contents.get(key, keepScalar) : undefined;
                        }
                    }, {
                        key: "getIn",
                        value: function getIn(path, keepScalar) {
                            if ((0, _Collection.isEmptyPath)(path))
                                return !keepScalar && this.contents instanceof _Scalar.default ? this.contents.value : this.contents;
                            return this.contents instanceof _Collection.default ? this.contents.getIn(path, keepScalar) : undefined;
                        }
                    }, {
                        key: "has",
                        value: function has(key) {
                            return this.contents instanceof _Collection.default ? this.contents.has(key) : false;
                        }
                    }, {
                        key: "hasIn",
                        value: function hasIn(path) {
                            if ((0, _Collection.isEmptyPath)(path))
                                return this.contents !== undefined;
                            return this.contents instanceof _Collection.default ? this.contents.hasIn(path) : false;
                        }
                    }, {
                        key: "set",
                        value: function set(key, value) {
                            this.assertCollectionContents();
                            this.contents.set(key, value);
                        }
                    }, {
                        key: "setIn",
                        value: function setIn(path, value) {
                            if ((0, _Collection.isEmptyPath)(path))
                                this.contents = value;
                            else {
                                this.assertCollectionContents();
                                this.contents.setIn(path, value);
                            }
                        }
                    }, {
                        key: "setSchema",
                        value: function setSchema(id, customTags) {
                            if (!id && !customTags && this.schema)
                                return;
                            if (typeof id === 'number')
                                id = id.toFixed(1);
                            if (id === '1.0' || id === '1.1' || id === '1.2') {
                                if (this.version)
                                    this.version = id;
                                else
                                    this.options.version = id;
                                delete this.options.schema;
                            }
                            else if (id && typeof id === 'string') {
                                this.options.schema = id;
                            }
                            if (Array.isArray(customTags))
                                this.options.customTags = customTags;
                            var opt = Object.assign({}, this.getDefaults(), this.options);
                            this.schema = new _schema.default(opt);
                        }
                    }, {
                        key: "parse",
                        value: function parse(node, prevDoc) {
                            if (this.options.keepCstNodes)
                                this.cstNode = node;
                            if (this.options.keepNodeTypes)
                                this.type = 'DOCUMENT';
                            var _node$directives = node.directives, directives = _node$directives === void 0 ? [] : _node$directives, _node$contents = node.contents, contents = _node$contents === void 0 ? [] : _node$contents, directivesEndMarker = node.directivesEndMarker, error = node.error, valueRange = node.valueRange;
                            if (error) {
                                if (!error.source)
                                    error.source = this;
                                this.errors.push(error);
                            }
                            this.parseDirectives(directives, prevDoc);
                            if (directivesEndMarker)
                                this.directivesEndMarker = true;
                            this.range = valueRange ? [valueRange.start, valueRange.end] : null;
                            this.setSchema();
                            this.anchors._cstAliases = [];
                            this.parseContents(contents);
                            this.anchors.resolveNodes();
                            if (this.options.prettyErrors) {
                                var _iteratorNormalCompletion = true;
                                var _didIteratorError = false;
                                var _iteratorError = undefined;
                                try {
                                    for (var _iterator = this.errors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                        var _error = _step.value;
                                        if (_error instanceof _errors.YAMLError)
                                            _error.makePretty();
                                    }
                                }
                                catch (err) {
                                    _didIteratorError = true;
                                    _iteratorError = err;
                                }
                                finally {
                                    try {
                                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                                            _iterator.return();
                                        }
                                    }
                                    finally {
                                        if (_didIteratorError) {
                                            throw _iteratorError;
                                        }
                                    }
                                }
                                var _iteratorNormalCompletion2 = true;
                                var _didIteratorError2 = false;
                                var _iteratorError2 = undefined;
                                try {
                                    for (var _iterator2 = this.warnings[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                        var warn = _step2.value;
                                        if (warn instanceof _errors.YAMLError)
                                            warn.makePretty();
                                    }
                                }
                                catch (err) {
                                    _didIteratorError2 = true;
                                    _iteratorError2 = err;
                                }
                                finally {
                                    try {
                                        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                                            _iterator2.return();
                                        }
                                    }
                                    finally {
                                        if (_didIteratorError2) {
                                            throw _iteratorError2;
                                        }
                                    }
                                }
                            }
                            return this;
                        }
                    }, {
                        key: "parseDirectives",
                        value: function parseDirectives(directives, prevDoc) {
                            var _this = this;
                            var directiveComments = [];
                            var hasDirectives = false;
                            directives.forEach(function (directive) {
                                var comment = directive.comment, name = directive.name;
                                switch (name) {
                                    case 'TAG':
                                        _this.resolveTagDirective(directive);
                                        hasDirectives = true;
                                        break;
                                    case 'YAML':
                                    case 'YAML:1.0':
                                        _this.resolveYamlDirective(directive);
                                        hasDirectives = true;
                                        break;
                                    default:
                                        if (name) {
                                            var msg = "YAML only supports %TAG and %YAML directives, and not %".concat(name);
                                            _this.warnings.push(new _errors.YAMLWarning(directive, msg));
                                        }
                                }
                                if (comment)
                                    directiveComments.push(comment);
                            });
                            if (prevDoc && !hasDirectives && '1.1' === (this.version || prevDoc.version || this.options.version)) {
                                var copyTagPrefix = function copyTagPrefix(_ref) {
                                    var handle = _ref.handle, prefix = _ref.prefix;
                                    return {
                                        handle: handle,
                                        prefix: prefix
                                    };
                                };
                                this.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);
                                this.version = prevDoc.version;
                            }
                            this.commentBefore = directiveComments.join('\n') || null;
                        }
                    }, {
                        key: "parseContents",
                        value: function parseContents(contents) {
                            var _this2 = this;
                            var comments = {
                                before: [],
                                after: []
                            };
                            var contentNodes = [];
                            var spaceBefore = false;
                            contents.forEach(function (node) {
                                if (node.valueRange) {
                                    if (contentNodes.length === 1) {
                                        var msg = 'Document is not valid YAML (bad indentation?)';
                                        _this2.errors.push(new _errors.YAMLSyntaxError(node, msg));
                                    }
                                    var res = _this2.resolveNode(node);
                                    if (spaceBefore) {
                                        res.spaceBefore = true;
                                        spaceBefore = false;
                                    }
                                    contentNodes.push(res);
                                }
                                else if (node.comment !== null) {
                                    var cc = contentNodes.length === 0 ? comments.before : comments.after;
                                    cc.push(node.comment);
                                }
                                else if (node.type === _constants.Type.BLANK_LINE) {
                                    spaceBefore = true;
                                    if (contentNodes.length === 0 && comments.before.length > 0 && !_this2.commentBefore) {
                                        // space-separated comments at start are parsed as document comments
                                        _this2.commentBefore = comments.before.join('\n');
                                        comments.before = [];
                                    }
                                }
                            });
                            switch (contentNodes.length) {
                                case 0:
                                    this.contents = null;
                                    comments.after = comments.before;
                                    break;
                                case 1:
                                    this.contents = contentNodes[0];
                                    if (this.contents) {
                                        var cb = comments.before.join('\n') || null;
                                        if (cb) {
                                            var cbNode = this.contents instanceof _Collection.default && this.contents.items[0] ? this.contents.items[0] : this.contents;
                                            cbNode.commentBefore = cbNode.commentBefore ? "".concat(cb, "\n").concat(cbNode.commentBefore) : cb;
                                        }
                                    }
                                    else {
                                        comments.after = comments.before.concat(comments.after);
                                    }
                                    break;
                                default:
                                    this.contents = contentNodes;
                                    if (this.contents[0]) {
                                        this.contents[0].commentBefore = comments.before.join('\n') || null;
                                    }
                                    else {
                                        comments.after = comments.before.concat(comments.after);
                                    }
                            }
                            this.comment = comments.after.join('\n') || null;
                        }
                    }, {
                        key: "resolveTagDirective",
                        value: function resolveTagDirective(directive) {
                            var _directive$parameters = (0, _slicedToArray2.default)(directive.parameters, 2), handle = _directive$parameters[0], prefix = _directive$parameters[1];
                            if (handle && prefix) {
                                if (this.tagPrefixes.every(function (p) {
                                    return p.handle !== handle;
                                })) {
                                    this.tagPrefixes.push({
                                        handle: handle,
                                        prefix: prefix
                                    });
                                }
                                else {
                                    var msg = 'The %TAG directive must only be given at most once per handle in the same document.';
                                    this.errors.push(new _errors.YAMLSemanticError(directive, msg));
                                }
                            }
                            else {
                                var _msg = 'Insufficient parameters given for %TAG directive';
                                this.errors.push(new _errors.YAMLSemanticError(directive, _msg));
                            }
                        }
                    }, {
                        key: "resolveYamlDirective",
                        value: function resolveYamlDirective(directive) {
                            var _directive$parameters2 = (0, _slicedToArray2.default)(directive.parameters, 1), version = _directive$parameters2[0];
                            if (directive.name === 'YAML:1.0')
                                version = '1.0';
                            if (this.version) {
                                var msg = 'The %YAML directive must only be given at most once per document.';
                                this.errors.push(new _errors.YAMLSemanticError(directive, msg));
                            }
                            if (!version) {
                                var _msg2 = 'Insufficient parameters given for %YAML directive';
                                this.errors.push(new _errors.YAMLSemanticError(directive, _msg2));
                            }
                            else {
                                if (!Document.defaults[version]) {
                                    var v0 = this.version || this.options.version;
                                    var _msg3 = "Document will be parsed as YAML ".concat(v0, " rather than YAML ").concat(version);
                                    this.warnings.push(new _errors.YAMLWarning(directive, _msg3));
                                }
                                this.version = version;
                            }
                        }
                    }, {
                        key: "resolveTagName",
                        value: function resolveTagName(node) {
                            var tag = node.tag, type = node.type;
                            var nonSpecific = false;
                            if (tag) {
                                var handle = tag.handle, suffix = tag.suffix, verbatim = tag.verbatim;
                                if (verbatim) {
                                    if (verbatim !== '!' && verbatim !== '!!')
                                        return verbatim;
                                    var msg = "Verbatim tags aren't resolved, so ".concat(verbatim, " is invalid.");
                                    this.errors.push(new _errors.YAMLSemanticError(node, msg));
                                }
                                else if (handle === '!' && !suffix) {
                                    nonSpecific = true;
                                }
                                else {
                                    var prefix = this.tagPrefixes.find(function (p) {
                                        return p.handle === handle;
                                    });
                                    if (!prefix) {
                                        var dtp = this.getDefaults().tagPrefixes;
                                        if (dtp)
                                            prefix = dtp.find(function (p) {
                                                return p.handle === handle;
                                            });
                                    }
                                    if (prefix) {
                                        if (suffix) {
                                            if (handle === '!' && (this.version || this.options.version) === '1.0') {
                                                if (suffix[0] === '^')
                                                    return suffix;
                                                if (/[:/]/.test(suffix)) {
                                                    // word/foo -> tag:word.yaml.org,2002:foo
                                                    var vocab = suffix.match(/^([a-z0-9-]+)\/(.*)/i);
                                                    return vocab ? "tag:".concat(vocab[1], ".yaml.org,2002:").concat(vocab[2]) : "tag:".concat(suffix);
                                                }
                                            }
                                            return prefix.prefix + decodeURIComponent(suffix);
                                        }
                                        this.errors.push(new _errors.YAMLSemanticError(node, "The ".concat(handle, " tag has no suffix.")));
                                    }
                                    else {
                                        var _msg4 = "The ".concat(handle, " tag handle is non-default and was not declared.");
                                        this.errors.push(new _errors.YAMLSemanticError(node, _msg4));
                                    }
                                }
                            }
                            switch (type) {
                                case _constants.Type.BLOCK_FOLDED:
                                case _constants.Type.BLOCK_LITERAL:
                                case _constants.Type.QUOTE_DOUBLE:
                                case _constants.Type.QUOTE_SINGLE:
                                    return _schema.default.defaultTags.STR;
                                case _constants.Type.FLOW_MAP:
                                case _constants.Type.MAP:
                                    return _schema.default.defaultTags.MAP;
                                case _constants.Type.FLOW_SEQ:
                                case _constants.Type.SEQ:
                                    return _schema.default.defaultTags.SEQ;
                                case _constants.Type.PLAIN:
                                    return nonSpecific ? _schema.default.defaultTags.STR : null;
                                default:
                                    return null;
                            }
                        }
                    }, {
                        key: "resolveNode",
                        value: function resolveNode(node) {
                            if (!node)
                                return null;
                            var anchors = this.anchors, errors = this.errors, schema = this.schema;
                            var hasAnchor = false;
                            var hasTag = false;
                            var comments = {
                                before: [],
                                after: []
                            };
                            var props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;
                            var _iteratorNormalCompletion3 = true;
                            var _didIteratorError3 = false;
                            var _iteratorError3 = undefined;
                            try {
                                for (var _iterator3 = props[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                                    var _step3$value = _step3.value, start = _step3$value.start, end = _step3$value.end;
                                    switch (node.context.src[start]) {
                                        case _constants.Char.COMMENT:
                                            {
                                                if (!node.commentHasRequiredWhitespace(start)) {
                                                    var _msg7 = 'Comments must be separated from other tokens by white space characters';
                                                    errors.push(new _errors.YAMLSemanticError(node, _msg7));
                                                }
                                                var c = node.context.src.slice(start + 1, end);
                                                var header = node.header, valueRange = node.valueRange;
                                                if (valueRange && (start > valueRange.start || header && start > header.start)) {
                                                    comments.after.push(c);
                                                }
                                                else {
                                                    comments.before.push(c);
                                                }
                                            }
                                            break;
                                        case _constants.Char.ANCHOR:
                                            if (hasAnchor) {
                                                var _msg8 = 'A node can have at most one anchor';
                                                errors.push(new _errors.YAMLSemanticError(node, _msg8));
                                            }
                                            hasAnchor = true;
                                            break;
                                        case _constants.Char.TAG:
                                            if (hasTag) {
                                                var _msg9 = 'A node can have at most one tag';
                                                errors.push(new _errors.YAMLSemanticError(node, _msg9));
                                            }
                                            hasTag = true;
                                            break;
                                    }
                                }
                            }
                            catch (err) {
                                _didIteratorError3 = true;
                                _iteratorError3 = err;
                            }
                            finally {
                                try {
                                    if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                                        _iterator3.return();
                                    }
                                }
                                finally {
                                    if (_didIteratorError3) {
                                        throw _iteratorError3;
                                    }
                                }
                            }
                            if (hasAnchor) {
                                var name = node.anchor;
                                var prev = anchors.getNode(name); // At this point, aliases for any preceding node with the same anchor
                                // name have already been resolved, so it may safely be renamed.
                                if (prev)
                                    anchors.map[anchors.newName(name)] = prev; // During parsing, we need to store the CST node in anchors.map as
                                // anchors need to be available during resolution to allow for
                                // circular references.
                                anchors.map[name] = node;
                            }
                            var res;
                            if (node.type === _constants.Type.ALIAS) {
                                if (hasAnchor || hasTag) {
                                    var msg = 'An alias node must not specify any properties';
                                    errors.push(new _errors.YAMLSemanticError(node, msg));
                                }
                                var _name = node.rawValue;
                                var src = anchors.getNode(_name);
                                if (!src) {
                                    var _msg5 = "Aliased anchor not found: ".concat(_name);
                                    errors.push(new _errors.YAMLReferenceError(node, _msg5));
                                    return null;
                                } // Lazy resolution for circular references
                                res = new _Alias.default(src);
                                anchors._cstAliases.push(res);
                            }
                            else {
                                var tagName = this.resolveTagName(node);
                                if (tagName) {
                                    res = schema.resolveNodeWithFallback(this, node, tagName);
                                }
                                else {
                                    if (node.type !== _constants.Type.PLAIN) {
                                        var _msg6 = "Failed to resolve ".concat(node.type, " node here");
                                        errors.push(new _errors.YAMLSyntaxError(node, _msg6));
                                        return null;
                                    }
                                    try {
                                        res = schema.resolveScalar(node.strValue || '');
                                    }
                                    catch (error) {
                                        if (!error.source)
                                            error.source = node;
                                        errors.push(error);
                                        return null;
                                    }
                                }
                            }
                            if (res) {
                                res.range = [node.range.start, node.range.end];
                                if (this.options.keepCstNodes)
                                    res.cstNode = node;
                                if (this.options.keepNodeTypes)
                                    res.type = node.type;
                                var cb = comments.before.join('\n');
                                if (cb) {
                                    res.commentBefore = res.commentBefore ? "".concat(res.commentBefore, "\n").concat(cb) : cb;
                                }
                                var ca = comments.after.join('\n');
                                if (ca)
                                    res.comment = res.comment ? "".concat(res.comment, "\n").concat(ca) : ca;
                            }
                            return node.resolved = res;
                        }
                    }, {
                        key: "listNonDefaultTags",
                        value: function listNonDefaultTags() {
                            return (0, _listTagNames.default)(this.contents).filter(function (t) {
                                return t.indexOf(_schema.default.defaultPrefix) !== 0;
                            });
                        }
                    }, {
                        key: "setTagPrefix",
                        value: function setTagPrefix(handle, prefix) {
                            if (handle[0] !== '!' || handle[handle.length - 1] !== '!')
                                throw new Error('Handle must start and end with !');
                            if (prefix) {
                                var prev = this.tagPrefixes.find(function (p) {
                                    return p.handle === handle;
                                });
                                if (prev)
                                    prev.prefix = prefix;
                                else
                                    this.tagPrefixes.push({
                                        handle: handle,
                                        prefix: prefix
                                    });
                            }
                            else {
                                this.tagPrefixes = this.tagPrefixes.filter(function (p) {
                                    return p.handle !== handle;
                                });
                            }
                        }
                    }, {
                        key: "stringifyTag",
                        value: function stringifyTag(tag) {
                            if ((this.version || this.options.version) === '1.0') {
                                var priv = tag.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/);
                                if (priv)
                                    return '!' + priv[1];
                                var vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/);
                                return vocab ? "!".concat(vocab[1], "/").concat(vocab[2]) : "!".concat(tag.replace(/^tag:/, ''));
                            }
                            else {
                                var p = this.tagPrefixes.find(function (p) {
                                    return tag.indexOf(p.prefix) === 0;
                                });
                                if (!p) {
                                    var dtp = this.getDefaults().tagPrefixes;
                                    p = dtp && dtp.find(function (p) {
                                        return tag.indexOf(p.prefix) === 0;
                                    });
                                }
                                if (!p)
                                    return tag[0] === '!' ? tag : "!<".concat(tag, ">");
                                var suffix = tag.substr(p.prefix.length).replace(/[!,[\]{}]/g, function (ch) {
                                    return {
                                        '!': '%21',
                                        ',': '%2C',
                                        '[': '%5B',
                                        ']': '%5D',
                                        '{': '%7B',
                                        '}': '%7D'
                                    }[ch];
                                });
                                return p.handle + suffix;
                            }
                        }
                    }, {
                        key: "toJSON",
                        value: function toJSON(arg) {
                            var _this3 = this;
                            var _this$options = this.options, keepBlobsInJSON = _this$options.keepBlobsInJSON, mapAsMap = _this$options.mapAsMap, maxAliasCount = _this$options.maxAliasCount;
                            var keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof _Scalar.default));
                            var ctx = {
                                doc: this,
                                keep: keep,
                                mapAsMap: keep && !!mapAsMap,
                                maxAliasCount: maxAliasCount
                            };
                            var anchorNames = Object.keys(this.anchors.map);
                            if (anchorNames.length > 0)
                                ctx.anchors = anchorNames.map(function (name) {
                                    return {
                                        alias: [],
                                        aliasCount: 0,
                                        count: 1,
                                        node: _this3.anchors.map[name]
                                    };
                                });
                            return (0, _toJSON2.default)(this.contents, arg, ctx);
                        }
                    }, {
                        key: "toString",
                        value: function toString() {
                            if (this.errors.length > 0)
                                throw new Error('Document with errors cannot be stringified');
                            this.setSchema();
                            var lines = [];
                            var hasDirectives = false;
                            if (this.version) {
                                var vd = '%YAML 1.2';
                                if (this.schema.name === 'yaml-1.1') {
                                    if (this.version === '1.0')
                                        vd = '%YAML:1.0';
                                    else if (this.version === '1.1')
                                        vd = '%YAML 1.1';
                                }
                                lines.push(vd);
                                hasDirectives = true;
                            }
                            var tagNames = this.listNonDefaultTags();
                            this.tagPrefixes.forEach(function (_ref2) {
                                var handle = _ref2.handle, prefix = _ref2.prefix;
                                if (tagNames.some(function (t) {
                                    return t.indexOf(prefix) === 0;
                                })) {
                                    lines.push("%TAG ".concat(handle, " ").concat(prefix));
                                    hasDirectives = true;
                                }
                            });
                            if (hasDirectives || this.directivesEndMarker)
                                lines.push('---');
                            if (this.commentBefore) {
                                if (hasDirectives || !this.directivesEndMarker)
                                    lines.unshift('');
                                lines.unshift(this.commentBefore.replace(/^/gm, '#'));
                            }
                            var ctx = {
                                anchors: {},
                                doc: this,
                                indent: ''
                            };
                            var chompKeep = false;
                            var contentComment = null;
                            if (this.contents) {
                                if (this.contents instanceof _Node.default) {
                                    if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker))
                                        lines.push('');
                                    if (this.contents.commentBefore)
                                        lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment
                                    ctx.forceBlockIndent = !!this.comment;
                                    contentComment = this.contents.comment;
                                }
                                var onChompKeep = contentComment ? null : function () {
                                    return chompKeep = true;
                                };
                                var body = this.schema.stringify(this.contents, ctx, function () {
                                    return contentComment = null;
                                }, onChompKeep);
                                lines.push((0, _addComment.default)(body, '', contentComment));
                            }
                            else if (this.contents !== undefined) {
                                lines.push(this.schema.stringify(this.contents, ctx));
                            }
                            if (this.comment) {
                                if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '')
                                    lines.push('');
                                lines.push(this.comment.replace(/^/gm, '#'));
                            }
                            return lines.join('\n') + '\n';
                        }
                    }]);
                return Document;
            }();
            exports.default = Document;
            (0, _defineProperty2.default)(Document, "defaults", {
                '1.0': {
                    schema: 'yaml-1.1',
                    merge: true,
                    tagPrefixes: [{
                            handle: '!',
                            prefix: _schema.default.defaultPrefix
                        }, {
                            handle: '!!',
                            prefix: 'tag:private.yaml.org,2002:'
                        }]
                },
                '1.1': {
                    schema: 'yaml-1.1',
                    merge: true,
                    tagPrefixes: [{
                            handle: '!',
                            prefix: '!'
                        }, {
                            handle: '!!',
                            prefix: _schema.default.defaultPrefix
                        }]
                },
                '1.2': {
                    schema: 'core',
                    merge: false,
                    tagPrefixes: [{
                            handle: '!',
                            prefix: '!'
                        }, {
                            handle: '!!',
                            prefix: _schema.default.defaultPrefix
                        }]
                }
            });
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/addComment.js": 
        /*!******************************************************!*\
          !*** ./node_modules/yaml/browser/dist/addComment.js ***!
          \******************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.addCommentBefore = addCommentBefore;
            exports.default = addComment;
            function addCommentBefore(str, indent, comment) {
                if (!comment)
                    return str;
                var cc = comment.replace(/[\s\S]^/gm, "$&".concat(indent, "#"));
                return "#".concat(cc, "\n").concat(indent).concat(str);
            }
            function addComment(str, indent, comment) {
                return !comment ? str : comment.indexOf('\n') === -1 ? "".concat(str, " #").concat(comment) : "".concat(str, "\n") + comment.replace(/^/gm, "".concat(indent || '', "#"));
            }
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/constants.js": 
        /*!*****************************************************!*\
          !*** ./node_modules/yaml/browser/dist/constants.js ***!
          \*****************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.Type = exports.Char = void 0;
            var Char = {
                ANCHOR: '&',
                COMMENT: '#',
                TAG: '!',
                DIRECTIVES_END: '-',
                DOCUMENT_END: '.'
            };
            exports.Char = Char;
            var Type = {
                ALIAS: 'ALIAS',
                BLANK_LINE: 'BLANK_LINE',
                BLOCK_FOLDED: 'BLOCK_FOLDED',
                BLOCK_LITERAL: 'BLOCK_LITERAL',
                COMMENT: 'COMMENT',
                DIRECTIVE: 'DIRECTIVE',
                DOCUMENT: 'DOCUMENT',
                FLOW_MAP: 'FLOW_MAP',
                FLOW_SEQ: 'FLOW_SEQ',
                MAP: 'MAP',
                MAP_KEY: 'MAP_KEY',
                MAP_VALUE: 'MAP_VALUE',
                PLAIN: 'PLAIN',
                QUOTE_DOUBLE: 'QUOTE_DOUBLE',
                QUOTE_SINGLE: 'QUOTE_SINGLE',
                SEQ: 'SEQ',
                SEQ_ITEM: 'SEQ_ITEM'
            };
            exports.Type = Type;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/cst/Alias.js": 
        /*!*****************************************************!*\
          !*** ./node_modules/yaml/browser/dist/cst/Alias.js ***!
          \*****************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));
            var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));
            var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));
            var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));
            var _Node2 = _interopRequireDefault(__webpack_require__(/*! ./Node */ "./node_modules/yaml/browser/dist/cst/Node.js"));
            var _Range = _interopRequireDefault(__webpack_require__(/*! ./Range */ "./node_modules/yaml/browser/dist/cst/Range.js"));
            var Alias = 
            /*#__PURE__*/
            function (_Node) {
                (0, _inherits2.default)(Alias, _Node);
                function Alias() {
                    (0, _classCallCheck2.default)(this, Alias);
                    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Alias).apply(this, arguments));
                }
                (0, _createClass2.default)(Alias, [{
                        key: "parse",
                        /**
                         * Parses an *alias from the source
                         *
                         * @param {ParseContext} context
                         * @param {number} start - Index of first character
                         * @returns {number} - Index of the character after this scalar
                         */
                        value: function parse(context, start) {
                            this.context = context;
                            var src = context.src;
                            var offset = _Node2.default.endOfIdentifier(src, start + 1);
                            this.valueRange = new _Range.default(start + 1, offset);
                            offset = _Node2.default.endOfWhiteSpace(src, offset);
                            offset = this.parseComment(offset);
                            return offset;
                        }
                    }]);
                return Alias;
            }(_Node2.default);
            exports.default = Alias;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/cst/BlankLine.js": 
        /*!*********************************************************!*\
          !*** ./node_modules/yaml/browser/dist/cst/BlankLine.js ***!
          \*********************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));
            var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));
            var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));
            var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));
            var _constants = __webpack_require__(/*! ../constants */ "./node_modules/yaml/browser/dist/constants.js");
            var _Node2 = _interopRequireDefault(__webpack_require__(/*! ./Node */ "./node_modules/yaml/browser/dist/cst/Node.js"));
            var _Range = _interopRequireDefault(__webpack_require__(/*! ./Range */ "./node_modules/yaml/browser/dist/cst/Range.js"));
            var BlankLine = 
            /*#__PURE__*/
            function (_Node) {
                (0, _inherits2.default)(BlankLine, _Node);
                function BlankLine() {
                    (0, _classCallCheck2.default)(this, BlankLine);
                    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(BlankLine).call(this, _constants.Type.BLANK_LINE));
                }
                (0, _createClass2.default)(BlankLine, [{
                        key: "parse",
                        /**
                         * Parses blank lines from the source
                         *
                         * @param {ParseContext} context
                         * @param {number} start - Index of first \n character
                         * @returns {number} - Index of the character after this
                         */
                        value: function parse(context, start) {
                            this.context = context;
                            var src = context.src;
                            var offset = start + 1;
                            while (_Node2.default.atBlank(src, offset)) {
                                var lineEnd = _Node2.default.endOfWhiteSpace(src, offset);
                                if (lineEnd === '\n')
                                    offset = lineEnd + 1;
                                else
                                    break;
                            }
                            this.range = new _Range.default(start, offset);
                            return offset;
                        }
                    }, {
                        key: "includesTrailingLines",
                        get: function get() {
                            return true;
                        }
                    }]);
                return BlankLine;
            }(_Node2.default);
            exports.default = BlankLine;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/cst/BlockValue.js": 
        /*!**********************************************************!*\
          !*** ./node_modules/yaml/browser/dist/cst/BlockValue.js ***!
          \**********************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = exports.Chomp = void 0;
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));
            var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));
            var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));
            var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js"));
            var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));
            var _constants = __webpack_require__(/*! ../constants */ "./node_modules/yaml/browser/dist/constants.js");
            var _Node2 = _interopRequireDefault(__webpack_require__(/*! ./Node */ "./node_modules/yaml/browser/dist/cst/Node.js"));
            var _Range = _interopRequireDefault(__webpack_require__(/*! ./Range */ "./node_modules/yaml/browser/dist/cst/Range.js"));
            var Chomp = {
                CLIP: 'CLIP',
                KEEP: 'KEEP',
                STRIP: 'STRIP'
            };
            exports.Chomp = Chomp;
            var BlockValue = 
            /*#__PURE__*/
            function (_Node) {
                (0, _inherits2.default)(BlockValue, _Node);
                function BlockValue(type, props) {
                    var _this;
                    (0, _classCallCheck2.default)(this, BlockValue);
                    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(BlockValue).call(this, type, props));
                    _this.blockIndent = null;
                    _this.chomping = Chomp.CLIP;
                    _this.header = null;
                    return _this;
                }
                (0, _createClass2.default)(BlockValue, [{
                        key: "parseBlockHeader",
                        value: function parseBlockHeader(start) {
                            var src = this.context.src;
                            var offset = start + 1;
                            var bi = '';
                            while (true) {
                                var ch = src[offset];
                                switch (ch) {
                                    case '-':
                                        this.chomping = Chomp.STRIP;
                                        break;
                                    case '+':
                                        this.chomping = Chomp.KEEP;
                                        break;
                                    case '0':
                                    case '1':
                                    case '2':
                                    case '3':
                                    case '4':
                                    case '5':
                                    case '6':
                                    case '7':
                                    case '8':
                                    case '9':
                                        bi += ch;
                                        break;
                                    default:
                                        this.blockIndent = Number(bi) || null;
                                        this.header = new _Range.default(start, offset);
                                        return offset;
                                }
                                offset += 1;
                            }
                        }
                    }, {
                        key: "parseBlockValue",
                        value: function parseBlockValue(start) {
                            var _this$context = this.context, indent = _this$context.indent, src = _this$context.src;
                            var offset = start;
                            var valueEnd = start;
                            var bi = this.blockIndent ? indent + this.blockIndent - 1 : indent;
                            var minBlockIndent = 1;
                            for (var ch = src[offset]; ch === '\n'; ch = src[offset]) {
                                offset += 1;
                                if (_Node2.default.atDocumentBoundary(src, offset))
                                    break;
                                var end = _Node2.default.endOfBlockIndent(src, bi, offset); // should not include tab?
                                if (end === null)
                                    break;
                                if (!this.blockIndent) {
                                    // no explicit block indent, none yet detected
                                    var lineIndent = end - (offset + indent);
                                    if (src[end] !== '\n') {
                                        // first line with non-whitespace content
                                        if (lineIndent < minBlockIndent) {
                                            offset -= 1;
                                            break;
                                        }
                                        this.blockIndent = lineIndent;
                                        bi = indent + this.blockIndent - 1;
                                    }
                                    else if (lineIndent > minBlockIndent) {
                                        // empty line with more whitespace
                                        minBlockIndent = lineIndent;
                                    }
                                }
                                if (src[end] === '\n') {
                                    offset = end;
                                }
                                else {
                                    offset = valueEnd = _Node2.default.endOfLine(src, end);
                                }
                            }
                            if (this.chomping !== Chomp.KEEP) {
                                offset = src[valueEnd] ? valueEnd + 1 : valueEnd;
                            }
                            this.valueRange = new _Range.default(start + 1, offset);
                            return offset;
                        }
                        /**
                         * Parses a block value from the source
                         *
                         * Accepted forms are:
                         * ```
                         * BS
                         * block
                         * lines
                         *
                         * BS #comment
                         * block
                         * lines
                         * ```
                         * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines
                         * are empty or have an indent level greater than `indent`.
                         *
                         * @param {ParseContext} context
                         * @param {number} start - Index of first character
                         * @returns {number} - Index of the character after this block
                         */
                    }, {
                        key: "parse",
                        value: function parse(context, start) {
                            this.context = context;
                            var src = context.src;
                            var offset = this.parseBlockHeader(start);
                            offset = _Node2.default.endOfWhiteSpace(src, offset);
                            offset = this.parseComment(offset);
                            offset = this.parseBlockValue(offset);
                            return offset;
                        }
                    }, {
                        key: "setOrigRanges",
                        value: function setOrigRanges(cr, offset) {
                            offset = (0, _get2.default)((0, _getPrototypeOf2.default)(BlockValue.prototype), "setOrigRanges", this).call(this, cr, offset);
                            return this.header ? this.header.setOrigRange(cr, offset) : offset;
                        }
                    }, {
                        key: "includesTrailingLines",
                        get: function get() {
                            return this.chomping === Chomp.KEEP;
                        }
                    }, {
                        key: "strValue",
                        get: function get() {
                            if (!this.valueRange || !this.context)
                                return null;
                            var _this$valueRange = this.valueRange, start = _this$valueRange.start, end = _this$valueRange.end;
                            var _this$context2 = this.context, indent = _this$context2.indent, src = _this$context2.src;
                            if (this.valueRange.isEmpty())
                                return '';
                            var lastNewLine = null;
                            var ch = src[end - 1];
                            while (ch === '\n' || ch === '\t' || ch === ' ') {
                                end -= 1;
                                if (end <= start) {
                                    if (this.chomping === Chomp.KEEP)
                                        break;
                                    else
                                        return '';
                                }
                                if (ch === '\n')
                                    lastNewLine = end;
                                ch = src[end - 1];
                            }
                            var keepStart = end + 1;
                            if (lastNewLine) {
                                if (this.chomping === Chomp.KEEP) {
                                    keepStart = lastNewLine;
                                    end = this.valueRange.end;
                                }
                                else {
                                    end = lastNewLine;
                                }
                            }
                            var bi = indent + this.blockIndent;
                            var folded = this.type === _constants.Type.BLOCK_FOLDED;
                            var atStart = true;
                            var str = '';
                            var sep = '';
                            var prevMoreIndented = false;
                            for (var i = start; i < end; ++i) {
                                for (var j = 0; j < bi; ++j) {
                                    if (src[i] !== ' ')
                                        break;
                                    i += 1;
                                }
                                var _ch = src[i];
                                if (_ch === '\n') {
                                    if (sep === '\n')
                                        str += '\n';
                                    else
                                        sep = '\n';
                                }
                                else {
                                    var lineEnd = _Node2.default.endOfLine(src, i);
                                    var line = src.slice(i, lineEnd);
                                    i = lineEnd;
                                    if (folded && (_ch === ' ' || _ch === '\t') && i < keepStart) {
                                        if (sep === ' ')
                                            sep = '\n';
                                        else if (!prevMoreIndented && !atStart && sep === '\n')
                                            sep = '\n\n';
                                        str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')
                                        sep = lineEnd < end && src[lineEnd] || '';
                                        prevMoreIndented = true;
                                    }
                                    else {
                                        str += sep + line;
                                        sep = folded && i < keepStart ? ' ' : '\n';
                                        prevMoreIndented = false;
                                    }
                                    if (atStart && line !== '')
                                        atStart = false;
                                }
                            }
                            return this.chomping === Chomp.STRIP ? str : str + '\n';
                        }
                    }]);
                return BlockValue;
            }(_Node2.default);
            exports.default = BlockValue;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/cst/Collection.js": 
        /*!**********************************************************!*\
          !*** ./node_modules/yaml/browser/dist/cst/Collection.js ***!
          \**********************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.grabCollectionEndComments = grabCollectionEndComments;
            exports.default = void 0;
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));
            var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));
            var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js"));
            var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));
            var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));
            var _constants = __webpack_require__(/*! ../constants */ "./node_modules/yaml/browser/dist/constants.js");
            var _BlankLine = _interopRequireDefault(__webpack_require__(/*! ./BlankLine */ "./node_modules/yaml/browser/dist/cst/BlankLine.js"));
            var _CollectionItem = _interopRequireDefault(__webpack_require__(/*! ./CollectionItem */ "./node_modules/yaml/browser/dist/cst/CollectionItem.js"));
            var _Comment = _interopRequireDefault(__webpack_require__(/*! ./Comment */ "./node_modules/yaml/browser/dist/cst/Comment.js"));
            var _Node2 = _interopRequireDefault(__webpack_require__(/*! ./Node */ "./node_modules/yaml/browser/dist/cst/Node.js"));
            var _Range = _interopRequireDefault(__webpack_require__(/*! ./Range */ "./node_modules/yaml/browser/dist/cst/Range.js"));
            function grabCollectionEndComments(node) {
                var cnode = node;
                while (cnode instanceof _CollectionItem.default) {
                    cnode = cnode.node;
                }
                if (!(cnode instanceof Collection))
                    return null;
                var len = cnode.items.length;
                var ci = -1;
                for (var i = len - 1; i >= 0; --i) {
                    var n = cnode.items[i];
                    if (n.type === _constants.Type.COMMENT) {
                        // Keep sufficiently indented comments with preceding node
                        var _n$context = n.context, indent = _n$context.indent, lineStart = _n$context.lineStart;
                        if (indent > 0 && n.range.start >= lineStart + indent)
                            break;
                        ci = i;
                    }
                    else if (n.type === _constants.Type.BLANK_LINE)
                        ci = i;
                    else
                        break;
                }
                if (ci === -1)
                    return null;
                var ca = cnode.items.splice(ci, len - ci);
                var prevEnd = ca[0].range.start;
                while (true) {
                    cnode.range.end = prevEnd;
                    if (cnode.valueRange && cnode.valueRange.end > prevEnd)
                        cnode.valueRange.end = prevEnd;
                    if (cnode === node)
                        break;
                    cnode = cnode.context.parent;
                }
                return ca;
            }
            var Collection = 
            /*#__PURE__*/
            function (_Node) {
                (0, _inherits2.default)(Collection, _Node);
                (0, _createClass2.default)(Collection, null, [{
                        key: "nextContentHasIndent",
                        value: function nextContentHasIndent(src, offset, indent) {
                            var lineStart = _Node2.default.endOfLine(src, offset) + 1;
                            offset = _Node2.default.endOfWhiteSpace(src, lineStart);
                            var ch = src[offset];
                            if (!ch)
                                return false;
                            if (offset >= lineStart + indent)
                                return true;
                            if (ch !== '#' && ch !== '\n')
                                return false;
                            return Collection.nextContentHasIndent(src, offset, indent);
                        }
                    }]);
                function Collection(firstItem) {
                    var _this;
                    (0, _classCallCheck2.default)(this, Collection);
                    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Collection).call(this, firstItem.type === _constants.Type.SEQ_ITEM ? _constants.Type.SEQ : _constants.Type.MAP));
                    for (var i = firstItem.props.length - 1; i >= 0; --i) {
                        if (firstItem.props[i].start < firstItem.context.lineStart) {
                            // props on previous line are assumed by the collection
                            _this.props = firstItem.props.slice(0, i + 1);
                            firstItem.props = firstItem.props.slice(i + 1);
                            var itemRange = firstItem.props[0] || firstItem.valueRange;
                            firstItem.range.start = itemRange.start;
                            break;
                        }
                    }
                    _this.items = [firstItem];
                    var ec = grabCollectionEndComments(firstItem);
                    if (ec)
                        Array.prototype.push.apply(_this.items, ec);
                    return _this;
                }
                (0, _createClass2.default)(Collection, [{
                        key: "parse",
                        /**
                         * @param {ParseContext} context
                         * @param {number} start - Index of first character
                         * @returns {number} - Index of the character after this
                         */
                        value: function parse(context, start) {
                            this.context = context;
                            var parseNode = context.parseNode, src = context.src; // It's easier to recalculate lineStart here rather than tracking down the
                            // last context from which to read it -- eemeli/yaml#2
                            var lineStart = _Node2.default.startOfLine(src, start);
                            var firstItem = this.items[0]; // First-item context needs to be correct for later comment handling
                            // -- eemeli/yaml#17
                            firstItem.context.parent = this;
                            this.valueRange = _Range.default.copy(firstItem.valueRange);
                            var indent = firstItem.range.start - firstItem.context.lineStart;
                            var offset = start;
                            offset = _Node2.default.normalizeOffset(src, offset);
                            var ch = src[offset];
                            var atLineStart = _Node2.default.endOfWhiteSpace(src, lineStart) === offset;
                            var prevIncludesTrailingLines = false;
                            while (ch) {
                                while (ch === '\n' || ch === '#') {
                                    if (atLineStart && ch === '\n' && !prevIncludesTrailingLines) {
                                        var blankLine = new _BlankLine.default();
                                        offset = blankLine.parse({
                                            src: src
                                        }, offset);
                                        this.valueRange.end = offset;
                                        if (offset >= src.length) {
                                            ch = null;
                                            break;
                                        }
                                        this.items.push(blankLine);
                                        offset -= 1; // blankLine.parse() consumes terminal newline
                                    }
                                    else if (ch === '#') {
                                        if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) {
                                            return offset;
                                        }
                                        var comment = new _Comment.default();
                                        offset = comment.parse({
                                            indent: indent,
                                            lineStart: lineStart,
                                            src: src
                                        }, offset);
                                        this.items.push(comment);
                                        this.valueRange.end = offset;
                                        if (offset >= src.length) {
                                            ch = null;
                                            break;
                                        }
                                    }
                                    lineStart = offset + 1;
                                    offset = _Node2.default.endOfIndent(src, lineStart);
                                    if (_Node2.default.atBlank(src, offset)) {
                                        var wsEnd = _Node2.default.endOfWhiteSpace(src, offset);
                                        var next = src[wsEnd];
                                        if (!next || next === '\n' || next === '#') {
                                            offset = wsEnd;
                                        }
                                    }
                                    ch = src[offset];
                                    atLineStart = true;
                                }
                                if (!ch) {
                                    break;
                                }
                                if (offset !== lineStart + indent && (atLineStart || ch !== ':')) {
                                    if (lineStart > start)
                                        offset = lineStart;
                                    break;
                                }
                                if (firstItem.type === _constants.Type.SEQ_ITEM !== (ch === '-')) {
                                    var typeswitch = true;
                                    if (ch === '-') {
                                        // map key may start with -, as long as it's followed by a non-whitespace char
                                        var _next = src[offset + 1];
                                        typeswitch = !_next || _next === '\n' || _next === '\t' || _next === ' ';
                                    }
                                    if (typeswitch) {
                                        if (lineStart > start)
                                            offset = lineStart;
                                        break;
                                    }
                                }
                                var node = parseNode({
                                    atLineStart: atLineStart,
                                    inCollection: true,
                                    indent: indent,
                                    lineStart: lineStart,
                                    parent: this
                                }, offset);
                                if (!node)
                                    return offset; // at next document start
                                this.items.push(node);
                                this.valueRange.end = node.valueRange.end;
                                offset = _Node2.default.normalizeOffset(src, node.range.end);
                                ch = src[offset];
                                atLineStart = false;
                                prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range
                                // has advanced to check the current line's indentation level
                                // -- eemeli/yaml#10 & eemeli/yaml#38
                                if (ch) {
                                    var ls = offset - 1;
                                    var prev = src[ls];
                                    while (prev === ' ' || prev === '\t') {
                                        prev = src[--ls];
                                    }
                                    if (prev === '\n') {
                                        lineStart = ls + 1;
                                        atLineStart = true;
                                    }
                                }
                                var ec = grabCollectionEndComments(node);
                                if (ec)
                                    Array.prototype.push.apply(this.items, ec);
                            }
                            return offset;
                        }
                    }, {
                        key: "setOrigRanges",
                        value: function setOrigRanges(cr, offset) {
                            offset = (0, _get2.default)((0, _getPrototypeOf2.default)(Collection.prototype), "setOrigRanges", this).call(this, cr, offset);
                            this.items.forEach(function (node) {
                                offset = node.setOrigRanges(cr, offset);
                            });
                            return offset;
                        }
                    }, {
                        key: "toString",
                        value: function toString() {
                            var src = this.context.src, items = this.items, range = this.range, value = this.value;
                            if (value != null)
                                return value;
                            var str = src.slice(range.start, items[0].range.start) + String(items[0]);
                            for (var i = 1; i < items.length; ++i) {
                                var item = items[i];
                                var _item$context = item.context, atLineStart = _item$context.atLineStart, indent = _item$context.indent;
                                if (atLineStart)
                                    for (var _i = 0; _i < indent; ++_i) {
                                        str += ' ';
                                    }
                                str += String(item);
                            }
                            return _Node2.default.addStringTerminator(src, range.end, str);
                        }
                    }, {
                        key: "includesTrailingLines",
                        get: function get() {
                            return this.items.length > 0;
                        }
                    }]);
                return Collection;
            }(_Node2.default);
            exports.default = Collection;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/cst/CollectionItem.js": 
        /*!**************************************************************!*\
          !*** ./node_modules/yaml/browser/dist/cst/CollectionItem.js ***!
          \**************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));
            var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));
            var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));
            var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js"));
            var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));
            var _constants = __webpack_require__(/*! ../constants */ "./node_modules/yaml/browser/dist/constants.js");
            var _errors = __webpack_require__(/*! ../errors */ "./node_modules/yaml/browser/dist/errors.js");
            var _BlankLine = _interopRequireDefault(__webpack_require__(/*! ./BlankLine */ "./node_modules/yaml/browser/dist/cst/BlankLine.js"));
            var _Node2 = _interopRequireDefault(__webpack_require__(/*! ./Node */ "./node_modules/yaml/browser/dist/cst/Node.js"));
            var _Range = _interopRequireDefault(__webpack_require__(/*! ./Range */ "./node_modules/yaml/browser/dist/cst/Range.js"));
            var CollectionItem = 
            /*#__PURE__*/
            function (_Node) {
                (0, _inherits2.default)(CollectionItem, _Node);
                function CollectionItem(type, props) {
                    var _this;
                    (0, _classCallCheck2.default)(this, CollectionItem);
                    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(CollectionItem).call(this, type, props));
                    _this.node = null;
                    return _this;
                }
                (0, _createClass2.default)(CollectionItem, [{
                        key: "parse",
                        /**
                         * @param {ParseContext} context
                         * @param {number} start - Index of first character
                         * @returns {number} - Index of the character after this
                         */
                        value: function parse(context, start) {
                            this.context = context;
                            var parseNode = context.parseNode, src = context.src;
                            var atLineStart = context.atLineStart, lineStart = context.lineStart;
                            if (!atLineStart && this.type === _constants.Type.SEQ_ITEM)
                                this.error = new _errors.YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');
                            var indent = atLineStart ? start - lineStart : context.indent;
                            var offset = _Node2.default.endOfWhiteSpace(src, start + 1);
                            var ch = src[offset];
                            var inlineComment = ch === '#';
                            var comments = [];
                            var blankLine = null;
                            while (ch === '\n' || ch === '#') {
                                if (ch === '#') {
                                    var _end = _Node2.default.endOfLine(src, offset + 1);
                                    comments.push(new _Range.default(offset, _end));
                                    offset = _end;
                                }
                                else {
                                    atLineStart = true;
                                    lineStart = offset + 1;
                                    var wsEnd = _Node2.default.endOfWhiteSpace(src, lineStart);
                                    if (src[wsEnd] === '\n' && comments.length === 0) {
                                        blankLine = new _BlankLine.default();
                                        lineStart = blankLine.parse({
                                            src: src
                                        }, lineStart);
                                    }
                                    offset = _Node2.default.endOfIndent(src, lineStart);
                                }
                                ch = src[offset];
                            }
                            if (_Node2.default.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== _constants.Type.SEQ_ITEM)) {
                                this.node = parseNode({
                                    atLineStart: atLineStart,
                                    inCollection: false,
                                    indent: indent,
                                    lineStart: lineStart,
                                    parent: this
                                }, offset);
                            }
                            else if (ch && lineStart > start + 1) {
                                offset = lineStart - 1;
                            }
                            if (this.node) {
                                if (blankLine) {
                                    // Only blank lines preceding non-empty nodes are captured. Note that
                                    // this means that collection item range start indices do not always
                                    // increase monotonically. -- eemeli/yaml#126
                                    var items = context.parent.items || context.parent.contents;
                                    if (items)
                                        items.push(blankLine);
                                }
                                if (comments.length)
                                    Array.prototype.push.apply(this.props, comments);
                                offset = this.node.range.end;
                            }
                            else {
                                if (inlineComment) {
                                    var c = comments[0];
                                    this.props.push(c);
                                    offset = c.end;
                                }
                                else {
                                    offset = _Node2.default.endOfLine(src, start + 1);
                                }
                            }
                            var end = this.node ? this.node.valueRange.end : offset;
                            this.valueRange = new _Range.default(start, end);
                            return offset;
                        }
                    }, {
                        key: "setOrigRanges",
                        value: function setOrigRanges(cr, offset) {
                            offset = (0, _get2.default)((0, _getPrototypeOf2.default)(CollectionItem.prototype), "setOrigRanges", this).call(this, cr, offset);
                            return this.node ? this.node.setOrigRanges(cr, offset) : offset;
                        }
                    }, {
                        key: "toString",
                        value: function toString() {
                            var src = this.context.src, node = this.node, range = this.range, value = this.value;
                            if (value != null)
                                return value;
                            var str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);
                            return _Node2.default.addStringTerminator(src, range.end, str);
                        }
                    }, {
                        key: "includesTrailingLines",
                        get: function get() {
                            return !!this.node && this.node.includesTrailingLines;
                        }
                    }]);
                return CollectionItem;
            }(_Node2.default);
            exports.default = CollectionItem;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/cst/Comment.js": 
        /*!*******************************************************!*\
          !*** ./node_modules/yaml/browser/dist/cst/Comment.js ***!
          \*******************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));
            var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));
            var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));
            var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));
            var _constants = __webpack_require__(/*! ../constants */ "./node_modules/yaml/browser/dist/constants.js");
            var _Node2 = _interopRequireDefault(__webpack_require__(/*! ./Node */ "./node_modules/yaml/browser/dist/cst/Node.js"));
            var _Range = _interopRequireDefault(__webpack_require__(/*! ./Range */ "./node_modules/yaml/browser/dist/cst/Range.js"));
            var Comment = 
            /*#__PURE__*/
            function (_Node) {
                (0, _inherits2.default)(Comment, _Node);
                function Comment() {
                    (0, _classCallCheck2.default)(this, Comment);
                    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Comment).call(this, _constants.Type.COMMENT));
                }
                /**
                 * Parses a comment line from the source
                 *
                 * @param {ParseContext} context
                 * @param {number} start - Index of first character
                 * @returns {number} - Index of the character after this scalar
                 */
                (0, _createClass2.default)(Comment, [{
                        key: "parse",
                        value: function parse(context, start) {
                            this.context = context;
                            var offset = this.parseComment(start);
                            this.range = new _Range.default(start, offset);
                            return offset;
                        }
                    }]);
                return Comment;
            }(_Node2.default);
            exports.default = Comment;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/cst/Directive.js": 
        /*!*********************************************************!*\
          !*** ./node_modules/yaml/browser/dist/cst/Directive.js ***!
          \*********************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));
            var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));
            var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));
            var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));
            var _constants = __webpack_require__(/*! ../constants */ "./node_modules/yaml/browser/dist/constants.js");
            var _Node2 = _interopRequireDefault(__webpack_require__(/*! ./Node */ "./node_modules/yaml/browser/dist/cst/Node.js"));
            var _Range = _interopRequireDefault(__webpack_require__(/*! ./Range */ "./node_modules/yaml/browser/dist/cst/Range.js"));
            var Directive = 
            /*#__PURE__*/
            function (_Node) {
                (0, _inherits2.default)(Directive, _Node);
                (0, _createClass2.default)(Directive, null, [{
                        key: "endOfDirective",
                        value: function endOfDirective(src, offset) {
                            var ch = src[offset];
                            while (ch && ch !== '\n' && ch !== '#') {
                                ch = src[offset += 1];
                            } // last char can't be whitespace
                            ch = src[offset - 1];
                            while (ch === ' ' || ch === '\t') {
                                offset -= 1;
                                ch = src[offset - 1];
                            }
                            return offset;
                        }
                    }]);
                function Directive() {
                    var _this;
                    (0, _classCallCheck2.default)(this, Directive);
                    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Directive).call(this, _constants.Type.DIRECTIVE));
                    _this.name = null;
                    return _this;
                }
                (0, _createClass2.default)(Directive, [{
                        key: "parseName",
                        value: function parseName(start) {
                            var src = this.context.src;
                            var offset = start;
                            var ch = src[offset];
                            while (ch && ch !== '\n' && ch !== '\t' && ch !== ' ') {
                                ch = src[offset += 1];
                            }
                            this.name = src.slice(start, offset);
                            return offset;
                        }
                    }, {
                        key: "parseParameters",
                        value: function parseParameters(start) {
                            var src = this.context.src;
                            var offset = start;
                            var ch = src[offset];
                            while (ch && ch !== '\n' && ch !== '#') {
                                ch = src[offset += 1];
                            }
                            this.valueRange = new _Range.default(start, offset);
                            return offset;
                        }
                    }, {
                        key: "parse",
                        value: function parse(context, start) {
                            this.context = context;
                            var offset = this.parseName(start + 1);
                            offset = this.parseParameters(offset);
                            offset = this.parseComment(offset);
                            this.range = new _Range.default(start, offset);
                            return offset;
                        }
                    }, {
                        key: "parameters",
                        get: function get() {
                            var raw = this.rawValue;
                            return raw ? raw.trim().split(/[ \t]+/) : [];
                        }
                    }]);
                return Directive;
            }(_Node2.default);
            exports.default = Directive;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/cst/Document.js": 
        /*!********************************************************!*\
          !*** ./node_modules/yaml/browser/dist/cst/Document.js ***!
          \********************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));
            var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));
            var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js"));
            var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));
            var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));
            var _constants = __webpack_require__(/*! ../constants */ "./node_modules/yaml/browser/dist/constants.js");
            var _errors = __webpack_require__(/*! ../errors */ "./node_modules/yaml/browser/dist/errors.js");
            var _BlankLine = _interopRequireDefault(__webpack_require__(/*! ./BlankLine */ "./node_modules/yaml/browser/dist/cst/BlankLine.js"));
            var _Collection = __webpack_require__(/*! ./Collection */ "./node_modules/yaml/browser/dist/cst/Collection.js");
            var _Comment = _interopRequireDefault(__webpack_require__(/*! ./Comment */ "./node_modules/yaml/browser/dist/cst/Comment.js"));
            var _Directive = _interopRequireDefault(__webpack_require__(/*! ./Directive */ "./node_modules/yaml/browser/dist/cst/Directive.js"));
            var _Node2 = _interopRequireDefault(__webpack_require__(/*! ./Node */ "./node_modules/yaml/browser/dist/cst/Node.js"));
            var _Range = _interopRequireDefault(__webpack_require__(/*! ./Range */ "./node_modules/yaml/browser/dist/cst/Range.js"));
            var Document = 
            /*#__PURE__*/
            function (_Node) {
                (0, _inherits2.default)(Document, _Node);
                (0, _createClass2.default)(Document, null, [{
                        key: "startCommentOrEndBlankLine",
                        value: function startCommentOrEndBlankLine(src, start) {
                            var offset = _Node2.default.endOfWhiteSpace(src, start);
                            var ch = src[offset];
                            return ch === '#' || ch === '\n' ? offset : start;
                        }
                    }]);
                function Document() {
                    var _this;
                    (0, _classCallCheck2.default)(this, Document);
                    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Document).call(this, _constants.Type.DOCUMENT));
                    _this.directives = null;
                    _this.contents = null;
                    _this.directivesEndMarker = null;
                    _this.documentEndMarker = null;
                    return _this;
                }
                (0, _createClass2.default)(Document, [{
                        key: "parseDirectives",
                        value: function parseDirectives(start) {
                            var src = this.context.src;
                            this.directives = [];
                            var atLineStart = true;
                            var hasDirectives = false;
                            var offset = start;
                            while (!_Node2.default.atDocumentBoundary(src, offset, _constants.Char.DIRECTIVES_END)) {
                                offset = Document.startCommentOrEndBlankLine(src, offset);
                                switch (src[offset]) {
                                    case '\n':
                                        if (atLineStart) {
                                            var blankLine = new _BlankLine.default();
                                            offset = blankLine.parse({
                                                src: src
                                            }, offset);
                                            if (offset < src.length) {
                                                this.directives.push(blankLine);
                                            }
                                        }
                                        else {
                                            offset += 1;
                                            atLineStart = true;
                                        }
                                        break;
                                    case '#':
                                        {
                                            var comment = new _Comment.default();
                                            offset = comment.parse({
                                                src: src
                                            }, offset);
                                            this.directives.push(comment);
                                            atLineStart = false;
                                        }
                                        break;
                                    case '%':
                                        {
                                            var directive = new _Directive.default();
                                            offset = directive.parse({
                                                parent: this,
                                                src: src
                                            }, offset);
                                            this.directives.push(directive);
                                            hasDirectives = true;
                                            atLineStart = false;
                                        }
                                        break;
                                    default:
                                        if (hasDirectives) {
                                            this.error = new _errors.YAMLSemanticError(this, 'Missing directives-end indicator line');
                                        }
                                        else if (this.directives.length > 0) {
                                            this.contents = this.directives;
                                            this.directives = [];
                                        }
                                        return offset;
                                }
                            }
                            if (src[offset]) {
                                this.directivesEndMarker = new _Range.default(offset, offset + 3);
                                return offset + 3;
                            }
                            if (hasDirectives) {
                                this.error = new _errors.YAMLSemanticError(this, 'Missing directives-end indicator line');
                            }
                            else if (this.directives.length > 0) {
                                this.contents = this.directives;
                                this.directives = [];
                            }
                            return offset;
                        }
                    }, {
                        key: "parseContents",
                        value: function parseContents(start) {
                            var _this$context = this.context, parseNode = _this$context.parseNode, src = _this$context.src;
                            if (!this.contents)
                                this.contents = [];
                            var lineStart = start;
                            while (src[lineStart - 1] === '-') {
                                lineStart -= 1;
                            }
                            var offset = _Node2.default.endOfWhiteSpace(src, start);
                            var atLineStart = lineStart === start;
                            this.valueRange = new _Range.default(offset);
                            while (!_Node2.default.atDocumentBoundary(src, offset, _constants.Char.DOCUMENT_END)) {
                                switch (src[offset]) {
                                    case '\n':
                                        if (atLineStart) {
                                            var blankLine = new _BlankLine.default();
                                            offset = blankLine.parse({
                                                src: src
                                            }, offset);
                                            if (offset < src.length) {
                                                this.contents.push(blankLine);
                                            }
                                        }
                                        else {
                                            offset += 1;
                                            atLineStart = true;
                                        }
                                        lineStart = offset;
                                        break;
                                    case '#':
                                        {
                                            var comment = new _Comment.default();
                                            offset = comment.parse({
                                                src: src
                                            }, offset);
                                            this.contents.push(comment);
                                            atLineStart = false;
                                        }
                                        break;
                                    default:
                                        {
                                            var iEnd = _Node2.default.endOfIndent(src, offset);
                                            var context = {
                                                atLineStart: atLineStart,
                                                indent: -1,
                                                inFlow: false,
                                                inCollection: false,
                                                lineStart: lineStart,
                                                parent: this
                                            };
                                            var node = parseNode(context, iEnd);
                                            if (!node)
                                                return this.valueRange.end = iEnd; // at next document start
                                            this.contents.push(node);
                                            offset = node.range.end;
                                            atLineStart = false;
                                            var ec = (0, _Collection.grabCollectionEndComments)(node);
                                            if (ec)
                                                Array.prototype.push.apply(this.contents, ec);
                                        }
                                }
                                offset = Document.startCommentOrEndBlankLine(src, offset);
                            }
                            this.valueRange.end = offset;
                            if (src[offset]) {
                                this.documentEndMarker = new _Range.default(offset, offset + 3);
                                offset += 3;
                                if (src[offset]) {
                                    offset = _Node2.default.endOfWhiteSpace(src, offset);
                                    if (src[offset] === '#') {
                                        var _comment = new _Comment.default();
                                        offset = _comment.parse({
                                            src: src
                                        }, offset);
                                        this.contents.push(_comment);
                                    }
                                    switch (src[offset]) {
                                        case '\n':
                                            offset += 1;
                                            break;
                                        case undefined:
                                            break;
                                        default:
                                            this.error = new _errors.YAMLSyntaxError(this, 'Document end marker line cannot have a non-comment suffix');
                                    }
                                }
                            }
                            return offset;
                        }
                        /**
                         * @param {ParseContext} context
                         * @param {number} start - Index of first character
                         * @returns {number} - Index of the character after this
                         */
                    }, {
                        key: "parse",
                        value: function parse(context, start) {
                            context.root = this;
                            this.context = context;
                            var src = context.src;
                            var offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM
                            offset = this.parseDirectives(offset);
                            offset = this.parseContents(offset);
                            return offset;
                        }
                    }, {
                        key: "setOrigRanges",
                        value: function setOrigRanges(cr, offset) {
                            offset = (0, _get2.default)((0, _getPrototypeOf2.default)(Document.prototype), "setOrigRanges", this).call(this, cr, offset);
                            this.directives.forEach(function (node) {
                                offset = node.setOrigRanges(cr, offset);
                            });
                            if (this.directivesEndMarker)
                                offset = this.directivesEndMarker.setOrigRange(cr, offset);
                            this.contents.forEach(function (node) {
                                offset = node.setOrigRanges(cr, offset);
                            });
                            if (this.documentEndMarker)
                                offset = this.documentEndMarker.setOrigRange(cr, offset);
                            return offset;
                        }
                    }, {
                        key: "toString",
                        value: function toString() {
                            var contents = this.contents, directives = this.directives, value = this.value;
                            if (value != null)
                                return value;
                            var str = directives.join('');
                            if (contents.length > 0) {
                                if (directives.length > 0 || contents[0].type === _constants.Type.COMMENT)
                                    str += '---\n';
                                str += contents.join('');
                            }
                            if (str[str.length - 1] !== '\n')
                                str += '\n';
                            return str;
                        }
                    }]);
                return Document;
            }(_Node2.default);
            exports.default = Document;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/cst/FlowCollection.js": 
        /*!**************************************************************!*\
          !*** ./node_modules/yaml/browser/dist/cst/FlowCollection.js ***!
          \**************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));
            var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));
            var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));
            var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js"));
            var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));
            var _constants = __webpack_require__(/*! ../constants */ "./node_modules/yaml/browser/dist/constants.js");
            var _errors = __webpack_require__(/*! ../errors */ "./node_modules/yaml/browser/dist/errors.js");
            var _BlankLine = _interopRequireDefault(__webpack_require__(/*! ./BlankLine */ "./node_modules/yaml/browser/dist/cst/BlankLine.js"));
            var _Comment = _interopRequireDefault(__webpack_require__(/*! ./Comment */ "./node_modules/yaml/browser/dist/cst/Comment.js"));
            var _Node2 = _interopRequireDefault(__webpack_require__(/*! ./Node */ "./node_modules/yaml/browser/dist/cst/Node.js"));
            var _Range = _interopRequireDefault(__webpack_require__(/*! ./Range */ "./node_modules/yaml/browser/dist/cst/Range.js"));
            var FlowCollection = 
            /*#__PURE__*/
            function (_Node) {
                (0, _inherits2.default)(FlowCollection, _Node);
                function FlowCollection(type, props) {
                    var _this;
                    (0, _classCallCheck2.default)(this, FlowCollection);
                    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FlowCollection).call(this, type, props));
                    _this.items = null;
                    return _this;
                }
                (0, _createClass2.default)(FlowCollection, [{
                        key: "prevNodeIsJsonLike",
                        value: function prevNodeIsJsonLike() {
                            var idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items.length;
                            var node = this.items[idx - 1];
                            return !!node && (node.jsonLike || node.type === _constants.Type.COMMENT && this.nodeIsJsonLike(idx - 1));
                        }
                        /**
                         * @param {ParseContext} context
                         * @param {number} start - Index of first character
                         * @returns {number} - Index of the character after this
                         */
                    }, {
                        key: "parse",
                        value: function parse(context, start) {
                            this.context = context;
                            var parseNode = context.parseNode, src = context.src;
                            var indent = context.indent, lineStart = context.lineStart;
                            var char = src[start]; // { or [
                            this.items = [{
                                    char: char,
                                    offset: start
                                }];
                            var offset = _Node2.default.endOfWhiteSpace(src, start + 1);
                            char = src[offset];
                            while (char && char !== ']' && char !== '}') {
                                switch (char) {
                                    case '\n':
                                        {
                                            lineStart = offset + 1;
                                            var wsEnd = _Node2.default.endOfWhiteSpace(src, lineStart);
                                            if (src[wsEnd] === '\n') {
                                                var blankLine = new _BlankLine.default();
                                                lineStart = blankLine.parse({
                                                    src: src
                                                }, lineStart);
                                                this.items.push(blankLine);
                                            }
                                            offset = _Node2.default.endOfIndent(src, lineStart);
                                            if (offset <= lineStart + indent) {
                                                char = src[offset];
                                                if (offset < lineStart + indent || char !== ']' && char !== '}') {
                                                    var msg = 'Insufficient indentation in flow collection';
                                                    this.error = new _errors.YAMLSemanticError(this, msg);
                                                }
                                            }
                                        }
                                        break;
                                    case ',':
                                        {
                                            this.items.push({
                                                char: char,
                                                offset: offset
                                            });
                                            offset += 1;
                                        }
                                        break;
                                    case '#':
                                        {
                                            var comment = new _Comment.default();
                                            offset = comment.parse({
                                                src: src
                                            }, offset);
                                            this.items.push(comment);
                                        }
                                        break;
                                    case '?':
                                    case ':':
                                        {
                                            var next = src[offset + 1];
                                            if (next === '\n' || next === '\t' || next === ' ' || next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace
                                                char === ':' && this.prevNodeIsJsonLike()) {
                                                this.items.push({
                                                    char: char,
                                                    offset: offset
                                                });
                                                offset += 1;
                                                break;
                                            }
                                        }
                                    // fallthrough
                                    default:
                                        {
                                            var node = parseNode({
                                                atLineStart: false,
                                                inCollection: false,
                                                inFlow: true,
                                                indent: -1,
                                                lineStart: lineStart,
                                                parent: this
                                            }, offset);
                                            if (!node) {
                                                // at next document start
                                                this.valueRange = new _Range.default(start, offset);
                                                return offset;
                                            }
                                            this.items.push(node);
                                            offset = _Node2.default.normalizeOffset(src, node.range.end);
                                        }
                                }
                                offset = _Node2.default.endOfWhiteSpace(src, offset);
                                char = src[offset];
                            }
                            this.valueRange = new _Range.default(start, offset + 1);
                            if (char) {
                                this.items.push({
                                    char: char,
                                    offset: offset
                                });
                                offset = _Node2.default.endOfWhiteSpace(src, offset + 1);
                                offset = this.parseComment(offset);
                            }
                            return offset;
                        }
                    }, {
                        key: "setOrigRanges",
                        value: function setOrigRanges(cr, offset) {
                            offset = (0, _get2.default)((0, _getPrototypeOf2.default)(FlowCollection.prototype), "setOrigRanges", this).call(this, cr, offset);
                            this.items.forEach(function (node) {
                                if (node instanceof _Node2.default) {
                                    offset = node.setOrigRanges(cr, offset);
                                }
                                else if (cr.length === 0) {
                                    node.origOffset = node.offset;
                                }
                                else {
                                    var i = offset;
                                    while (i < cr.length) {
                                        if (cr[i] > node.offset)
                                            break;
                                        else
                                            ++i;
                                    }
                                    node.origOffset = node.offset + i;
                                    offset = i;
                                }
                            });
                            return offset;
                        }
                    }, {
                        key: "toString",
                        value: function toString() {
                            var src = this.context.src, items = this.items, range = this.range, value = this.value;
                            if (value != null)
                                return value;
                            var nodes = items.filter(function (item) {
                                return item instanceof _Node2.default;
                            });
                            var str = '';
                            var prevEnd = range.start;
                            nodes.forEach(function (node) {
                                var prefix = src.slice(prevEnd, node.range.start);
                                prevEnd = node.range.end;
                                str += prefix + String(node);
                                if (str[str.length - 1] === '\n' && src[prevEnd - 1] !== '\n' && src[prevEnd] === '\n') {
                                    // Comment range does not include the terminal newline, but its
                                    // stringified value does. Without this fix, newlines at comment ends
                                    // get duplicated.
                                    prevEnd += 1;
                                }
                            });
                            str += src.slice(prevEnd, range.end);
                            return _Node2.default.addStringTerminator(src, range.end, str);
                        }
                    }]);
                return FlowCollection;
            }(_Node2.default);
            exports.default = FlowCollection;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/cst/Node.js": 
        /*!****************************************************!*\
          !*** ./node_modules/yaml/browser/dist/cst/Node.js ***!
          \****************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _slicedToArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js"));
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));
            var _constants = __webpack_require__(/*! ../constants */ "./node_modules/yaml/browser/dist/constants.js");
            var _sourceUtils = __webpack_require__(/*! ./source-utils */ "./node_modules/yaml/browser/dist/cst/source-utils.js");
            var _Range = _interopRequireDefault(__webpack_require__(/*! ./Range */ "./node_modules/yaml/browser/dist/cst/Range.js"));
            /** Root class of all nodes */
            var Node = 
            /*#__PURE__*/
            function () {
                (0, _createClass2.default)(Node, null, [{
                        key: "addStringTerminator",
                        value: function addStringTerminator(src, offset, str) {
                            if (str[str.length - 1] === '\n')
                                return str;
                            var next = Node.endOfWhiteSpace(src, offset);
                            return next >= src.length || src[next] === '\n' ? str + '\n' : str;
                        } // ^(---|...)
                    }, {
                        key: "atDocumentBoundary",
                        value: function atDocumentBoundary(src, offset, sep) {
                            var ch0 = src[offset];
                            if (!ch0)
                                return true;
                            var prev = src[offset - 1];
                            if (prev && prev !== '\n')
                                return false;
                            if (sep) {
                                if (ch0 !== sep)
                                    return false;
                            }
                            else {
                                if (ch0 !== _constants.Char.DIRECTIVES_END && ch0 !== _constants.Char.DOCUMENT_END)
                                    return false;
                            }
                            var ch1 = src[offset + 1];
                            var ch2 = src[offset + 2];
                            if (ch1 !== ch0 || ch2 !== ch0)
                                return false;
                            var ch3 = src[offset + 3];
                            return !ch3 || ch3 === '\n' || ch3 === '\t' || ch3 === ' ';
                        }
                    }, {
                        key: "endOfIdentifier",
                        value: function endOfIdentifier(src, offset) {
                            var ch = src[offset];
                            var isVerbatim = ch === '<';
                            var notOk = isVerbatim ? ['\n', '\t', ' ', '>'] : ['\n', '\t', ' ', '[', ']', '{', '}', ','];
                            while (ch && notOk.indexOf(ch) === -1) {
                                ch = src[offset += 1];
                            }
                            if (isVerbatim && ch === '>')
                                offset += 1;
                            return offset;
                        }
                    }, {
                        key: "endOfIndent",
                        value: function endOfIndent(src, offset) {
                            var ch = src[offset];
                            while (ch === ' ') {
                                ch = src[offset += 1];
                            }
                            return offset;
                        }
                    }, {
                        key: "endOfLine",
                        value: function endOfLine(src, offset) {
                            var ch = src[offset];
                            while (ch && ch !== '\n') {
                                ch = src[offset += 1];
                            }
                            return offset;
                        }
                    }, {
                        key: "endOfWhiteSpace",
                        value: function endOfWhiteSpace(src, offset) {
                            var ch = src[offset];
                            while (ch === '\t' || ch === ' ') {
                                ch = src[offset += 1];
                            }
                            return offset;
                        }
                    }, {
                        key: "startOfLine",
                        value: function startOfLine(src, offset) {
                            var ch = src[offset - 1];
                            if (ch === '\n')
                                return offset;
                            while (ch && ch !== '\n') {
                                ch = src[offset -= 1];
                            }
                            return offset + 1;
                        }
                        /**
                         * End of indentation, or null if the line's indent level is not more
                         * than `indent`
                         *
                         * @param {string} src
                         * @param {number} indent
                         * @param {number} lineStart
                         * @returns {?number}
                         */
                    }, {
                        key: "endOfBlockIndent",
                        value: function endOfBlockIndent(src, indent, lineStart) {
                            var inEnd = Node.endOfIndent(src, lineStart);
                            if (inEnd > lineStart + indent) {
                                return inEnd;
                            }
                            else {
                                var wsEnd = Node.endOfWhiteSpace(src, inEnd);
                                var ch = src[wsEnd];
                                if (!ch || ch === '\n')
                                    return wsEnd;
                            }
                            return null;
                        }
                    }, {
                        key: "atBlank",
                        value: function atBlank(src, offset, endAsBlank) {
                            var ch = src[offset];
                            return ch === '\n' || ch === '\t' || ch === ' ' || endAsBlank && !ch;
                        }
                    }, {
                        key: "atCollectionItem",
                        value: function atCollectionItem(src, offset) {
                            var ch = src[offset];
                            return (ch === '?' || ch === ':' || ch === '-') && Node.atBlank(src, offset + 1, true);
                        }
                    }, {
                        key: "nextNodeIsIndented",
                        value: function nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {
                            if (!ch || indentDiff < 0)
                                return false;
                            if (indentDiff > 0)
                                return true;
                            return indicatorAsIndent && ch === '-';
                        } // should be at line or string end, or at next non-whitespace char
                    }, {
                        key: "normalizeOffset",
                        value: function normalizeOffset(src, offset) {
                            var ch = src[offset];
                            return !ch ? offset : ch !== '\n' && src[offset - 1] === '\n' ? offset - 1 : Node.endOfWhiteSpace(src, offset);
                        } // fold single newline into space, multiple newlines to N - 1 newlines
                        // presumes src[offset] === '\n'
                    }, {
                        key: "foldNewline",
                        value: function foldNewline(src, offset, indent) {
                            var inCount = 0;
                            var error = false;
                            var fold = '';
                            var ch = src[offset + 1];
                            while (ch === ' ' || ch === '\t' || ch === '\n') {
                                switch (ch) {
                                    case '\n':
                                        inCount = 0;
                                        offset += 1;
                                        fold += '\n';
                                        break;
                                    case '\t':
                                        if (inCount <= indent)
                                            error = true;
                                        offset = Node.endOfWhiteSpace(src, offset + 2) - 1;
                                        break;
                                    case ' ':
                                        inCount += 1;
                                        offset += 1;
                                        break;
                                }
                                ch = src[offset + 1];
                            }
                            if (!fold)
                                fold = ' ';
                            if (ch && inCount <= indent)
                                error = true;
                            return {
                                fold: fold,
                                offset: offset,
                                error: error
                            };
                        }
                    }]);
                function Node(type, props, context) {
                    (0, _classCallCheck2.default)(this, Node);
                    Object.defineProperty(this, 'context', {
                        value: context || null,
                        writable: true
                    });
                    this.error = null;
                    this.range = null;
                    this.valueRange = null;
                    this.props = props || [];
                    this.type = type;
                    this.value = null;
                }
                (0, _createClass2.default)(Node, [{
                        key: "getPropValue",
                        value: function getPropValue(idx, key, skipKey) {
                            if (!this.context)
                                return null;
                            var src = this.context.src;
                            var prop = this.props[idx];
                            return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;
                        }
                    }, {
                        key: "commentHasRequiredWhitespace",
                        value: function commentHasRequiredWhitespace(start) {
                            var src = this.context.src;
                            if (this.header && start === this.header.end)
                                return false;
                            if (!this.valueRange)
                                return false;
                            var end = this.valueRange.end;
                            return start !== end || Node.atBlank(src, end - 1);
                        }
                    }, {
                        key: "parseComment",
                        value: function parseComment(start) {
                            var src = this.context.src;
                            if (src[start] === _constants.Char.COMMENT) {
                                var end = Node.endOfLine(src, start + 1);
                                var commentRange = new _Range.default(start, end);
                                this.props.push(commentRange);
                                return end;
                            }
                            return start;
                        }
                        /**
                         * Populates the `origStart` and `origEnd` values of all ranges for this
                         * node. Extended by child classes to handle descendant nodes.
                         *
                         * @param {number[]} cr - Positions of dropped CR characters
                         * @param {number} offset - Starting index of `cr` from the last call
                         * @returns {number} - The next offset, matching the one found for `origStart`
                         */
                    }, {
                        key: "setOrigRanges",
                        value: function setOrigRanges(cr, offset) {
                            if (this.range)
                                offset = this.range.setOrigRange(cr, offset);
                            if (this.valueRange)
                                this.valueRange.setOrigRange(cr, offset);
                            this.props.forEach(function (prop) {
                                return prop.setOrigRange(cr, offset);
                            });
                            return offset;
                        }
                    }, {
                        key: "toString",
                        value: function toString() {
                            var src = this.context.src, range = this.range, value = this.value;
                            if (value != null)
                                return value;
                            var str = src.slice(range.start, range.end);
                            return Node.addStringTerminator(src, range.end, str);
                        }
                    }, {
                        key: "anchor",
                        get: function get() {
                            for (var i = 0; i < this.props.length; ++i) {
                                var anchor = this.getPropValue(i, _constants.Char.ANCHOR, true);
                                if (anchor != null)
                                    return anchor;
                            }
                            return null;
                        }
                    }, {
                        key: "comment",
                        get: function get() {
                            var comments = [];
                            for (var i = 0; i < this.props.length; ++i) {
                                var comment = this.getPropValue(i, _constants.Char.COMMENT, true);
                                if (comment != null)
                                    comments.push(comment);
                            }
                            return comments.length > 0 ? comments.join('\n') : null;
                        }
                    }, {
                        key: "hasComment",
                        get: function get() {
                            if (this.context) {
                                var src = this.context.src;
                                for (var i = 0; i < this.props.length; ++i) {
                                    if (src[this.props[i].start] === _constants.Char.COMMENT)
                                        return true;
                                }
                            }
                            return false;
                        }
                    }, {
                        key: "hasProps",
                        get: function get() {
                            if (this.context) {
                                var src = this.context.src;
                                for (var i = 0; i < this.props.length; ++i) {
                                    if (src[this.props[i].start] !== _constants.Char.COMMENT)
                                        return true;
                                }
                            }
                            return false;
                        }
                    }, {
                        key: "includesTrailingLines",
                        get: function get() {
                            return false;
                        }
                    }, {
                        key: "jsonLike",
                        get: function get() {
                            var jsonLikeTypes = [_constants.Type.FLOW_MAP, _constants.Type.FLOW_SEQ, _constants.Type.QUOTE_DOUBLE, _constants.Type.QUOTE_SINGLE];
                            return jsonLikeTypes.indexOf(this.type) !== -1;
                        }
                    }, {
                        key: "rangeAsLinePos",
                        get: function get() {
                            if (!this.range || !this.context)
                                return undefined;
                            var start = (0, _sourceUtils.getLinePos)(this.range.start, this.context.root);
                            if (!start)
                                return undefined;
                            var end = (0, _sourceUtils.getLinePos)(this.range.end, this.context.root);
                            return {
                                start: start,
                                end: end
                            };
                        }
                    }, {
                        key: "rawValue",
                        get: function get() {
                            if (!this.valueRange || !this.context)
                                return null;
                            var _this$valueRange = this.valueRange, start = _this$valueRange.start, end = _this$valueRange.end;
                            return this.context.src.slice(start, end);
                        }
                    }, {
                        key: "tag",
                        get: function get() {
                            for (var i = 0; i < this.props.length; ++i) {
                                var tag = this.getPropValue(i, _constants.Char.TAG, false);
                                if (tag != null) {
                                    if (tag[1] === '<') {
                                        return {
                                            verbatim: tag.slice(2, -1)
                                        };
                                    }
                                    else {
                                        // eslint-disable-next-line no-unused-vars
                                        var _tag$match = tag.match(/^(.*!)([^!]*)$/), _tag$match2 = (0, _slicedToArray2.default)(_tag$match, 3), _ = _tag$match2[0], handle = _tag$match2[1], suffix = _tag$match2[2];
                                        return {
                                            handle: handle,
                                            suffix: suffix
                                        };
                                    }
                                }
                            }
                            return null;
                        }
                    }, {
                        key: "valueRangeContainsNewline",
                        get: function get() {
                            if (!this.valueRange || !this.context)
                                return false;
                            var _this$valueRange2 = this.valueRange, start = _this$valueRange2.start, end = _this$valueRange2.end;
                            var src = this.context.src;
                            for (var i = start; i < end; ++i) {
                                if (src[i] === '\n')
                                    return true;
                            }
                            return false;
                        }
                    }]);
                return Node;
            }();
            exports.default = Node;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/cst/ParseContext.js": 
        /*!************************************************************!*\
          !*** ./node_modules/yaml/browser/dist/cst/ParseContext.js ***!
          \************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));
            var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));
            var _constants = __webpack_require__(/*! ../constants */ "./node_modules/yaml/browser/dist/constants.js");
            var _errors = __webpack_require__(/*! ../errors */ "./node_modules/yaml/browser/dist/errors.js");
            var _Alias = _interopRequireDefault(__webpack_require__(/*! ./Alias */ "./node_modules/yaml/browser/dist/cst/Alias.js"));
            var _BlockValue = _interopRequireDefault(__webpack_require__(/*! ./BlockValue */ "./node_modules/yaml/browser/dist/cst/BlockValue.js"));
            var _Collection = _interopRequireDefault(__webpack_require__(/*! ./Collection */ "./node_modules/yaml/browser/dist/cst/Collection.js"));
            var _CollectionItem = _interopRequireDefault(__webpack_require__(/*! ./CollectionItem */ "./node_modules/yaml/browser/dist/cst/CollectionItem.js"));
            var _FlowCollection = _interopRequireDefault(__webpack_require__(/*! ./FlowCollection */ "./node_modules/yaml/browser/dist/cst/FlowCollection.js"));
            var _Node = _interopRequireDefault(__webpack_require__(/*! ./Node */ "./node_modules/yaml/browser/dist/cst/Node.js"));
            var _PlainValue = _interopRequireDefault(__webpack_require__(/*! ./PlainValue */ "./node_modules/yaml/browser/dist/cst/PlainValue.js"));
            var _QuoteDouble = _interopRequireDefault(__webpack_require__(/*! ./QuoteDouble */ "./node_modules/yaml/browser/dist/cst/QuoteDouble.js"));
            var _QuoteSingle = _interopRequireDefault(__webpack_require__(/*! ./QuoteSingle */ "./node_modules/yaml/browser/dist/cst/QuoteSingle.js"));
            var _Range = _interopRequireDefault(__webpack_require__(/*! ./Range */ "./node_modules/yaml/browser/dist/cst/Range.js"));
            /**
             * @param {boolean} atLineStart - Node starts at beginning of line
             * @param {boolean} inFlow - true if currently in a flow context
             * @param {boolean} inCollection - true if currently in a collection context
             * @param {number} indent - Current level of indentation
             * @param {number} lineStart - Start of the current line
             * @param {Node} parent - The parent of the node
             * @param {string} src - Source of the YAML document
             */
            var ParseContext = 
            /*#__PURE__*/
            function () {
                (0, _createClass2.default)(ParseContext, null, [{
                        key: "parseType",
                        value: function parseType(src, offset, inFlow) {
                            switch (src[offset]) {
                                case '*':
                                    return _constants.Type.ALIAS;
                                case '>':
                                    return _constants.Type.BLOCK_FOLDED;
                                case '|':
                                    return _constants.Type.BLOCK_LITERAL;
                                case '{':
                                    return _constants.Type.FLOW_MAP;
                                case '[':
                                    return _constants.Type.FLOW_SEQ;
                                case '?':
                                    return !inFlow && _Node.default.atBlank(src, offset + 1, true) ? _constants.Type.MAP_KEY : _constants.Type.PLAIN;
                                case ':':
                                    return !inFlow && _Node.default.atBlank(src, offset + 1, true) ? _constants.Type.MAP_VALUE : _constants.Type.PLAIN;
                                case '-':
                                    return !inFlow && _Node.default.atBlank(src, offset + 1, true) ? _constants.Type.SEQ_ITEM : _constants.Type.PLAIN;
                                case '"':
                                    return _constants.Type.QUOTE_DOUBLE;
                                case "'":
                                    return _constants.Type.QUOTE_SINGLE;
                                default:
                                    return _constants.Type.PLAIN;
                            }
                        }
                    }]);
                function ParseContext() {
                    var _this = this;
                    var orig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, atLineStart = _ref.atLineStart, inCollection = _ref.inCollection, inFlow = _ref.inFlow, indent = _ref.indent, lineStart = _ref.lineStart, parent = _ref.parent;
                    (0, _classCallCheck2.default)(this, ParseContext);
                    (0, _defineProperty2.default)(this, "parseNode", function (overlay, start) {
                        if (_Node.default.atDocumentBoundary(_this.src, start))
                            return null;
                        var context = new ParseContext(_this, overlay);
                        var _context$parseProps = context.parseProps(start), props = _context$parseProps.props, type = _context$parseProps.type, valueStart = _context$parseProps.valueStart;
                        var node;
                        switch (type) {
                            case _constants.Type.ALIAS:
                                node = new _Alias.default(type, props);
                                break;
                            case _constants.Type.BLOCK_FOLDED:
                            case _constants.Type.BLOCK_LITERAL:
                                node = new _BlockValue.default(type, props);
                                break;
                            case _constants.Type.FLOW_MAP:
                            case _constants.Type.FLOW_SEQ:
                                node = new _FlowCollection.default(type, props);
                                break;
                            case _constants.Type.MAP_KEY:
                            case _constants.Type.MAP_VALUE:
                            case _constants.Type.SEQ_ITEM:
                                node = new _CollectionItem.default(type, props);
                                break;
                            case _constants.Type.COMMENT:
                            case _constants.Type.PLAIN:
                                node = new _PlainValue.default(type, props);
                                break;
                            case _constants.Type.QUOTE_DOUBLE:
                                node = new _QuoteDouble.default(type, props);
                                break;
                            case _constants.Type.QUOTE_SINGLE:
                                node = new _QuoteSingle.default(type, props);
                                break;
                            default:
                                node.error = new _errors.YAMLSyntaxError(node, "Unknown node type: ".concat(JSON.stringify(type)));
                                node.range = new _Range.default(start, start + 1);
                                return node;
                        }
                        var offset = node.parse(context, valueStart);
                        node.range = new _Range.default(start, offset);
                        if (offset <= start) {
                            node.error = new Error("Node#parse consumed no characters");
                            node.error.parseEnd = offset;
                            node.error.source = node;
                            node.range.end = start + 1;
                        }
                        if (context.nodeStartsCollection(node)) {
                            if (!node.error && !context.atLineStart && context.parent.type === _constants.Type.DOCUMENT) {
                                node.error = new _errors.YAMLSyntaxError(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');
                            }
                            var collection = new _Collection.default(node);
                            offset = collection.parse(new ParseContext(context), offset);
                            collection.range = new _Range.default(start, offset);
                            return collection;
                        }
                        return node;
                    });
                    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;
                    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;
                    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;
                    this.indent = indent != null ? indent : orig.indent;
                    this.lineStart = lineStart != null ? lineStart : orig.lineStart;
                    this.parent = parent != null ? parent : orig.parent || {};
                    this.root = orig.root;
                    this.src = orig.src;
                } // for logging
                (0, _createClass2.default)(ParseContext, [{
                        key: "nodeStartsCollection",
                        value: function nodeStartsCollection(node) {
                            var inCollection = this.inCollection, inFlow = this.inFlow, src = this.src;
                            if (inCollection || inFlow)
                                return false;
                            if (node instanceof _CollectionItem.default)
                                return true; // check for implicit key
                            var offset = node.range.end;
                            if (src[offset] === '\n' || src[offset - 1] === '\n')
                                return false;
                            offset = _Node.default.endOfWhiteSpace(src, offset);
                            return src[offset] === ':';
                        } // Anchor and tag are before type, which determines the node implementation
                        // class; hence this intermediate step.
                    }, {
                        key: "parseProps",
                        value: function parseProps(offset) {
                            var inFlow = this.inFlow, parent = this.parent, src = this.src;
                            var props = [];
                            var lineHasProps = false;
                            offset = _Node.default.endOfWhiteSpace(src, offset);
                            var ch = src[offset];
                            while (ch === _constants.Char.ANCHOR || ch === _constants.Char.COMMENT || ch === _constants.Char.TAG || ch === '\n') {
                                if (ch === '\n') {
                                    var lineStart = offset + 1;
                                    var inEnd = _Node.default.endOfIndent(src, lineStart);
                                    var indentDiff = inEnd - (lineStart + this.indent);
                                    var noIndicatorAsIndent = parent.type === _constants.Type.SEQ_ITEM && parent.context.atLineStart;
                                    if (!_Node.default.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent))
                                        break;
                                    this.atLineStart = true;
                                    this.lineStart = lineStart;
                                    lineHasProps = false;
                                    offset = inEnd;
                                }
                                else if (ch === _constants.Char.COMMENT) {
                                    var end = _Node.default.endOfLine(src, offset + 1);
                                    props.push(new _Range.default(offset, end));
                                    offset = end;
                                }
                                else {
                                    var _end = _Node.default.endOfIdentifier(src, offset + 1);
                                    if (ch === _constants.Char.TAG && src[_end] === ',' && /^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d){0,2}\/\S/.test(src.slice(offset + 1, _end + 13))) {
                                        // Let's presume we're dealing with a YAML 1.0 domain tag here, rather
                                        // than an empty but 'foo.bar' private-tagged node in a flow collection
                                        // followed without whitespace by a plain string starting with a year
                                        // or date divided by something.
                                        _end = _Node.default.endOfIdentifier(src, _end + 5);
                                    }
                                    props.push(new _Range.default(offset, _end));
                                    lineHasProps = true;
                                    offset = _Node.default.endOfWhiteSpace(src, _end);
                                }
                                ch = src[offset];
                            } // '- &a : b' has an anchor on an empty node
                            if (lineHasProps && ch === ':' && _Node.default.atBlank(src, offset + 1, true))
                                offset -= 1;
                            var type = ParseContext.parseType(src, offset, inFlow);
                            return {
                                props: props,
                                type: type,
                                valueStart: offset
                            };
                        }
                        /**
                         * Parses a node from the source
                         * @param {ParseContext} overlay
                         * @param {number} start - Index of first non-whitespace character for the node
                         * @returns {?Node} - null if at a document boundary
                         */
                    }, {
                        key: "pretty",
                        get: function get() {
                            var obj = {
                                start: "".concat(this.lineStart, " + ").concat(this.indent),
                                in: [],
                                parent: this.parent.type
                            };
                            if (!this.atLineStart)
                                obj.start += ' + N';
                            if (this.inCollection)
                                obj.in.push('collection');
                            if (this.inFlow)
                                obj.in.push('flow');
                            return obj;
                        }
                    }]);
                return ParseContext;
            }();
            exports.default = ParseContext;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/cst/PlainValue.js": 
        /*!**********************************************************!*\
          !*** ./node_modules/yaml/browser/dist/cst/PlainValue.js ***!
          \**********************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));
            var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));
            var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));
            var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));
            var _Node2 = _interopRequireDefault(__webpack_require__(/*! ./Node */ "./node_modules/yaml/browser/dist/cst/Node.js"));
            var _Range = _interopRequireDefault(__webpack_require__(/*! ./Range */ "./node_modules/yaml/browser/dist/cst/Range.js"));
            var PlainValue = 
            /*#__PURE__*/
            function (_Node) {
                (0, _inherits2.default)(PlainValue, _Node);
                function PlainValue() {
                    (0, _classCallCheck2.default)(this, PlainValue);
                    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(PlainValue).apply(this, arguments));
                }
                (0, _createClass2.default)(PlainValue, [{
                        key: "parseBlockValue",
                        value: function parseBlockValue(start) {
                            var _this$context = this.context, indent = _this$context.indent, inFlow = _this$context.inFlow, src = _this$context.src;
                            var offset = start;
                            var valueEnd = start;
                            for (var ch = src[offset]; ch === '\n'; ch = src[offset]) {
                                if (_Node2.default.atDocumentBoundary(src, offset + 1))
                                    break;
                                var end = _Node2.default.endOfBlockIndent(src, indent, offset + 1);
                                if (end === null || src[end] === '#')
                                    break;
                                if (src[end] === '\n') {
                                    offset = end;
                                }
                                else {
                                    valueEnd = PlainValue.endOfLine(src, end, inFlow);
                                    offset = valueEnd;
                                }
                            }
                            if (this.valueRange.isEmpty())
                                this.valueRange.start = start;
                            this.valueRange.end = valueEnd;
                            return valueEnd;
                        }
                        /**
                         * Parses a plain value from the source
                         *
                         * Accepted forms are:
                         * ```
                         * #comment
                         *
                         * first line
                         *
                         * first line #comment
                         *
                         * first line
                         * block
                         * lines
                         *
                         * #comment
                         * block
                         * lines
                         * ```
                         * where block lines are empty or have an indent level greater than `indent`.
                         *
                         * @param {ParseContext} context
                         * @param {number} start - Index of first character
                         * @returns {number} - Index of the character after this scalar, may be `\n`
                         */
                    }, {
                        key: "parse",
                        value: function parse(context, start) {
                            this.context = context;
                            var inFlow = context.inFlow, src = context.src;
                            var offset = start;
                            var ch = src[offset];
                            if (ch && ch !== '#' && ch !== '\n') {
                                offset = PlainValue.endOfLine(src, start, inFlow);
                            }
                            this.valueRange = new _Range.default(start, offset);
                            offset = _Node2.default.endOfWhiteSpace(src, offset);
                            offset = this.parseComment(offset);
                            if (!this.hasComment || this.valueRange.isEmpty()) {
                                offset = this.parseBlockValue(offset);
                            }
                            return offset;
                        }
                    }, {
                        key: "strValue",
                        get: function get() {
                            if (!this.valueRange || !this.context)
                                return null;
                            var _this$valueRange = this.valueRange, start = _this$valueRange.start, end = _this$valueRange.end;
                            var src = this.context.src;
                            var ch = src[end - 1];
                            while (start < end && (ch === '\n' || ch === '\t' || ch === ' ')) {
                                ch = src[--end - 1];
                            }
                            ch = src[start];
                            while (start < end && (ch === '\n' || ch === '\t' || ch === ' ')) {
                                ch = src[++start];
                            }
                            var str = '';
                            for (var i = start; i < end; ++i) {
                                var _ch = src[i];
                                if (_ch === '\n') {
                                    var _Node$foldNewline = _Node2.default.foldNewline(src, i, -1), fold = _Node$foldNewline.fold, offset = _Node$foldNewline.offset;
                                    str += fold;
                                    i = offset;
                                }
                                else if (_ch === ' ' || _ch === '\t') {
                                    // trim trailing whitespace
                                    var wsStart = i;
                                    var next = src[i + 1];
                                    while (i < end && (next === ' ' || next === '\t')) {
                                        i += 1;
                                        next = src[i + 1];
                                    }
                                    if (next !== '\n')
                                        str += i > wsStart ? src.slice(wsStart, i + 1) : _ch;
                                }
                                else {
                                    str += _ch;
                                }
                            }
                            return str;
                        }
                    }], [{
                        key: "endOfLine",
                        value: function endOfLine(src, start, inFlow) {
                            var ch = src[start];
                            var offset = start;
                            while (ch && ch !== '\n') {
                                if (inFlow && (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ','))
                                    break;
                                var next = src[offset + 1];
                                if (ch === ':' && (!next || next === '\n' || next === '\t' || next === ' ' || inFlow && next === ','))
                                    break;
                                if ((ch === ' ' || ch === '\t') && next === '#')
                                    break;
                                offset += 1;
                                ch = next;
                            }
                            return offset;
                        }
                    }]);
                return PlainValue;
            }(_Node2.default);
            exports.default = PlainValue;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/cst/QuoteDouble.js": 
        /*!***********************************************************!*\
          !*** ./node_modules/yaml/browser/dist/cst/QuoteDouble.js ***!
          \***********************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));
            var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));
            var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));
            var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));
            var _errors = __webpack_require__(/*! ../errors */ "./node_modules/yaml/browser/dist/errors.js");
            var _Node2 = _interopRequireDefault(__webpack_require__(/*! ./Node */ "./node_modules/yaml/browser/dist/cst/Node.js"));
            var _Range = _interopRequireDefault(__webpack_require__(/*! ./Range */ "./node_modules/yaml/browser/dist/cst/Range.js"));
            var QuoteDouble = 
            /*#__PURE__*/
            function (_Node) {
                (0, _inherits2.default)(QuoteDouble, _Node);
                function QuoteDouble() {
                    (0, _classCallCheck2.default)(this, QuoteDouble);
                    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(QuoteDouble).apply(this, arguments));
                }
                (0, _createClass2.default)(QuoteDouble, [{
                        key: "parseCharCode",
                        value: function parseCharCode(offset, length, errors) {
                            var src = this.context.src;
                            var cc = src.substr(offset, length);
                            var ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
                            var code = ok ? parseInt(cc, 16) : NaN;
                            if (isNaN(code)) {
                                errors.push(new _errors.YAMLSyntaxError(this, "Invalid escape sequence ".concat(src.substr(offset - 2, length + 2))));
                                return src.substr(offset - 2, length + 2);
                            }
                            return String.fromCodePoint(code);
                        }
                        /**
                         * Parses a "double quoted" value from the source
                         *
                         * @param {ParseContext} context
                         * @param {number} start - Index of first character
                         * @returns {number} - Index of the character after this scalar
                         */
                    }, {
                        key: "parse",
                        value: function parse(context, start) {
                            this.context = context;
                            var src = context.src;
                            var offset = QuoteDouble.endOfQuote(src, start + 1);
                            this.valueRange = new _Range.default(start, offset);
                            offset = _Node2.default.endOfWhiteSpace(src, offset);
                            offset = this.parseComment(offset);
                            return offset;
                        }
                    }, {
                        key: "strValue",
                        /**
                         * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
                         */
                        get: function get() {
                            if (!this.valueRange || !this.context)
                                return null;
                            var errors = [];
                            var _this$valueRange = this.valueRange, start = _this$valueRange.start, end = _this$valueRange.end;
                            var _this$context = this.context, indent = _this$context.indent, src = _this$context.src;
                            if (src[end - 1] !== '"')
                                errors.push(new _errors.YAMLSyntaxError(this, 'Missing closing "quote')); // Using String#replace is too painful with escaped newlines preceded by
                            // escaped backslashes; also, this should be faster.
                            var str = '';
                            for (var i = start + 1; i < end - 1; ++i) {
                                var ch = src[i];
                                if (ch === '\n') {
                                    if (_Node2.default.atDocumentBoundary(src, i + 1))
                                        errors.push(new _errors.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));
                                    var _Node$foldNewline = _Node2.default.foldNewline(src, i, indent), fold = _Node$foldNewline.fold, offset = _Node$foldNewline.offset, error = _Node$foldNewline.error;
                                    str += fold;
                                    i = offset;
                                    if (error)
                                        errors.push(new _errors.YAMLSemanticError(this, 'Multi-line double-quoted string needs to be sufficiently indented'));
                                }
                                else if (ch === '\\') {
                                    i += 1;
                                    switch (src[i]) {
                                        case '0':
                                            str += '\0';
                                            break;
                                        // null character
                                        case 'a':
                                            str += '\x07';
                                            break;
                                        // bell character
                                        case 'b':
                                            str += '\b';
                                            break;
                                        // backspace
                                        case 'e':
                                            str += '\x1b';
                                            break;
                                        // escape character
                                        case 'f':
                                            str += '\f';
                                            break;
                                        // form feed
                                        case 'n':
                                            str += '\n';
                                            break;
                                        // line feed
                                        case 'r':
                                            str += '\r';
                                            break;
                                        // carriage return
                                        case 't':
                                            str += '\t';
                                            break;
                                        // horizontal tab
                                        case 'v':
                                            str += '\v';
                                            break;
                                        // vertical tab
                                        case 'N':
                                            str += "\x85";
                                            break;
                                        // Unicode next line
                                        case '_':
                                            str += "\xA0";
                                            break;
                                        // Unicode non-breaking space
                                        case 'L':
                                            str += "\u2028";
                                            break;
                                        // Unicode line separator
                                        case 'P':
                                            str += "\u2029";
                                            break;
                                        // Unicode paragraph separator
                                        case ' ':
                                            str += ' ';
                                            break;
                                        case '"':
                                            str += '"';
                                            break;
                                        case '/':
                                            str += '/';
                                            break;
                                        case '\\':
                                            str += '\\';
                                            break;
                                        case '\t':
                                            str += '\t';
                                            break;
                                        case 'x':
                                            str += this.parseCharCode(i + 1, 2, errors);
                                            i += 2;
                                            break;
                                        case 'u':
                                            str += this.parseCharCode(i + 1, 4, errors);
                                            i += 4;
                                            break;
                                        case 'U':
                                            str += this.parseCharCode(i + 1, 8, errors);
                                            i += 8;
                                            break;
                                        case '\n':
                                            // skip escaped newlines, but still trim the following line
                                            while (src[i + 1] === ' ' || src[i + 1] === '\t') {
                                                i += 1;
                                            }
                                            break;
                                        default:
                                            errors.push(new _errors.YAMLSyntaxError(this, "Invalid escape sequence ".concat(src.substr(i - 1, 2))));
                                            str += '\\' + src[i];
                                    }
                                }
                                else if (ch === ' ' || ch === '\t') {
                                    // trim trailing whitespace
                                    var wsStart = i;
                                    var next = src[i + 1];
                                    while (next === ' ' || next === '\t') {
                                        i += 1;
                                        next = src[i + 1];
                                    }
                                    if (next !== '\n')
                                        str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
                                }
                                else {
                                    str += ch;
                                }
                            }
                            return errors.length > 0 ? {
                                errors: errors,
                                str: str
                            } : str;
                        }
                    }], [{
                        key: "endOfQuote",
                        value: function endOfQuote(src, offset) {
                            var ch = src[offset];
                            while (ch && ch !== '"') {
                                offset += ch === '\\' ? 2 : 1;
                                ch = src[offset];
                            }
                            return offset + 1;
                        }
                    }]);
                return QuoteDouble;
            }(_Node2.default);
            exports.default = QuoteDouble;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/cst/QuoteSingle.js": 
        /*!***********************************************************!*\
          !*** ./node_modules/yaml/browser/dist/cst/QuoteSingle.js ***!
          \***********************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));
            var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));
            var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));
            var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));
            var _errors = __webpack_require__(/*! ../errors */ "./node_modules/yaml/browser/dist/errors.js");
            var _Node2 = _interopRequireDefault(__webpack_require__(/*! ./Node */ "./node_modules/yaml/browser/dist/cst/Node.js"));
            var _Range = _interopRequireDefault(__webpack_require__(/*! ./Range */ "./node_modules/yaml/browser/dist/cst/Range.js"));
            var QuoteSingle = 
            /*#__PURE__*/
            function (_Node) {
                (0, _inherits2.default)(QuoteSingle, _Node);
                function QuoteSingle() {
                    (0, _classCallCheck2.default)(this, QuoteSingle);
                    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(QuoteSingle).apply(this, arguments));
                }
                (0, _createClass2.default)(QuoteSingle, [{
                        key: "parse",
                        /**
                         * Parses a 'single quoted' value from the source
                         *
                         * @param {ParseContext} context
                         * @param {number} start - Index of first character
                         * @returns {number} - Index of the character after this scalar
                         */
                        value: function parse(context, start) {
                            this.context = context;
                            var src = context.src;
                            var offset = QuoteSingle.endOfQuote(src, start + 1);
                            this.valueRange = new _Range.default(start, offset);
                            offset = _Node2.default.endOfWhiteSpace(src, offset);
                            offset = this.parseComment(offset);
                            return offset;
                        }
                    }, {
                        key: "strValue",
                        /**
                         * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
                         */
                        get: function get() {
                            if (!this.valueRange || !this.context)
                                return null;
                            var errors = [];
                            var _this$valueRange = this.valueRange, start = _this$valueRange.start, end = _this$valueRange.end;
                            var _this$context = this.context, indent = _this$context.indent, src = _this$context.src;
                            if (src[end - 1] !== "'")
                                errors.push(new _errors.YAMLSyntaxError(this, "Missing closing 'quote"));
                            var str = '';
                            for (var i = start + 1; i < end - 1; ++i) {
                                var ch = src[i];
                                if (ch === '\n') {
                                    if (_Node2.default.atDocumentBoundary(src, i + 1))
                                        errors.push(new _errors.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));
                                    var _Node$foldNewline = _Node2.default.foldNewline(src, i, indent), fold = _Node$foldNewline.fold, offset = _Node$foldNewline.offset, error = _Node$foldNewline.error;
                                    str += fold;
                                    i = offset;
                                    if (error)
                                        errors.push(new _errors.YAMLSemanticError(this, 'Multi-line single-quoted string needs to be sufficiently indented'));
                                }
                                else if (ch === "'") {
                                    str += ch;
                                    i += 1;
                                    if (src[i] !== "'")
                                        errors.push(new _errors.YAMLSyntaxError(this, 'Unescaped single quote? This should not happen.'));
                                }
                                else if (ch === ' ' || ch === '\t') {
                                    // trim trailing whitespace
                                    var wsStart = i;
                                    var next = src[i + 1];
                                    while (next === ' ' || next === '\t') {
                                        i += 1;
                                        next = src[i + 1];
                                    }
                                    if (next !== '\n')
                                        str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
                                }
                                else {
                                    str += ch;
                                }
                            }
                            return errors.length > 0 ? {
                                errors: errors,
                                str: str
                            } : str;
                        }
                    }], [{
                        key: "endOfQuote",
                        value: function endOfQuote(src, offset) {
                            var ch = src[offset];
                            while (ch) {
                                if (ch === "'") {
                                    if (src[offset + 1] !== "'")
                                        break;
                                    ch = src[offset += 2];
                                }
                                else {
                                    ch = src[offset += 1];
                                }
                            }
                            return offset + 1;
                        }
                    }]);
                return QuoteSingle;
            }(_Node2.default);
            exports.default = QuoteSingle;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/cst/Range.js": 
        /*!*****************************************************!*\
          !*** ./node_modules/yaml/browser/dist/cst/Range.js ***!
          \*****************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));
            var Range = 
            /*#__PURE__*/
            function () {
                (0, _createClass2.default)(Range, null, [{
                        key: "copy",
                        value: function copy(orig) {
                            return new Range(orig.start, orig.end);
                        }
                    }]);
                function Range(start, end) {
                    (0, _classCallCheck2.default)(this, Range);
                    this.start = start;
                    this.end = end || start;
                }
                (0, _createClass2.default)(Range, [{
                        key: "isEmpty",
                        value: function isEmpty() {
                            return typeof this.start !== 'number' || !this.end || this.end <= this.start;
                        }
                        /**
                         * Set `origStart` and `origEnd` to point to the original source range for
                         * this node, which may differ due to dropped CR characters.
                         *
                         * @param {number[]} cr - Positions of dropped CR characters
                         * @param {number} offset - Starting index of `cr` from the last call
                         * @returns {number} - The next offset, matching the one found for `origStart`
                         */
                    }, {
                        key: "setOrigRange",
                        value: function setOrigRange(cr, offset) {
                            var start = this.start, end = this.end;
                            if (cr.length === 0 || end <= cr[0]) {
                                this.origStart = start;
                                this.origEnd = end;
                                return offset;
                            }
                            var i = offset;
                            while (i < cr.length) {
                                if (cr[i] > start)
                                    break;
                                else
                                    ++i;
                            }
                            this.origStart = start + i;
                            var nextOffset = i;
                            while (i < cr.length) {
                                // if end was at \n, it should now be at \r
                                if (cr[i] >= end)
                                    break;
                                else
                                    ++i;
                            }
                            this.origEnd = end + i;
                            return nextOffset;
                        }
                    }]);
                return Range;
            }();
            exports.default = Range;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/cst/parse.js": 
        /*!*****************************************************!*\
          !*** ./node_modules/yaml/browser/dist/cst/parse.js ***!
          \*****************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = parse;
            var _Document = _interopRequireDefault(__webpack_require__(/*! ./Document */ "./node_modules/yaml/browser/dist/cst/Document.js"));
            var _ParseContext = _interopRequireDefault(__webpack_require__(/*! ./ParseContext */ "./node_modules/yaml/browser/dist/cst/ParseContext.js"));
            // Published as 'yaml/parse-cst'
            function parse(src) {
                var cr = [];
                if (src.indexOf('\r') !== -1) {
                    src = src.replace(/\r\n?/g, function (match, offset) {
                        if (match.length > 1)
                            cr.push(offset);
                        return '\n';
                    });
                }
                var documents = [];
                var offset = 0;
                do {
                    var doc = new _Document.default();
                    var context = new _ParseContext.default({
                        src: src
                    });
                    offset = doc.parse(context, offset);
                    documents.push(doc);
                } while (offset < src.length);
                documents.setOrigRanges = function () {
                    if (cr.length === 0)
                        return false;
                    for (var i = 1; i < cr.length; ++i) {
                        cr[i] -= i;
                    }
                    var crOffset = 0;
                    for (var _i = 0; _i < documents.length; ++_i) {
                        crOffset = documents[_i].setOrigRanges(cr, crOffset);
                    }
                    cr.splice(0, cr.length);
                    return true;
                };
                documents.toString = function () {
                    return documents.join('...\n');
                };
                return documents;
            }
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/cst/source-utils.js": 
        /*!************************************************************!*\
          !*** ./node_modules/yaml/browser/dist/cst/source-utils.js ***!
          \************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.getLinePos = getLinePos;
            exports.getLine = getLine;
            exports.getPrettyContext = getPrettyContext;
            function findLineStarts(src) {
                var ls = [0];
                var offset = src.indexOf('\n');
                while (offset !== -1) {
                    offset += 1;
                    ls.push(offset);
                    offset = src.indexOf('\n', offset);
                }
                return ls;
            }
            function getSrcInfo(cst) {
                var lineStarts, src;
                if (typeof cst === 'string') {
                    lineStarts = findLineStarts(cst);
                    src = cst;
                }
                else {
                    if (Array.isArray(cst))
                        cst = cst[0];
                    if (cst && cst.context) {
                        if (!cst.lineStarts)
                            cst.lineStarts = findLineStarts(cst.context.src);
                        lineStarts = cst.lineStarts;
                        src = cst.context.src;
                    }
                }
                return {
                    lineStarts: lineStarts,
                    src: src
                };
            }
            /**
             * @typedef {Object} LinePos - One-indexed position in the source
             * @property {number} line
             * @property {number} col
             */
            /**
             * Determine the line/col position matching a character offset.
             *
             * Accepts a source string or a CST document as the second parameter. With
             * the latter, starting indices for lines are cached in the document as
             * `lineStarts: number[]`.
             *
             * Returns a one-indexed `{ line, col }` location if found, or
             * `undefined` otherwise.
             *
             * @param {number} offset
             * @param {string|Document|Document[]} cst
             * @returns {?LinePos}
             */
            function getLinePos(offset, cst) {
                if (typeof offset !== 'number' || offset < 0)
                    return null;
                var _getSrcInfo = getSrcInfo(cst), lineStarts = _getSrcInfo.lineStarts, src = _getSrcInfo.src;
                if (!lineStarts || !src || offset > src.length)
                    return null;
                for (var i = 0; i < lineStarts.length; ++i) {
                    var start = lineStarts[i];
                    if (offset < start) {
                        return {
                            line: i,
                            col: offset - lineStarts[i - 1] + 1
                        };
                    }
                    if (offset === start)
                        return {
                            line: i + 1,
                            col: 1
                        };
                }
                var line = lineStarts.length;
                return {
                    line: line,
                    col: offset - lineStarts[line - 1] + 1
                };
            }
            /**
             * Get a specified line from the source.
             *
             * Accepts a source string or a CST document as the second parameter. With
             * the latter, starting indices for lines are cached in the document as
             * `lineStarts: number[]`.
             *
             * Returns the line as a string if found, or `null` otherwise.
             *
             * @param {number} line One-indexed line number
             * @param {string|Document|Document[]} cst
             * @returns {?string}
             */
            function getLine(line, cst) {
                var _getSrcInfo2 = getSrcInfo(cst), lineStarts = _getSrcInfo2.lineStarts, src = _getSrcInfo2.src;
                if (!lineStarts || !(line >= 1) || line > lineStarts.length)
                    return null;
                var start = lineStarts[line - 1];
                var end = lineStarts[line]; // undefined for last line; that's ok for slice()
                while (end && end > start && src[end - 1] === '\n') {
                    --end;
                }
                return src.slice(start, end);
            }
            /**
             * Pretty-print the starting line from the source indicated by the range `pos`
             *
             * Trims output to `maxWidth` chars while keeping the starting column visible,
             * using `…` at either end to indicate dropped characters.
             *
             * Returns a two-line string (or `null`) with `\n` as separator; the second line
             * will hold appropriately indented `^` marks indicating the column range.
             *
             * @param {Object} pos
             * @param {LinePos} pos.start
             * @param {LinePos} [pos.end]
             * @param {string|Document|Document[]*} cst
             * @param {number} [maxWidth=80]
             * @returns {?string}
             */
            function getPrettyContext(_ref, cst) {
                var start = _ref.start, end = _ref.end;
                var maxWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 80;
                var src = getLine(start.line, cst);
                if (!src)
                    return null;
                var col = start.col;
                if (src.length > maxWidth) {
                    if (col <= maxWidth - 10) {
                        src = src.substr(0, maxWidth - 1) + '…';
                    }
                    else {
                        var halfWidth = Math.round(maxWidth / 2);
                        if (src.length > col + halfWidth)
                            src = src.substr(0, col + halfWidth - 1) + '…';
                        col -= src.length - maxWidth;
                        src = '…' + src.substr(1 - maxWidth);
                    }
                }
                var errLen = 1;
                var errEnd = '';
                if (end) {
                    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {
                        errLen = end.col - start.col;
                    }
                    else {
                        errLen = Math.min(src.length + 1, maxWidth) - col;
                        errEnd = '…';
                    }
                }
                var offset = col > 1 ? ' '.repeat(col - 1) : '';
                var err = '^'.repeat(errLen);
                return "".concat(src, "\n").concat(offset).concat(err).concat(errEnd);
            }
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/errors.js": 
        /*!**************************************************!*\
          !*** ./node_modules/yaml/browser/dist/errors.js ***!
          \**************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.YAMLWarning = exports.YAMLSyntaxError = exports.YAMLSemanticError = exports.YAMLReferenceError = exports.YAMLError = void 0;
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));
            var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));
            var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));
            var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));
            var _wrapNativeSuper2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/wrapNativeSuper */ "./node_modules/@babel/runtime/helpers/wrapNativeSuper.js"));
            var _Node = _interopRequireDefault(__webpack_require__(/*! ./cst/Node */ "./node_modules/yaml/browser/dist/cst/Node.js"));
            var _sourceUtils = __webpack_require__(/*! ./cst/source-utils */ "./node_modules/yaml/browser/dist/cst/source-utils.js");
            var _Range = _interopRequireDefault(__webpack_require__(/*! ./cst/Range */ "./node_modules/yaml/browser/dist/cst/Range.js"));
            var YAMLError = 
            /*#__PURE__*/
            function (_Error) {
                (0, _inherits2.default)(YAMLError, _Error);
                function YAMLError(name, source, message) {
                    var _this;
                    (0, _classCallCheck2.default)(this, YAMLError);
                    if (!message || !(source instanceof _Node.default))
                        throw new Error("Invalid arguments for new ".concat(name));
                    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(YAMLError).call(this));
                    _this.name = name;
                    _this.message = message;
                    _this.source = source;
                    return _this;
                }
                (0, _createClass2.default)(YAMLError, [{
                        key: "makePretty",
                        value: function makePretty() {
                            if (!this.source)
                                return;
                            this.nodeType = this.source.type;
                            var cst = this.source.context && this.source.context.root;
                            if (typeof this.offset === 'number') {
                                this.range = new _Range.default(this.offset, this.offset + 1);
                                var start = cst && (0, _sourceUtils.getLinePos)(this.offset, cst);
                                if (start) {
                                    var end = {
                                        line: start.line,
                                        col: start.col + 1
                                    };
                                    this.linePos = {
                                        start: start,
                                        end: end
                                    };
                                }
                                delete this.offset;
                            }
                            else {
                                this.range = this.source.range;
                                this.linePos = this.source.rangeAsLinePos;
                            }
                            if (this.linePos) {
                                var _this$linePos$start = this.linePos.start, line = _this$linePos$start.line, col = _this$linePos$start.col;
                                this.message += " at line ".concat(line, ", column ").concat(col);
                                var ctx = cst && (0, _sourceUtils.getPrettyContext)(this.linePos, cst);
                                if (ctx)
                                    this.message += ":\n\n".concat(ctx, "\n");
                            }
                            delete this.source;
                        }
                    }]);
                return YAMLError;
            }((0, _wrapNativeSuper2.default)(Error));
            exports.YAMLError = YAMLError;
            var YAMLReferenceError = 
            /*#__PURE__*/
            function (_YAMLError) {
                (0, _inherits2.default)(YAMLReferenceError, _YAMLError);
                function YAMLReferenceError(source, message) {
                    (0, _classCallCheck2.default)(this, YAMLReferenceError);
                    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(YAMLReferenceError).call(this, 'YAMLReferenceError', source, message));
                }
                return YAMLReferenceError;
            }(YAMLError);
            exports.YAMLReferenceError = YAMLReferenceError;
            var YAMLSemanticError = 
            /*#__PURE__*/
            function (_YAMLError2) {
                (0, _inherits2.default)(YAMLSemanticError, _YAMLError2);
                function YAMLSemanticError(source, message) {
                    (0, _classCallCheck2.default)(this, YAMLSemanticError);
                    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(YAMLSemanticError).call(this, 'YAMLSemanticError', source, message));
                }
                return YAMLSemanticError;
            }(YAMLError);
            exports.YAMLSemanticError = YAMLSemanticError;
            var YAMLSyntaxError = 
            /*#__PURE__*/
            function (_YAMLError3) {
                (0, _inherits2.default)(YAMLSyntaxError, _YAMLError3);
                function YAMLSyntaxError(source, message) {
                    (0, _classCallCheck2.default)(this, YAMLSyntaxError);
                    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(YAMLSyntaxError).call(this, 'YAMLSyntaxError', source, message));
                }
                return YAMLSyntaxError;
            }(YAMLError);
            exports.YAMLSyntaxError = YAMLSyntaxError;
            var YAMLWarning = 
            /*#__PURE__*/
            function (_YAMLError4) {
                (0, _inherits2.default)(YAMLWarning, _YAMLError4);
                function YAMLWarning(source, message) {
                    (0, _classCallCheck2.default)(this, YAMLWarning);
                    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(YAMLWarning).call(this, 'YAMLWarning', source, message));
                }
                return YAMLWarning;
            }(YAMLError);
            exports.YAMLWarning = YAMLWarning;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/foldFlowLines.js": 
        /*!*********************************************************!*\
          !*** ./node_modules/yaml/browser/dist/foldFlowLines.js ***!
          \*********************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = foldFlowLines;
            exports.FOLD_QUOTED = exports.FOLD_BLOCK = exports.FOLD_FLOW = void 0;
            var FOLD_FLOW = 'flow';
            exports.FOLD_FLOW = FOLD_FLOW;
            var FOLD_BLOCK = 'block';
            exports.FOLD_BLOCK = FOLD_BLOCK;
            var FOLD_QUOTED = 'quoted'; // presumes i+1 is at the start of a line
            // returns index of last newline in more-indented block
            exports.FOLD_QUOTED = FOLD_QUOTED;
            var consumeMoreIndentedLines = function consumeMoreIndentedLines(text, i) {
                var ch = text[i + 1];
                while (ch === ' ' || ch === '\t') {
                    do {
                        ch = text[i += 1];
                    } while (ch && ch !== '\n');
                    ch = text[i + 1];
                }
                return i;
            };
            /**
             * Tries to keep input at up to `lineWidth` characters, splitting only on spaces
             * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
             * terminated with `\n` and started with `indent`.
             *
             * @param {string} text
             * @param {string} indent
             * @param {string} [mode='flow'] `'block'` prevents more-indented lines
             *   from being folded; `'quoted'` allows for `\` escapes, including escaped
             *   newlines
             * @param {Object} options
             * @param {number} [options.indentAtStart] Accounts for leading contents on
             *   the first line, defaulting to `indent.length`
             * @param {number} [options.lineWidth=80]
             * @param {number} [options.minContentWidth=20] Allow highly indented lines to
             *   stretch the line width
             * @param {function} options.onFold Called once if the text is folded
             * @param {function} options.onFold Called once if any line of text exceeds
             *   lineWidth characters
             */
            function foldFlowLines(text, indent, mode, _ref) {
                var indentAtStart = _ref.indentAtStart, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 80 : _ref$lineWidth, _ref$minContentWidth = _ref.minContentWidth, minContentWidth = _ref$minContentWidth === void 0 ? 20 : _ref$minContentWidth, onFold = _ref.onFold, onOverflow = _ref.onOverflow;
                if (!lineWidth || lineWidth < 0)
                    return text;
                var endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
                if (text.length <= endStep)
                    return text;
                var folds = [];
                var escapedFolds = {};
                var end = lineWidth - (typeof indentAtStart === 'number' ? indentAtStart : indent.length);
                var split = undefined;
                var prev = undefined;
                var overflow = false;
                var i = -1;
                if (mode === FOLD_BLOCK) {
                    i = consumeMoreIndentedLines(text, i);
                    if (i !== -1)
                        end = i + endStep;
                }
                for (var ch; ch = text[i += 1];) {
                    if (mode === FOLD_QUOTED && ch === '\\') {
                        switch (text[i + 1]) {
                            case 'x':
                                i += 3;
                                break;
                            case 'u':
                                i += 5;
                                break;
                            case 'U':
                                i += 9;
                                break;
                            default:
                                i += 1;
                        }
                    }
                    if (ch === '\n') {
                        if (mode === FOLD_BLOCK)
                            i = consumeMoreIndentedLines(text, i);
                        end = i + endStep;
                        split = undefined;
                    }
                    else {
                        if (ch === ' ' && prev && prev !== ' ' && prev !== '\n' && prev !== '\t') {
                            // space surrounded by non-space can be replaced with newline + indent
                            var next = text[i + 1];
                            if (next && next !== ' ' && next !== '\n' && next !== '\t')
                                split = i;
                        }
                        if (i >= end) {
                            if (split) {
                                folds.push(split);
                                end = split + endStep;
                                split = undefined;
                            }
                            else if (mode === FOLD_QUOTED) {
                                // white-space collected at end may stretch past lineWidth
                                while (prev === ' ' || prev === '\t') {
                                    prev = ch;
                                    ch = text[i += 1];
                                    overflow = true;
                                } // i - 2 accounts for not-dropped last char + newline-escaping \
                                folds.push(i - 2);
                                escapedFolds[i - 2] = true;
                                end = i - 2 + endStep;
                                split = undefined;
                            }
                            else {
                                overflow = true;
                            }
                        }
                    }
                    prev = ch;
                }
                if (overflow && onOverflow)
                    onOverflow();
                if (folds.length === 0)
                    return text;
                if (onFold)
                    onFold();
                var res = text.slice(0, folds[0]);
                for (var _i = 0; _i < folds.length; ++_i) {
                    var fold = folds[_i];
                    var _end = folds[_i + 1] || text.length;
                    if (mode === FOLD_QUOTED && escapedFolds[fold])
                        res += "".concat(text[fold], "\\");
                    res += "\n".concat(indent).concat(text.slice(fold + 1, _end));
                }
                return res;
            }
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/index.js": 
        /*!*************************************************!*\
          !*** ./node_modules/yaml/browser/dist/index.js ***!
          \*************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));
            var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));
            var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));
            var _parse = _interopRequireDefault(__webpack_require__(/*! ./cst/parse */ "./node_modules/yaml/browser/dist/cst/parse.js"));
            var _Document = _interopRequireDefault(__webpack_require__(/*! ./Document */ "./node_modules/yaml/browser/dist/Document.js"));
            var _errors = __webpack_require__(/*! ./errors */ "./node_modules/yaml/browser/dist/errors.js");
            var _schema = _interopRequireDefault(__webpack_require__(/*! ./schema */ "./node_modules/yaml/browser/dist/schema/index.js"));
            var _warnings = __webpack_require__(/*! ./warnings */ "./node_modules/yaml/browser/dist/warnings.js");
            var defaultOptions = {
                anchorPrefix: 'a',
                customTags: null,
                keepCstNodes: false,
                keepNodeTypes: true,
                keepBlobsInJSON: true,
                mapAsMap: false,
                maxAliasCount: 100,
                prettyErrors: false,
                // TODO Set true in v2
                simpleKeys: false,
                version: '1.2'
            };
            function createNode(value) {
                var wrapScalars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
                var tag = arguments.length > 2 ? arguments[2] : undefined;
                if (tag === undefined && typeof wrapScalars === 'string') {
                    tag = wrapScalars;
                    wrapScalars = true;
                }
                var options = Object.assign({}, _Document.default.defaults[defaultOptions.version], defaultOptions);
                var schema = new _schema.default(options);
                return schema.createNode(value, wrapScalars, tag);
            }
            var Document = 
            /*#__PURE__*/
            function (_YAMLDocument) {
                (0, _inherits2.default)(Document, _YAMLDocument);
                function Document(options) {
                    (0, _classCallCheck2.default)(this, Document);
                    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Document).call(this, Object.assign({}, defaultOptions, options)));
                }
                return Document;
            }(_Document.default);
            function parseAllDocuments(src, options) {
                var stream = [];
                var prev;
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;
                try {
                    for (var _iterator = (0, _parse.default)(src)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var cstDoc = _step.value;
                        var doc = new Document(options);
                        doc.parse(cstDoc, prev);
                        stream.push(doc);
                        prev = doc;
                    }
                }
                catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                }
                finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    }
                    finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return stream;
            }
            function parseDocument(src, options) {
                var cst = (0, _parse.default)(src);
                var doc = new Document(options).parse(cst[0]);
                if (cst.length > 1) {
                    var errMsg = 'Source contains multiple documents; please use YAML.parseAllDocuments()';
                    doc.errors.unshift(new _errors.YAMLSemanticError(cst[1], errMsg));
                }
                return doc;
            }
            function parse(src, options) {
                var doc = parseDocument(src, options);
                doc.warnings.forEach(function (warning) {
                    return (0, _warnings.warn)(warning);
                });
                if (doc.errors.length > 0)
                    throw doc.errors[0];
                return doc.toJSON();
            }
            function stringify(value, options) {
                var doc = new Document(options);
                doc.contents = value;
                return String(doc);
            }
            var _default = {
                createNode: createNode,
                defaultOptions: defaultOptions,
                Document: Document,
                parse: parse,
                parseAllDocuments: parseAllDocuments,
                parseCST: _parse.default,
                parseDocument: parseDocument,
                stringify: stringify
            };
            exports.default = _default;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/listTagNames.js": 
        /*!********************************************************!*\
          !*** ./node_modules/yaml/browser/dist/listTagNames.js ***!
          \********************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js"));
            var _Collection = _interopRequireDefault(__webpack_require__(/*! ./schema/Collection */ "./node_modules/yaml/browser/dist/schema/Collection.js"));
            var _Pair = _interopRequireDefault(__webpack_require__(/*! ./schema/Pair */ "./node_modules/yaml/browser/dist/schema/Pair.js"));
            var _Scalar = _interopRequireDefault(__webpack_require__(/*! ./schema/Scalar */ "./node_modules/yaml/browser/dist/schema/Scalar.js"));
            var visit = function visit(node, tags) {
                if (node && (0, _typeof2.default)(node) === 'object') {
                    var tag = node.tag;
                    if (node instanceof _Collection.default) {
                        if (tag)
                            tags[tag] = true;
                        node.items.forEach(function (n) {
                            return visit(n, tags);
                        });
                    }
                    else if (node instanceof _Pair.default) {
                        visit(node.key, tags);
                        visit(node.value, tags);
                    }
                    else if (node instanceof _Scalar.default) {
                        if (tag)
                            tags[tag] = true;
                    }
                }
                return tags;
            };
            var _default = function _default(node) {
                return Object.keys(visit(node, {}));
            };
            exports.default = _default;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/schema/Alias.js": 
        /*!********************************************************!*\
          !*** ./node_modules/yaml/browser/dist/schema/Alias.js ***!
          \********************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));
            var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));
            var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));
            var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));
            var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));
            var _constants = __webpack_require__(/*! ../constants */ "./node_modules/yaml/browser/dist/constants.js");
            var _errors = __webpack_require__(/*! ../errors */ "./node_modules/yaml/browser/dist/errors.js");
            var _toJSON2 = _interopRequireDefault(__webpack_require__(/*! ../toJSON */ "./node_modules/yaml/browser/dist/toJSON.js"));
            var _Collection = _interopRequireDefault(__webpack_require__(/*! ./Collection */ "./node_modules/yaml/browser/dist/schema/Collection.js"));
            var _Node2 = _interopRequireDefault(__webpack_require__(/*! ./Node */ "./node_modules/yaml/browser/dist/schema/Node.js"));
            var _Pair = _interopRequireDefault(__webpack_require__(/*! ./Pair */ "./node_modules/yaml/browser/dist/schema/Pair.js"));
            var getAliasCount = function getAliasCount(node, anchors) {
                if (node instanceof Alias) {
                    var anchor = anchors.find(function (a) {
                        return a.node === node.source;
                    });
                    return anchor.count * anchor.aliasCount;
                }
                else if (node instanceof _Collection.default) {
                    var count = 0;
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;
                    try {
                        for (var _iterator = node.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var item = _step.value;
                            var c = getAliasCount(item, anchors);
                            if (c > count)
                                count = c;
                        }
                    }
                    catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    }
                    finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        }
                        finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                    return count;
                }
                else if (node instanceof _Pair.default) {
                    var kc = getAliasCount(node.key, anchors);
                    var vc = getAliasCount(node.value, anchors);
                    return Math.max(kc, vc);
                }
                return 1;
            };
            var Alias = 
            /*#__PURE__*/
            function (_Node) {
                (0, _inherits2.default)(Alias, _Node);
                (0, _createClass2.default)(Alias, null, [{
                        key: "stringify",
                        value: function stringify(_ref, _ref2) {
                            var range = _ref.range, source = _ref.source;
                            var anchors = _ref2.anchors, doc = _ref2.doc, implicitKey = _ref2.implicitKey, inStringifyKey = _ref2.inStringifyKey;
                            var anchor = Object.keys(anchors).find(function (a) {
                                return anchors[a] === source;
                            });
                            if (!anchor && inStringifyKey)
                                anchor = doc.anchors.getName(source) || doc.anchors.newName();
                            if (anchor)
                                return "*".concat(anchor).concat(implicitKey ? ' ' : '');
                            var msg = doc.anchors.getName(source) ? 'Alias node must be after source node' : 'Source node not found for alias node';
                            throw new Error("".concat(msg, " [").concat(range, "]"));
                        }
                    }]);
                function Alias(source) {
                    var _this;
                    (0, _classCallCheck2.default)(this, Alias);
                    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Alias).call(this));
                    _this.source = source;
                    _this.type = _constants.Type.ALIAS;
                    return _this;
                }
                (0, _createClass2.default)(Alias, [{
                        key: "toJSON",
                        value: function toJSON(arg, ctx) {
                            var _this2 = this;
                            if (!ctx)
                                return (0, _toJSON2.default)(this.source, arg, ctx);
                            var anchors = ctx.anchors, maxAliasCount = ctx.maxAliasCount;
                            var anchor = anchors.find(function (a) {
                                return a.node === _this2.source;
                            });
                            if (!anchor || anchor.res === undefined) {
                                var msg = 'This should not happen: Alias anchor was not resolved?';
                                if (this.cstNode)
                                    throw new _errors.YAMLReferenceError(this.cstNode, msg);
                                else
                                    throw new ReferenceError(msg);
                            }
                            if (maxAliasCount >= 0) {
                                anchor.count += 1;
                                if (anchor.aliasCount === 0)
                                    anchor.aliasCount = getAliasCount(this.source, anchors);
                                if (anchor.count * anchor.aliasCount > maxAliasCount) {
                                    var _msg = 'Excessive alias count indicates a resource exhaustion attack';
                                    if (this.cstNode)
                                        throw new _errors.YAMLReferenceError(this.cstNode, _msg);
                                    else
                                        throw new ReferenceError(_msg);
                                }
                            }
                            return anchor.res;
                        } // Only called when stringifying an alias mapping key while constructing
                        // Object output.
                    }, {
                        key: "toString",
                        value: function toString(ctx) {
                            return Alias.stringify(this, ctx);
                        }
                    }, {
                        key: "tag",
                        set: function set(t) {
                            throw new Error('Alias nodes cannot have tags');
                        }
                    }]);
                return Alias;
            }(_Node2.default);
            exports.default = Alias;
            (0, _defineProperty2.default)(Alias, "default", true);
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/schema/Collection.js": 
        /*!*************************************************************!*\
          !*** ./node_modules/yaml/browser/dist/schema/Collection.js ***!
          \*************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = exports.isEmptyPath = void 0;
            var _toArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/toArray */ "./node_modules/@babel/runtime/helpers/toArray.js"));
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));
            var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));
            var _getPrototypeOf3 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));
            var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js"));
            var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));
            var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));
            var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js"));
            var _addComment = _interopRequireDefault(__webpack_require__(/*! ../addComment */ "./node_modules/yaml/browser/dist/addComment.js"));
            var _Node2 = _interopRequireDefault(__webpack_require__(/*! ./Node */ "./node_modules/yaml/browser/dist/schema/Node.js"));
            var _Pair = _interopRequireDefault(__webpack_require__(/*! ./Pair */ "./node_modules/yaml/browser/dist/schema/Pair.js"));
            var _Scalar = _interopRequireDefault(__webpack_require__(/*! ./Scalar */ "./node_modules/yaml/browser/dist/schema/Scalar.js"));
            // null, undefined, or an empty non-string iterable (e.g. [])
            var isEmptyPath = function isEmptyPath(path) {
                return path == null || (0, _typeof2.default)(path) === 'object' && path[Symbol.iterator]().next().done;
            };
            exports.isEmptyPath = isEmptyPath;
            var Collection = 
            /*#__PURE__*/
            function (_Node) {
                (0, _inherits2.default)(Collection, _Node);
                function Collection() {
                    var _getPrototypeOf2;
                    var _this;
                    (0, _classCallCheck2.default)(this, Collection);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(Collection)).call.apply(_getPrototypeOf2, [this].concat(args)));
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "items", []);
                    return _this;
                }
                (0, _createClass2.default)(Collection, [{
                        key: "addIn",
                        value: function addIn(path, value) {
                            if (isEmptyPath(path))
                                this.add(value);
                            else {
                                var _path = (0, _toArray2.default)(path), key = _path[0], rest = _path.slice(1);
                                var node = this.get(key, true);
                                if (node instanceof Collection)
                                    node.addIn(rest, value);
                                else
                                    throw new Error("Expected YAML collection at ".concat(key, ". Remaining path: ").concat(rest));
                            }
                        }
                    }, {
                        key: "deleteIn",
                        value: function deleteIn(_ref) {
                            var _ref2 = (0, _toArray2.default)(_ref), key = _ref2[0], rest = _ref2.slice(1);
                            if (rest.length === 0)
                                return this.delete(key);
                            var node = this.get(key, true);
                            if (node instanceof Collection)
                                return node.deleteIn(rest);
                            else
                                throw new Error("Expected YAML collection at ".concat(key, ". Remaining path: ").concat(rest));
                        }
                    }, {
                        key: "getIn",
                        value: function getIn(_ref3, keepScalar) {
                            var _ref4 = (0, _toArray2.default)(_ref3), key = _ref4[0], rest = _ref4.slice(1);
                            var node = this.get(key, true);
                            if (rest.length === 0)
                                return !keepScalar && node instanceof _Scalar.default ? node.value : node;
                            else
                                return node instanceof Collection ? node.getIn(rest, keepScalar) : undefined;
                        }
                    }, {
                        key: "hasAllNullValues",
                        value: function hasAllNullValues() {
                            return this.items.every(function (node) {
                                if (!(node instanceof _Pair.default))
                                    return false;
                                var n = node.value;
                                return n == null || n instanceof _Scalar.default && n.value == null && !n.commentBefore && !n.comment && !n.tag;
                            });
                        }
                    }, {
                        key: "hasIn",
                        value: function hasIn(_ref5) {
                            var _ref6 = (0, _toArray2.default)(_ref5), key = _ref6[0], rest = _ref6.slice(1);
                            if (rest.length === 0)
                                return this.has(key);
                            var node = this.get(key, true);
                            return node instanceof Collection ? node.hasIn(rest) : false;
                        }
                    }, {
                        key: "setIn",
                        value: function setIn(_ref7, value) {
                            var _ref8 = (0, _toArray2.default)(_ref7), key = _ref8[0], rest = _ref8.slice(1);
                            if (rest.length === 0) {
                                this.set(key, value);
                            }
                            else {
                                var node = this.get(key, true);
                                if (node instanceof Collection)
                                    node.setIn(rest, value);
                                else
                                    throw new Error("Expected YAML collection at ".concat(key, ". Remaining path: ").concat(rest));
                            }
                        } // overridden in implementations
                    }, {
                        key: "toJSON",
                        value: function toJSON() {
                            return null;
                        }
                    }, {
                        key: "toString",
                        value: function toString(ctx, _ref9, onComment, onChompKeep) {
                            var _this2 = this;
                            var blockItem = _ref9.blockItem, flowChars = _ref9.flowChars, isMap = _ref9.isMap, itemIndent = _ref9.itemIndent;
                            var _ctx = ctx, doc = _ctx.doc, indent = _ctx.indent;
                            var inFlow = this.type && this.type.substr(0, 4) === 'FLOW' || ctx.inFlow;
                            if (inFlow)
                                itemIndent += '  ';
                            var allNullValues = isMap && this.hasAllNullValues();
                            ctx = Object.assign({}, ctx, {
                                allNullValues: allNullValues,
                                indent: itemIndent,
                                inFlow: inFlow,
                                type: null
                            });
                            var chompKeep = false;
                            var hasItemWithNewLine = false;
                            var nodes = this.items.reduce(function (nodes, item, i) {
                                var comment;
                                if (item) {
                                    if (!chompKeep && item.spaceBefore)
                                        nodes.push({
                                            type: 'comment',
                                            str: ''
                                        });
                                    if (item.commentBefore)
                                        item.commentBefore.match(/^.*$/gm).forEach(function (line) {
                                            nodes.push({
                                                type: 'comment',
                                                str: "#".concat(line)
                                            });
                                        });
                                    if (item.comment)
                                        comment = item.comment;
                                    if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment)))
                                        hasItemWithNewLine = true;
                                }
                                chompKeep = false;
                                var str = doc.schema.stringify(item, ctx, function () {
                                    return comment = null;
                                }, function () {
                                    return chompKeep = true;
                                });
                                if (inFlow && !hasItemWithNewLine && str.includes('\n'))
                                    hasItemWithNewLine = true;
                                if (inFlow && i < _this2.items.length - 1)
                                    str += ',';
                                str = (0, _addComment.default)(str, itemIndent, comment);
                                if (chompKeep && (comment || inFlow))
                                    chompKeep = false;
                                nodes.push({
                                    type: 'item',
                                    str: str
                                });
                                return nodes;
                            }, []);
                            var str;
                            if (nodes.length === 0) {
                                str = flowChars.start + flowChars.end;
                            }
                            else if (inFlow) {
                                var start = flowChars.start, end = flowChars.end;
                                var strings = nodes.map(function (n) {
                                    return n.str;
                                });
                                if (hasItemWithNewLine || strings.reduce(function (sum, str) {
                                    return sum + str.length + 2;
                                }, 2) > Collection.maxFlowStringSingleLineLength) {
                                    str = start;
                                    var _iteratorNormalCompletion = true;
                                    var _didIteratorError = false;
                                    var _iteratorError = undefined;
                                    try {
                                        for (var _iterator = strings[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                            var s = _step.value;
                                            str += s ? "\n  ".concat(indent).concat(s) : '\n';
                                        }
                                    }
                                    catch (err) {
                                        _didIteratorError = true;
                                        _iteratorError = err;
                                    }
                                    finally {
                                        try {
                                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                                _iterator.return();
                                            }
                                        }
                                        finally {
                                            if (_didIteratorError) {
                                                throw _iteratorError;
                                            }
                                        }
                                    }
                                    str += "\n".concat(indent).concat(end);
                                }
                                else {
                                    str = "".concat(start, " ").concat(strings.join(' '), " ").concat(end);
                                }
                            }
                            else {
                                var _strings = nodes.map(blockItem);
                                str = _strings.shift();
                                var _iteratorNormalCompletion2 = true;
                                var _didIteratorError2 = false;
                                var _iteratorError2 = undefined;
                                try {
                                    for (var _iterator2 = _strings[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                        var _s = _step2.value;
                                        str += _s ? "\n".concat(indent).concat(_s) : '\n';
                                    }
                                }
                                catch (err) {
                                    _didIteratorError2 = true;
                                    _iteratorError2 = err;
                                }
                                finally {
                                    try {
                                        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                                            _iterator2.return();
                                        }
                                    }
                                    finally {
                                        if (_didIteratorError2) {
                                            throw _iteratorError2;
                                        }
                                    }
                                }
                            }
                            if (this.comment) {
                                str += '\n' + this.comment.replace(/^/gm, "".concat(indent, "#"));
                                if (onComment)
                                    onComment();
                            }
                            else if (chompKeep && onChompKeep)
                                onChompKeep();
                            return str;
                        }
                    }]);
                return Collection;
            }(_Node2.default);
            exports.default = Collection;
            (0, _defineProperty2.default)(Collection, "maxFlowStringSingleLineLength", 60);
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/schema/Map.js": 
        /*!******************************************************!*\
          !*** ./node_modules/yaml/browser/dist/schema/Map.js ***!
          \******************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.findPair = findPair;
            exports.default = void 0;
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));
            var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));
            var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));
            var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js"));
            var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));
            var _Collection2 = _interopRequireDefault(__webpack_require__(/*! ./Collection */ "./node_modules/yaml/browser/dist/schema/Collection.js"));
            var _Pair = _interopRequireDefault(__webpack_require__(/*! ./Pair */ "./node_modules/yaml/browser/dist/schema/Pair.js"));
            var _Scalar = _interopRequireDefault(__webpack_require__(/*! ./Scalar */ "./node_modules/yaml/browser/dist/schema/Scalar.js"));
            function findPair(items, key) {
                var k = key instanceof _Scalar.default ? key.value : key;
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;
                try {
                    for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var it = _step.value;
                        if (it instanceof _Pair.default) {
                            if (it.key === key || it.key === k)
                                return it;
                            if (it.key && it.key.value === k)
                                return it;
                        }
                    }
                }
                catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                }
                finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    }
                    finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return undefined;
            }
            var YAMLMap = 
            /*#__PURE__*/
            function (_Collection) {
                (0, _inherits2.default)(YAMLMap, _Collection);
                function YAMLMap() {
                    (0, _classCallCheck2.default)(this, YAMLMap);
                    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(YAMLMap).apply(this, arguments));
                }
                (0, _createClass2.default)(YAMLMap, [{
                        key: "add",
                        value: function add(pair) {
                            if (!pair)
                                pair = new _Pair.default(pair);
                            else if (!(pair instanceof _Pair.default))
                                pair = new _Pair.default(pair.key || pair, pair.value);
                            var prev = findPair(this.items, pair.key);
                            if (prev)
                                throw new Error("Key ".concat(pair.key, " already set"));
                            this.items.push(pair);
                        }
                    }, {
                        key: "delete",
                        value: function _delete(key) {
                            var it = findPair(this.items, key);
                            if (!it)
                                return false;
                            var del = this.items.splice(this.items.indexOf(it), 1);
                            return del.length > 0;
                        }
                    }, {
                        key: "get",
                        value: function get(key, keepScalar) {
                            var it = findPair(this.items, key);
                            var node = it && it.value;
                            return !keepScalar && node instanceof _Scalar.default ? node.value : node;
                        }
                    }, {
                        key: "has",
                        value: function has(key) {
                            return !!findPair(this.items, key);
                        }
                    }, {
                        key: "set",
                        value: function set(key, value) {
                            var prev = findPair(this.items, key);
                            if (prev)
                                prev.value = value;
                            else
                                this.items.push(new _Pair.default(key, value));
                        }
                        /**
                         * @param {*} arg ignored
                         * @param {*} ctx Conversion context, originally set in Document#toJSON()
                         * @param {Class} Type If set, forces the returned collection type
                         * @returns {*} Instance of Type, Map, or Object
                         */
                    }, {
                        key: "toJSON",
                        value: function toJSON(_, ctx, Type) {
                            var map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};
                            if (ctx && ctx.onCreate)
                                ctx.onCreate(map);
                            var _iteratorNormalCompletion2 = true;
                            var _didIteratorError2 = false;
                            var _iteratorError2 = undefined;
                            try {
                                for (var _iterator2 = this.items[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                    var item = _step2.value;
                                    item.addToJSMap(ctx, map);
                                }
                            }
                            catch (err) {
                                _didIteratorError2 = true;
                                _iteratorError2 = err;
                            }
                            finally {
                                try {
                                    if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                                        _iterator2.return();
                                    }
                                }
                                finally {
                                    if (_didIteratorError2) {
                                        throw _iteratorError2;
                                    }
                                }
                            }
                            return map;
                        }
                    }, {
                        key: "toString",
                        value: function toString(ctx, onComment, onChompKeep) {
                            if (!ctx)
                                return JSON.stringify(this);
                            var _iteratorNormalCompletion3 = true;
                            var _didIteratorError3 = false;
                            var _iteratorError3 = undefined;
                            try {
                                for (var _iterator3 = this.items[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                                    var item = _step3.value;
                                    if (!(item instanceof _Pair.default))
                                        throw new Error("Map items must all be pairs; found ".concat(JSON.stringify(item), " instead"));
                                }
                            }
                            catch (err) {
                                _didIteratorError3 = true;
                                _iteratorError3 = err;
                            }
                            finally {
                                try {
                                    if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                                        _iterator3.return();
                                    }
                                }
                                finally {
                                    if (_didIteratorError3) {
                                        throw _iteratorError3;
                                    }
                                }
                            }
                            return (0, _get2.default)((0, _getPrototypeOf2.default)(YAMLMap.prototype), "toString", this).call(this, ctx, {
                                blockItem: function blockItem(n) {
                                    return n.str;
                                },
                                flowChars: {
                                    start: '{',
                                    end: '}'
                                },
                                isMap: true,
                                itemIndent: ctx.indent || ''
                            }, onComment, onChompKeep);
                        }
                    }]);
                return YAMLMap;
            }(_Collection2.default);
            exports.default = YAMLMap;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/schema/Merge.js": 
        /*!********************************************************!*\
          !*** ./node_modules/yaml/browser/dist/schema/Merge.js ***!
          \********************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = exports.MERGE_KEY = void 0;
            var _slicedToArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js"));
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));
            var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));
            var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));
            var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js"));
            var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));
            var _Map = _interopRequireDefault(__webpack_require__(/*! ./Map */ "./node_modules/yaml/browser/dist/schema/Map.js"));
            var _Pair2 = _interopRequireDefault(__webpack_require__(/*! ./Pair */ "./node_modules/yaml/browser/dist/schema/Pair.js"));
            var _Scalar = _interopRequireDefault(__webpack_require__(/*! ./Scalar */ "./node_modules/yaml/browser/dist/schema/Scalar.js"));
            var _Seq = _interopRequireDefault(__webpack_require__(/*! ./Seq */ "./node_modules/yaml/browser/dist/schema/Seq.js"));
            var MERGE_KEY = '<<';
            exports.MERGE_KEY = MERGE_KEY;
            var Merge = 
            /*#__PURE__*/
            function (_Pair) {
                (0, _inherits2.default)(Merge, _Pair);
                function Merge(pair) {
                    var _this;
                    (0, _classCallCheck2.default)(this, Merge);
                    if (pair instanceof _Pair2.default) {
                        var seq = pair.value;
                        if (!(seq instanceof _Seq.default)) {
                            seq = new _Seq.default();
                            seq.items.push(pair.value);
                            seq.range = pair.value.range;
                        }
                        _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Merge).call(this, pair.key, seq));
                        _this.range = pair.range;
                    }
                    else {
                        _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Merge).call(this, new _Scalar.default(MERGE_KEY), new _Seq.default()));
                    }
                    _this.type = 'MERGE_PAIR';
                    return (0, _possibleConstructorReturn2.default)(_this);
                } // If the value associated with a merge key is a single mapping node, each of
                // its key/value pairs is inserted into the current mapping, unless the key
                // already exists in it. If the value associated with the merge key is a
                // sequence, then this sequence is expected to contain mapping nodes and each
                // of these nodes is merged in turn according to its order in the sequence.
                // Keys in mapping nodes earlier in the sequence override keys specified in
                // later mapping nodes. -- http://yaml.org/type/merge.html
                (0, _createClass2.default)(Merge, [{
                        key: "addToJSMap",
                        value: function addToJSMap(ctx, map) {
                            var _iteratorNormalCompletion = true;
                            var _didIteratorError = false;
                            var _iteratorError = undefined;
                            try {
                                for (var _iterator = this.value.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                    var source = _step.value.source;
                                    if (!(source instanceof _Map.default))
                                        throw new Error('Merge sources must be maps');
                                    var srcMap = source.toJSON(null, ctx, Map);
                                    var _iteratorNormalCompletion2 = true;
                                    var _didIteratorError2 = false;
                                    var _iteratorError2 = undefined;
                                    try {
                                        for (var _iterator2 = srcMap[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                            var _step2$value = (0, _slicedToArray2.default)(_step2.value, 2), key = _step2$value[0], value = _step2$value[1];
                                            if (map instanceof Map) {
                                                if (!map.has(key))
                                                    map.set(key, value);
                                            }
                                            else if (map instanceof Set) {
                                                map.add(key);
                                            }
                                            else {
                                                if (!Object.prototype.hasOwnProperty.call(map, key))
                                                    map[key] = value;
                                            }
                                        }
                                    }
                                    catch (err) {
                                        _didIteratorError2 = true;
                                        _iteratorError2 = err;
                                    }
                                    finally {
                                        try {
                                            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                                                _iterator2.return();
                                            }
                                        }
                                        finally {
                                            if (_didIteratorError2) {
                                                throw _iteratorError2;
                                            }
                                        }
                                    }
                                }
                            }
                            catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            }
                            finally {
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                                        _iterator.return();
                                    }
                                }
                                finally {
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                            return map;
                        }
                    }, {
                        key: "toString",
                        value: function toString(ctx, onComment) {
                            var seq = this.value;
                            if (seq.items.length > 1)
                                return (0, _get2.default)((0, _getPrototypeOf2.default)(Merge.prototype), "toString", this).call(this, ctx, onComment);
                            this.value = seq.items[0];
                            var str = (0, _get2.default)((0, _getPrototypeOf2.default)(Merge.prototype), "toString", this).call(this, ctx, onComment);
                            this.value = seq;
                            return str;
                        }
                    }]);
                return Merge;
            }(_Pair2.default);
            exports.default = Merge;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/schema/Node.js": 
        /*!*******************************************************!*\
          !*** ./node_modules/yaml/browser/dist/schema/Node.js ***!
          \*******************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var Node = function Node() {
                (0, _classCallCheck2.default)(this, Node);
            };
            exports.default = Node;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/schema/Pair.js": 
        /*!*******************************************************!*\
          !*** ./node_modules/yaml/browser/dist/schema/Pair.js ***!
          \*******************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));
            var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));
            var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));
            var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));
            var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js"));
            var _addComment = _interopRequireDefault(__webpack_require__(/*! ../addComment */ "./node_modules/yaml/browser/dist/addComment.js"));
            var _constants = __webpack_require__(/*! ../constants */ "./node_modules/yaml/browser/dist/constants.js");
            var _toJSON = _interopRequireDefault(__webpack_require__(/*! ../toJSON */ "./node_modules/yaml/browser/dist/toJSON.js"));
            var _Collection = _interopRequireDefault(__webpack_require__(/*! ./Collection */ "./node_modules/yaml/browser/dist/schema/Collection.js"));
            var _Node2 = _interopRequireDefault(__webpack_require__(/*! ./Node */ "./node_modules/yaml/browser/dist/schema/Node.js"));
            var _Scalar = _interopRequireDefault(__webpack_require__(/*! ./Scalar */ "./node_modules/yaml/browser/dist/schema/Scalar.js"));
            // Published as 'yaml/pair'
            var stringifyKey = function stringifyKey(key, jsKey, ctx) {
                if (jsKey === null)
                    return '';
                if ((0, _typeof2.default)(jsKey) !== 'object')
                    return String(jsKey);
                if (key instanceof _Node2.default && ctx && ctx.doc)
                    return key.toString({
                        anchors: {},
                        doc: ctx.doc,
                        indent: '',
                        inFlow: true,
                        inStringifyKey: true
                    });
                return JSON.stringify(jsKey);
            };
            var Pair = 
            /*#__PURE__*/
            function (_Node) {
                (0, _inherits2.default)(Pair, _Node);
                function Pair(key) {
                    var _this;
                    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                    (0, _classCallCheck2.default)(this, Pair);
                    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Pair).call(this));
                    _this.key = key;
                    _this.value = value;
                    _this.type = 'PAIR';
                    return _this;
                }
                (0, _createClass2.default)(Pair, [{
                        key: "addToJSMap",
                        value: function addToJSMap(ctx, map) {
                            var key = (0, _toJSON.default)(this.key, '', ctx);
                            if (map instanceof Map) {
                                var value = (0, _toJSON.default)(this.value, key, ctx);
                                map.set(key, value);
                            }
                            else if (map instanceof Set) {
                                map.add(key);
                            }
                            else {
                                var stringKey = stringifyKey(this.key, key, ctx);
                                map[stringKey] = (0, _toJSON.default)(this.value, stringKey, ctx);
                            }
                            return map;
                        }
                    }, {
                        key: "toJSON",
                        value: function toJSON(_, ctx) {
                            var pair = ctx && ctx.mapAsMap ? new Map() : {};
                            return this.addToJSMap(ctx, pair);
                        }
                    }, {
                        key: "toString",
                        value: function toString(ctx, onComment, onChompKeep) {
                            if (!ctx || !ctx.doc)
                                return JSON.stringify(this);
                            var simpleKeys = ctx.doc.options.simpleKeys;
                            var key = this.key, value = this.value;
                            var keyComment = key instanceof _Node2.default && key.comment;
                            if (simpleKeys) {
                                if (keyComment) {
                                    throw new Error('With simple keys, key nodes cannot have comments');
                                }
                                if (key instanceof _Collection.default) {
                                    var msg = 'With simple keys, collection cannot be used as a key value';
                                    throw new Error(msg);
                                }
                            }
                            var explicitKey = !simpleKeys && (!key || keyComment || key instanceof _Collection.default || key.type === _constants.Type.BLOCK_FOLDED || key.type === _constants.Type.BLOCK_LITERAL);
                            var _ctx = ctx, doc = _ctx.doc, indent = _ctx.indent;
                            ctx = Object.assign({}, ctx, {
                                implicitKey: !explicitKey,
                                indent: indent + '  '
                            });
                            var chompKeep = false;
                            var str = doc.schema.stringify(key, ctx, function () {
                                return keyComment = null;
                            }, function () {
                                return chompKeep = true;
                            });
                            str = (0, _addComment.default)(str, ctx.indent, keyComment);
                            if (ctx.allNullValues && !simpleKeys) {
                                if (this.comment) {
                                    str = (0, _addComment.default)(str, ctx.indent, this.comment);
                                    if (onComment)
                                        onComment();
                                }
                                else if (chompKeep && !keyComment && onChompKeep)
                                    onChompKeep();
                                return ctx.inFlow ? str : "? ".concat(str);
                            }
                            str = explicitKey ? "? ".concat(str, "\n").concat(indent, ":") : "".concat(str, ":");
                            if (this.comment) {
                                // expected (but not strictly required) to be a single-line comment
                                str = (0, _addComment.default)(str, ctx.indent, this.comment);
                                if (onComment)
                                    onComment();
                            }
                            var vcb = '';
                            var valueComment = null;
                            if (value instanceof _Node2.default) {
                                if (value.spaceBefore)
                                    vcb = '\n';
                                if (value.commentBefore) {
                                    var cs = value.commentBefore.replace(/^/gm, "".concat(ctx.indent, "#"));
                                    vcb += "\n".concat(cs);
                                }
                                valueComment = value.comment;
                            }
                            else if (value && (0, _typeof2.default)(value) === 'object') {
                                value = doc.schema.createNode(value, true);
                            }
                            ctx.implicitKey = false;
                            chompKeep = false;
                            var valueStr = doc.schema.stringify(value, ctx, function () {
                                return valueComment = null;
                            }, function () {
                                return chompKeep = true;
                            });
                            var ws = ' ';
                            if (vcb || this.comment) {
                                ws = "".concat(vcb, "\n").concat(ctx.indent);
                            }
                            else if (!explicitKey && value instanceof _Collection.default) {
                                var flow = valueStr[0] === '[' || valueStr[0] === '{';
                                if (!flow || valueStr.includes('\n'))
                                    ws = "\n".concat(ctx.indent);
                            }
                            if (chompKeep && !valueComment && onChompKeep)
                                onChompKeep();
                            return (0, _addComment.default)(str + ws + valueStr, ctx.indent, valueComment);
                        }
                    }, {
                        key: "commentBefore",
                        get: function get() {
                            return this.key && this.key.commentBefore;
                        },
                        set: function set(cb) {
                            if (this.key == null)
                                this.key = new _Scalar.default(null);
                            this.key.commentBefore = cb;
                        }
                    }]);
                return Pair;
            }(_Node2.default);
            exports.default = Pair;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/schema/Scalar.js": 
        /*!*********************************************************!*\
          !*** ./node_modules/yaml/browser/dist/schema/Scalar.js ***!
          \*********************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));
            var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));
            var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));
            var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));
            var _toJSON2 = _interopRequireDefault(__webpack_require__(/*! ../toJSON */ "./node_modules/yaml/browser/dist/toJSON.js"));
            var _Node2 = _interopRequireDefault(__webpack_require__(/*! ./Node */ "./node_modules/yaml/browser/dist/schema/Node.js"));
            // Published as 'yaml/scalar'
            var Scalar = 
            /*#__PURE__*/
            function (_Node) {
                (0, _inherits2.default)(Scalar, _Node);
                function Scalar(value) {
                    var _this;
                    (0, _classCallCheck2.default)(this, Scalar);
                    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Scalar).call(this));
                    _this.value = value;
                    return _this;
                }
                (0, _createClass2.default)(Scalar, [{
                        key: "toJSON",
                        value: function toJSON(arg, ctx) {
                            return ctx && ctx.keep ? this.value : (0, _toJSON2.default)(this.value, arg, ctx);
                        }
                    }, {
                        key: "toString",
                        value: function toString() {
                            return String(this.value);
                        }
                    }]);
                return Scalar;
            }(_Node2.default);
            exports.default = Scalar;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/schema/Seq.js": 
        /*!******************************************************!*\
          !*** ./node_modules/yaml/browser/dist/schema/Seq.js ***!
          \******************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));
            var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));
            var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));
            var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js"));
            var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));
            var _toJSON2 = _interopRequireDefault(__webpack_require__(/*! ../toJSON */ "./node_modules/yaml/browser/dist/toJSON.js"));
            var _Collection2 = _interopRequireDefault(__webpack_require__(/*! ./Collection */ "./node_modules/yaml/browser/dist/schema/Collection.js"));
            var _Scalar = _interopRequireDefault(__webpack_require__(/*! ./Scalar */ "./node_modules/yaml/browser/dist/schema/Scalar.js"));
            // Published as 'yaml/seq'
            function asItemIndex(key) {
                var idx = key instanceof _Scalar.default ? key.value : key;
                if (idx && typeof idx === 'string')
                    idx = Number(idx);
                return Number.isInteger(idx) && idx >= 0 ? idx : null;
            }
            var YAMLSeq = 
            /*#__PURE__*/
            function (_Collection) {
                (0, _inherits2.default)(YAMLSeq, _Collection);
                function YAMLSeq() {
                    (0, _classCallCheck2.default)(this, YAMLSeq);
                    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(YAMLSeq).apply(this, arguments));
                }
                (0, _createClass2.default)(YAMLSeq, [{
                        key: "add",
                        value: function add(value) {
                            this.items.push(value);
                        }
                    }, {
                        key: "delete",
                        value: function _delete(key) {
                            var idx = asItemIndex(key);
                            if (typeof idx !== 'number')
                                return false;
                            var del = this.items.splice(idx, 1);
                            return del.length > 0;
                        }
                    }, {
                        key: "get",
                        value: function get(key, keepScalar) {
                            var idx = asItemIndex(key);
                            if (typeof idx !== 'number')
                                return undefined;
                            var it = this.items[idx];
                            return !keepScalar && it instanceof _Scalar.default ? it.value : it;
                        }
                    }, {
                        key: "has",
                        value: function has(key) {
                            var idx = asItemIndex(key);
                            return typeof idx === 'number' && idx < this.items.length;
                        }
                    }, {
                        key: "set",
                        value: function set(key, value) {
                            var idx = asItemIndex(key);
                            if (typeof idx !== 'number')
                                throw new Error("Expected a valid index, not ".concat(key, "."));
                            this.items[idx] = value;
                        }
                    }, {
                        key: "toJSON",
                        value: function toJSON(_, ctx) {
                            var seq = [];
                            if (ctx && ctx.onCreate)
                                ctx.onCreate(seq);
                            var i = 0;
                            var _iteratorNormalCompletion = true;
                            var _didIteratorError = false;
                            var _iteratorError = undefined;
                            try {
                                for (var _iterator = this.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                    var item = _step.value;
                                    seq.push((0, _toJSON2.default)(item, String(i++), ctx));
                                }
                            }
                            catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            }
                            finally {
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                                        _iterator.return();
                                    }
                                }
                                finally {
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                            return seq;
                        }
                    }, {
                        key: "toString",
                        value: function toString(ctx, onComment, onChompKeep) {
                            if (!ctx)
                                return JSON.stringify(this);
                            return (0, _get2.default)((0, _getPrototypeOf2.default)(YAMLSeq.prototype), "toString", this).call(this, ctx, {
                                blockItem: function blockItem(n) {
                                    return n.type === 'comment' ? n.str : "- ".concat(n.str);
                                },
                                flowChars: {
                                    start: '[',
                                    end: ']'
                                },
                                isMap: false,
                                itemIndent: (ctx.indent || '') + '  '
                            }, onComment, onChompKeep);
                        }
                    }]);
                return YAMLSeq;
            }(_Collection2.default);
            exports.default = YAMLSeq;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/schema/index.js": 
        /*!********************************************************!*\
          !*** ./node_modules/yaml/browser/dist/schema/index.js ***!
          \********************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js"));
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));
            var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));
            var _warnings = __webpack_require__(/*! ../warnings */ "./node_modules/yaml/browser/dist/warnings.js");
            var _constants = __webpack_require__(/*! ../constants */ "./node_modules/yaml/browser/dist/constants.js");
            var _errors = __webpack_require__(/*! ../errors */ "./node_modules/yaml/browser/dist/errors.js");
            var _stringify = __webpack_require__(/*! ../stringify */ "./node_modules/yaml/browser/dist/stringify.js");
            var _tags = __webpack_require__(/*! ../tags */ "./node_modules/yaml/browser/dist/tags/index.js");
            var _string = __webpack_require__(/*! ../tags/failsafe/string */ "./node_modules/yaml/browser/dist/tags/failsafe/string.js");
            var _Alias = _interopRequireDefault(__webpack_require__(/*! ./Alias */ "./node_modules/yaml/browser/dist/schema/Alias.js"));
            var _Collection = _interopRequireDefault(__webpack_require__(/*! ./Collection */ "./node_modules/yaml/browser/dist/schema/Collection.js"));
            var _Node = _interopRequireDefault(__webpack_require__(/*! ./Node */ "./node_modules/yaml/browser/dist/schema/Node.js"));
            var _Pair = _interopRequireDefault(__webpack_require__(/*! ./Pair */ "./node_modules/yaml/browser/dist/schema/Pair.js"));
            var _Scalar = _interopRequireDefault(__webpack_require__(/*! ./Scalar */ "./node_modules/yaml/browser/dist/schema/Scalar.js"));
            var isMap = function isMap(_ref) {
                var type = _ref.type;
                return type === _constants.Type.FLOW_MAP || type === _constants.Type.MAP;
            };
            var isSeq = function isSeq(_ref2) {
                var type = _ref2.type;
                return type === _constants.Type.FLOW_SEQ || type === _constants.Type.SEQ;
            };
            var Schema = 
            /*#__PURE__*/
            function () {
                function Schema(_ref3) {
                    var customTags = _ref3.customTags, merge = _ref3.merge, schema = _ref3.schema, deprecatedCustomTags = _ref3.tags;
                    (0, _classCallCheck2.default)(this, Schema);
                    this.merge = !!merge;
                    this.name = schema;
                    this.tags = _tags.schemas[schema.replace(/\W/g, '')]; // 'yaml-1.1' -> 'yaml11'
                    if (!this.tags) {
                        var keys = Object.keys(_tags.schemas).map(function (key) {
                            return JSON.stringify(key);
                        }).join(', ');
                        throw new Error("Unknown schema \"".concat(schema, "\"; use one of ").concat(keys));
                    }
                    if (!customTags && deprecatedCustomTags) {
                        customTags = deprecatedCustomTags;
                        (0, _warnings.warnOptionDeprecation)('tags', 'customTags');
                    }
                    if (Array.isArray(customTags)) {
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;
                        try {
                            for (var _iterator = customTags[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var tag = _step.value;
                                this.tags = this.tags.concat(tag);
                            }
                        }
                        catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        }
                        finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            }
                            finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                    }
                    else if (typeof customTags === 'function') {
                        this.tags = customTags(this.tags.slice());
                    }
                    for (var i = 0; i < this.tags.length; ++i) {
                        var _tag = this.tags[i];
                        if (typeof _tag === 'string') {
                            var tagObj = _tags.tags[_tag];
                            if (!tagObj) {
                                var _keys = Object.keys(_tags.tags).map(function (key) {
                                    return JSON.stringify(key);
                                }).join(', ');
                                throw new Error("Unknown custom tag \"".concat(_tag, "\"; use one of ").concat(_keys));
                            }
                            this.tags[i] = tagObj;
                        }
                    }
                }
                (0, _createClass2.default)(Schema, [{
                        key: "createNode",
                        value: function createNode(value, wrapScalars, tag, ctx) {
                            if (value instanceof _Node.default)
                                return value;
                            var tagObj;
                            if (tag) {
                                if (tag.startsWith('!!'))
                                    tag = Schema.defaultPrefix + tag.slice(2);
                                var match = this.tags.filter(function (t) {
                                    return t.tag === tag;
                                });
                                tagObj = match.find(function (t) {
                                    return !t.format;
                                }) || match[0];
                                if (!tagObj)
                                    throw new Error("Tag ".concat(tag, " not found"));
                            }
                            else {
                                // TODO: deprecate/remove class check
                                tagObj = this.tags.find(function (t) {
                                    return (t.identify && t.identify(value) || t.class && value instanceof t.class) && !t.format;
                                });
                                if (!tagObj) {
                                    if (typeof value.toJSON === 'function')
                                        value = value.toJSON();
                                    if ((0, _typeof2.default)(value) !== 'object')
                                        return wrapScalars ? new _Scalar.default(value) : value;
                                    tagObj = value instanceof Map ? _tags.tags.map : value[Symbol.iterator] ? _tags.tags.seq : _tags.tags.map;
                                }
                            }
                            if (!ctx)
                                ctx = {
                                    wrapScalars: wrapScalars
                                };
                            else
                                ctx.wrapScalars = wrapScalars;
                            if (ctx.onTagObj) {
                                ctx.onTagObj(tagObj);
                                delete ctx.onTagObj;
                            }
                            var obj = {};
                            if (value && (0, _typeof2.default)(value) === 'object' && ctx.prevObjects) {
                                var prev = ctx.prevObjects.find(function (o) {
                                    return o.value === value;
                                });
                                if (prev) {
                                    var alias = new _Alias.default(prev); // leaves source dirty; must be cleaned by caller
                                    ctx.aliasNodes.push(alias);
                                    return alias;
                                }
                                obj.value = value;
                                ctx.prevObjects.push(obj);
                            }
                            obj.node = tagObj.createNode ? tagObj.createNode(this, value, ctx) : wrapScalars ? new _Scalar.default(value) : value;
                            return obj.node;
                        }
                    }, {
                        key: "createPair",
                        value: function createPair(key, value, ctx) {
                            var k = this.createNode(key, ctx.wrapScalars, null, ctx);
                            var v = this.createNode(value, ctx.wrapScalars, null, ctx);
                            return new _Pair.default(k, v);
                        } // falls back to string on no match
                    }, {
                        key: "resolveScalar",
                        value: function resolveScalar(str, tags) {
                            if (!tags)
                                tags = this.tags;
                            for (var i = 0; i < tags.length; ++i) {
                                var _tags$i = tags[i], format = _tags$i.format, test = _tags$i.test, resolve = _tags$i.resolve;
                                if (test) {
                                    var match = str.match(test);
                                    if (match) {
                                        var res = resolve.apply(null, match);
                                        if (!(res instanceof _Scalar.default))
                                            res = new _Scalar.default(res);
                                        if (format)
                                            res.format = format;
                                        return res;
                                    }
                                }
                            }
                            if (this.tags.scalarFallback)
                                str = this.tags.scalarFallback(str);
                            return new _Scalar.default(str);
                        } // sets node.resolved on success
                    }, {
                        key: "resolveNode",
                        value: function resolveNode(doc, node, tagName) {
                            var tags = this.tags.filter(function (_ref4) {
                                var tag = _ref4.tag;
                                return tag === tagName;
                            });
                            var generic = tags.find(function (_ref5) {
                                var test = _ref5.test;
                                return !test;
                            });
                            if (node.error)
                                doc.errors.push(node.error);
                            try {
                                if (generic) {
                                    var res = generic.resolve(doc, node);
                                    if (!(res instanceof _Collection.default))
                                        res = new _Scalar.default(res);
                                    node.resolved = res;
                                }
                                else {
                                    var str = (0, _string.resolveString)(doc, node);
                                    if (typeof str === 'string' && tags.length > 0) {
                                        node.resolved = this.resolveScalar(str, tags);
                                    }
                                }
                            }
                            catch (error) {
                                if (!error.source)
                                    error.source = node;
                                doc.errors.push(error);
                                node.resolved = null;
                            }
                            if (!node.resolved)
                                return null;
                            if (tagName && node.tag)
                                node.resolved.tag = tagName;
                            return node.resolved;
                        }
                    }, {
                        key: "resolveNodeWithFallback",
                        value: function resolveNodeWithFallback(doc, node, tagName) {
                            var res = this.resolveNode(doc, node, tagName);
                            if (Object.prototype.hasOwnProperty.call(node, 'resolved'))
                                return res;
                            var fallback = isMap(node) ? Schema.defaultTags.MAP : isSeq(node) ? Schema.defaultTags.SEQ : Schema.defaultTags.STR;
                            if (fallback) {
                                doc.warnings.push(new _errors.YAMLWarning(node, "The tag ".concat(tagName, " is unavailable, falling back to ").concat(fallback)));
                                var _res = this.resolveNode(doc, node, fallback);
                                _res.tag = tagName;
                                return _res;
                            }
                            else {
                                doc.errors.push(new _errors.YAMLReferenceError(node, "The tag ".concat(tagName, " is unavailable")));
                            }
                            return null;
                        }
                    }, {
                        key: "getTagObject",
                        value: function getTagObject(item) {
                            if (item instanceof _Alias.default)
                                return _Alias.default;
                            if (item.tag) {
                                var match = this.tags.filter(function (t) {
                                    return t.tag === item.tag;
                                });
                                if (match.length > 0)
                                    return match.find(function (t) {
                                        return t.format === item.format;
                                    }) || match[0];
                            }
                            var tagObj, obj;
                            if (item instanceof _Scalar.default) {
                                obj = item.value; // TODO: deprecate/remove class check
                                var _match = this.tags.filter(function (t) {
                                    return t.identify && t.identify(obj) || t.class && obj instanceof t.class;
                                });
                                tagObj = _match.find(function (t) {
                                    return t.format === item.format;
                                }) || _match.find(function (t) {
                                    return !t.format;
                                });
                            }
                            else {
                                obj = item;
                                tagObj = this.tags.find(function (t) {
                                    return t.nodeClass && obj instanceof t.nodeClass;
                                });
                            }
                            if (!tagObj) {
                                var name = obj && obj.constructor ? obj.constructor.name : (0, _typeof2.default)(obj);
                                throw new Error("Tag not resolved for ".concat(name, " value"));
                            }
                            return tagObj;
                        } // needs to be called before stringifier to allow for circular anchor refs
                    }, {
                        key: "stringifyProps",
                        value: function stringifyProps(node, tagObj, _ref6) {
                            var anchors = _ref6.anchors, doc = _ref6.doc;
                            var props = [];
                            var anchor = doc.anchors.getName(node);
                            if (anchor) {
                                anchors[anchor] = node;
                                props.push("&".concat(anchor));
                            }
                            if (node.tag) {
                                props.push(doc.stringifyTag(node.tag));
                            }
                            else if (!tagObj.default) {
                                props.push(doc.stringifyTag(tagObj.tag));
                            }
                            return props.join(' ');
                        }
                    }, {
                        key: "stringify",
                        value: function stringify(item, ctx, onComment, onChompKeep) {
                            var tagObj;
                            if (!(item instanceof _Node.default)) {
                                var createCtx = {
                                    aliasNodes: [],
                                    onTagObj: function onTagObj(o) {
                                        return tagObj = o;
                                    },
                                    prevObjects: []
                                };
                                item = this.createNode(item, true, null, createCtx);
                                var anchors = ctx.doc.anchors;
                                var _iteratorNormalCompletion2 = true;
                                var _didIteratorError2 = false;
                                var _iteratorError2 = undefined;
                                try {
                                    for (var _iterator2 = createCtx.aliasNodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                        var alias = _step2.value;
                                        alias.source = alias.source.node;
                                        var name = anchors.getName(alias.source);
                                        if (!name) {
                                            name = anchors.newName();
                                            anchors.map[name] = alias.source;
                                        }
                                    }
                                }
                                catch (err) {
                                    _didIteratorError2 = true;
                                    _iteratorError2 = err;
                                }
                                finally {
                                    try {
                                        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                                            _iterator2.return();
                                        }
                                    }
                                    finally {
                                        if (_didIteratorError2) {
                                            throw _iteratorError2;
                                        }
                                    }
                                }
                            }
                            ctx.tags = this;
                            if (item instanceof _Pair.default)
                                return item.toString(ctx, onComment, onChompKeep);
                            if (!tagObj)
                                tagObj = this.getTagObject(item);
                            var props = this.stringifyProps(item, tagObj, ctx);
                            var str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof _Collection.default ? item.toString(ctx, onComment, onChompKeep) : (0, _stringify.stringifyString)(item, ctx, onComment, onChompKeep);
                            return props ? item instanceof _Collection.default && str[0] !== '{' && str[0] !== '[' ? "".concat(props, "\n").concat(ctx.indent).concat(str) : "".concat(props, " ").concat(str) : str;
                        }
                    }]);
                return Schema;
            }();
            exports.default = Schema;
            (0, _defineProperty2.default)(Schema, "defaultPrefix", 'tag:yaml.org,2002:');
            (0, _defineProperty2.default)(Schema, "defaultTags", {
                MAP: 'tag:yaml.org,2002:map',
                SEQ: 'tag:yaml.org,2002:seq',
                STR: 'tag:yaml.org,2002:str'
            });
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/schema/parseMap.js": 
        /*!***********************************************************!*\
          !*** ./node_modules/yaml/browser/dist/schema/parseMap.js ***!
          \***********************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = parseMap;
            var _constants = __webpack_require__(/*! ../constants */ "./node_modules/yaml/browser/dist/constants.js");
            var _PlainValue = _interopRequireDefault(__webpack_require__(/*! ../cst/PlainValue */ "./node_modules/yaml/browser/dist/cst/PlainValue.js"));
            var _errors = __webpack_require__(/*! ../errors */ "./node_modules/yaml/browser/dist/errors.js");
            var _Map = _interopRequireDefault(__webpack_require__(/*! ./Map */ "./node_modules/yaml/browser/dist/schema/Map.js"));
            var _Merge = _interopRequireWildcard(__webpack_require__(/*! ./Merge */ "./node_modules/yaml/browser/dist/schema/Merge.js"));
            var _Pair = _interopRequireDefault(__webpack_require__(/*! ./Pair */ "./node_modules/yaml/browser/dist/schema/Pair.js"));
            var _parseUtils = __webpack_require__(/*! ./parseUtils */ "./node_modules/yaml/browser/dist/schema/parseUtils.js");
            var _Alias = _interopRequireDefault(__webpack_require__(/*! ./Alias */ "./node_modules/yaml/browser/dist/schema/Alias.js"));
            var _Collection = _interopRequireDefault(__webpack_require__(/*! ./Collection */ "./node_modules/yaml/browser/dist/schema/Collection.js"));
            function parseMap(doc, cst) {
                if (cst.type !== _constants.Type.MAP && cst.type !== _constants.Type.FLOW_MAP) {
                    var msg = "A ".concat(cst.type, " node cannot be resolved as a mapping");
                    doc.errors.push(new _errors.YAMLSyntaxError(cst, msg));
                    return null;
                }
                var _ref = cst.type === _constants.Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst), comments = _ref.comments, items = _ref.items;
                var map = new _Map.default();
                map.items = items;
                (0, _parseUtils.resolveComments)(map, comments);
                var hasCollectionKey = false;
                for (var i = 0; i < items.length; ++i) {
                    var iKey = items[i].key;
                    if (iKey instanceof _Collection.default)
                        hasCollectionKey = true;
                    if (doc.schema.merge && iKey && iKey.value === _Merge.MERGE_KEY) {
                        items[i] = new _Merge.default(items[i]);
                        var sources = items[i].value.items;
                        var error = null;
                        sources.some(function (node) {
                            if (node instanceof _Alias.default) {
                                // During parsing, alias sources are CST nodes; to account for
                                // circular references their resolved values can't be used here.
                                var type = node.source.type;
                                if (type === _constants.Type.MAP || type === _constants.Type.FLOW_MAP)
                                    return false;
                                return error = 'Merge nodes aliases can only point to maps';
                            }
                            return error = 'Merge nodes can only have Alias nodes as values';
                        });
                        if (error)
                            doc.errors.push(new _errors.YAMLSemanticError(cst, error));
                    }
                    else {
                        for (var j = i + 1; j < items.length; ++j) {
                            var jKey = items[j].key;
                            if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, 'value') && iKey.value === jKey.value) {
                                var _msg = "Map keys must be unique; \"".concat(iKey, "\" is repeated");
                                doc.errors.push(new _errors.YAMLSemanticError(cst, _msg));
                                break;
                            }
                        }
                    }
                }
                if (hasCollectionKey && !doc.options.mapAsMap) {
                    var warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';
                    doc.warnings.push(new _errors.YAMLWarning(cst, warn));
                }
                cst.resolved = map;
                return map;
            }
            var valueHasPairComment = function valueHasPairComment(_ref2) {
                var _ref2$context = _ref2.context, lineStart = _ref2$context.lineStart, node = _ref2$context.node, src = _ref2$context.src, props = _ref2.props;
                if (props.length === 0)
                    return false;
                var start = props[0].start;
                if (node && start > node.valueRange.start)
                    return false;
                if (src[start] !== _constants.Char.COMMENT)
                    return false;
                for (var i = lineStart; i < start; ++i) {
                    if (src[i] === '\n')
                        return false;
                }
                return true;
            };
            function resolvePairComment(item, pair) {
                if (!valueHasPairComment(item))
                    return;
                var comment = item.getPropValue(0, _constants.Char.COMMENT, true);
                var found = false;
                var cb = pair.value.commentBefore;
                if (cb && cb.startsWith(comment)) {
                    pair.value.commentBefore = cb.substr(comment.length + 1);
                    found = true;
                }
                else {
                    var cc = pair.value.comment;
                    if (!item.node && cc && cc.startsWith(comment)) {
                        pair.value.comment = cc.substr(comment.length + 1);
                        found = true;
                    }
                }
                if (found)
                    pair.comment = comment;
            }
            function resolveBlockMapItems(doc, cst) {
                var comments = [];
                var items = [];
                var key = undefined;
                var keyStart = null;
                for (var i = 0; i < cst.items.length; ++i) {
                    var item = cst.items[i];
                    switch (item.type) {
                        case _constants.Type.BLANK_LINE:
                            comments.push({
                                afterKey: !!key,
                                before: items.length
                            });
                            break;
                        case _constants.Type.COMMENT:
                            comments.push({
                                afterKey: !!key,
                                before: items.length,
                                comment: item.comment
                            });
                            break;
                        case _constants.Type.MAP_KEY:
                            if (key !== undefined)
                                items.push(new _Pair.default(key));
                            if (item.error)
                                doc.errors.push(item.error);
                            key = doc.resolveNode(item.node);
                            keyStart = null;
                            break;
                        case _constants.Type.MAP_VALUE:
                            {
                                if (key === undefined)
                                    key = null;
                                if (item.error)
                                    doc.errors.push(item.error);
                                if (!item.context.atLineStart && item.node && item.node.type === _constants.Type.MAP && !item.node.context.atLineStart) {
                                    var msg = 'Nested mappings are not allowed in compact mappings';
                                    doc.errors.push(new _errors.YAMLSemanticError(item.node, msg));
                                }
                                var valueNode = item.node;
                                if (!valueNode && item.props.length > 0) {
                                    // Comments on an empty mapping value need to be preserved, so we
                                    // need to construct a minimal empty node here to use instead of the
                                    // missing `item.node`. -- eemeli/yaml#19
                                    valueNode = new _PlainValue.default(_constants.Type.PLAIN, []);
                                    valueNode.context = {
                                        parent: item,
                                        src: item.context.src
                                    };
                                    var pos = item.range.start + 1;
                                    valueNode.range = {
                                        start: pos,
                                        end: pos
                                    };
                                    valueNode.valueRange = {
                                        start: pos,
                                        end: pos
                                    };
                                    if (typeof item.range.origStart === 'number') {
                                        var origPos = item.range.origStart + 1;
                                        valueNode.range.origStart = valueNode.range.origEnd = origPos;
                                        valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;
                                    }
                                }
                                var pair = new _Pair.default(key, doc.resolveNode(valueNode));
                                resolvePairComment(item, pair);
                                items.push(pair);
                                (0, _parseUtils.checkKeyLength)(doc.errors, cst, i, key, keyStart);
                                key = undefined;
                                keyStart = null;
                            }
                            break;
                        default:
                            if (key !== undefined)
                                items.push(new _Pair.default(key));
                            key = doc.resolveNode(item);
                            keyStart = item.range.start;
                            if (item.error)
                                doc.errors.push(item.error);
                            next: for (var j = i + 1;; ++j) {
                                var nextItem = cst.items[j];
                                switch (nextItem && nextItem.type) {
                                    case _constants.Type.BLANK_LINE:
                                    case _constants.Type.COMMENT:
                                        continue next;
                                    case _constants.Type.MAP_VALUE:
                                        break next;
                                    default:
                                        doc.errors.push(new _errors.YAMLSemanticError(item, 'Implicit map keys need to be followed by map values'));
                                        break next;
                                }
                            }
                            if (item.valueRangeContainsNewline) {
                                var _msg2 = 'Implicit map keys need to be on a single line';
                                doc.errors.push(new _errors.YAMLSemanticError(item, _msg2));
                            }
                    }
                }
                if (key !== undefined)
                    items.push(new _Pair.default(key));
                return {
                    comments: comments,
                    items: items
                };
            }
            function resolveFlowMapItems(doc, cst) {
                var comments = [];
                var items = [];
                var key = undefined;
                var keyStart = null;
                var explicitKey = false;
                var next = '{';
                for (var i = 0; i < cst.items.length; ++i) {
                    (0, _parseUtils.checkKeyLength)(doc.errors, cst, i, key, keyStart);
                    var item = cst.items[i];
                    if (typeof item.char === 'string') {
                        var char = item.char, offset = item.offset;
                        if (char === '?' && key === undefined && !explicitKey) {
                            explicitKey = true;
                            next = ':';
                            continue;
                        }
                        if (char === ':') {
                            if (key === undefined)
                                key = null;
                            if (next === ':') {
                                next = ',';
                                continue;
                            }
                        }
                        else {
                            if (explicitKey) {
                                if (key === undefined && char !== ',')
                                    key = null;
                                explicitKey = false;
                            }
                            if (key !== undefined) {
                                items.push(new _Pair.default(key));
                                key = undefined;
                                keyStart = null;
                                if (char === ',') {
                                    next = ':';
                                    continue;
                                }
                            }
                        }
                        if (char === '}') {
                            if (i === cst.items.length - 1)
                                continue;
                        }
                        else if (char === next) {
                            next = ':';
                            continue;
                        }
                        var msg = "Flow map contains an unexpected ".concat(char);
                        var err = new _errors.YAMLSyntaxError(cst, msg);
                        err.offset = offset;
                        doc.errors.push(err);
                    }
                    else if (item.type === _constants.Type.BLANK_LINE) {
                        comments.push({
                            afterKey: !!key,
                            before: items.length
                        });
                    }
                    else if (item.type === _constants.Type.COMMENT) {
                        comments.push({
                            afterKey: !!key,
                            before: items.length,
                            comment: item.comment
                        });
                    }
                    else if (key === undefined) {
                        if (next === ',')
                            doc.errors.push(new _errors.YAMLSemanticError(item, 'Separator , missing in flow map'));
                        key = doc.resolveNode(item);
                        keyStart = explicitKey ? null : item.range.start; // TODO: add error for non-explicit multiline plain key
                    }
                    else {
                        if (next !== ',')
                            doc.errors.push(new _errors.YAMLSemanticError(item, 'Indicator : missing in flow map entry'));
                        items.push(new _Pair.default(key, doc.resolveNode(item)));
                        key = undefined;
                        explicitKey = false;
                    }
                }
                (0, _parseUtils.checkFlowCollectionEnd)(doc.errors, cst);
                if (key !== undefined)
                    items.push(new _Pair.default(key));
                return {
                    comments: comments,
                    items: items
                };
            }
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/schema/parseSeq.js": 
        /*!***********************************************************!*\
          !*** ./node_modules/yaml/browser/dist/schema/parseSeq.js ***!
          \***********************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = parseSeq;
            var _constants = __webpack_require__(/*! ../constants */ "./node_modules/yaml/browser/dist/constants.js");
            var _errors = __webpack_require__(/*! ../errors */ "./node_modules/yaml/browser/dist/errors.js");
            var _Pair = _interopRequireDefault(__webpack_require__(/*! ./Pair */ "./node_modules/yaml/browser/dist/schema/Pair.js"));
            var _parseUtils = __webpack_require__(/*! ./parseUtils */ "./node_modules/yaml/browser/dist/schema/parseUtils.js");
            var _Seq = _interopRequireDefault(__webpack_require__(/*! ./Seq */ "./node_modules/yaml/browser/dist/schema/Seq.js"));
            var _Collection = _interopRequireDefault(__webpack_require__(/*! ./Collection */ "./node_modules/yaml/browser/dist/schema/Collection.js"));
            function parseSeq(doc, cst) {
                if (cst.type !== _constants.Type.SEQ && cst.type !== _constants.Type.FLOW_SEQ) {
                    var msg = "A ".concat(cst.type, " node cannot be resolved as a sequence");
                    doc.errors.push(new _errors.YAMLSyntaxError(cst, msg));
                    return null;
                }
                var _ref = cst.type === _constants.Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst), comments = _ref.comments, items = _ref.items;
                var seq = new _Seq.default();
                seq.items = items;
                (0, _parseUtils.resolveComments)(seq, comments);
                if (!doc.options.mapAsMap && items.some(function (it) {
                    return it instanceof _Pair.default && it.key instanceof _Collection.default;
                })) {
                    var warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';
                    doc.warnings.push(new _errors.YAMLWarning(cst, warn));
                }
                cst.resolved = seq;
                return seq;
            }
            function resolveBlockSeqItems(doc, cst) {
                var comments = [];
                var items = [];
                for (var i = 0; i < cst.items.length; ++i) {
                    var item = cst.items[i];
                    switch (item.type) {
                        case _constants.Type.BLANK_LINE:
                            comments.push({
                                before: items.length
                            });
                            break;
                        case _constants.Type.COMMENT:
                            comments.push({
                                comment: item.comment,
                                before: items.length
                            });
                            break;
                        case _constants.Type.SEQ_ITEM:
                            if (item.error)
                                doc.errors.push(item.error);
                            items.push(doc.resolveNode(item.node));
                            if (item.hasProps) {
                                var msg = 'Sequence items cannot have tags or anchors before the - indicator';
                                doc.errors.push(new _errors.YAMLSemanticError(item, msg));
                            }
                            break;
                        default:
                            if (item.error)
                                doc.errors.push(item.error);
                            doc.errors.push(new _errors.YAMLSyntaxError(item, "Unexpected ".concat(item.type, " node in sequence")));
                    }
                }
                return {
                    comments: comments,
                    items: items
                };
            }
            function resolveFlowSeqItems(doc, cst) {
                var comments = [];
                var items = [];
                var explicitKey = false;
                var key = undefined;
                var keyStart = null;
                var next = '[';
                for (var i = 0; i < cst.items.length; ++i) {
                    var item = cst.items[i];
                    if (typeof item.char === 'string') {
                        var char = item.char, offset = item.offset;
                        if (char !== ':' && (explicitKey || key !== undefined)) {
                            if (explicitKey && key === undefined)
                                key = next ? items.pop() : null;
                            items.push(new _Pair.default(key));
                            explicitKey = false;
                            key = undefined;
                            keyStart = null;
                        }
                        if (char === next) {
                            next = null;
                        }
                        else if (!next && char === '?') {
                            explicitKey = true;
                        }
                        else if (next !== '[' && char === ':' && key === undefined) {
                            if (next === ',') {
                                key = items.pop();
                                if (key instanceof _Pair.default) {
                                    var msg = 'Chaining flow sequence pairs is invalid';
                                    var err = new _errors.YAMLSemanticError(cst, msg);
                                    err.offset = offset;
                                    doc.errors.push(err);
                                }
                                if (!explicitKey)
                                    (0, _parseUtils.checkKeyLength)(doc.errors, cst, i, key, keyStart);
                            }
                            else {
                                key = null;
                            }
                            keyStart = null;
                            explicitKey = false; // TODO: add error for non-explicit multiline plain key
                            next = null;
                        }
                        else if (next === '[' || char !== ']' || i < cst.items.length - 1) {
                            var _msg = "Flow sequence contains an unexpected ".concat(char);
                            var _err = new _errors.YAMLSyntaxError(cst, _msg);
                            _err.offset = offset;
                            doc.errors.push(_err);
                        }
                    }
                    else if (item.type === _constants.Type.BLANK_LINE) {
                        comments.push({
                            before: items.length
                        });
                    }
                    else if (item.type === _constants.Type.COMMENT) {
                        comments.push({
                            comment: item.comment,
                            before: items.length
                        });
                    }
                    else {
                        if (next) {
                            var _msg2 = "Expected a ".concat(next, " in flow sequence");
                            doc.errors.push(new _errors.YAMLSemanticError(item, _msg2));
                        }
                        var value = doc.resolveNode(item);
                        if (key === undefined) {
                            items.push(value);
                        }
                        else {
                            items.push(new _Pair.default(key, value));
                            key = undefined;
                        }
                        keyStart = item.range.start;
                        next = ',';
                    }
                }
                (0, _parseUtils.checkFlowCollectionEnd)(doc.errors, cst);
                if (key !== undefined)
                    items.push(new _Pair.default(key));
                return {
                    comments: comments,
                    items: items
                };
            }
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/schema/parseUtils.js": 
        /*!*************************************************************!*\
          !*** ./node_modules/yaml/browser/dist/schema/parseUtils.js ***!
          \*************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.checkFlowCollectionEnd = checkFlowCollectionEnd;
            exports.checkKeyLength = checkKeyLength;
            exports.resolveComments = resolveComments;
            var _errors = __webpack_require__(/*! ../errors */ "./node_modules/yaml/browser/dist/errors.js");
            var _constants = __webpack_require__(/*! ../constants */ "./node_modules/yaml/browser/dist/constants.js");
            function checkFlowCollectionEnd(errors, cst) {
                var char, name;
                switch (cst.type) {
                    case _constants.Type.FLOW_MAP:
                        char = '}';
                        name = 'flow map';
                        break;
                    case _constants.Type.FLOW_SEQ:
                        char = ']';
                        name = 'flow sequence';
                        break;
                    default:
                        errors.push(new _errors.YAMLSemanticError(cst, 'Not a flow collection!?'));
                        return;
                }
                var lastItem;
                for (var i = cst.items.length - 1; i >= 0; --i) {
                    var item = cst.items[i];
                    if (!item || item.type !== _constants.Type.COMMENT) {
                        lastItem = item;
                        break;
                    }
                }
                if (lastItem && lastItem.char !== char) {
                    var msg = "Expected ".concat(name, " to end with ").concat(char);
                    var err;
                    if (typeof lastItem.offset === 'number') {
                        err = new _errors.YAMLSemanticError(cst, msg);
                        err.offset = lastItem.offset + 1;
                    }
                    else {
                        err = new _errors.YAMLSemanticError(lastItem, msg);
                        if (lastItem.range && lastItem.range.end)
                            err.offset = lastItem.range.end - lastItem.range.start;
                    }
                    errors.push(err);
                }
            }
            function checkKeyLength(errors, node, itemIdx, key, keyStart) {
                if (!key || typeof keyStart !== 'number')
                    return;
                var item = node.items[itemIdx];
                var keyEnd = item && item.range && item.range.start;
                if (!keyEnd) {
                    for (var i = itemIdx - 1; i >= 0; --i) {
                        var it = node.items[i];
                        if (it && it.range) {
                            keyEnd = it.range.end + 2 * (itemIdx - i);
                            break;
                        }
                    }
                }
                if (keyEnd > keyStart + 1024) {
                    var k = String(key).substr(0, 8) + '...' + String(key).substr(-8);
                    errors.push(new _errors.YAMLSemanticError(node, "The \"".concat(k, "\" key is too long")));
                }
            }
            function resolveComments(collection, comments) {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;
                try {
                    for (var _iterator = comments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var _step$value = _step.value, afterKey = _step$value.afterKey, before = _step$value.before, comment = _step$value.comment;
                        var item = collection.items[before];
                        if (!item) {
                            if (comment !== undefined) {
                                if (collection.comment)
                                    collection.comment += '\n' + comment;
                                else
                                    collection.comment = comment;
                            }
                        }
                        else {
                            if (afterKey && item.value)
                                item = item.value;
                            if (comment === undefined) {
                                if (afterKey || !item.commentBefore)
                                    item.spaceBefore = true;
                            }
                            else {
                                if (item.commentBefore)
                                    item.commentBefore += '\n' + comment;
                                else
                                    item.commentBefore = comment;
                            }
                        }
                    }
                }
                catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                }
                finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    }
                    finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/stringify.js": 
        /*!*****************************************************!*\
          !*** ./node_modules/yaml/browser/dist/stringify.js ***!
          \*****************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.stringifyNumber = stringifyNumber;
            exports.stringifyString = stringifyString;
            var _addComment = __webpack_require__(/*! ./addComment */ "./node_modules/yaml/browser/dist/addComment.js");
            var _constants = __webpack_require__(/*! ./constants */ "./node_modules/yaml/browser/dist/constants.js");
            var _foldFlowLines = _interopRequireWildcard(__webpack_require__(/*! ./foldFlowLines */ "./node_modules/yaml/browser/dist/foldFlowLines.js"));
            var _options = __webpack_require__(/*! ./tags/options */ "./node_modules/yaml/browser/dist/tags/options.js");
            function stringifyNumber(_ref) {
                var format = _ref.format, minFractionDigits = _ref.minFractionDigits, tag = _ref.tag, value = _ref.value;
                if (!isFinite(value))
                    return isNaN(value) ? '.nan' : value < 0 ? '-.inf' : '.inf';
                var n = JSON.stringify(value);
                if (!format && minFractionDigits && (!tag || tag === 'tag:yaml.org,2002:float') && /^\d/.test(n)) {
                    var i = n.indexOf('.');
                    if (i < 0) {
                        i = n.length;
                        n += '.';
                    }
                    var d = minFractionDigits - (n.length - i - 1);
                    while (d-- > 0) {
                        n += '0';
                    }
                }
                return n;
            }
            function lineLengthOverLimit(str, limit) {
                var strLen = str.length;
                if (strLen <= limit)
                    return false;
                for (var i = 0, start = 0; i < strLen; ++i) {
                    if (str[i] === '\n') {
                        if (i - start > limit)
                            return true;
                        start = i + 1;
                        if (strLen - start <= limit)
                            return false;
                    }
                }
                return true;
            }
            function doubleQuotedString(value, _ref2) {
                var implicitKey = _ref2.implicitKey, indent = _ref2.indent;
                var _strOptions$doubleQuo = _options.strOptions.doubleQuoted, jsonEncoding = _strOptions$doubleQuo.jsonEncoding, minMultiLineLength = _strOptions$doubleQuo.minMultiLineLength;
                var json = JSON.stringify(value);
                if (jsonEncoding)
                    return json;
                var str = '';
                var start = 0;
                for (var i = 0, ch = json[i]; ch; ch = json[++i]) {
                    if (ch === ' ' && json[i + 1] === '\\' && json[i + 2] === 'n') {
                        // space before newline needs to be escaped to not be folded
                        str += json.slice(start, i) + '\\ ';
                        i += 1;
                        start = i;
                        ch = '\\';
                    }
                    if (ch === '\\')
                        switch (json[i + 1]) {
                            case 'u':
                                {
                                    str += json.slice(start, i);
                                    var code = json.substr(i + 2, 4);
                                    switch (code) {
                                        case '0000':
                                            str += '\\0';
                                            break;
                                        case '0007':
                                            str += '\\a';
                                            break;
                                        case '000b':
                                            str += '\\v';
                                            break;
                                        case '001b':
                                            str += '\\e';
                                            break;
                                        case '0085':
                                            str += '\\N';
                                            break;
                                        case '00a0':
                                            str += '\\_';
                                            break;
                                        case '2028':
                                            str += '\\L';
                                            break;
                                        case '2029':
                                            str += '\\P';
                                            break;
                                        default:
                                            if (code.substr(0, 2) === '00')
                                                str += '\\x' + code.substr(2);
                                            else
                                                str += json.substr(i, 6);
                                    }
                                    i += 5;
                                    start = i + 1;
                                }
                                break;
                            case 'n':
                                if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
                                    i += 1;
                                }
                                else {
                                    // folding will eat first newline
                                    str += json.slice(start, i) + '\n\n';
                                    while (json[i + 2] === '\\' && json[i + 3] === 'n' && json[i + 4] !== '"') {
                                        str += '\n';
                                        i += 2;
                                    }
                                    str += indent; // space after newline needs to be escaped to not be folded
                                    if (json[i + 2] === ' ')
                                        str += '\\';
                                    i += 1;
                                    start = i + 1;
                                }
                                break;
                            default:
                                i += 1;
                        }
                }
                str = start ? str + json.slice(start) : json;
                return implicitKey ? str : (0, _foldFlowLines.default)(str, indent, _foldFlowLines.FOLD_QUOTED, _options.strOptions.fold);
            }
            function singleQuotedString(value, ctx) {
                var indent = ctx.indent, implicitKey = ctx.implicitKey;
                if (implicitKey) {
                    if (/\n/.test(value))
                        return doubleQuotedString(value, ctx);
                }
                else {
                    // single quoted string can't have leading or trailing whitespace around newline
                    if (/[ \t]\n|\n[ \t]/.test(value))
                        return doubleQuotedString(value, ctx);
                }
                var res = "'" + value.replace(/'/g, "''").replace(/\n+/g, "$&\n".concat(indent)) + "'";
                return implicitKey ? res : (0, _foldFlowLines.default)(res, indent, _foldFlowLines.FOLD_FLOW, _options.strOptions.fold);
            }
            function blockString(_ref3, ctx, onComment, onChompKeep) {
                var comment = _ref3.comment, type = _ref3.type, value = _ref3.value;
                // 1. Block can't end in whitespace unless the last line is non-empty.
                // 2. Strings consisting of only whitespace are best rendered explicitly.
                if (/\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
                    return doubleQuotedString(value, ctx);
                }
                var indent = ctx.indent || (ctx.forceBlockIndent ? ' ' : '');
                var indentSize = indent ? '2' : '1'; // root is at -1
                var literal = type === _constants.Type.BLOCK_FOLDED ? false : type === _constants.Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, _options.strOptions.fold.lineWidth - indent.length);
                var header = literal ? '|' : '>';
                if (!value)
                    return header + '\n';
                var wsStart = '';
                var wsEnd = '';
                value = value.replace(/[\n\t ]*$/, function (ws) {
                    var n = ws.indexOf('\n');
                    if (n === -1) {
                        header += '-'; // strip
                    }
                    else if (value === ws || n !== ws.length - 1) {
                        header += '+'; // keep
                        if (onChompKeep)
                            onChompKeep();
                    }
                    wsEnd = ws.replace(/\n$/, '');
                    return '';
                }).replace(/^[\n ]*/, function (ws) {
                    if (ws.indexOf(' ') !== -1)
                        header += indentSize;
                    var m = ws.match(/ +$/);
                    if (m) {
                        wsStart = ws.slice(0, -m[0].length);
                        return m[0];
                    }
                    else {
                        wsStart = ws;
                        return '';
                    }
                });
                if (wsEnd)
                    wsEnd = wsEnd.replace(/\n+(?!\n|$)/g, "$&".concat(indent));
                if (wsStart)
                    wsStart = wsStart.replace(/\n+/g, "$&".concat(indent));
                if (comment) {
                    header += ' #' + comment.replace(/ ?[\r\n]+/g, ' ');
                    if (onComment)
                        onComment();
                }
                if (!value)
                    return "".concat(header).concat(indentSize, "\n").concat(indent).concat(wsEnd);
                if (literal) {
                    value = value.replace(/\n+/g, "$&".concat(indent));
                    return "".concat(header, "\n").concat(indent).concat(wsStart).concat(value).concat(wsEnd);
                }
                value = value.replace(/\n+/g, '\n$&').replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, '$1$2') // more-indented lines aren't folded
                    //         ^ ind.line  ^ empty     ^ capture next empty lines only at end of indent
                    .replace(/\n+/g, "$&".concat(indent));
                var body = (0, _foldFlowLines.default)("".concat(wsStart).concat(value).concat(wsEnd), indent, _foldFlowLines.FOLD_BLOCK, _options.strOptions.fold);
                return "".concat(header, "\n").concat(indent).concat(body);
            }
            function plainString(item, ctx, onComment, onChompKeep) {
                var comment = item.comment, type = item.type, value = item.value;
                var actualString = ctx.actualString, implicitKey = ctx.implicitKey, indent = ctx.indent, inFlow = ctx.inFlow, tags = ctx.tags;
                if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
                    return doubleQuotedString(value, ctx);
                }
                if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
                    // not allowed:
                    // - empty string, '-' or '?'
                    // - start with an indicator character (except [?:-]) or /[?-] /
                    // - '\n ', ': ' or ' \n' anywhere
                    // - '#' not preceded by a non-space char
                    // - end with ' ' or ':'
                    return implicitKey || inFlow || value.indexOf('\n') === -1 ? value.indexOf('"') !== -1 && value.indexOf("'") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
                }
                if (!implicitKey && !inFlow && type !== _constants.Type.PLAIN && value.indexOf('\n') !== -1) {
                    // Where allowed & type not set explicitly, prefer block style for multiline strings
                    return blockString(item, ctx, onComment, onChompKeep);
                }
                var str = value.replace(/\n+/g, "$&\n".concat(indent)); // Verify that output will be parsed as a string, as e.g. plain numbers and
                // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),
                // and others in v1.1.
                if (actualString && typeof tags.resolveScalar(str).value !== 'string') {
                    return doubleQuotedString(value, ctx);
                }
                var body = implicitKey ? str : (0, _foldFlowLines.default)(str, indent, _foldFlowLines.FOLD_FLOW, _options.strOptions.fold);
                if (comment && !inFlow && (body.indexOf('\n') !== -1 || comment.indexOf('\n') !== -1)) {
                    if (onComment)
                        onComment();
                    return (0, _addComment.addCommentBefore)(body, indent, comment);
                }
                return body;
            }
            function stringifyString(item, ctx, onComment, onChompKeep) {
                var defaultType = _options.strOptions.defaultType;
                var implicitKey = ctx.implicitKey, inFlow = ctx.inFlow;
                var _item = item, type = _item.type, value = _item.value;
                if (typeof value !== 'string') {
                    value = String(value);
                    item = Object.assign({}, item, {
                        value: value
                    });
                }
                var _stringify = function _stringify(_type) {
                    switch (_type) {
                        case _constants.Type.BLOCK_FOLDED:
                        case _constants.Type.BLOCK_LITERAL:
                            return blockString(item, ctx, onComment, onChompKeep);
                        case _constants.Type.QUOTE_DOUBLE:
                            return doubleQuotedString(value, ctx);
                        case _constants.Type.QUOTE_SINGLE:
                            return singleQuotedString(value, ctx);
                        case _constants.Type.PLAIN:
                            return plainString(item, ctx, onComment, onChompKeep);
                        default:
                            return null;
                    }
                };
                if (type !== _constants.Type.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(value)) {
                    // force double quotes on control characters
                    type = _constants.Type.QUOTE_DOUBLE;
                }
                else if ((implicitKey || inFlow) && (type === _constants.Type.BLOCK_FOLDED || type === _constants.Type.BLOCK_LITERAL)) {
                    // should not happen; blocks are not valid inside flow containers
                    type = _constants.Type.QUOTE_DOUBLE;
                }
                var res = _stringify(type);
                if (res === null) {
                    res = _stringify(defaultType);
                    if (res === null)
                        throw new Error("Unsupported default string type ".concat(defaultType));
                }
                return res;
            }
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/tags/core.js": 
        /*!*****************************************************!*\
          !*** ./node_modules/yaml/browser/dist/tags/core.js ***!
          \*****************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _Scalar = _interopRequireDefault(__webpack_require__(/*! ../schema/Scalar */ "./node_modules/yaml/browser/dist/schema/Scalar.js"));
            var _stringify = __webpack_require__(/*! ../stringify */ "./node_modules/yaml/browser/dist/stringify.js");
            var _failsafe = _interopRequireDefault(__webpack_require__(/*! ./failsafe */ "./node_modules/yaml/browser/dist/tags/failsafe/index.js"));
            var _options = __webpack_require__(/*! ./options */ "./node_modules/yaml/browser/dist/tags/options.js");
            var _default = _failsafe.default.concat([{
                    identify: function identify(value) {
                        return value == null;
                    },
                    createNode: function createNode(schema, value, ctx) {
                        return ctx.wrapScalars ? new _Scalar.default(null) : null;
                    },
                    default: true,
                    tag: 'tag:yaml.org,2002:null',
                    test: /^(?:~|[Nn]ull|NULL)?$/,
                    resolve: function resolve() {
                        return null;
                    },
                    options: _options.nullOptions,
                    stringify: function stringify() {
                        return _options.nullOptions.nullStr;
                    }
                }, {
                    identify: function identify(value) {
                        return typeof value === 'boolean';
                    },
                    default: true,
                    tag: 'tag:yaml.org,2002:bool',
                    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
                    resolve: function resolve(str) {
                        return str[0] === 't' || str[0] === 'T';
                    },
                    options: _options.boolOptions,
                    stringify: function stringify(_ref) {
                        var value = _ref.value;
                        return value ? _options.boolOptions.trueStr : _options.boolOptions.falseStr;
                    }
                }, {
                    identify: function identify(value) {
                        return typeof value === 'number';
                    },
                    default: true,
                    tag: 'tag:yaml.org,2002:int',
                    format: 'OCT',
                    test: /^0o([0-7]+)$/,
                    resolve: function resolve(str, oct) {
                        return parseInt(oct, 8);
                    },
                    stringify: function stringify(_ref2) {
                        var value = _ref2.value;
                        return '0o' + value.toString(8);
                    }
                }, {
                    identify: function identify(value) {
                        return typeof value === 'number';
                    },
                    default: true,
                    tag: 'tag:yaml.org,2002:int',
                    test: /^[-+]?[0-9]+$/,
                    resolve: function resolve(str) {
                        return parseInt(str, 10);
                    },
                    stringify: _stringify.stringifyNumber
                }, {
                    identify: function identify(value) {
                        return typeof value === 'number';
                    },
                    default: true,
                    tag: 'tag:yaml.org,2002:int',
                    format: 'HEX',
                    test: /^0x([0-9a-fA-F]+)$/,
                    resolve: function resolve(str, hex) {
                        return parseInt(hex, 16);
                    },
                    stringify: function stringify(_ref3) {
                        var value = _ref3.value;
                        return '0x' + value.toString(16);
                    }
                }, {
                    identify: function identify(value) {
                        return typeof value === 'number';
                    },
                    default: true,
                    tag: 'tag:yaml.org,2002:float',
                    test: /^(?:[-+]?\.inf|(\.nan))$/i,
                    resolve: function resolve(str, nan) {
                        return nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
                    },
                    stringify: _stringify.stringifyNumber
                }, {
                    identify: function identify(value) {
                        return typeof value === 'number';
                    },
                    default: true,
                    tag: 'tag:yaml.org,2002:float',
                    format: 'EXP',
                    test: /^[-+]?(?:0|[1-9][0-9]*)(\.[0-9]*)?[eE][-+]?[0-9]+$/,
                    resolve: function resolve(str) {
                        return parseFloat(str);
                    },
                    stringify: function stringify(_ref4) {
                        var value = _ref4.value;
                        return Number(value).toExponential();
                    }
                }, {
                    identify: function identify(value) {
                        return typeof value === 'number';
                    },
                    default: true,
                    tag: 'tag:yaml.org,2002:float',
                    test: /^[-+]?(?:0|[1-9][0-9]*)\.([0-9]*)$/,
                    resolve: function resolve(str, frac) {
                        var node = new _Scalar.default(parseFloat(str));
                        if (frac && frac[frac.length - 1] === '0')
                            node.minFractionDigits = frac.length;
                        return node;
                    },
                    stringify: _stringify.stringifyNumber
                }]);
            exports.default = _default;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/tags/failsafe/index.js": 
        /*!***************************************************************!*\
          !*** ./node_modules/yaml/browser/dist/tags/failsafe/index.js ***!
          \***************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _map = _interopRequireDefault(__webpack_require__(/*! ./map */ "./node_modules/yaml/browser/dist/tags/failsafe/map.js"));
            var _seq = _interopRequireDefault(__webpack_require__(/*! ./seq */ "./node_modules/yaml/browser/dist/tags/failsafe/seq.js"));
            var _string = _interopRequireDefault(__webpack_require__(/*! ./string */ "./node_modules/yaml/browser/dist/tags/failsafe/string.js"));
            var _default = [_map.default, _seq.default, _string.default];
            exports.default = _default;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/tags/failsafe/map.js": 
        /*!*************************************************************!*\
          !*** ./node_modules/yaml/browser/dist/tags/failsafe/map.js ***!
          \*************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js"));
            var _slicedToArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js"));
            var _Map = _interopRequireDefault(__webpack_require__(/*! ../../schema/Map */ "./node_modules/yaml/browser/dist/schema/Map.js"));
            var _parseMap = _interopRequireDefault(__webpack_require__(/*! ../../schema/parseMap */ "./node_modules/yaml/browser/dist/schema/parseMap.js"));
            function createMap(schema, obj, ctx) {
                var map = new _Map.default();
                if (obj instanceof Map) {
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;
                    try {
                        for (var _iterator = obj[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var _step$value = (0, _slicedToArray2.default)(_step.value, 2), key = _step$value[0], value = _step$value[1];
                            map.items.push(schema.createPair(key, value, ctx));
                        }
                    }
                    catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    }
                    finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        }
                        finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                }
                else if (obj && (0, _typeof2.default)(obj) === 'object') {
                    for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
                        var _key = _Object$keys[_i];
                        map.items.push(schema.createPair(_key, obj[_key], ctx));
                    }
                }
                return map;
            }
            var _default = {
                createNode: createMap,
                default: true,
                nodeClass: _Map.default,
                tag: 'tag:yaml.org,2002:map',
                resolve: _parseMap.default
            };
            exports.default = _default;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/tags/failsafe/seq.js": 
        /*!*************************************************************!*\
          !*** ./node_modules/yaml/browser/dist/tags/failsafe/seq.js ***!
          \*************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _parseSeq = _interopRequireDefault(__webpack_require__(/*! ../../schema/parseSeq */ "./node_modules/yaml/browser/dist/schema/parseSeq.js"));
            var _Seq = _interopRequireDefault(__webpack_require__(/*! ../../schema/Seq */ "./node_modules/yaml/browser/dist/schema/Seq.js"));
            function createSeq(schema, obj, ctx) {
                var seq = new _Seq.default();
                if (obj && obj[Symbol.iterator]) {
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;
                    try {
                        for (var _iterator = obj[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var it = _step.value;
                            var v = schema.createNode(it, ctx.wrapScalars, null, ctx);
                            seq.items.push(v);
                        }
                    }
                    catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    }
                    finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        }
                        finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                }
                return seq;
            }
            var _default = {
                createNode: createSeq,
                default: true,
                nodeClass: _Seq.default,
                tag: 'tag:yaml.org,2002:seq',
                resolve: _parseSeq.default
            };
            exports.default = _default;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/tags/failsafe/string.js": 
        /*!****************************************************************!*\
          !*** ./node_modules/yaml/browser/dist/tags/failsafe/string.js ***!
          \****************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = exports.resolveString = void 0;
            var _stringify = __webpack_require__(/*! ../../stringify */ "./node_modules/yaml/browser/dist/stringify.js");
            var _options = __webpack_require__(/*! ../options */ "./node_modules/yaml/browser/dist/tags/options.js");
            var resolveString = function resolveString(doc, node) {
                // on error, will return { str: string, errors: Error[] }
                var res = node.strValue;
                if (!res)
                    return '';
                if (typeof res === 'string')
                    return res;
                res.errors.forEach(function (error) {
                    if (!error.source)
                        error.source = node;
                    doc.errors.push(error);
                });
                return res.str;
            };
            exports.resolveString = resolveString;
            var _default = {
                identify: function identify(value) {
                    return typeof value === 'string';
                },
                default: true,
                tag: 'tag:yaml.org,2002:str',
                resolve: resolveString,
                stringify: function stringify(item, ctx, onComment, onChompKeep) {
                    ctx = Object.assign({
                        actualString: true
                    }, ctx);
                    return (0, _stringify.stringifyString)(item, ctx, onComment, onChompKeep);
                },
                options: _options.strOptions
            };
            exports.default = _default;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/tags/index.js": 
        /*!******************************************************!*\
          !*** ./node_modules/yaml/browser/dist/tags/index.js ***!
          \******************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.tags = exports.schemas = void 0;
            var _core = _interopRequireDefault(__webpack_require__(/*! ./core */ "./node_modules/yaml/browser/dist/tags/core.js"));
            var _failsafe = _interopRequireDefault(__webpack_require__(/*! ./failsafe */ "./node_modules/yaml/browser/dist/tags/failsafe/index.js"));
            var _json = _interopRequireDefault(__webpack_require__(/*! ./json */ "./node_modules/yaml/browser/dist/tags/json.js"));
            var _yaml = _interopRequireDefault(__webpack_require__(/*! ./yaml-1.1 */ "./node_modules/yaml/browser/dist/tags/yaml-1.1/index.js"));
            var _map = _interopRequireDefault(__webpack_require__(/*! ./failsafe/map */ "./node_modules/yaml/browser/dist/tags/failsafe/map.js"));
            var _seq = _interopRequireDefault(__webpack_require__(/*! ./failsafe/seq */ "./node_modules/yaml/browser/dist/tags/failsafe/seq.js"));
            var _binary = _interopRequireDefault(__webpack_require__(/*! ./yaml-1.1/binary */ "./node_modules/yaml/browser/dist/tags/yaml-1.1/binary.js"));
            var _omap = _interopRequireDefault(__webpack_require__(/*! ./yaml-1.1/omap */ "./node_modules/yaml/browser/dist/tags/yaml-1.1/omap.js"));
            var _pairs = _interopRequireDefault(__webpack_require__(/*! ./yaml-1.1/pairs */ "./node_modules/yaml/browser/dist/tags/yaml-1.1/pairs.js"));
            var _set = _interopRequireDefault(__webpack_require__(/*! ./yaml-1.1/set */ "./node_modules/yaml/browser/dist/tags/yaml-1.1/set.js"));
            var _timestamp = __webpack_require__(/*! ./yaml-1.1/timestamp */ "./node_modules/yaml/browser/dist/tags/yaml-1.1/timestamp.js");
            var schemas = {
                core: _core.default,
                failsafe: _failsafe.default,
                json: _json.default,
                yaml11: _yaml.default
            };
            exports.schemas = schemas;
            var tags = {
                binary: _binary.default,
                floatTime: _timestamp.floatTime,
                intTime: _timestamp.intTime,
                map: _map.default,
                omap: _omap.default,
                pairs: _pairs.default,
                seq: _seq.default,
                set: _set.default,
                timestamp: _timestamp.timestamp
            };
            exports.tags = tags;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/tags/json.js": 
        /*!*****************************************************!*\
          !*** ./node_modules/yaml/browser/dist/tags/json.js ***!
          \*****************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _map = _interopRequireDefault(__webpack_require__(/*! ./failsafe/map */ "./node_modules/yaml/browser/dist/tags/failsafe/map.js"));
            var _seq = _interopRequireDefault(__webpack_require__(/*! ./failsafe/seq */ "./node_modules/yaml/browser/dist/tags/failsafe/seq.js"));
            var _Scalar = _interopRequireDefault(__webpack_require__(/*! ../schema/Scalar */ "./node_modules/yaml/browser/dist/schema/Scalar.js"));
            var _string = __webpack_require__(/*! ./failsafe/string */ "./node_modules/yaml/browser/dist/tags/failsafe/string.js");
            var schema = [_map.default, _seq.default, {
                    identify: function identify(value) {
                        return typeof value === 'string';
                    },
                    default: true,
                    tag: 'tag:yaml.org,2002:str',
                    resolve: _string.resolveString,
                    stringify: function stringify(value) {
                        return JSON.stringify(value);
                    }
                }, {
                    identify: function identify(value) {
                        return value == null;
                    },
                    createNode: function createNode(schema, value, ctx) {
                        return ctx.wrapScalars ? new _Scalar.default(null) : null;
                    },
                    default: true,
                    tag: 'tag:yaml.org,2002:null',
                    test: /^null$/,
                    resolve: function resolve() {
                        return null;
                    },
                    stringify: function stringify(value) {
                        return JSON.stringify(value);
                    }
                }, {
                    identify: function identify(value) {
                        return typeof value === 'boolean';
                    },
                    default: true,
                    tag: 'tag:yaml.org,2002:bool',
                    test: /^true$/,
                    resolve: function resolve() {
                        return true;
                    },
                    stringify: function stringify(value) {
                        return JSON.stringify(value);
                    }
                }, {
                    identify: function identify(value) {
                        return typeof value === 'boolean';
                    },
                    default: true,
                    tag: 'tag:yaml.org,2002:bool',
                    test: /^false$/,
                    resolve: function resolve() {
                        return false;
                    },
                    stringify: function stringify(value) {
                        return JSON.stringify(value);
                    }
                }, {
                    identify: function identify(value) {
                        return typeof value === 'number';
                    },
                    default: true,
                    tag: 'tag:yaml.org,2002:int',
                    test: /^-?(?:0|[1-9][0-9]*)$/,
                    resolve: function resolve(str) {
                        return parseInt(str, 10);
                    },
                    stringify: function stringify(value) {
                        return JSON.stringify(value);
                    }
                }, {
                    identify: function identify(value) {
                        return typeof value === 'number';
                    },
                    default: true,
                    tag: 'tag:yaml.org,2002:float',
                    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
                    resolve: function resolve(str) {
                        return parseFloat(str);
                    },
                    stringify: function stringify(value) {
                        return JSON.stringify(value);
                    }
                }];
            schema.scalarFallback = function (str) {
                throw new SyntaxError("Unresolved plain scalar ".concat(JSON.stringify(str)));
            };
            var _default = schema;
            exports.default = _default;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/tags/options.js": 
        /*!********************************************************!*\
          !*** ./node_modules/yaml/browser/dist/tags/options.js ***!
          \********************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.strOptions = exports.nullOptions = exports.boolOptions = exports.binaryOptions = void 0;
            var _constants = __webpack_require__(/*! ../constants */ "./node_modules/yaml/browser/dist/constants.js");
            var binaryOptions = {
                defaultType: _constants.Type.BLOCK_LITERAL,
                lineWidth: 76
            };
            exports.binaryOptions = binaryOptions;
            var boolOptions = {
                trueStr: 'true',
                falseStr: 'false'
            };
            exports.boolOptions = boolOptions;
            var nullOptions = {
                nullStr: 'null'
            };
            exports.nullOptions = nullOptions;
            var strOptions = {
                defaultType: _constants.Type.PLAIN,
                doubleQuoted: {
                    jsonEncoding: false,
                    minMultiLineLength: 40
                },
                fold: {
                    lineWidth: 80,
                    minContentWidth: 20
                }
            };
            exports.strOptions = strOptions;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/tags/yaml-1.1/binary.js": 
        /*!****************************************************************!*\
          !*** ./node_modules/yaml/browser/dist/tags/yaml-1.1/binary.js ***!
          \****************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _constants = __webpack_require__(/*! ../../constants */ "./node_modules/yaml/browser/dist/constants.js");
            var _errors = __webpack_require__(/*! ../../errors */ "./node_modules/yaml/browser/dist/errors.js");
            var _stringify = __webpack_require__(/*! ../../stringify */ "./node_modules/yaml/browser/dist/stringify.js");
            var _string = __webpack_require__(/*! ../failsafe/string */ "./node_modules/yaml/browser/dist/tags/failsafe/string.js");
            var _options = __webpack_require__(/*! ../options */ "./node_modules/yaml/browser/dist/tags/options.js");
            /* global atob, btoa, Buffer */
            var _default = {
                identify: function identify(value) {
                    return value instanceof Uint8Array;
                },
                // Buffer inherits from Uint8Array
                default: false,
                tag: 'tag:yaml.org,2002:binary',
                /**
                 * Returns a Buffer in node and an Uint8Array in browsers
                 *
                 * To use the resulting buffer as an image, you'll want to do something like:
                 *
                 *   const blob = new Blob([buffer], { type: 'image/jpeg' })
                 *   document.querySelector('#photo').src = URL.createObjectURL(blob)
                 */
                resolve: function resolve(doc, node) {
                    if (typeof Buffer === 'function') {
                        var src = (0, _string.resolveString)(doc, node);
                        return Buffer.from(src, 'base64');
                    }
                    else if (typeof atob === 'function') {
                        var _src = atob((0, _string.resolveString)(doc, node));
                        var buffer = new Uint8Array(_src.length);
                        for (var i = 0; i < _src.length; ++i) {
                            buffer[i] = _src.charCodeAt(i);
                        }
                        return buffer;
                    }
                    else {
                        doc.errors.push(new _errors.YAMLReferenceError(node, 'This environment does not support reading binary tags; either Buffer or atob is required'));
                        return null;
                    }
                },
                options: _options.binaryOptions,
                stringify: function stringify(_ref, ctx, onComment, onChompKeep) {
                    var comment = _ref.comment, type = _ref.type, value = _ref.value;
                    var src;
                    if (typeof Buffer === 'function') {
                        src = value instanceof Buffer ? value.toString('base64') : Buffer.from(value.buffer).toString('base64');
                    }
                    else if (typeof btoa === 'function') {
                        var s = '';
                        for (var i = 0; i < value.length; ++i) {
                            s += String.fromCharCode(value[i]);
                        }
                        src = btoa(s);
                    }
                    else {
                        throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');
                    }
                    if (!type)
                        type = _options.binaryOptions.defaultType;
                    if (type === _constants.Type.QUOTE_DOUBLE) {
                        value = src;
                    }
                    else {
                        var lineWidth = _options.binaryOptions.lineWidth;
                        var n = Math.ceil(src.length / lineWidth);
                        var lines = new Array(n);
                        for (var _i = 0, o = 0; _i < n; ++_i, o += lineWidth) {
                            lines[_i] = src.substr(o, lineWidth);
                        }
                        value = lines.join(type === _constants.Type.BLOCK_LITERAL ? '\n' : ' ');
                    }
                    return (0, _stringify.stringifyString)({
                        comment: comment,
                        type: type,
                        value: value
                    }, ctx, onComment, onChompKeep);
                }
            };
            exports.default = _default;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/tags/yaml-1.1/index.js": 
        /*!***************************************************************!*\
          !*** ./node_modules/yaml/browser/dist/tags/yaml-1.1/index.js ***!
          \***************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _Scalar = _interopRequireDefault(__webpack_require__(/*! ../../schema/Scalar */ "./node_modules/yaml/browser/dist/schema/Scalar.js"));
            var _stringify = __webpack_require__(/*! ../../stringify */ "./node_modules/yaml/browser/dist/stringify.js");
            var _failsafe = _interopRequireDefault(__webpack_require__(/*! ../failsafe */ "./node_modules/yaml/browser/dist/tags/failsafe/index.js"));
            var _options = __webpack_require__(/*! ../options */ "./node_modules/yaml/browser/dist/tags/options.js");
            var _binary = _interopRequireDefault(__webpack_require__(/*! ./binary */ "./node_modules/yaml/browser/dist/tags/yaml-1.1/binary.js"));
            var _omap = _interopRequireDefault(__webpack_require__(/*! ./omap */ "./node_modules/yaml/browser/dist/tags/yaml-1.1/omap.js"));
            var _pairs = _interopRequireDefault(__webpack_require__(/*! ./pairs */ "./node_modules/yaml/browser/dist/tags/yaml-1.1/pairs.js"));
            var _set = _interopRequireDefault(__webpack_require__(/*! ./set */ "./node_modules/yaml/browser/dist/tags/yaml-1.1/set.js"));
            var _timestamp = __webpack_require__(/*! ./timestamp */ "./node_modules/yaml/browser/dist/tags/yaml-1.1/timestamp.js");
            var _default = _failsafe.default.concat([{
                    identify: function identify(value) {
                        return value == null;
                    },
                    createNode: function createNode(schema, value, ctx) {
                        return ctx.wrapScalars ? new _Scalar.default(null) : null;
                    },
                    default: true,
                    tag: 'tag:yaml.org,2002:null',
                    test: /^(?:~|[Nn]ull|NULL)?$/,
                    resolve: function resolve() {
                        return null;
                    },
                    options: _options.nullOptions,
                    stringify: function stringify() {
                        return _options.nullOptions.nullStr;
                    }
                }, {
                    identify: function identify(value) {
                        return typeof value === 'boolean';
                    },
                    default: true,
                    tag: 'tag:yaml.org,2002:bool',
                    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
                    resolve: function resolve() {
                        return true;
                    },
                    options: _options.boolOptions,
                    stringify: function stringify(_ref) {
                        var value = _ref.value;
                        return value ? _options.boolOptions.trueStr : _options.boolOptions.falseStr;
                    }
                }, {
                    identify: function identify(value) {
                        return typeof value === 'boolean';
                    },
                    default: true,
                    tag: 'tag:yaml.org,2002:bool',
                    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
                    resolve: function resolve() {
                        return false;
                    },
                    options: _options.boolOptions,
                    stringify: function stringify(_ref2) {
                        var value = _ref2.value;
                        return value ? _options.boolOptions.trueStr : _options.boolOptions.falseStr;
                    }
                }, {
                    identify: function identify(value) {
                        return typeof value === 'number';
                    },
                    default: true,
                    tag: 'tag:yaml.org,2002:int',
                    format: 'BIN',
                    test: /^0b([0-1_]+)$/,
                    resolve: function resolve(str, bin) {
                        return parseInt(bin.replace(/_/g, ''), 2);
                    },
                    stringify: function stringify(_ref3) {
                        var value = _ref3.value;
                        return '0b' + value.toString(2);
                    }
                }, {
                    identify: function identify(value) {
                        return typeof value === 'number';
                    },
                    default: true,
                    tag: 'tag:yaml.org,2002:int',
                    format: 'OCT',
                    test: /^[-+]?0([0-7_]+)$/,
                    resolve: function resolve(str, oct) {
                        return parseInt(oct.replace(/_/g, ''), 8);
                    },
                    stringify: function stringify(_ref4) {
                        var value = _ref4.value;
                        return (value < 0 ? '-0' : '0') + value.toString(8);
                    }
                }, {
                    identify: function identify(value) {
                        return typeof value === 'number';
                    },
                    default: true,
                    tag: 'tag:yaml.org,2002:int',
                    test: /^[-+]?[0-9][0-9_]*$/,
                    resolve: function resolve(str) {
                        return parseInt(str.replace(/_/g, ''), 10);
                    },
                    stringify: _stringify.stringifyNumber
                }, {
                    identify: function identify(value) {
                        return typeof value === 'number';
                    },
                    default: true,
                    tag: 'tag:yaml.org,2002:int',
                    format: 'HEX',
                    test: /^0x([0-9a-fA-F_]+)$/,
                    resolve: function resolve(str, hex) {
                        return parseInt(hex.replace(/_/g, ''), 16);
                    },
                    stringify: function stringify(_ref5) {
                        var value = _ref5.value;
                        return (value < 0 ? '-0x' : '0x') + value.toString(16);
                    }
                }, {
                    identify: function identify(value) {
                        return typeof value === 'number';
                    },
                    default: true,
                    tag: 'tag:yaml.org,2002:float',
                    test: /^(?:[-+]?\.inf|(\.nan))$/i,
                    resolve: function resolve(str, nan) {
                        return nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
                    },
                    stringify: _stringify.stringifyNumber
                }, {
                    identify: function identify(value) {
                        return typeof value === 'number';
                    },
                    default: true,
                    tag: 'tag:yaml.org,2002:float',
                    format: 'EXP',
                    test: /^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/,
                    resolve: function resolve(str) {
                        return parseFloat(str.replace(/_/g, ''));
                    },
                    stringify: function stringify(_ref6) {
                        var value = _ref6.value;
                        return Number(value).toExponential();
                    }
                }, {
                    identify: function identify(value) {
                        return typeof value === 'number';
                    },
                    default: true,
                    tag: 'tag:yaml.org,2002:float',
                    test: /^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/,
                    resolve: function resolve(str, frac) {
                        var node = new _Scalar.default(parseFloat(str.replace(/_/g, '')));
                        if (frac) {
                            var f = frac.replace(/_/g, '');
                            if (f[f.length - 1] === '0')
                                node.minFractionDigits = f.length;
                        }
                        return node;
                    },
                    stringify: _stringify.stringifyNumber
                }], _binary.default, _omap.default, _pairs.default, _set.default, _timestamp.intTime, _timestamp.floatTime, _timestamp.timestamp);
            exports.default = _default;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/tags/yaml-1.1/omap.js": 
        /*!**************************************************************!*\
          !*** ./node_modules/yaml/browser/dist/tags/yaml-1.1/omap.js ***!
          \**************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = exports.YAMLOMap = void 0;
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));
            var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));
            var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));
            var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js"));
            var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));
            var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));
            var _errors = __webpack_require__(/*! ../../errors */ "./node_modules/yaml/browser/dist/errors.js");
            var _toJSON2 = _interopRequireDefault(__webpack_require__(/*! ../../toJSON */ "./node_modules/yaml/browser/dist/toJSON.js"));
            var _Map = _interopRequireDefault(__webpack_require__(/*! ../../schema/Map */ "./node_modules/yaml/browser/dist/schema/Map.js"));
            var _Pair = _interopRequireDefault(__webpack_require__(/*! ../../schema/Pair */ "./node_modules/yaml/browser/dist/schema/Pair.js"));
            var _Scalar = _interopRequireDefault(__webpack_require__(/*! ../../schema/Scalar */ "./node_modules/yaml/browser/dist/schema/Scalar.js"));
            var _Seq = _interopRequireDefault(__webpack_require__(/*! ../../schema/Seq */ "./node_modules/yaml/browser/dist/schema/Seq.js"));
            var _pairs = __webpack_require__(/*! ./pairs */ "./node_modules/yaml/browser/dist/tags/yaml-1.1/pairs.js");
            var YAMLOMap = 
            /*#__PURE__*/
            function (_YAMLSeq) {
                (0, _inherits2.default)(YAMLOMap, _YAMLSeq);
                function YAMLOMap() {
                    var _this;
                    (0, _classCallCheck2.default)(this, YAMLOMap);
                    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(YAMLOMap).call(this));
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "add", _Map.default.prototype.add.bind((0, _assertThisInitialized2.default)(_this)));
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "delete", _Map.default.prototype.delete.bind((0, _assertThisInitialized2.default)(_this)));
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "get", _Map.default.prototype.get.bind((0, _assertThisInitialized2.default)(_this)));
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "has", _Map.default.prototype.has.bind((0, _assertThisInitialized2.default)(_this)));
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "set", _Map.default.prototype.set.bind((0, _assertThisInitialized2.default)(_this)));
                    _this.tag = YAMLOMap.tag;
                    return _this;
                }
                (0, _createClass2.default)(YAMLOMap, [{
                        key: "toJSON",
                        value: function toJSON(_, ctx) {
                            var map = new Map();
                            if (ctx && ctx.onCreate)
                                ctx.onCreate(map);
                            var _iteratorNormalCompletion = true;
                            var _didIteratorError = false;
                            var _iteratorError = undefined;
                            try {
                                for (var _iterator = this.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                    var pair = _step.value;
                                    var key = void 0, value = void 0;
                                    if (pair instanceof _Pair.default) {
                                        key = (0, _toJSON2.default)(pair.key, '', ctx);
                                        value = (0, _toJSON2.default)(pair.value, key, ctx);
                                    }
                                    else {
                                        key = (0, _toJSON2.default)(pair, '', ctx);
                                    }
                                    if (map.has(key))
                                        throw new Error('Ordered maps must not include duplicate keys');
                                    map.set(key, value);
                                }
                            }
                            catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            }
                            finally {
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                                        _iterator.return();
                                    }
                                }
                                finally {
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                            return map;
                        }
                    }]);
                return YAMLOMap;
            }(_Seq.default);
            exports.YAMLOMap = YAMLOMap;
            (0, _defineProperty2.default)(YAMLOMap, "tag", 'tag:yaml.org,2002:omap');
            function parseOMap(doc, cst) {
                var pairs = (0, _pairs.parsePairs)(doc, cst);
                var seenKeys = [];
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;
                try {
                    for (var _iterator2 = pairs.items[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var key = _step2.value.key;
                        if (key instanceof _Scalar.default) {
                            if (seenKeys.includes(key.value)) {
                                var msg = 'Ordered maps must not include duplicate keys';
                                throw new _errors.YAMLSemanticError(cst, msg);
                            }
                            else {
                                seenKeys.push(key.value);
                            }
                        }
                    }
                }
                catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                }
                finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                            _iterator2.return();
                        }
                    }
                    finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }
                return Object.assign(new YAMLOMap(), pairs);
            }
            function createOMap(schema, iterable, ctx) {
                var pairs = (0, _pairs.createPairs)(schema, iterable, ctx);
                var omap = new YAMLOMap();
                omap.items = pairs.items;
                return omap;
            }
            var _default = {
                identify: function identify(value) {
                    return value instanceof Map;
                },
                nodeClass: YAMLOMap,
                default: false,
                tag: 'tag:yaml.org,2002:omap',
                resolve: parseOMap,
                createNode: createOMap
            };
            exports.default = _default;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/tags/yaml-1.1/pairs.js": 
        /*!***************************************************************!*\
          !*** ./node_modules/yaml/browser/dist/tags/yaml-1.1/pairs.js ***!
          \***************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.parsePairs = parsePairs;
            exports.createPairs = createPairs;
            exports.default = void 0;
            var _errors = __webpack_require__(/*! ../../errors */ "./node_modules/yaml/browser/dist/errors.js");
            var _Map = _interopRequireDefault(__webpack_require__(/*! ../../schema/Map */ "./node_modules/yaml/browser/dist/schema/Map.js"));
            var _Pair = _interopRequireDefault(__webpack_require__(/*! ../../schema/Pair */ "./node_modules/yaml/browser/dist/schema/Pair.js"));
            var _parseSeq = _interopRequireDefault(__webpack_require__(/*! ../../schema/parseSeq */ "./node_modules/yaml/browser/dist/schema/parseSeq.js"));
            var _Seq = _interopRequireDefault(__webpack_require__(/*! ../../schema/Seq */ "./node_modules/yaml/browser/dist/schema/Seq.js"));
            function parsePairs(doc, cst) {
                var seq = (0, _parseSeq.default)(doc, cst);
                for (var i = 0; i < seq.items.length; ++i) {
                    var item = seq.items[i];
                    if (item instanceof _Pair.default)
                        continue;
                    else if (item instanceof _Map.default) {
                        if (item.items.length > 1) {
                            var msg = 'Each pair must have its own sequence indicator';
                            throw new _errors.YAMLSemanticError(cst, msg);
                        }
                        var pair = item.items[0] || new _Pair.default();
                        if (item.commentBefore)
                            pair.commentBefore = pair.commentBefore ? "".concat(item.commentBefore, "\n").concat(pair.commentBefore) : item.commentBefore;
                        if (item.comment)
                            pair.comment = pair.comment ? "".concat(item.comment, "\n").concat(pair.comment) : item.comment;
                        item = pair;
                    }
                    seq.items[i] = item instanceof _Pair.default ? item : new _Pair.default(item);
                }
                return seq;
            }
            function createPairs(schema, iterable, ctx) {
                var pairs = new _Seq.default();
                pairs.tag = 'tag:yaml.org,2002:pairs';
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;
                try {
                    for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var it = _step.value;
                        var key = void 0, value = void 0;
                        if (Array.isArray(it)) {
                            if (it.length === 2) {
                                key = it[0];
                                value = it[1];
                            }
                            else
                                throw new TypeError("Expected [key, value] tuple: ".concat(it));
                        }
                        else if (it && it instanceof Object) {
                            var keys = Object.keys(it);
                            if (keys.length === 1) {
                                key = keys[0];
                                value = it[key];
                            }
                            else
                                throw new TypeError("Expected { key: value } tuple: ".concat(it));
                        }
                        else {
                            key = it;
                        }
                        var pair = schema.createPair(key, value, ctx);
                        pairs.items.push(pair);
                    }
                }
                catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                }
                finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    }
                    finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return pairs;
            }
            var _default = {
                default: false,
                tag: 'tag:yaml.org,2002:pairs',
                resolve: parsePairs,
                createNode: createPairs
            };
            exports.default = _default;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/tags/yaml-1.1/set.js": 
        /*!*************************************************************!*\
          !*** ./node_modules/yaml/browser/dist/tags/yaml-1.1/set.js ***!
          \*************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");
            var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = exports.YAMLSet = void 0;
            var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js"));
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));
            var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));
            var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));
            var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js"));
            var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));
            var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));
            var _errors = __webpack_require__(/*! ../../errors */ "./node_modules/yaml/browser/dist/errors.js");
            var _Map = _interopRequireWildcard(__webpack_require__(/*! ../../schema/Map */ "./node_modules/yaml/browser/dist/schema/Map.js"));
            var _Pair = _interopRequireDefault(__webpack_require__(/*! ../../schema/Pair */ "./node_modules/yaml/browser/dist/schema/Pair.js"));
            var _parseMap = _interopRequireDefault(__webpack_require__(/*! ../../schema/parseMap */ "./node_modules/yaml/browser/dist/schema/parseMap.js"));
            var _Scalar = _interopRequireDefault(__webpack_require__(/*! ../../schema/Scalar */ "./node_modules/yaml/browser/dist/schema/Scalar.js"));
            var YAMLSet = 
            /*#__PURE__*/
            function (_YAMLMap) {
                (0, _inherits2.default)(YAMLSet, _YAMLMap);
                function YAMLSet() {
                    var _this;
                    (0, _classCallCheck2.default)(this, YAMLSet);
                    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(YAMLSet).call(this));
                    _this.tag = YAMLSet.tag;
                    return _this;
                }
                (0, _createClass2.default)(YAMLSet, [{
                        key: "add",
                        value: function add(key) {
                            var pair = key instanceof _Pair.default ? key : new _Pair.default(key);
                            var prev = (0, _Map.findPair)(this.items, pair.key);
                            if (!prev)
                                this.items.push(pair);
                        }
                    }, {
                        key: "get",
                        value: function get(key, keepPair) {
                            var pair = (0, _Map.findPair)(this.items, key);
                            return !keepPair && pair instanceof _Pair.default ? pair.key instanceof _Scalar.default ? pair.key.value : pair.key : pair;
                        }
                    }, {
                        key: "set",
                        value: function set(key, value) {
                            if (typeof value !== 'boolean')
                                throw new Error("Expected boolean value for set(key, value) in a YAML set, not ".concat((0, _typeof2.default)(value)));
                            var prev = (0, _Map.findPair)(this.items, key);
                            if (prev && !value) {
                                this.items.splice(this.items.indexOf(prev), 1);
                            }
                            else if (!prev && value) {
                                this.items.push(new _Pair.default(key));
                            }
                        }
                    }, {
                        key: "toJSON",
                        value: function toJSON(_, ctx) {
                            return (0, _get2.default)((0, _getPrototypeOf2.default)(YAMLSet.prototype), "toJSON", this).call(this, _, ctx, Set);
                        }
                    }, {
                        key: "toString",
                        value: function toString(ctx, onComment, onChompKeep) {
                            if (!ctx)
                                return JSON.stringify(this);
                            if (this.hasAllNullValues())
                                return (0, _get2.default)((0, _getPrototypeOf2.default)(YAMLSet.prototype), "toString", this).call(this, ctx, onComment, onChompKeep);
                            else
                                throw new Error('Set items must all have null values');
                        }
                    }]);
                return YAMLSet;
            }(_Map.default);
            exports.YAMLSet = YAMLSet;
            (0, _defineProperty2.default)(YAMLSet, "tag", 'tag:yaml.org,2002:set');
            function parseSet(doc, cst) {
                var map = (0, _parseMap.default)(doc, cst);
                if (!map.hasAllNullValues())
                    throw new _errors.YAMLSemanticError(cst, 'Set items must all have null values');
                return Object.assign(new YAMLSet(), map);
            }
            function createSet(schema, iterable, ctx) {
                var set = new YAMLSet();
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;
                try {
                    for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var value = _step.value;
                        set.items.push(schema.createPair(value, null, ctx));
                    }
                }
                catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                }
                finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    }
                    finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return set;
            }
            var _default = {
                identify: function identify(value) {
                    return value instanceof Set;
                },
                nodeClass: YAMLSet,
                default: false,
                tag: 'tag:yaml.org,2002:set',
                resolve: parseSet,
                createNode: createSet
            };
            exports.default = _default;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/tags/yaml-1.1/timestamp.js": 
        /*!*******************************************************************!*\
          !*** ./node_modules/yaml/browser/dist/tags/yaml-1.1/timestamp.js ***!
          \*******************************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.timestamp = exports.floatTime = exports.intTime = void 0;
            var _stringify = __webpack_require__(/*! ../../stringify */ "./node_modules/yaml/browser/dist/stringify.js");
            var parseSexagesimal = function parseSexagesimal(sign, parts) {
                var n = parts.split(':').reduce(function (n, p) {
                    return n * 60 + Number(p);
                }, 0);
                return sign === '-' ? -n : n;
            }; // hhhh:mm:ss.sss
            var stringifySexagesimal = function stringifySexagesimal(_ref) {
                var value = _ref.value;
                if (isNaN(value) || !isFinite(value))
                    return (0, _stringify.stringifyNumber)(value);
                var sign = '';
                if (value < 0) {
                    sign = '-';
                    value = Math.abs(value);
                }
                var parts = [value % 60]; // seconds, including ms
                if (value < 60) {
                    parts.unshift(0); // at least one : is required
                }
                else {
                    value = Math.round((value - parts[0]) / 60);
                    parts.unshift(value % 60); // minutes
                    if (value >= 60) {
                        value = Math.round((value - parts[0]) / 60);
                        parts.unshift(value); // hours
                    }
                }
                return sign + parts.map(function (n) {
                    return n < 10 ? '0' + String(n) : String(n);
                }).join(':').replace(/000000\d*$/, '') // % 60 may introduce error
                ;
            };
            var intTime = {
                identify: function identify(value) {
                    return typeof value === 'number';
                },
                default: true,
                tag: 'tag:yaml.org,2002:int',
                format: 'TIME',
                test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,
                resolve: function resolve(str, sign, parts) {
                    return parseSexagesimal(sign, parts.replace(/_/g, ''));
                },
                stringify: stringifySexagesimal
            };
            exports.intTime = intTime;
            var floatTime = {
                identify: function identify(value) {
                    return typeof value === 'number';
                },
                default: true,
                tag: 'tag:yaml.org,2002:float',
                format: 'TIME',
                test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/,
                resolve: function resolve(str, sign, parts) {
                    return parseSexagesimal(sign, parts.replace(/_/g, ''));
                },
                stringify: stringifySexagesimal
            };
            exports.floatTime = floatTime;
            var timestamp = {
                identify: function identify(value) {
                    return value instanceof Date;
                },
                default: true,
                tag: 'tag:yaml.org,2002:timestamp',
                // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
                // may be omitted altogether, resulting in a date format. In such a case, the time part is
                // assumed to be 00:00:00Z (start of day, UTC).
                test: RegExp('^(?:' + '([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd
                    '(?:(?:t|T|[ \\t]+)' + // t | T | whitespace
                    '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?
                    '(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30
                    ')?' + ')$'),
                resolve: function resolve(str, year, month, day, hour, minute, second, millisec, tz) {
                    if (millisec)
                        millisec = (millisec + '00').substr(1, 3);
                    var date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);
                    if (tz && tz !== 'Z') {
                        var d = parseSexagesimal(tz[0], tz.slice(1));
                        if (Math.abs(d) < 30)
                            d *= 60;
                        date -= 60000 * d;
                    }
                    return new Date(date);
                },
                stringify: function stringify(_ref2) {
                    var value = _ref2.value;
                    return value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, '');
                }
            };
            exports.timestamp = timestamp;
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/toJSON.js": 
        /*!**************************************************!*\
          !*** ./node_modules/yaml/browser/dist/toJSON.js ***!
          \**************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = toJSON;
            function toJSON(value, arg, ctx) {
                if (Array.isArray(value))
                    return value.map(function (v, i) {
                        return toJSON(v, String(i), ctx);
                    });
                if (value && typeof value.toJSON === 'function') {
                    var anchor = ctx && ctx.anchors && ctx.anchors.find(function (a) {
                        return a.node === value;
                    });
                    if (anchor)
                        ctx.onCreate = function (res) {
                            anchor.res = res;
                            delete ctx.onCreate;
                        };
                    var res = value.toJSON(arg, ctx);
                    if (anchor && ctx.onCreate)
                        ctx.onCreate(res);
                    return res;
                }
                return value;
            }
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/dist/warnings.js": 
        /*!****************************************************!*\
          !*** ./node_modules/yaml/browser/dist/warnings.js ***!
          \****************************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.warn = warn;
            exports.warnFileDeprecation = warnFileDeprecation;
            exports.warnOptionDeprecation = warnOptionDeprecation;
            /* global global, console */
            function warn(warning, type) {
                if (global && global._YAML_SILENCE_WARNINGS)
                    return;
                var _ref = global && global.process, emitWarning = _ref.emitWarning; // This will throw in Jest if `warning` is an Error instance due to
                // https://github.com/facebook/jest/issues/2549
                if (emitWarning)
                    emitWarning(warning, type);
                else {
                    // eslint-disable-next-line no-console
                    console.warn(type ? "".concat(type, ": ").concat(warning) : warning);
                }
            }
            function warnFileDeprecation(filename) {
                if (global && global._YAML_SILENCE_DEPRECATION_WARNINGS)
                    return;
                var path = filename.replace(/.*yaml[/\\]/i, '').replace(/\.js$/, '').replace(/\\/g, '/');
                warn("The endpoint 'yaml/".concat(path, "' will be removed in a future release."), 'DeprecationWarning');
            }
            var warned = {};
            function warnOptionDeprecation(name, alternative) {
                if (global && global._YAML_SILENCE_DEPRECATION_WARNINGS)
                    return;
                if (warned[name])
                    return;
                warned[name] = true;
                var msg = "The option '".concat(name, "' will be removed in a future release");
                msg += alternative ? ", use '".concat(alternative, "' instead.") : '.';
                warn(msg, 'DeprecationWarning');
            }
            /***/ 
        }),
        /***/ "./node_modules/yaml/browser/index.js": 
        /*!********************************************!*\
          !*** ./node_modules/yaml/browser/index.js ***!
          \********************************************/
        /*! no static exports found */
        /***/ (function (module, exports, __webpack_require__) {
            module.exports = __webpack_require__(/*! ./dist */ "./node_modules/yaml/browser/dist/index.js").default;
            /***/ 
        }),
        /***/ "./src/app/core/core.module.ts": 
        /*!*************************************!*\
          !*** ./src/app/core/core.module.ts ***!
          \*************************************/
        /*! exports provided: CoreModule */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CoreModule", function () { return CoreModule; });
            /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var angular6_json_schema_form__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! angular6-json-schema-form */ "./node_modules/angular6-json-schema-form/fesm2015/angular6-json-schema-form.js");
            /* harmony import */ var ngx_markdown__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ngx-markdown */ "./node_modules/ngx-markdown/fesm2015/ngx-markdown.js");
            var CoreModule = /** @class */ (function () {
                function CoreModule() {
                }
                return CoreModule;
            }());
            CoreModule = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"])({
                    declarations: [],
                    imports: [
                        _angular_common__WEBPACK_IMPORTED_MODULE_2__["CommonModule"],
                        angular6_json_schema_form__WEBPACK_IMPORTED_MODULE_3__["MaterialDesignFrameworkModule"],
                        ngx_markdown__WEBPACK_IMPORTED_MODULE_4__["MarkdownModule"].forRoot()
                    ],
                    exports: [
                        angular6_json_schema_form__WEBPACK_IMPORTED_MODULE_3__["MaterialDesignFrameworkModule"]
                    ]
                })
            ], CoreModule);
            /***/ 
        }),
        /***/ "./src/app/core/transform-tool/transform-tool.component.scss": 
        /*!*******************************************************************!*\
          !*** ./src/app/core/transform-tool/transform-tool.component.scss ***!
          \*******************************************************************/
        /*! exports provided: default */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony default export */ __webpack_exports__["default"] = ("\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJzcmMvYXBwL2NvcmUvdHJhbnNmb3JtLXRvb2wvdHJhbnNmb3JtLXRvb2wuY29tcG9uZW50LnNjc3MifQ== */");
            /***/ 
        }),
        /***/ "./src/app/core/transform-tool/transform-tool.component.ts": 
        /*!*****************************************************************!*\
          !*** ./src/app/core/transform-tool/transform-tool.component.ts ***!
          \*****************************************************************/
        /*! exports provided: Transform, TransformToolComponent */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Transform", function () { return Transform; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TransformToolComponent", function () { return TransformToolComponent; });
            /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            var Transform = /** @class */ (function () {
                function Transform() {
                }
                return Transform;
            }());
            var TransformToolComponent = /** @class */ (function () {
                function TransformToolComponent() {
                    this.formOptions = {};
                    this.data = {};
                    this.result = null;
                }
                TransformToolComponent.prototype.ngOnInit = function () {
                    this.layout = [
                        '*',
                        {
                            type: 'submit',
                            title: this.action
                        }
                    ];
                };
                TransformToolComponent.prototype.onSubmit = function () {
                    this.result = this.onTransform(this.data);
                };
                return TransformToolComponent;
            }());
            TransformToolComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
                    selector: 'app-transform-tool',
                    template: tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__(/*! raw-loader!./transform-tool.component.html */ "./node_modules/raw-loader/dist/cjs.js!./src/app/core/transform-tool/transform-tool.component.html")).default,
                    styles: [tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__(/*! ./transform-tool.component.scss */ "./src/app/core/transform-tool/transform-tool.component.scss")).default]
                })
            ], TransformToolComponent);
            /***/ 
        }),
        /***/ "./src/app/json/components/json-format.component.ts": 
        /*!**********************************************************!*\
          !*** ./src/app/json/components/json-format.component.ts ***!
          \**********************************************************/
        /*! exports provided: JsonFormatComponent */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JsonFormatComponent", function () { return JsonFormatComponent; });
            /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
            /* harmony import */ var src_app_core_transform_tool_transform_tool_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! src/app/core/transform-tool/transform-tool.component */ "./src/app/core/transform-tool/transform-tool.component.ts");
            var JsonFormatComponent = /** @class */ (function (_super) {
                __extends(JsonFormatComponent, _super);
                function JsonFormatComponent() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.title = 'JSON Format';
                    _this_1.action = 'Format';
                    _this_1.schema = {
                        type: 'object',
                        properties: {
                            input: { type: 'string', title: 'JSON', description: 'JSON to format' },
                            advanced: {
                                type: 'object',
                                properties: {
                                    whitespaceType: { type: 'string', enum: ['space', 'tab'], default: 'space', description: 'New line indent format' },
                                    size: { type: 'number', default: 3, description: 'Number of spaces to indent with' }
                                },
                                required: ['whitespaceType'],
                                "x-schema-form": {
                                    type: "section",
                                    expandable: true,
                                    expande: false,
                                    title: 'Advanced'
                                }
                            }
                        },
                        required: ['input']
                    };
                    _this_1.documentation = "\n  JSON is often minified or uglified to reduce the size of the JSON. \n  Minifying is the process of removing whitespace and other unneccassary characters.\n  Web pages load faster when load sizes are smaller, so this minification process is often used in web development.\n  However, the minified versions are harder to read by humans.\n\n  This tool will quickly format a json document to make it easily readable.\n  ";
                    return _this_1;
                }
                JsonFormatComponent.prototype.onTransform = function (transform) {
                    var input = transform.input;
                    var options = transform.advanced;
                    var object = JSON.parse(input);
                    var format = options.whitespaceType == 'space' ? options.size : '\t';
                    return JSON.stringify(object, null, format);
                };
                return JsonFormatComponent;
            }(src_app_core_transform_tool_transform_tool_component__WEBPACK_IMPORTED_MODULE_1__["TransformToolComponent"]));
            /***/ 
        }),
        /***/ "./src/app/json/components/json-to-schema.component.ts": 
        /*!*************************************************************!*\
          !*** ./src/app/json/components/json-to-schema.component.ts ***!
          \*************************************************************/
        /*! exports provided: JsonToSchemaComponent */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JsonToSchemaComponent", function () { return JsonToSchemaComponent; });
            /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
            /* harmony import */ var src_app_core_transform_tool_transform_tool_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! src/app/core/transform-tool/transform-tool.component */ "./src/app/core/transform-tool/transform-tool.component.ts");
            /* harmony import */ var generate_schema__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! generate-schema */ "./node_modules/generate-schema/src/index.js");
            /* harmony import */ var generate_schema__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __webpack_require__.n(generate_schema__WEBPACK_IMPORTED_MODULE_2__);
            var JsonToSchemaComponent = /** @class */ (function (_super) {
                __extends(JsonToSchemaComponent, _super);
                function JsonToSchemaComponent() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.action = 'Create Schema';
                    _this_1.title = 'Create JSON Schema from JSON Object';
                    _this_1.schema = {
                        type: 'object',
                        properties: {
                            input: { type: 'string', title: 'JSON', description: 'JSON to create schema from' },
                            name: { type: 'string', description: 'Name of schema created' }
                        },
                        required: ['input', 'name']
                    };
                    _this_1.documentation = "\n    This tool will convert a JSON document to JSON Schema.\n    ";
                    return _this_1;
                }
                JsonToSchemaComponent.prototype.onTransform = function (transform) {
                    var schema = generate_schema__WEBPACK_IMPORTED_MODULE_2___default.a.json(transform.name, JSON.parse(transform.input));
                    return JSON.stringify(schema, null, 3);
                };
                ;
                return JsonToSchemaComponent;
            }(src_app_core_transform_tool_transform_tool_component__WEBPACK_IMPORTED_MODULE_1__["TransformToolComponent"]));
            /***/ 
        }),
        /***/ "./src/app/json/components/json-to-xml.ts": 
        /*!************************************************!*\
          !*** ./src/app/json/components/json-to-xml.ts ***!
          \************************************************/
        /*! exports provided: JsonToXmlComponent */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JsonToXmlComponent", function () { return JsonToXmlComponent; });
            /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
            /* harmony import */ var src_app_core_transform_tool_transform_tool_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! src/app/core/transform-tool/transform-tool.component */ "./src/app/core/transform-tool/transform-tool.component.ts");
            /* harmony import */ var jsontoxml__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jsontoxml */ "./node_modules/jsontoxml/jsontoxml.js");
            /* harmony import */ var jsontoxml__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __webpack_require__.n(jsontoxml__WEBPACK_IMPORTED_MODULE_2__);
            var JsonToXmlComponent = /** @class */ (function (_super) {
                __extends(JsonToXmlComponent, _super);
                function JsonToXmlComponent() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.title = 'Convert JSON to XML';
                    _this_1.action = 'Convert';
                    _this_1.schema = {
                        type: 'object',
                        properties: {
                            input: { type: 'string', title: 'JSON', description: 'JSON to Convert' },
                            advanced: {
                                type: 'object',
                                properties: {
                                    xmlHeader: { type: 'boolean', description: 'Add XML header' },
                                    prettyPrint: { type: 'boolean', default: true, description: 'Make XML human readable' }
                                },
                                "x-schema-form": {
                                    type: "section",
                                    expandable: true,
                                    expande: false,
                                    title: 'Advanced'
                                }
                            }
                        },
                        required: ['input']
                    };
                    _this_1.documentation = "\n    This tool will convert a JSON document to XML.\n    ";
                    return _this_1;
                }
                JsonToXmlComponent.prototype.onTransform = function (transform) {
                    return jsontoxml__WEBPACK_IMPORTED_MODULE_2___default()(transform.input, transform.advanced);
                };
                return JsonToXmlComponent;
            }(src_app_core_transform_tool_transform_tool_component__WEBPACK_IMPORTED_MODULE_1__["TransformToolComponent"]));
            /***/ 
        }),
        /***/ "./src/app/json/components/json-to-yaml.ts": 
        /*!*************************************************!*\
          !*** ./src/app/json/components/json-to-yaml.ts ***!
          \*************************************************/
        /*! exports provided: JsonToYamlComponent */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JsonToYamlComponent", function () { return JsonToYamlComponent; });
            /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
            /* harmony import */ var src_app_core_transform_tool_transform_tool_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! src/app/core/transform-tool/transform-tool.component */ "./src/app/core/transform-tool/transform-tool.component.ts");
            /* harmony import */ var yaml__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! yaml */ "./node_modules/yaml/browser/index.js");
            /* harmony import */ var yaml__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __webpack_require__.n(yaml__WEBPACK_IMPORTED_MODULE_2__);
            var JsonToYamlComponent = /** @class */ (function (_super) {
                __extends(JsonToYamlComponent, _super);
                function JsonToYamlComponent() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.title = 'Convert JSON to YAML';
                    _this_1.action = 'Convert';
                    _this_1.schema = {
                        type: 'object',
                        properties: {
                            input: { type: 'string', title: 'JSON', description: 'JSON to convert' }
                        },
                        required: ['input']
                    };
                    _this_1.documentation = "\n    This tool will convert a JSON document to YAML.\n    ";
                    return _this_1;
                }
                JsonToYamlComponent.prototype.onTransform = function (transform) {
                    var result = yaml__WEBPACK_IMPORTED_MODULE_2___default.a.parse(transform.input);
                    return yaml__WEBPACK_IMPORTED_MODULE_2___default.a.stringify(result);
                };
                return JsonToYamlComponent;
            }(src_app_core_transform_tool_transform_tool_component__WEBPACK_IMPORTED_MODULE_1__["TransformToolComponent"]));
            /***/ 
        }),
        /***/ "./src/app/json/json-routing.module.ts": 
        /*!*********************************************!*\
          !*** ./src/app/json/json-routing.module.ts ***!
          \*********************************************/
        /*! exports provided: JsonRoutingModule */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JsonRoutingModule", function () { return JsonRoutingModule; });
            /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/router */ "./node_modules/@angular/router/fesm2015/router.js");
            /* harmony import */ var _components_json_format_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/json-format.component */ "./src/app/json/components/json-format.component.ts");
            /* harmony import */ var _components_json_to_schema_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/json-to-schema.component */ "./src/app/json/components/json-to-schema.component.ts");
            /* harmony import */ var _components_json_to_yaml__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/json-to-yaml */ "./src/app/json/components/json-to-yaml.ts");
            /* harmony import */ var _components_json_to_xml__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/json-to-xml */ "./src/app/json/components/json-to-xml.ts");
            var routes = [
                {
                    path: 'format', component: _components_json_format_component__WEBPACK_IMPORTED_MODULE_3__["JsonFormatComponent"],
                },
                {
                    path: 'to', children: [
                        { path: 'schema', component: _components_json_to_schema_component__WEBPACK_IMPORTED_MODULE_4__["JsonToSchemaComponent"] },
                        { path: 'yaml', component: _components_json_to_yaml__WEBPACK_IMPORTED_MODULE_5__["JsonToYamlComponent"] },
                        { path: 'xml', component: _components_json_to_xml__WEBPACK_IMPORTED_MODULE_6__["JsonToXmlComponent"] }
                    ]
                }
            ];
            var JsonRoutingModule = /** @class */ (function () {
                function JsonRoutingModule() {
                }
                return JsonRoutingModule;
            }());
            JsonRoutingModule = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"])({
                    imports: [_angular_router__WEBPACK_IMPORTED_MODULE_2__["RouterModule"].forChild(routes)],
                    exports: [_angular_router__WEBPACK_IMPORTED_MODULE_2__["RouterModule"]]
                })
            ], JsonRoutingModule);
            /***/ 
        }),
        /***/ "./src/app/json/json.module.ts": 
        /*!*************************************!*\
          !*** ./src/app/json/json.module.ts ***!
          \*************************************/
        /*! exports provided: JsonModule */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JsonModule", function () { return JsonModule; });
            /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _json_routing_module__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./json-routing.module */ "./src/app/json/json-routing.module.ts");
            /* harmony import */ var _components_json_format_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/json-format.component */ "./src/app/json/components/json-format.component.ts");
            /* harmony import */ var _components_json_to_schema_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/json-to-schema.component */ "./src/app/json/components/json-to-schema.component.ts");
            /* harmony import */ var _core_core_module__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/core.module */ "./src/app/core/core.module.ts");
            /* harmony import */ var _components_json_to_yaml__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/json-to-yaml */ "./src/app/json/components/json-to-yaml.ts");
            /* harmony import */ var _components_json_to_xml__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./components/json-to-xml */ "./src/app/json/components/json-to-xml.ts");
            /* harmony import */ var ngx_markdown__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ngx-markdown */ "./node_modules/ngx-markdown/fesm2015/ngx-markdown.js");
            var JsonModule = /** @class */ (function () {
                function JsonModule() {
                }
                return JsonModule;
            }());
            JsonModule = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"])({
                    declarations: [
                        _components_json_format_component__WEBPACK_IMPORTED_MODULE_4__["JsonFormatComponent"],
                        _components_json_to_schema_component__WEBPACK_IMPORTED_MODULE_5__["JsonToSchemaComponent"],
                        _components_json_to_yaml__WEBPACK_IMPORTED_MODULE_7__["JsonToYamlComponent"],
                        _components_json_to_xml__WEBPACK_IMPORTED_MODULE_8__["JsonToXmlComponent"]
                    ],
                    imports: [
                        _angular_common__WEBPACK_IMPORTED_MODULE_2__["CommonModule"],
                        _json_routing_module__WEBPACK_IMPORTED_MODULE_3__["JsonRoutingModule"],
                        _core_core_module__WEBPACK_IMPORTED_MODULE_6__["CoreModule"],
                        ngx_markdown__WEBPACK_IMPORTED_MODULE_9__["MarkdownModule"].forChild()
                    ]
                })
            ], JsonModule);
            /***/ 
        })
    }]);
//# sourceMappingURL=json-json-module-es2015.js.map
//# sourceMappingURL=json-json-module-es5.js.map
//# sourceMappingURL=json-json-module-es5.js.map